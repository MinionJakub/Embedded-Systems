   1               		.file	"tasks.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 183               	prvResetNextTaskUnblockTime:
 184               		.stabd	46,0,0
   1:FreeRTOS/Source/tasks.c **** /*
   2:FreeRTOS/Source/tasks.c ****  * FreeRTOS Kernel V10.1.1
   3:FreeRTOS/Source/tasks.c ****  * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Source/tasks.c ****  *
   5:FreeRTOS/Source/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Source/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Source/tasks.c ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Source/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Source/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Source/tasks.c ****  * subject to the following conditions:
  11:FreeRTOS/Source/tasks.c ****  *
  12:FreeRTOS/Source/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/Source/tasks.c ****  * copies or substantial portions of the Software.
  14:FreeRTOS/Source/tasks.c ****  *
  15:FreeRTOS/Source/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:FreeRTOS/Source/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:FreeRTOS/Source/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:FreeRTOS/Source/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:FreeRTOS/Source/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:FreeRTOS/Source/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:FreeRTOS/Source/tasks.c ****  *
  22:FreeRTOS/Source/tasks.c ****  * http://www.FreeRTOS.org
  23:FreeRTOS/Source/tasks.c ****  * http://aws.amazon.com/freertos
  24:FreeRTOS/Source/tasks.c ****  *
  25:FreeRTOS/Source/tasks.c ****  * 1 tab == 4 spaces!
  26:FreeRTOS/Source/tasks.c ****  */
  27:FreeRTOS/Source/tasks.c **** 
  28:FreeRTOS/Source/tasks.c **** /* Standard includes. */
  29:FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  30:FreeRTOS/Source/tasks.c **** #include <string.h>
  31:FreeRTOS/Source/tasks.c **** 
  32:FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  33:FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  34:FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  35:FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:FreeRTOS/Source/tasks.c **** 
  37:FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  38:FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  39:FreeRTOS/Source/tasks.c **** #include "task.h"
  40:FreeRTOS/Source/tasks.c **** #include "timers.h"
  41:FreeRTOS/Source/tasks.c **** #include "stack_macros.h"
  42:FreeRTOS/Source/tasks.c **** 
  43:FreeRTOS/Source/tasks.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  44:FreeRTOS/Source/tasks.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  45:FreeRTOS/Source/tasks.c **** for the header files above, but not in this file, in order to generate the
  46:FreeRTOS/Source/tasks.c **** correct privileged Vs unprivileged linkage and placement. */
  47:FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  48:FreeRTOS/Source/tasks.c **** 
  49:FreeRTOS/Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  50:FreeRTOS/Source/tasks.c **** functions but without including stdio.h here. */
  51:FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  52:FreeRTOS/Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  53:FreeRTOS/Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  54:FreeRTOS/Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  55:FreeRTOS/Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  56:FreeRTOS/Source/tasks.c **** 	#include <stdio.h>
  57:FreeRTOS/Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  58:FreeRTOS/Source/tasks.c **** 
  59:FreeRTOS/Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
  60:FreeRTOS/Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  61:FreeRTOS/Source/tasks.c **** 	performed just because a higher priority task has been woken. */
  62:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
  63:FreeRTOS/Source/tasks.c **** #else
  64:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  65:FreeRTOS/Source/tasks.c **** #endif
  66:FreeRTOS/Source/tasks.c **** 
  67:FreeRTOS/Source/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  68:FreeRTOS/Source/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
  69:FreeRTOS/Source/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
  70:FreeRTOS/Source/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
  71:FreeRTOS/Source/tasks.c **** 
  72:FreeRTOS/Source/tasks.c **** /*
  73:FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  74:FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
  75:FreeRTOS/Source/tasks.c ****  */
  76:FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
  77:FreeRTOS/Source/tasks.c **** 
  78:FreeRTOS/Source/tasks.c **** /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
  79:FreeRTOS/Source/tasks.c **** dynamically allocated RAM, in which case when any task is deleted it is known
  80:FreeRTOS/Source/tasks.c **** that both the task's stack and TCB need to be freed.  Sometimes the
  81:FreeRTOS/Source/tasks.c **** FreeRTOSConfig.h settings only allow a task to be created using statically
  82:FreeRTOS/Source/tasks.c **** allocated RAM, in which case when any task is deleted it is known that neither
  83:FreeRTOS/Source/tasks.c **** the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
  84:FreeRTOS/Source/tasks.c **** settings allow a task to be created using either statically or dynamically
  85:FreeRTOS/Source/tasks.c **** allocated RAM, in which case a member of the TCB is used to record whether the
  86:FreeRTOS/Source/tasks.c **** stack and/or TCB were allocated statically or dynamically, so when a task is
  87:FreeRTOS/Source/tasks.c **** deleted the RAM that was allocated dynamically is freed again and no attempt is
  88:FreeRTOS/Source/tasks.c **** made to free the RAM that was allocated statically.
  89:FreeRTOS/Source/tasks.c **** tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
  90:FreeRTOS/Source/tasks.c **** task to be created using either statically or dynamically allocated RAM.  Note
  91:FreeRTOS/Source/tasks.c **** that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
  92:FreeRTOS/Source/tasks.c **** a statically allocated stack and a dynamically allocated TCB.
  93:FreeRTOS/Source/tasks.c **** !!!NOTE!!! If the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is
  94:FreeRTOS/Source/tasks.c **** changed then the definition of StaticTask_t must also be updated. */
  95:FreeRTOS/Source/tasks.c **** #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( c
  96:FreeRTOS/Source/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
  97:FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
  98:FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
  99:FreeRTOS/Source/tasks.c **** 
 100:FreeRTOS/Source/tasks.c **** /* If any of the following are set then task stacks are filled with a known
 101:FreeRTOS/Source/tasks.c **** value so the high water mark can be determined.  If none of the following are
 102:FreeRTOS/Source/tasks.c **** set then don't fill the stack so there is no unnecessary dependency on memset. */
 103:FreeRTOS/Source/tasks.c **** #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTas
 104:FreeRTOS/Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
 105:FreeRTOS/Source/tasks.c **** #else
 106:FreeRTOS/Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
 107:FreeRTOS/Source/tasks.c **** #endif
 108:FreeRTOS/Source/tasks.c **** 
 109:FreeRTOS/Source/tasks.c **** /*
 110:FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 111:FreeRTOS/Source/tasks.c ****  */
 112:FreeRTOS/Source/tasks.c **** #define tskRUNNING_CHAR		( 'X' )
 113:FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 114:FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
 115:FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 116:FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 117:FreeRTOS/Source/tasks.c **** 
 118:FreeRTOS/Source/tasks.c **** /*
 119:FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 120:FreeRTOS/Source/tasks.c ****  * global, rather than file scope.
 121:FreeRTOS/Source/tasks.c ****  */
 122:FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 123:FreeRTOS/Source/tasks.c **** 	#define static
 124:FreeRTOS/Source/tasks.c **** #endif
 125:FreeRTOS/Source/tasks.c **** 
 126:FreeRTOS/Source/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 127:FreeRTOS/Source/tasks.c **** configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 128:FreeRTOS/Source/tasks.c **** #ifndef configIDLE_TASK_NAME
 129:FreeRTOS/Source/tasks.c **** 	#define configIDLE_TASK_NAME "IDLE"
 130:FreeRTOS/Source/tasks.c **** #endif
 131:FreeRTOS/Source/tasks.c **** 
 132:FreeRTOS/Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 133:FreeRTOS/Source/tasks.c **** 
 134:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 135:FreeRTOS/Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 136:FreeRTOS/Source/tasks.c **** 	microcontroller architecture. */
 137:FreeRTOS/Source/tasks.c **** 
 138:FreeRTOS/Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 139:FreeRTOS/Source/tasks.c **** 	state task. */
 140:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 141:FreeRTOS/Source/tasks.c **** 	{																									\
 142:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 143:FreeRTOS/Source/tasks.c **** 		{																								\
 144:FreeRTOS/Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 145:FreeRTOS/Source/tasks.c **** 		}																								\
 146:FreeRTOS/Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 147:FreeRTOS/Source/tasks.c **** 
 148:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 149:FreeRTOS/Source/tasks.c **** 
 150:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 151:FreeRTOS/Source/tasks.c **** 	{																									\
 152:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 153:FreeRTOS/Source/tasks.c **** 																										\
 154:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 155:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 156:FreeRTOS/Source/tasks.c **** 		{																								\
 157:FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopPriority );																\
 158:FreeRTOS/Source/tasks.c **** 			--uxTopPriority;																			\
 159:FreeRTOS/Source/tasks.c **** 		}																								\
 160:FreeRTOS/Source/tasks.c **** 																										\
 161:FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 162:FreeRTOS/Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 163:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 164:FreeRTOS/Source/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 165:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 166:FreeRTOS/Source/tasks.c **** 
 167:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 168:FreeRTOS/Source/tasks.c **** 
 169:FreeRTOS/Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 170:FreeRTOS/Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 171:FreeRTOS/Source/tasks.c **** 	being used. */
 172:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 173:FreeRTOS/Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 174:FreeRTOS/Source/tasks.c **** 
 175:FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 176:FreeRTOS/Source/tasks.c **** 
 177:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 178:FreeRTOS/Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 179:FreeRTOS/Source/tasks.c **** 	architecture being used. */
 180:FreeRTOS/Source/tasks.c **** 
 181:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 182:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 183:FreeRTOS/Source/tasks.c **** 
 184:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 185:FreeRTOS/Source/tasks.c **** 
 186:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 187:FreeRTOS/Source/tasks.c **** 	{																								\
 188:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 189:FreeRTOS/Source/tasks.c **** 																									\
 190:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 191:FreeRTOS/Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 192:FreeRTOS/Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 193:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 194:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 195:FreeRTOS/Source/tasks.c **** 
 196:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 197:FreeRTOS/Source/tasks.c **** 
 198:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 199:FreeRTOS/Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 200:FreeRTOS/Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 201:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 202:FreeRTOS/Source/tasks.c **** 	{																									\
 203:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 204:FreeRTOS/Source/tasks.c **** 		{																								\
 205:FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 206:FreeRTOS/Source/tasks.c **** 		}																								\
 207:FreeRTOS/Source/tasks.c **** 	}
 208:FreeRTOS/Source/tasks.c **** 
 209:FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 210:FreeRTOS/Source/tasks.c **** 
 211:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 212:FreeRTOS/Source/tasks.c **** 
 213:FreeRTOS/Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 214:FreeRTOS/Source/tasks.c **** count overflows. */
 215:FreeRTOS/Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 216:FreeRTOS/Source/tasks.c **** {																									\
 217:FreeRTOS/Source/tasks.c **** 	List_t *pxTemp;																					\
 218:FreeRTOS/Source/tasks.c **** 																									\
 219:FreeRTOS/Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 220:FreeRTOS/Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 221:FreeRTOS/Source/tasks.c **** 																									\
 222:FreeRTOS/Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 223:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 224:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 225:FreeRTOS/Source/tasks.c **** 	xNumOfOverflows++;																				\
 226:FreeRTOS/Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 227:FreeRTOS/Source/tasks.c **** }
 228:FreeRTOS/Source/tasks.c **** 
 229:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 230:FreeRTOS/Source/tasks.c **** 
 231:FreeRTOS/Source/tasks.c **** /*
 232:FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 233:FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 234:FreeRTOS/Source/tasks.c ****  */
 235:FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 236:FreeRTOS/Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 237:FreeRTOS/Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 238:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 239:FreeRTOS/Source/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 240:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 241:FreeRTOS/Source/tasks.c **** 
 242:FreeRTOS/Source/tasks.c **** /*
 243:FreeRTOS/Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 244:FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 245:FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 246:FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 247:FreeRTOS/Source/tasks.c ****  */
 248:FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
 249:FreeRTOS/Source/tasks.c **** 
 250:FreeRTOS/Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 251:FreeRTOS/Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 252:FreeRTOS/Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 253:FreeRTOS/Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 254:FreeRTOS/Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 255:FreeRTOS/Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 256:FreeRTOS/Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 257:FreeRTOS/Source/tasks.c **** to its original value when it is released. */
 258:FreeRTOS/Source/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 259:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 260:FreeRTOS/Source/tasks.c **** #else
 261:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 262:FreeRTOS/Source/tasks.c **** #endif
 263:FreeRTOS/Source/tasks.c **** 
 264:FreeRTOS/Source/tasks.c **** /*
 265:FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 266:FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 267:FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
 268:FreeRTOS/Source/tasks.c ****  */
 269:FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel 
 270:FreeRTOS/Source/tasks.c **** {
 271:FreeRTOS/Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 272:FreeRTOS/Source/tasks.c **** 
 273:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 274:FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 275:FreeRTOS/Source/tasks.c **** 	#endif
 276:FreeRTOS/Source/tasks.c **** 
 277:FreeRTOS/Source/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 278:FreeRTOS/Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 279:FreeRTOS/Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 280:FreeRTOS/Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 281:FreeRTOS/Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 282:FreeRTOS/Source/tasks.c **** 
 283:FreeRTOS/Source/tasks.c **** 	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 284:FreeRTOS/Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
 285:FreeRTOS/Source/tasks.c **** 	#endif
 286:FreeRTOS/Source/tasks.c **** 
 287:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 288:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 289:FreeRTOS/Source/tasks.c **** 	#endif
 290:FreeRTOS/Source/tasks.c **** 
 291:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 292:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 293:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 294:FreeRTOS/Source/tasks.c **** 	#endif
 295:FreeRTOS/Source/tasks.c **** 
 296:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 297:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 298:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 299:FreeRTOS/Source/tasks.c **** 	#endif
 300:FreeRTOS/Source/tasks.c **** 
 301:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 302:FreeRTOS/Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 303:FreeRTOS/Source/tasks.c **** 	#endif
 304:FreeRTOS/Source/tasks.c **** 
 305:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 306:FreeRTOS/Source/tasks.c **** 		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 307:FreeRTOS/Source/tasks.c **** 	#endif
 308:FreeRTOS/Source/tasks.c **** 
 309:FreeRTOS/Source/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 310:FreeRTOS/Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 311:FreeRTOS/Source/tasks.c **** 	#endif
 312:FreeRTOS/Source/tasks.c **** 
 313:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 314:FreeRTOS/Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 315:FreeRTOS/Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 316:FreeRTOS/Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 317:FreeRTOS/Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 318:FreeRTOS/Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 319:FreeRTOS/Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 320:FreeRTOS/Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 321:FreeRTOS/Source/tasks.c **** 		struct	_reent xNewLib_reent;
 322:FreeRTOS/Source/tasks.c **** 	#endif
 323:FreeRTOS/Source/tasks.c **** 
 324:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 325:FreeRTOS/Source/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 326:FreeRTOS/Source/tasks.c **** 		volatile uint8_t ucNotifyState;
 327:FreeRTOS/Source/tasks.c **** 	#endif
 328:FreeRTOS/Source/tasks.c **** 
 329:FreeRTOS/Source/tasks.c **** 	/* See the comments above the definition of
 330:FreeRTOS/Source/tasks.c **** 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 331:FreeRTOS/Source/tasks.c **** 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolida
 332:FreeRTOS/Source/tasks.c **** 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensur
 333:FreeRTOS/Source/tasks.c **** 	#endif
 334:FreeRTOS/Source/tasks.c **** 
 335:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 336:FreeRTOS/Source/tasks.c **** 		uint8_t ucDelayAborted;
 337:FreeRTOS/Source/tasks.c **** 	#endif
 338:FreeRTOS/Source/tasks.c **** 
 339:FreeRTOS/Source/tasks.c **** 	#if( configUSE_POSIX_ERRNO == 1 )
 340:FreeRTOS/Source/tasks.c **** 		int iTaskErrno;
 341:FreeRTOS/Source/tasks.c **** 	#endif
 342:FreeRTOS/Source/tasks.c **** 
 343:FreeRTOS/Source/tasks.c **** } tskTCB;
 344:FreeRTOS/Source/tasks.c **** 
 345:FreeRTOS/Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 346:FreeRTOS/Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 347:FreeRTOS/Source/tasks.c **** typedef tskTCB TCB_t;
 348:FreeRTOS/Source/tasks.c **** 
 349:FreeRTOS/Source/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 350:FreeRTOS/Source/tasks.c **** which static variables must be declared volatile. */
 351:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 352:FreeRTOS/Source/tasks.c **** 
 353:FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------
 354:FreeRTOS/Source/tasks.c **** xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
 355:FreeRTOS/Source/tasks.c **** doing so breaks some kernel aware debuggers and debuggers that rely on removing
 356:FreeRTOS/Source/tasks.c **** the static qualifier. */
 357:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 358:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 359:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 360:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 361:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 362:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 363:FreeRTOS/Source/tasks.c **** 
 364:FreeRTOS/Source/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 365:FreeRTOS/Source/tasks.c **** 
 366:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 367:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 368:FreeRTOS/Source/tasks.c **** 
 369:FreeRTOS/Source/tasks.c **** #endif
 370:FreeRTOS/Source/tasks.c **** 
 371:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 372:FreeRTOS/Source/tasks.c **** 
 373:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 374:FreeRTOS/Source/tasks.c **** 
 375:FreeRTOS/Source/tasks.c **** #endif
 376:FreeRTOS/Source/tasks.c **** 
 377:FreeRTOS/Source/tasks.c **** /* Global POSIX errno. Its value is changed upon context switching to match
 378:FreeRTOS/Source/tasks.c **** the errno of the currently running task. */
 379:FreeRTOS/Source/tasks.c **** #if ( configUSE_POSIX_ERRNO == 1 )
 380:FreeRTOS/Source/tasks.c **** 	int FreeRTOS_errno = 0;
 381:FreeRTOS/Source/tasks.c **** #endif
 382:FreeRTOS/Source/tasks.c **** 
 383:FreeRTOS/Source/tasks.c **** /* Other file private variables. --------------------------------*/
 384:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 385:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT
 386:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 387:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 388:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 389:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 390:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 391:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 392:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 393:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 394:FreeRTOS/Source/tasks.c **** 
 395:FreeRTOS/Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 396:FreeRTOS/Source/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 397:FreeRTOS/Source/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 398:FreeRTOS/Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 399:FreeRTOS/Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 400:FreeRTOS/Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 401:FreeRTOS/Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 402:FreeRTOS/Source/tasks.c **** accessed from a critical section. */
 403:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 404:FreeRTOS/Source/tasks.c **** 
 405:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 406:FreeRTOS/Source/tasks.c **** 
 407:FreeRTOS/Source/tasks.c **** 	/* Do not move these variables to function scope as doing so prevents the
 408:FreeRTOS/Source/tasks.c **** 	code working with debuggers that need to remove the static qualifier. */
 409:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 410:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 411:FreeRTOS/Source/tasks.c **** 
 412:FreeRTOS/Source/tasks.c **** #endif
 413:FreeRTOS/Source/tasks.c **** 
 414:FreeRTOS/Source/tasks.c **** /*lint -restore */
 415:FreeRTOS/Source/tasks.c **** 
 416:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 417:FreeRTOS/Source/tasks.c **** 
 418:FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 419:FreeRTOS/Source/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 420:FreeRTOS/Source/tasks.c **** 
 421:FreeRTOS/Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 422:FreeRTOS/Source/tasks.c **** 
 423:FreeRTOS/Source/tasks.c **** #endif
 424:FreeRTOS/Source/tasks.c **** 
 425:FreeRTOS/Source/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 426:FreeRTOS/Source/tasks.c **** 
 427:FreeRTOS/Source/tasks.c **** 	extern void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application 
 428:FreeRTOS/Source/tasks.c **** 
 429:FreeRTOS/Source/tasks.c **** #endif
 430:FreeRTOS/Source/tasks.c **** 
 431:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 432:FreeRTOS/Source/tasks.c **** 
 433:FreeRTOS/Source/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 434:FreeRTOS/Source/tasks.c **** 
 435:FreeRTOS/Source/tasks.c **** #endif
 436:FreeRTOS/Source/tasks.c **** 
 437:FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 438:FreeRTOS/Source/tasks.c **** 
 439:FreeRTOS/Source/tasks.c **** /**
 440:FreeRTOS/Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 441:FreeRTOS/Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 442:FreeRTOS/Source/tasks.c ****  * is in any other state.
 443:FreeRTOS/Source/tasks.c ****  */
 444:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 445:FreeRTOS/Source/tasks.c **** 
 446:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 447:FreeRTOS/Source/tasks.c **** 
 448:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 449:FreeRTOS/Source/tasks.c **** 
 450:FreeRTOS/Source/tasks.c **** /*
 451:FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 452:FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 453:FreeRTOS/Source/tasks.c ****  */
 454:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 455:FreeRTOS/Source/tasks.c **** 
 456:FreeRTOS/Source/tasks.c **** /*
 457:FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 458:FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 459:FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 460:FreeRTOS/Source/tasks.c ****  *
 461:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 462:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 463:FreeRTOS/Source/tasks.c ****  *
 464:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 465:FreeRTOS/Source/tasks.c ****  *
 466:FreeRTOS/Source/tasks.c ****  */
 467:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 468:FreeRTOS/Source/tasks.c **** 
 469:FreeRTOS/Source/tasks.c **** /*
 470:FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 471:FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 472:FreeRTOS/Source/tasks.c ****  *
 473:FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 474:FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 475:FreeRTOS/Source/tasks.c ****  */
 476:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 477:FreeRTOS/Source/tasks.c **** 
 478:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 479:FreeRTOS/Source/tasks.c **** 
 480:FreeRTOS/Source/tasks.c **** #endif
 481:FreeRTOS/Source/tasks.c **** 
 482:FreeRTOS/Source/tasks.c **** /*
 483:FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 484:FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 485:FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 486:FreeRTOS/Source/tasks.c ****  */
 487:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 488:FreeRTOS/Source/tasks.c **** 
 489:FreeRTOS/Source/tasks.c **** /*
 490:FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 491:FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 492:FreeRTOS/Source/tasks.c ****  */
 493:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 494:FreeRTOS/Source/tasks.c **** 
 495:FreeRTOS/Source/tasks.c **** /*
 496:FreeRTOS/Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 497:FreeRTOS/Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 498:FreeRTOS/Source/tasks.c ****  * a suspended list, etc.).
 499:FreeRTOS/Source/tasks.c ****  *
 500:FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 501:FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 502:FreeRTOS/Source/tasks.c ****  */
 503:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 504:FreeRTOS/Source/tasks.c **** 
 505:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 506:FreeRTOS/Source/tasks.c **** 
 507:FreeRTOS/Source/tasks.c **** #endif
 508:FreeRTOS/Source/tasks.c **** 
 509:FreeRTOS/Source/tasks.c **** /*
 510:FreeRTOS/Source/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 511:FreeRTOS/Source/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 512:FreeRTOS/Source/tasks.c ****  */
 513:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 514:FreeRTOS/Source/tasks.c **** 
 515:FreeRTOS/Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 516:FreeRTOS/Source/tasks.c **** 
 517:FreeRTOS/Source/tasks.c **** #endif
 518:FreeRTOS/Source/tasks.c **** 
 519:FreeRTOS/Source/tasks.c **** /*
 520:FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 521:FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 522:FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 523:FreeRTOS/Source/tasks.c ****  */
 524:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 525:FreeRTOS/Source/tasks.c **** 
 526:FreeRTOS/Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGE
 527:FreeRTOS/Source/tasks.c **** 
 528:FreeRTOS/Source/tasks.c **** #endif
 529:FreeRTOS/Source/tasks.c **** 
 530:FreeRTOS/Source/tasks.c **** /*
 531:FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 532:FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 533:FreeRTOS/Source/tasks.c ****  *
 534:FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 535:FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 536:FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 537:FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 538:FreeRTOS/Source/tasks.c ****  */
 539:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 540:FreeRTOS/Source/tasks.c **** 
 541:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 542:FreeRTOS/Source/tasks.c **** 
 543:FreeRTOS/Source/tasks.c **** #endif
 544:FreeRTOS/Source/tasks.c **** 
 545:FreeRTOS/Source/tasks.c **** /*
 546:FreeRTOS/Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 547:FreeRTOS/Source/tasks.c ****  * will exit the Blocked state.
 548:FreeRTOS/Source/tasks.c ****  */
 549:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 550:FreeRTOS/Source/tasks.c **** 
 551:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 552:FreeRTOS/Source/tasks.c **** 
 553:FreeRTOS/Source/tasks.c **** 	/*
 554:FreeRTOS/Source/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 555:FreeRTOS/Source/tasks.c **** 	 * human readable tables of task information.
 556:FreeRTOS/Source/tasks.c **** 	 */
 557:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 558:FreeRTOS/Source/tasks.c **** 
 559:FreeRTOS/Source/tasks.c **** #endif
 560:FreeRTOS/Source/tasks.c **** 
 561:FreeRTOS/Source/tasks.c **** /*
 562:FreeRTOS/Source/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 563:FreeRTOS/Source/tasks.c ****  * dynamically to fill in the structure's members.
 564:FreeRTOS/Source/tasks.c ****  */
 565:FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 566:FreeRTOS/Source/tasks.c **** 									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings a
 567:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 568:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 569:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 570:FreeRTOS/Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 571:FreeRTOS/Source/tasks.c **** 									TCB_t *pxNewTCB,
 572:FreeRTOS/Source/tasks.c **** 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 573:FreeRTOS/Source/tasks.c **** 
 574:FreeRTOS/Source/tasks.c **** /*
 575:FreeRTOS/Source/tasks.c ****  * Called after a new task has been created and initialised to place the task
 576:FreeRTOS/Source/tasks.c ****  * under the control of the scheduler.
 577:FreeRTOS/Source/tasks.c ****  */
 578:FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 579:FreeRTOS/Source/tasks.c **** 
 580:FreeRTOS/Source/tasks.c **** /*
 581:FreeRTOS/Source/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 582:FreeRTOS/Source/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 583:FreeRTOS/Source/tasks.c ****  * called by the function.
 584:FreeRTOS/Source/tasks.c ****  */
 585:FreeRTOS/Source/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 586:FreeRTOS/Source/tasks.c **** 
 587:FreeRTOS/Source/tasks.c **** 	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 588:FreeRTOS/Source/tasks.c **** 
 589:FreeRTOS/Source/tasks.c **** #endif
 590:FreeRTOS/Source/tasks.c **** 
 591:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 592:FreeRTOS/Source/tasks.c **** 
 593:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 594:FreeRTOS/Source/tasks.c **** 
 595:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
 596:FreeRTOS/Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 597:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 598:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 599:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 600:FreeRTOS/Source/tasks.c **** 									StackType_t * const puxStackBuffer,
 601:FreeRTOS/Source/tasks.c **** 									StaticTask_t * const pxTaskBuffer )
 602:FreeRTOS/Source/tasks.c **** 	{
 603:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 604:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
 605:FreeRTOS/Source/tasks.c **** 
 606:FreeRTOS/Source/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 607:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 608:FreeRTOS/Source/tasks.c **** 
 609:FreeRTOS/Source/tasks.c **** 		#if( configASSERT_DEFINED == 1 )
 610:FreeRTOS/Source/tasks.c **** 		{
 611:FreeRTOS/Source/tasks.c **** 			/* Sanity check that the size of the structure used to declare a
 612:FreeRTOS/Source/tasks.c **** 			variable of type StaticTask_t equals the size of the real task
 613:FreeRTOS/Source/tasks.c **** 			structure. */
 614:FreeRTOS/Source/tasks.c **** 			volatile size_t xSize = sizeof( StaticTask_t );
 615:FreeRTOS/Source/tasks.c **** 			configASSERT( xSize == sizeof( TCB_t ) );
 616:FreeRTOS/Source/tasks.c **** 			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 617:FreeRTOS/Source/tasks.c **** 		}
 618:FreeRTOS/Source/tasks.c **** 		#endif /* configASSERT_DEFINED */
 619:FreeRTOS/Source/tasks.c **** 
 620:FreeRTOS/Source/tasks.c **** 
 621:FreeRTOS/Source/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 622:FreeRTOS/Source/tasks.c **** 		{
 623:FreeRTOS/Source/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 624:FreeRTOS/Source/tasks.c **** 			function - use them. */
 625:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures ar
 626:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 627:FreeRTOS/Source/tasks.c **** 
 628:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consoli
 629:FreeRTOS/Source/tasks.c **** 			{
 630:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 631:FreeRTOS/Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 632:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 633:FreeRTOS/Source/tasks.c **** 			}
 634:FreeRTOS/Source/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 635:FreeRTOS/Source/tasks.c **** 
 636:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 637:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 638:FreeRTOS/Source/tasks.c **** 		}
 639:FreeRTOS/Source/tasks.c **** 		else
 640:FreeRTOS/Source/tasks.c **** 		{
 641:FreeRTOS/Source/tasks.c **** 			xReturn = NULL;
 642:FreeRTOS/Source/tasks.c **** 		}
 643:FreeRTOS/Source/tasks.c **** 
 644:FreeRTOS/Source/tasks.c **** 		return xReturn;
 645:FreeRTOS/Source/tasks.c **** 	}
 646:FreeRTOS/Source/tasks.c **** 
 647:FreeRTOS/Source/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 648:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 649:FreeRTOS/Source/tasks.c **** 
 650:FreeRTOS/Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 651:FreeRTOS/Source/tasks.c **** 
 652:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandl
 653:FreeRTOS/Source/tasks.c **** 	{
 654:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 655:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 656:FreeRTOS/Source/tasks.c **** 
 657:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 658:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 659:FreeRTOS/Source/tasks.c **** 
 660:FreeRTOS/Source/tasks.c **** 		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
 661:FreeRTOS/Source/tasks.c **** 		{
 662:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 663:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 664:FreeRTOS/Source/tasks.c **** 			not static allocation is being used. */
 665:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 666:FreeRTOS/Source/tasks.c **** 
 667:FreeRTOS/Source/tasks.c **** 			/* Store the stack location in the TCB. */
 668:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 669:FreeRTOS/Source/tasks.c **** 
 670:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 671:FreeRTOS/Source/tasks.c **** 			{
 672:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 673:FreeRTOS/Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 674:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 675:FreeRTOS/Source/tasks.c **** 			}
 676:FreeRTOS/Source/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 677:FreeRTOS/Source/tasks.c **** 
 678:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 679:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->pcName,
 680:FreeRTOS/Source/tasks.c **** 									( uint32_t ) pxTaskDefinition->usStackDepth,
 681:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->pvParameters,
 682:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->uxPriority,
 683:FreeRTOS/Source/tasks.c **** 									pxCreatedTask, pxNewTCB,
 684:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->xRegions );
 685:FreeRTOS/Source/tasks.c **** 
 686:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 687:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 688:FreeRTOS/Source/tasks.c **** 		}
 689:FreeRTOS/Source/tasks.c **** 
 690:FreeRTOS/Source/tasks.c **** 		return xReturn;
 691:FreeRTOS/Source/tasks.c **** 	}
 692:FreeRTOS/Source/tasks.c **** 
 693:FreeRTOS/Source/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 694:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 695:FreeRTOS/Source/tasks.c **** 
 696:FreeRTOS/Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 697:FreeRTOS/Source/tasks.c **** 
 698:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *p
 699:FreeRTOS/Source/tasks.c **** 	{
 700:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 701:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 702:FreeRTOS/Source/tasks.c **** 
 703:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer );
 704:FreeRTOS/Source/tasks.c **** 
 705:FreeRTOS/Source/tasks.c **** 		if( pxTaskDefinition->puxStackBuffer != NULL )
 706:FreeRTOS/Source/tasks.c **** 		{
 707:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 708:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 709:FreeRTOS/Source/tasks.c **** 			not static allocation is being used. */
 710:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 711:FreeRTOS/Source/tasks.c **** 
 712:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
 713:FreeRTOS/Source/tasks.c **** 			{
 714:FreeRTOS/Source/tasks.c **** 				/* Store the stack location in the TCB. */
 715:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 716:FreeRTOS/Source/tasks.c **** 
 717:FreeRTOS/Source/tasks.c **** 				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 718:FreeRTOS/Source/tasks.c **** 				{
 719:FreeRTOS/Source/tasks.c **** 					/* Tasks can be created statically or dynamically, so note
 720:FreeRTOS/Source/tasks.c **** 					this task had a statically allocated stack in case it is
 721:FreeRTOS/Source/tasks.c **** 					later deleted.  The TCB was allocated dynamically. */
 722:FreeRTOS/Source/tasks.c **** 					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 723:FreeRTOS/Source/tasks.c **** 				}
 724:FreeRTOS/Source/tasks.c **** 				#endif
 725:FreeRTOS/Source/tasks.c **** 
 726:FreeRTOS/Source/tasks.c **** 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 727:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->pcName,
 728:FreeRTOS/Source/tasks.c **** 										( uint32_t ) pxTaskDefinition->usStackDepth,
 729:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->pvParameters,
 730:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->uxPriority,
 731:FreeRTOS/Source/tasks.c **** 										pxCreatedTask, pxNewTCB,
 732:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->xRegions );
 733:FreeRTOS/Source/tasks.c **** 
 734:FreeRTOS/Source/tasks.c **** 				prvAddNewTaskToReadyList( pxNewTCB );
 735:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
 736:FreeRTOS/Source/tasks.c **** 			}
 737:FreeRTOS/Source/tasks.c **** 		}
 738:FreeRTOS/Source/tasks.c **** 
 739:FreeRTOS/Source/tasks.c **** 		return xReturn;
 740:FreeRTOS/Source/tasks.c **** 	}
 741:FreeRTOS/Source/tasks.c **** 
 742:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 743:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 744:FreeRTOS/Source/tasks.c **** 
 745:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 746:FreeRTOS/Source/tasks.c **** 
 747:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 748:FreeRTOS/Source/tasks.c **** 							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and 
 749:FreeRTOS/Source/tasks.c **** 							const configSTACK_DEPTH_TYPE usStackDepth,
 750:FreeRTOS/Source/tasks.c **** 							void * const pvParameters,
 751:FreeRTOS/Source/tasks.c **** 							UBaseType_t uxPriority,
 752:FreeRTOS/Source/tasks.c **** 							TaskHandle_t * const pxCreatedTask )
 753:FreeRTOS/Source/tasks.c **** 	{
 754:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 755:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
 756:FreeRTOS/Source/tasks.c **** 
 757:FreeRTOS/Source/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 758:FreeRTOS/Source/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 759:FreeRTOS/Source/tasks.c **** 		the TCB then the stack. */
 760:FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 761:FreeRTOS/Source/tasks.c **** 		{
 762:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 763:FreeRTOS/Source/tasks.c **** 			the implementation of the port malloc function and whether or not static
 764:FreeRTOS/Source/tasks.c **** 			allocation is being used. */
 765:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 766:FreeRTOS/Source/tasks.c **** 
 767:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
 768:FreeRTOS/Source/tasks.c **** 			{
 769:FreeRTOS/Source/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 770:FreeRTOS/Source/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 771:FreeRTOS/Source/tasks.c **** 				be deleted later if required. */
 772:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 773:FreeRTOS/Source/tasks.c **** 
 774:FreeRTOS/Source/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 775:FreeRTOS/Source/tasks.c **** 				{
 776:FreeRTOS/Source/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 777:FreeRTOS/Source/tasks.c **** 					vPortFree( pxNewTCB );
 778:FreeRTOS/Source/tasks.c **** 					pxNewTCB = NULL;
 779:FreeRTOS/Source/tasks.c **** 				}
 780:FreeRTOS/Source/tasks.c **** 			}
 781:FreeRTOS/Source/tasks.c **** 		}
 782:FreeRTOS/Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 783:FreeRTOS/Source/tasks.c **** 		{
 784:FreeRTOS/Source/tasks.c **** 		StackType_t *pxStack;
 785:FreeRTOS/Source/tasks.c **** 
 786:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 787:FreeRTOS/Source/tasks.c **** 			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079
 788:FreeRTOS/Source/tasks.c **** 
 789:FreeRTOS/Source/tasks.c **** 			if( pxStack != NULL )
 790:FreeRTOS/Source/tasks.c **** 			{
 791:FreeRTOS/Source/tasks.c **** 				/* Allocate space for the TCB. */
 792:FreeRTOS/Source/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returne
 793:FreeRTOS/Source/tasks.c **** 
 794:FreeRTOS/Source/tasks.c **** 				if( pxNewTCB != NULL )
 795:FreeRTOS/Source/tasks.c **** 				{
 796:FreeRTOS/Source/tasks.c **** 					/* Store the stack location in the TCB. */
 797:FreeRTOS/Source/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 798:FreeRTOS/Source/tasks.c **** 				}
 799:FreeRTOS/Source/tasks.c **** 				else
 800:FreeRTOS/Source/tasks.c **** 				{
 801:FreeRTOS/Source/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 802:FreeRTOS/Source/tasks.c **** 					it again. */
 803:FreeRTOS/Source/tasks.c **** 					vPortFree( pxStack );
 804:FreeRTOS/Source/tasks.c **** 				}
 805:FreeRTOS/Source/tasks.c **** 			}
 806:FreeRTOS/Source/tasks.c **** 			else
 807:FreeRTOS/Source/tasks.c **** 			{
 808:FreeRTOS/Source/tasks.c **** 				pxNewTCB = NULL;
 809:FreeRTOS/Source/tasks.c **** 			}
 810:FreeRTOS/Source/tasks.c **** 		}
 811:FreeRTOS/Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 812:FreeRTOS/Source/tasks.c **** 
 813:FreeRTOS/Source/tasks.c **** 		if( pxNewTCB != NULL )
 814:FreeRTOS/Source/tasks.c **** 		{
 815:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consoli
 816:FreeRTOS/Source/tasks.c **** 			{
 817:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 818:FreeRTOS/Source/tasks.c **** 				task was created dynamically in case it is later deleted. */
 819:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 820:FreeRTOS/Source/tasks.c **** 			}
 821:FreeRTOS/Source/tasks.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 822:FreeRTOS/Source/tasks.c **** 
 823:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 824:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 825:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 826:FreeRTOS/Source/tasks.c **** 		}
 827:FreeRTOS/Source/tasks.c **** 		else
 828:FreeRTOS/Source/tasks.c **** 		{
 829:FreeRTOS/Source/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 830:FreeRTOS/Source/tasks.c **** 		}
 831:FreeRTOS/Source/tasks.c **** 
 832:FreeRTOS/Source/tasks.c **** 		return xReturn;
 833:FreeRTOS/Source/tasks.c **** 	}
 834:FreeRTOS/Source/tasks.c **** 
 835:FreeRTOS/Source/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 836:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 837:FreeRTOS/Source/tasks.c **** 
 838:FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 839:FreeRTOS/Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 840:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 841:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 842:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 843:FreeRTOS/Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 844:FreeRTOS/Source/tasks.c **** 									TCB_t *pxNewTCB,
 845:FreeRTOS/Source/tasks.c **** 									const MemoryRegion_t * const xRegions )
 846:FreeRTOS/Source/tasks.c **** {
 847:FreeRTOS/Source/tasks.c **** StackType_t *pxTopOfStack;
 848:FreeRTOS/Source/tasks.c **** UBaseType_t x;
 849:FreeRTOS/Source/tasks.c **** 
 850:FreeRTOS/Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 851:FreeRTOS/Source/tasks.c **** 		/* Should the task be created in privileged mode? */
 852:FreeRTOS/Source/tasks.c **** 		BaseType_t xRunPrivileged;
 853:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 854:FreeRTOS/Source/tasks.c **** 		{
 855:FreeRTOS/Source/tasks.c **** 			xRunPrivileged = pdTRUE;
 856:FreeRTOS/Source/tasks.c **** 		}
 857:FreeRTOS/Source/tasks.c **** 		else
 858:FreeRTOS/Source/tasks.c **** 		{
 859:FreeRTOS/Source/tasks.c **** 			xRunPrivileged = pdFALSE;
 860:FreeRTOS/Source/tasks.c **** 		}
 861:FreeRTOS/Source/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 862:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 863:FreeRTOS/Source/tasks.c **** 
 864:FreeRTOS/Source/tasks.c **** 	configASSERT( pcName );
 865:FreeRTOS/Source/tasks.c **** 
 866:FreeRTOS/Source/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 867:FreeRTOS/Source/tasks.c **** 	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 868:FreeRTOS/Source/tasks.c **** 	{
 869:FreeRTOS/Source/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 870:FreeRTOS/Source/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 871:FreeRTOS/Source/tasks.c **** 	}
 872:FreeRTOS/Source/tasks.c **** 	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 873:FreeRTOS/Source/tasks.c **** 
 874:FreeRTOS/Source/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 875:FreeRTOS/Source/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 876:FreeRTOS/Source/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 877:FreeRTOS/Source/tasks.c **** 	by the port. */
 878:FreeRTOS/Source/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 879:FreeRTOS/Source/tasks.c **** 	{
 880:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 881:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 882:FreeRTOS/Source/tasks.c **** 
 883:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 884:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 885:FreeRTOS/Source/tasks.c **** 
 886:FreeRTOS/Source/tasks.c **** 		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
 887:FreeRTOS/Source/tasks.c **** 		{
 888:FreeRTOS/Source/tasks.c **** 			/* Also record the stack's high address, which may assist
 889:FreeRTOS/Source/tasks.c **** 			debugging. */
 890:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxTopOfStack;
 891:FreeRTOS/Source/tasks.c **** 		}
 892:FreeRTOS/Source/tasks.c **** 		#endif /* configRECORD_STACK_HIGH_ADDRESS */
 893:FreeRTOS/Source/tasks.c **** 	}
 894:FreeRTOS/Source/tasks.c **** 	#else /* portSTACK_GROWTH */
 895:FreeRTOS/Source/tasks.c **** 	{
 896:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 897:FreeRTOS/Source/tasks.c **** 
 898:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 899:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 900:FreeRTOS/Source/tasks.c **** 
 901:FreeRTOS/Source/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 902:FreeRTOS/Source/tasks.c **** 		performed. */
 903:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 904:FreeRTOS/Source/tasks.c **** 	}
 905:FreeRTOS/Source/tasks.c **** 	#endif /* portSTACK_GROWTH */
 906:FreeRTOS/Source/tasks.c **** 
 907:FreeRTOS/Source/tasks.c **** 	/* Store the task name in the TCB. */
 908:FreeRTOS/Source/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 909:FreeRTOS/Source/tasks.c **** 	{
 910:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 911:FreeRTOS/Source/tasks.c **** 
 912:FreeRTOS/Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 913:FreeRTOS/Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
 914:FreeRTOS/Source/tasks.c **** 		string is not accessible (extremely unlikely). */
 915:FreeRTOS/Source/tasks.c **** 		if( pcName[ x ] == ( char ) 0x00 )
 916:FreeRTOS/Source/tasks.c **** 		{
 917:FreeRTOS/Source/tasks.c **** 			break;
 918:FreeRTOS/Source/tasks.c **** 		}
 919:FreeRTOS/Source/tasks.c **** 		else
 920:FreeRTOS/Source/tasks.c **** 		{
 921:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 922:FreeRTOS/Source/tasks.c **** 		}
 923:FreeRTOS/Source/tasks.c **** 	}
 924:FreeRTOS/Source/tasks.c **** 
 925:FreeRTOS/Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
 926:FreeRTOS/Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
 927:FreeRTOS/Source/tasks.c **** 	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 928:FreeRTOS/Source/tasks.c **** 
 929:FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 930:FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
 931:FreeRTOS/Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 932:FreeRTOS/Source/tasks.c **** 	{
 933:FreeRTOS/Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 934:FreeRTOS/Source/tasks.c **** 	}
 935:FreeRTOS/Source/tasks.c **** 	else
 936:FreeRTOS/Source/tasks.c **** 	{
 937:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 938:FreeRTOS/Source/tasks.c **** 	}
 939:FreeRTOS/Source/tasks.c **** 
 940:FreeRTOS/Source/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 941:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 942:FreeRTOS/Source/tasks.c **** 	{
 943:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 944:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 945:FreeRTOS/Source/tasks.c **** 	}
 946:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
 947:FreeRTOS/Source/tasks.c **** 
 948:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 949:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 950:FreeRTOS/Source/tasks.c **** 
 951:FreeRTOS/Source/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 952:FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 953:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 954:FreeRTOS/Source/tasks.c **** 
 955:FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
 956:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 957:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 958:FreeRTOS/Source/tasks.c **** 
 959:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 960:FreeRTOS/Source/tasks.c **** 	{
 961:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 962:FreeRTOS/Source/tasks.c **** 	}
 963:FreeRTOS/Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 964:FreeRTOS/Source/tasks.c **** 
 965:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 966:FreeRTOS/Source/tasks.c **** 	{
 967:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 968:FreeRTOS/Source/tasks.c **** 	}
 969:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 970:FreeRTOS/Source/tasks.c **** 
 971:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 972:FreeRTOS/Source/tasks.c **** 	{
 973:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 974:FreeRTOS/Source/tasks.c **** 	}
 975:FreeRTOS/Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 976:FreeRTOS/Source/tasks.c **** 
 977:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 978:FreeRTOS/Source/tasks.c **** 	{
 979:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 980:FreeRTOS/Source/tasks.c **** 	}
 981:FreeRTOS/Source/tasks.c **** 	#else
 982:FreeRTOS/Source/tasks.c **** 	{
 983:FreeRTOS/Source/tasks.c **** 		/* Avoid compiler warning about unreferenced parameter. */
 984:FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
 985:FreeRTOS/Source/tasks.c **** 	}
 986:FreeRTOS/Source/tasks.c **** 	#endif
 987:FreeRTOS/Source/tasks.c **** 
 988:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 989:FreeRTOS/Source/tasks.c **** 	{
 990:FreeRTOS/Source/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 991:FreeRTOS/Source/tasks.c **** 		{
 992:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 993:FreeRTOS/Source/tasks.c **** 		}
 994:FreeRTOS/Source/tasks.c **** 	}
 995:FreeRTOS/Source/tasks.c **** 	#endif
 996:FreeRTOS/Source/tasks.c **** 
 997:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 998:FreeRTOS/Source/tasks.c **** 	{
 999:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
1000:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1001:FreeRTOS/Source/tasks.c **** 	}
1002:FreeRTOS/Source/tasks.c **** 	#endif
1003:FreeRTOS/Source/tasks.c **** 
1004:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
1005:FreeRTOS/Source/tasks.c **** 	{
1006:FreeRTOS/Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
1007:FreeRTOS/Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
1008:FreeRTOS/Source/tasks.c **** 	}
1009:FreeRTOS/Source/tasks.c **** 	#endif
1010:FreeRTOS/Source/tasks.c **** 
1011:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
1012:FreeRTOS/Source/tasks.c **** 	{
1013:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
1014:FreeRTOS/Source/tasks.c **** 	}
1015:FreeRTOS/Source/tasks.c **** 	#endif
1016:FreeRTOS/Source/tasks.c **** 
1017:FreeRTOS/Source/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
1018:FreeRTOS/Source/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
1019:FreeRTOS/Source/tasks.c **** 	to the start of the task function. Once the stack has been initialised
1020:FreeRTOS/Source/tasks.c **** 	the top of stack variable is updated. */
1021:FreeRTOS/Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
1022:FreeRTOS/Source/tasks.c **** 	{
1023:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivi
1024:FreeRTOS/Source/tasks.c **** 	}
1025:FreeRTOS/Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
1026:FreeRTOS/Source/tasks.c **** 	{
1027:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
1028:FreeRTOS/Source/tasks.c **** 	}
1029:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
1030:FreeRTOS/Source/tasks.c **** 
1031:FreeRTOS/Source/tasks.c **** 	if( pxCreatedTask != NULL )
1032:FreeRTOS/Source/tasks.c **** 	{
1033:FreeRTOS/Source/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
1034:FreeRTOS/Source/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
1035:FreeRTOS/Source/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
1036:FreeRTOS/Source/tasks.c **** 	}
1037:FreeRTOS/Source/tasks.c **** 	else
1038:FreeRTOS/Source/tasks.c **** 	{
1039:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1040:FreeRTOS/Source/tasks.c **** 	}
1041:FreeRTOS/Source/tasks.c **** }
1042:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1043:FreeRTOS/Source/tasks.c **** 
1044:FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
1045:FreeRTOS/Source/tasks.c **** {
1046:FreeRTOS/Source/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
1047:FreeRTOS/Source/tasks.c **** 	updated. */
1048:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1049:FreeRTOS/Source/tasks.c **** 	{
1050:FreeRTOS/Source/tasks.c **** 		uxCurrentNumberOfTasks++;
1051:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB == NULL )
1052:FreeRTOS/Source/tasks.c **** 		{
1053:FreeRTOS/Source/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
1054:FreeRTOS/Source/tasks.c **** 			the suspended state - make this the current task. */
1055:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB = pxNewTCB;
1056:FreeRTOS/Source/tasks.c **** 
1057:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
1058:FreeRTOS/Source/tasks.c **** 			{
1059:FreeRTOS/Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
1060:FreeRTOS/Source/tasks.c **** 				initialisation required.  We will not recover if this call
1061:FreeRTOS/Source/tasks.c **** 				fails, but we will report the failure. */
1062:FreeRTOS/Source/tasks.c **** 				prvInitialiseTaskLists();
1063:FreeRTOS/Source/tasks.c **** 			}
1064:FreeRTOS/Source/tasks.c **** 			else
1065:FreeRTOS/Source/tasks.c **** 			{
1066:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1067:FreeRTOS/Source/tasks.c **** 			}
1068:FreeRTOS/Source/tasks.c **** 		}
1069:FreeRTOS/Source/tasks.c **** 		else
1070:FreeRTOS/Source/tasks.c **** 		{
1071:FreeRTOS/Source/tasks.c **** 			/* If the scheduler is not already running, make this task the
1072:FreeRTOS/Source/tasks.c **** 			current task if it is the highest priority task to be created
1073:FreeRTOS/Source/tasks.c **** 			so far. */
1074:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
1075:FreeRTOS/Source/tasks.c **** 			{
1076:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
1077:FreeRTOS/Source/tasks.c **** 				{
1078:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = pxNewTCB;
1079:FreeRTOS/Source/tasks.c **** 				}
1080:FreeRTOS/Source/tasks.c **** 				else
1081:FreeRTOS/Source/tasks.c **** 				{
1082:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1083:FreeRTOS/Source/tasks.c **** 				}
1084:FreeRTOS/Source/tasks.c **** 			}
1085:FreeRTOS/Source/tasks.c **** 			else
1086:FreeRTOS/Source/tasks.c **** 			{
1087:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1088:FreeRTOS/Source/tasks.c **** 			}
1089:FreeRTOS/Source/tasks.c **** 		}
1090:FreeRTOS/Source/tasks.c **** 
1091:FreeRTOS/Source/tasks.c **** 		uxTaskNumber++;
1092:FreeRTOS/Source/tasks.c **** 
1093:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
1094:FreeRTOS/Source/tasks.c **** 		{
1095:FreeRTOS/Source/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
1096:FreeRTOS/Source/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
1097:FreeRTOS/Source/tasks.c **** 		}
1098:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
1099:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
1100:FreeRTOS/Source/tasks.c **** 
1101:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
1102:FreeRTOS/Source/tasks.c **** 
1103:FreeRTOS/Source/tasks.c **** 		portSETUP_TCB( pxNewTCB );
1104:FreeRTOS/Source/tasks.c **** 	}
1105:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1106:FreeRTOS/Source/tasks.c **** 
1107:FreeRTOS/Source/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
1108:FreeRTOS/Source/tasks.c **** 	{
1109:FreeRTOS/Source/tasks.c **** 		/* If the created task is of a higher priority than the current task
1110:FreeRTOS/Source/tasks.c **** 		then it should run now. */
1111:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
1112:FreeRTOS/Source/tasks.c **** 		{
1113:FreeRTOS/Source/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
1114:FreeRTOS/Source/tasks.c **** 		}
1115:FreeRTOS/Source/tasks.c **** 		else
1116:FreeRTOS/Source/tasks.c **** 		{
1117:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1118:FreeRTOS/Source/tasks.c **** 		}
1119:FreeRTOS/Source/tasks.c **** 	}
1120:FreeRTOS/Source/tasks.c **** 	else
1121:FreeRTOS/Source/tasks.c **** 	{
1122:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1123:FreeRTOS/Source/tasks.c **** 	}
1124:FreeRTOS/Source/tasks.c **** }
1125:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1126:FreeRTOS/Source/tasks.c **** 
1127:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1128:FreeRTOS/Source/tasks.c **** 
1129:FreeRTOS/Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
1130:FreeRTOS/Source/tasks.c **** 	{
1131:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1132:FreeRTOS/Source/tasks.c **** 
1133:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1134:FreeRTOS/Source/tasks.c **** 		{
1135:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
1136:FreeRTOS/Source/tasks.c **** 			being deleted. */
1137:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
1138:FreeRTOS/Source/tasks.c **** 
1139:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list. */
1140:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1141:FreeRTOS/Source/tasks.c **** 			{
1142:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1143:FreeRTOS/Source/tasks.c **** 			}
1144:FreeRTOS/Source/tasks.c **** 			else
1145:FreeRTOS/Source/tasks.c **** 			{
1146:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1147:FreeRTOS/Source/tasks.c **** 			}
1148:FreeRTOS/Source/tasks.c **** 
1149:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1150:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1151:FreeRTOS/Source/tasks.c **** 			{
1152:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1153:FreeRTOS/Source/tasks.c **** 			}
1154:FreeRTOS/Source/tasks.c **** 			else
1155:FreeRTOS/Source/tasks.c **** 			{
1156:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1157:FreeRTOS/Source/tasks.c **** 			}
1158:FreeRTOS/Source/tasks.c **** 
1159:FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1160:FreeRTOS/Source/tasks.c **** 			detect that the task lists need re-generating.  This is done before
1161:FreeRTOS/Source/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1162:FreeRTOS/Source/tasks.c **** 			not return. */
1163:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
1164:FreeRTOS/Source/tasks.c **** 
1165:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1166:FreeRTOS/Source/tasks.c **** 			{
1167:FreeRTOS/Source/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
1168:FreeRTOS/Source/tasks.c **** 				task itself, as a context switch to another task is required.
1169:FreeRTOS/Source/tasks.c **** 				Place the task in the termination list.  The idle task will
1170:FreeRTOS/Source/tasks.c **** 				check the termination list and free up any memory allocated by
1171:FreeRTOS/Source/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
1172:FreeRTOS/Source/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
1173:FreeRTOS/Source/tasks.c **** 
1174:FreeRTOS/Source/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
1175:FreeRTOS/Source/tasks.c **** 				there is a task that has been deleted and that it should therefore
1176:FreeRTOS/Source/tasks.c **** 				check the xTasksWaitingTermination list. */
1177:FreeRTOS/Source/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
1178:FreeRTOS/Source/tasks.c **** 
1179:FreeRTOS/Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1180:FreeRTOS/Source/tasks.c **** 				in which Windows specific clean up operations are performed,
1181:FreeRTOS/Source/tasks.c **** 				after which it is not possible to yield away from this task -
1182:FreeRTOS/Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1183:FreeRTOS/Source/tasks.c **** 				required. */
1184:FreeRTOS/Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1185:FreeRTOS/Source/tasks.c **** 			}
1186:FreeRTOS/Source/tasks.c **** 			else
1187:FreeRTOS/Source/tasks.c **** 			{
1188:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
1189:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
1190:FreeRTOS/Source/tasks.c **** 
1191:FreeRTOS/Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1192:FreeRTOS/Source/tasks.c **** 				the task that has just been deleted. */
1193:FreeRTOS/Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1194:FreeRTOS/Source/tasks.c **** 			}
1195:FreeRTOS/Source/tasks.c **** 
1196:FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
1197:FreeRTOS/Source/tasks.c **** 		}
1198:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1199:FreeRTOS/Source/tasks.c **** 
1200:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1201:FreeRTOS/Source/tasks.c **** 		been deleted. */
1202:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1203:FreeRTOS/Source/tasks.c **** 		{
1204:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
1205:FreeRTOS/Source/tasks.c **** 			{
1206:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1207:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
1208:FreeRTOS/Source/tasks.c **** 			}
1209:FreeRTOS/Source/tasks.c **** 			else
1210:FreeRTOS/Source/tasks.c **** 			{
1211:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1212:FreeRTOS/Source/tasks.c **** 			}
1213:FreeRTOS/Source/tasks.c **** 		}
1214:FreeRTOS/Source/tasks.c **** 	}
1215:FreeRTOS/Source/tasks.c **** 
1216:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1217:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1218:FreeRTOS/Source/tasks.c **** 
1219:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1220:FreeRTOS/Source/tasks.c **** 
1221:FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1222:FreeRTOS/Source/tasks.c **** 	{
1223:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
1224:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1225:FreeRTOS/Source/tasks.c **** 
1226:FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
1227:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
1228:FreeRTOS/Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
1229:FreeRTOS/Source/tasks.c **** 
1230:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1231:FreeRTOS/Source/tasks.c **** 		{
1232:FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1233:FreeRTOS/Source/tasks.c **** 			block. */
1234:FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
1235:FreeRTOS/Source/tasks.c **** 
1236:FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1237:FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
1238:FreeRTOS/Source/tasks.c **** 
1239:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
1240:FreeRTOS/Source/tasks.c **** 			{
1241:FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
1242:FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
1243:FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1244:FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
1245:FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
1246:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
1247:FreeRTOS/Source/tasks.c **** 				{
1248:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
1249:FreeRTOS/Source/tasks.c **** 				}
1250:FreeRTOS/Source/tasks.c **** 				else
1251:FreeRTOS/Source/tasks.c **** 				{
1252:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1253:FreeRTOS/Source/tasks.c **** 				}
1254:FreeRTOS/Source/tasks.c **** 			}
1255:FreeRTOS/Source/tasks.c **** 			else
1256:FreeRTOS/Source/tasks.c **** 			{
1257:FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1258:FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1259:FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
1260:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
1261:FreeRTOS/Source/tasks.c **** 				{
1262:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
1263:FreeRTOS/Source/tasks.c **** 				}
1264:FreeRTOS/Source/tasks.c **** 				else
1265:FreeRTOS/Source/tasks.c **** 				{
1266:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1267:FreeRTOS/Source/tasks.c **** 				}
1268:FreeRTOS/Source/tasks.c **** 			}
1269:FreeRTOS/Source/tasks.c **** 
1270:FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
1271:FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
1272:FreeRTOS/Source/tasks.c **** 
1273:FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
1274:FreeRTOS/Source/tasks.c **** 			{
1275:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1276:FreeRTOS/Source/tasks.c **** 
1277:FreeRTOS/Source/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1278:FreeRTOS/Source/tasks.c **** 				the time to wake, so subtract the current tick count. */
1279:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
1280:FreeRTOS/Source/tasks.c **** 			}
1281:FreeRTOS/Source/tasks.c **** 			else
1282:FreeRTOS/Source/tasks.c **** 			{
1283:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1284:FreeRTOS/Source/tasks.c **** 			}
1285:FreeRTOS/Source/tasks.c **** 		}
1286:FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
1287:FreeRTOS/Source/tasks.c **** 
1288:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1289:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
1290:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1291:FreeRTOS/Source/tasks.c **** 		{
1292:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
1293:FreeRTOS/Source/tasks.c **** 		}
1294:FreeRTOS/Source/tasks.c **** 		else
1295:FreeRTOS/Source/tasks.c **** 		{
1296:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1297:FreeRTOS/Source/tasks.c **** 		}
1298:FreeRTOS/Source/tasks.c **** 	}
1299:FreeRTOS/Source/tasks.c **** 
1300:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1301:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1302:FreeRTOS/Source/tasks.c **** 
1303:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1304:FreeRTOS/Source/tasks.c **** 
1305:FreeRTOS/Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1306:FreeRTOS/Source/tasks.c **** 	{
1307:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
1308:FreeRTOS/Source/tasks.c **** 
1309:FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1310:FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
1311:FreeRTOS/Source/tasks.c **** 		{
1312:FreeRTOS/Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
1313:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
1314:FreeRTOS/Source/tasks.c **** 			{
1315:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
1316:FreeRTOS/Source/tasks.c **** 
1317:FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
1318:FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
1319:FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
1320:FreeRTOS/Source/tasks.c **** 				is resumed.
1321:FreeRTOS/Source/tasks.c **** 
1322:FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
1323:FreeRTOS/Source/tasks.c **** 				executing task. */
1324:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
1325:FreeRTOS/Source/tasks.c **** 			}
1326:FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
1327:FreeRTOS/Source/tasks.c **** 		}
1328:FreeRTOS/Source/tasks.c **** 		else
1329:FreeRTOS/Source/tasks.c **** 		{
1330:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1331:FreeRTOS/Source/tasks.c **** 		}
1332:FreeRTOS/Source/tasks.c **** 
1333:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1334:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
1335:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
1336:FreeRTOS/Source/tasks.c **** 		{
1337:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
1338:FreeRTOS/Source/tasks.c **** 		}
1339:FreeRTOS/Source/tasks.c **** 		else
1340:FreeRTOS/Source/tasks.c **** 		{
1341:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1342:FreeRTOS/Source/tasks.c **** 		}
1343:FreeRTOS/Source/tasks.c **** 	}
1344:FreeRTOS/Source/tasks.c **** 
1345:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1346:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1347:FreeRTOS/Source/tasks.c **** 
1348:FreeRTOS/Source/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1349:FreeRTOS/Source/tasks.c **** 
1350:FreeRTOS/Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1351:FreeRTOS/Source/tasks.c **** 	{
1352:FreeRTOS/Source/tasks.c **** 	eTaskState eReturn;
1353:FreeRTOS/Source/tasks.c **** 	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
1354:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1355:FreeRTOS/Source/tasks.c **** 
1356:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1357:FreeRTOS/Source/tasks.c **** 
1358:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1359:FreeRTOS/Source/tasks.c **** 		{
1360:FreeRTOS/Source/tasks.c **** 			/* The task calling this function is querying its own state. */
1361:FreeRTOS/Source/tasks.c **** 			eReturn = eRunning;
1362:FreeRTOS/Source/tasks.c **** 		}
1363:FreeRTOS/Source/tasks.c **** 		else
1364:FreeRTOS/Source/tasks.c **** 		{
1365:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1366:FreeRTOS/Source/tasks.c **** 			{
1367:FreeRTOS/Source/tasks.c **** 				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1368:FreeRTOS/Source/tasks.c **** 				pxDelayedList = pxDelayedTaskList;
1369:FreeRTOS/Source/tasks.c **** 				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
1370:FreeRTOS/Source/tasks.c **** 			}
1371:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1372:FreeRTOS/Source/tasks.c **** 
1373:FreeRTOS/Source/tasks.c **** 			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
1374:FreeRTOS/Source/tasks.c **** 			{
1375:FreeRTOS/Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1376:FreeRTOS/Source/tasks.c **** 				lists. */
1377:FreeRTOS/Source/tasks.c **** 				eReturn = eBlocked;
1378:FreeRTOS/Source/tasks.c **** 			}
1379:FreeRTOS/Source/tasks.c **** 
1380:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1381:FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1382:FreeRTOS/Source/tasks.c **** 				{
1383:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the suspended
1384:FreeRTOS/Source/tasks.c **** 					list.  Is it genuinely suspended or is it blocked
1385:FreeRTOS/Source/tasks.c **** 					indefinitely? */
1386:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1387:FreeRTOS/Source/tasks.c **** 					{
1388:FreeRTOS/Source/tasks.c **** 						#if( configUSE_TASK_NOTIFICATIONS == 1 )
1389:FreeRTOS/Source/tasks.c **** 						{
1390:FreeRTOS/Source/tasks.c **** 							/* The task does not appear on the event list item of
1391:FreeRTOS/Source/tasks.c **** 							and of the RTOS objects, but could still be in the
1392:FreeRTOS/Source/tasks.c **** 							blocked state if it is waiting on its notification
1393:FreeRTOS/Source/tasks.c **** 							rather than waiting on an object. */
1394:FreeRTOS/Source/tasks.c **** 							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1395:FreeRTOS/Source/tasks.c **** 							{
1396:FreeRTOS/Source/tasks.c **** 								eReturn = eBlocked;
1397:FreeRTOS/Source/tasks.c **** 							}
1398:FreeRTOS/Source/tasks.c **** 							else
1399:FreeRTOS/Source/tasks.c **** 							{
1400:FreeRTOS/Source/tasks.c **** 								eReturn = eSuspended;
1401:FreeRTOS/Source/tasks.c **** 							}
1402:FreeRTOS/Source/tasks.c **** 						}
1403:FreeRTOS/Source/tasks.c **** 						#else
1404:FreeRTOS/Source/tasks.c **** 						{
1405:FreeRTOS/Source/tasks.c **** 							eReturn = eSuspended;
1406:FreeRTOS/Source/tasks.c **** 						}
1407:FreeRTOS/Source/tasks.c **** 						#endif
1408:FreeRTOS/Source/tasks.c **** 					}
1409:FreeRTOS/Source/tasks.c **** 					else
1410:FreeRTOS/Source/tasks.c **** 					{
1411:FreeRTOS/Source/tasks.c **** 						eReturn = eBlocked;
1412:FreeRTOS/Source/tasks.c **** 					}
1413:FreeRTOS/Source/tasks.c **** 				}
1414:FreeRTOS/Source/tasks.c **** 			#endif
1415:FreeRTOS/Source/tasks.c **** 
1416:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1417:FreeRTOS/Source/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1418:FreeRTOS/Source/tasks.c **** 				{
1419:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the deleted
1420:FreeRTOS/Source/tasks.c **** 					tasks list, or it is not referenced from any lists at
1421:FreeRTOS/Source/tasks.c **** 					all. */
1422:FreeRTOS/Source/tasks.c **** 					eReturn = eDeleted;
1423:FreeRTOS/Source/tasks.c **** 				}
1424:FreeRTOS/Source/tasks.c **** 			#endif
1425:FreeRTOS/Source/tasks.c **** 
1426:FreeRTOS/Source/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1427:FreeRTOS/Source/tasks.c **** 			{
1428:FreeRTOS/Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
1429:FreeRTOS/Source/tasks.c **** 				Ready (including pending ready) state. */
1430:FreeRTOS/Source/tasks.c **** 				eReturn = eReady;
1431:FreeRTOS/Source/tasks.c **** 			}
1432:FreeRTOS/Source/tasks.c **** 		}
1433:FreeRTOS/Source/tasks.c **** 
1434:FreeRTOS/Source/tasks.c **** 		return eReturn;
1435:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1436:FreeRTOS/Source/tasks.c **** 
1437:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1438:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1439:FreeRTOS/Source/tasks.c **** 
1440:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1441:FreeRTOS/Source/tasks.c **** 
1442:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
1443:FreeRTOS/Source/tasks.c **** 	{
1444:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
1445:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
1446:FreeRTOS/Source/tasks.c **** 
1447:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1448:FreeRTOS/Source/tasks.c **** 		{
1449:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the task
1450:FreeRTOS/Source/tasks.c **** 			that called uxTaskPriorityGet() that is being queried. */
1451:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1452:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1453:FreeRTOS/Source/tasks.c **** 		}
1454:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1455:FreeRTOS/Source/tasks.c **** 
1456:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1457:FreeRTOS/Source/tasks.c **** 	}
1458:FreeRTOS/Source/tasks.c **** 
1459:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1460:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1461:FreeRTOS/Source/tasks.c **** 
1462:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1463:FreeRTOS/Source/tasks.c **** 
1464:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
1465:FreeRTOS/Source/tasks.c **** 	{
1466:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
1467:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1468:FreeRTOS/Source/tasks.c **** 
1469:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1470:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1471:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1472:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1473:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1474:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1475:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1476:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1477:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1478:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1479:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1480:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1481:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1482:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1483:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1484:FreeRTOS/Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1485:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1486:FreeRTOS/Source/tasks.c **** 
1487:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1488:FreeRTOS/Source/tasks.c **** 		{
1489:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1490:FreeRTOS/Source/tasks.c **** 			task that is being queried. */
1491:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1492:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1493:FreeRTOS/Source/tasks.c **** 		}
1494:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1495:FreeRTOS/Source/tasks.c **** 
1496:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1497:FreeRTOS/Source/tasks.c **** 	}
1498:FreeRTOS/Source/tasks.c **** 
1499:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1500:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1501:FreeRTOS/Source/tasks.c **** 
1502:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1503:FreeRTOS/Source/tasks.c **** 
1504:FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1505:FreeRTOS/Source/tasks.c **** 	{
1506:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1507:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1508:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1509:FreeRTOS/Source/tasks.c **** 
1510:FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1511:FreeRTOS/Source/tasks.c **** 
1512:FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
1513:FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1514:FreeRTOS/Source/tasks.c **** 		{
1515:FreeRTOS/Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1516:FreeRTOS/Source/tasks.c **** 		}
1517:FreeRTOS/Source/tasks.c **** 		else
1518:FreeRTOS/Source/tasks.c **** 		{
1519:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1520:FreeRTOS/Source/tasks.c **** 		}
1521:FreeRTOS/Source/tasks.c **** 
1522:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1523:FreeRTOS/Source/tasks.c **** 		{
1524:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1525:FreeRTOS/Source/tasks.c **** 			task that is being changed. */
1526:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1527:FreeRTOS/Source/tasks.c **** 
1528:FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1529:FreeRTOS/Source/tasks.c **** 
1530:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1531:FreeRTOS/Source/tasks.c **** 			{
1532:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1533:FreeRTOS/Source/tasks.c **** 			}
1534:FreeRTOS/Source/tasks.c **** 			#else
1535:FreeRTOS/Source/tasks.c **** 			{
1536:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1537:FreeRTOS/Source/tasks.c **** 			}
1538:FreeRTOS/Source/tasks.c **** 			#endif
1539:FreeRTOS/Source/tasks.c **** 
1540:FreeRTOS/Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
1541:FreeRTOS/Source/tasks.c **** 			{
1542:FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
1543:FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
1544:FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
1545:FreeRTOS/Source/tasks.c **** 				{
1546:FreeRTOS/Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
1547:FreeRTOS/Source/tasks.c **** 					{
1548:FreeRTOS/Source/tasks.c **** 						/* The priority of a task other than the currently
1549:FreeRTOS/Source/tasks.c **** 						running task is being raised.  Is the priority being
1550:FreeRTOS/Source/tasks.c **** 						raised above that of the running task? */
1551:FreeRTOS/Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1552:FreeRTOS/Source/tasks.c **** 						{
1553:FreeRTOS/Source/tasks.c **** 							xYieldRequired = pdTRUE;
1554:FreeRTOS/Source/tasks.c **** 						}
1555:FreeRTOS/Source/tasks.c **** 						else
1556:FreeRTOS/Source/tasks.c **** 						{
1557:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1558:FreeRTOS/Source/tasks.c **** 						}
1559:FreeRTOS/Source/tasks.c **** 					}
1560:FreeRTOS/Source/tasks.c **** 					else
1561:FreeRTOS/Source/tasks.c **** 					{
1562:FreeRTOS/Source/tasks.c **** 						/* The priority of the running task is being raised,
1563:FreeRTOS/Source/tasks.c **** 						but the running task must already be the highest
1564:FreeRTOS/Source/tasks.c **** 						priority task able to run so no yield is required. */
1565:FreeRTOS/Source/tasks.c **** 					}
1566:FreeRTOS/Source/tasks.c **** 				}
1567:FreeRTOS/Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
1568:FreeRTOS/Source/tasks.c **** 				{
1569:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of the running task down means
1570:FreeRTOS/Source/tasks.c **** 					there may now be another task of higher priority that
1571:FreeRTOS/Source/tasks.c **** 					is ready to execute. */
1572:FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
1573:FreeRTOS/Source/tasks.c **** 				}
1574:FreeRTOS/Source/tasks.c **** 				else
1575:FreeRTOS/Source/tasks.c **** 				{
1576:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of any other task down does not
1577:FreeRTOS/Source/tasks.c **** 					require a yield as the running task must be above the
1578:FreeRTOS/Source/tasks.c **** 					new priority of the task being modified. */
1579:FreeRTOS/Source/tasks.c **** 				}
1580:FreeRTOS/Source/tasks.c **** 
1581:FreeRTOS/Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1582:FreeRTOS/Source/tasks.c **** 				before its uxPriority member is changed so the
1583:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1584:FreeRTOS/Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1585:FreeRTOS/Source/tasks.c **** 
1586:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1587:FreeRTOS/Source/tasks.c **** 				{
1588:FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
1589:FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
1590:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1591:FreeRTOS/Source/tasks.c **** 					{
1592:FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1593:FreeRTOS/Source/tasks.c **** 					}
1594:FreeRTOS/Source/tasks.c **** 					else
1595:FreeRTOS/Source/tasks.c **** 					{
1596:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1597:FreeRTOS/Source/tasks.c **** 					}
1598:FreeRTOS/Source/tasks.c **** 
1599:FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
1600:FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1601:FreeRTOS/Source/tasks.c **** 				}
1602:FreeRTOS/Source/tasks.c **** 				#else
1603:FreeRTOS/Source/tasks.c **** 				{
1604:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1605:FreeRTOS/Source/tasks.c **** 				}
1606:FreeRTOS/Source/tasks.c **** 				#endif
1607:FreeRTOS/Source/tasks.c **** 
1608:FreeRTOS/Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1609:FreeRTOS/Source/tasks.c **** 				being used for anything else. */
1610:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
1611:FreeRTOS/Source/tasks.c **** 				{
1612:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
1613:FreeRTOS/Source/tasks.c **** 				}
1614:FreeRTOS/Source/tasks.c **** 				else
1615:FreeRTOS/Source/tasks.c **** 				{
1616:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1617:FreeRTOS/Source/tasks.c **** 				}
1618:FreeRTOS/Source/tasks.c **** 
1619:FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1620:FreeRTOS/Source/tasks.c **** 				nothing more than change its priority variable. However, if
1621:FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1622:FreeRTOS/Source/tasks.c **** 				in the list appropriate to its new priority. */
1623:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
1624:FreeRTOS/Source/tasks.c **** 				{
1625:FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before
1626:FreeRTOS/Source/tasks.c **** 					adding it to it's new ready list.  As we are in a critical
1627:FreeRTOS/Source/tasks.c **** 					section we can do this even if the scheduler is suspended. */
1628:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1629:FreeRTOS/Source/tasks.c **** 					{
1630:FreeRTOS/Source/tasks.c **** 						/* It is known that the task is in its ready list so
1631:FreeRTOS/Source/tasks.c **** 						there is no need to check again and the port level
1632:FreeRTOS/Source/tasks.c **** 						reset macro can be called directly. */
1633:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1634:FreeRTOS/Source/tasks.c **** 					}
1635:FreeRTOS/Source/tasks.c **** 					else
1636:FreeRTOS/Source/tasks.c **** 					{
1637:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1638:FreeRTOS/Source/tasks.c **** 					}
1639:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1640:FreeRTOS/Source/tasks.c **** 				}
1641:FreeRTOS/Source/tasks.c **** 				else
1642:FreeRTOS/Source/tasks.c **** 				{
1643:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1644:FreeRTOS/Source/tasks.c **** 				}
1645:FreeRTOS/Source/tasks.c **** 
1646:FreeRTOS/Source/tasks.c **** 				if( xYieldRequired != pdFALSE )
1647:FreeRTOS/Source/tasks.c **** 				{
1648:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1649:FreeRTOS/Source/tasks.c **** 				}
1650:FreeRTOS/Source/tasks.c **** 				else
1651:FreeRTOS/Source/tasks.c **** 				{
1652:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1653:FreeRTOS/Source/tasks.c **** 				}
1654:FreeRTOS/Source/tasks.c **** 
1655:FreeRTOS/Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1656:FreeRTOS/Source/tasks.c **** 				optimised task selection is not being used. */
1657:FreeRTOS/Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1658:FreeRTOS/Source/tasks.c **** 			}
1659:FreeRTOS/Source/tasks.c **** 		}
1660:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1661:FreeRTOS/Source/tasks.c **** 	}
1662:FreeRTOS/Source/tasks.c **** 
1663:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1664:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1665:FreeRTOS/Source/tasks.c **** 
1666:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1667:FreeRTOS/Source/tasks.c **** 
1668:FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1669:FreeRTOS/Source/tasks.c **** 	{
1670:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1671:FreeRTOS/Source/tasks.c **** 
1672:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1673:FreeRTOS/Source/tasks.c **** 		{
1674:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1675:FreeRTOS/Source/tasks.c **** 			being suspended. */
1676:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1677:FreeRTOS/Source/tasks.c **** 
1678:FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1679:FreeRTOS/Source/tasks.c **** 
1680:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1681:FreeRTOS/Source/tasks.c **** 			suspended list. */
1682:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1683:FreeRTOS/Source/tasks.c **** 			{
1684:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1685:FreeRTOS/Source/tasks.c **** 			}
1686:FreeRTOS/Source/tasks.c **** 			else
1687:FreeRTOS/Source/tasks.c **** 			{
1688:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1689:FreeRTOS/Source/tasks.c **** 			}
1690:FreeRTOS/Source/tasks.c **** 
1691:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1692:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1693:FreeRTOS/Source/tasks.c **** 			{
1694:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1695:FreeRTOS/Source/tasks.c **** 			}
1696:FreeRTOS/Source/tasks.c **** 			else
1697:FreeRTOS/Source/tasks.c **** 			{
1698:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1699:FreeRTOS/Source/tasks.c **** 			}
1700:FreeRTOS/Source/tasks.c **** 
1701:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
1702:FreeRTOS/Source/tasks.c **** 
1703:FreeRTOS/Source/tasks.c **** 			#if( configUSE_TASK_NOTIFICATIONS == 1 )
1704:FreeRTOS/Source/tasks.c **** 			{
1705:FreeRTOS/Source/tasks.c **** 				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1706:FreeRTOS/Source/tasks.c **** 				{
1707:FreeRTOS/Source/tasks.c **** 					/* The task was blocked to wait for a notification, but is
1708:FreeRTOS/Source/tasks.c **** 					now suspended, so no notification was received. */
1709:FreeRTOS/Source/tasks.c **** 					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
1710:FreeRTOS/Source/tasks.c **** 				}
1711:FreeRTOS/Source/tasks.c **** 			}
1712:FreeRTOS/Source/tasks.c **** 			#endif
1713:FreeRTOS/Source/tasks.c **** 		}
1714:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1715:FreeRTOS/Source/tasks.c **** 
1716:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
1717:FreeRTOS/Source/tasks.c **** 		{
1718:FreeRTOS/Source/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1719:FreeRTOS/Source/tasks.c **** 			task that is now in the Suspended state. */
1720:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1721:FreeRTOS/Source/tasks.c **** 			{
1722:FreeRTOS/Source/tasks.c **** 				prvResetNextTaskUnblockTime();
1723:FreeRTOS/Source/tasks.c **** 			}
1724:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1725:FreeRTOS/Source/tasks.c **** 		}
1726:FreeRTOS/Source/tasks.c **** 		else
1727:FreeRTOS/Source/tasks.c **** 		{
1728:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1729:FreeRTOS/Source/tasks.c **** 		}
1730:FreeRTOS/Source/tasks.c **** 
1731:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1732:FreeRTOS/Source/tasks.c **** 		{
1733:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1734:FreeRTOS/Source/tasks.c **** 			{
1735:FreeRTOS/Source/tasks.c **** 				/* The current task has just been suspended. */
1736:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1737:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
1738:FreeRTOS/Source/tasks.c **** 			}
1739:FreeRTOS/Source/tasks.c **** 			else
1740:FreeRTOS/Source/tasks.c **** 			{
1741:FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1742:FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1743:FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
1744:FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Rig
1745:FreeRTOS/Source/tasks.c **** 				{
1746:FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1747:FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1748:FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
1749:FreeRTOS/Source/tasks.c **** 					is. */
1750:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
1751:FreeRTOS/Source/tasks.c **** 				}
1752:FreeRTOS/Source/tasks.c **** 				else
1753:FreeRTOS/Source/tasks.c **** 				{
1754:FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
1755:FreeRTOS/Source/tasks.c **** 				}
1756:FreeRTOS/Source/tasks.c **** 			}
1757:FreeRTOS/Source/tasks.c **** 		}
1758:FreeRTOS/Source/tasks.c **** 		else
1759:FreeRTOS/Source/tasks.c **** 		{
1760:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1761:FreeRTOS/Source/tasks.c **** 		}
1762:FreeRTOS/Source/tasks.c **** 	}
1763:FreeRTOS/Source/tasks.c **** 
1764:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1765:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1766:FreeRTOS/Source/tasks.c **** 
1767:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1768:FreeRTOS/Source/tasks.c **** 
1769:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1770:FreeRTOS/Source/tasks.c **** 	{
1771:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
1772:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1773:FreeRTOS/Source/tasks.c **** 
1774:FreeRTOS/Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1775:FreeRTOS/Source/tasks.c **** 		section. */
1776:FreeRTOS/Source/tasks.c **** 
1777:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1778:FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
1779:FreeRTOS/Source/tasks.c **** 
1780:FreeRTOS/Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1781:FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
1782:FreeRTOS/Source/tasks.c **** 		{
1783:FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1784:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1785:FreeRTOS/Source/tasks.c **** 			{
1786:FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1787:FreeRTOS/Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1788:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The
1789:FreeRTOS/Source/tasks.c **** 				{
1790:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
1791:FreeRTOS/Source/tasks.c **** 				}
1792:FreeRTOS/Source/tasks.c **** 				else
1793:FreeRTOS/Source/tasks.c **** 				{
1794:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1795:FreeRTOS/Source/tasks.c **** 				}
1796:FreeRTOS/Source/tasks.c **** 			}
1797:FreeRTOS/Source/tasks.c **** 			else
1798:FreeRTOS/Source/tasks.c **** 			{
1799:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1800:FreeRTOS/Source/tasks.c **** 			}
1801:FreeRTOS/Source/tasks.c **** 		}
1802:FreeRTOS/Source/tasks.c **** 		else
1803:FreeRTOS/Source/tasks.c **** 		{
1804:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1805:FreeRTOS/Source/tasks.c **** 		}
1806:FreeRTOS/Source/tasks.c **** 
1807:FreeRTOS/Source/tasks.c **** 		return xReturn;
1808:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1809:FreeRTOS/Source/tasks.c **** 
1810:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1811:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1812:FreeRTOS/Source/tasks.c **** 
1813:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1814:FreeRTOS/Source/tasks.c **** 
1815:FreeRTOS/Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1816:FreeRTOS/Source/tasks.c **** 	{
1817:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1818:FreeRTOS/Source/tasks.c **** 
1819:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1820:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1821:FreeRTOS/Source/tasks.c **** 
1822:FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1823:FreeRTOS/Source/tasks.c **** 		currently executing task. */
1824:FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
1825:FreeRTOS/Source/tasks.c **** 		{
1826:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1827:FreeRTOS/Source/tasks.c **** 			{
1828:FreeRTOS/Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1829:FreeRTOS/Source/tasks.c **** 				{
1830:FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1831:FreeRTOS/Source/tasks.c **** 
1832:FreeRTOS/Source/tasks.c **** 					/* The ready list can be accessed even if the scheduler is
1833:FreeRTOS/Source/tasks.c **** 					suspended because this is inside a critical section. */
1834:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
1835:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1836:FreeRTOS/Source/tasks.c **** 
1837:FreeRTOS/Source/tasks.c **** 					/* A higher priority task may have just been resumed. */
1838:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1839:FreeRTOS/Source/tasks.c **** 					{
1840:FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1841:FreeRTOS/Source/tasks.c **** 						but will leave the lists in the correct state for the
1842:FreeRTOS/Source/tasks.c **** 						next yield. */
1843:FreeRTOS/Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1844:FreeRTOS/Source/tasks.c **** 					}
1845:FreeRTOS/Source/tasks.c **** 					else
1846:FreeRTOS/Source/tasks.c **** 					{
1847:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1848:FreeRTOS/Source/tasks.c **** 					}
1849:FreeRTOS/Source/tasks.c **** 				}
1850:FreeRTOS/Source/tasks.c **** 				else
1851:FreeRTOS/Source/tasks.c **** 				{
1852:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1853:FreeRTOS/Source/tasks.c **** 				}
1854:FreeRTOS/Source/tasks.c **** 			}
1855:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1856:FreeRTOS/Source/tasks.c **** 		}
1857:FreeRTOS/Source/tasks.c **** 		else
1858:FreeRTOS/Source/tasks.c **** 		{
1859:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1860:FreeRTOS/Source/tasks.c **** 		}
1861:FreeRTOS/Source/tasks.c **** 	}
1862:FreeRTOS/Source/tasks.c **** 
1863:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1864:FreeRTOS/Source/tasks.c **** 
1865:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1866:FreeRTOS/Source/tasks.c **** 
1867:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1868:FreeRTOS/Source/tasks.c **** 
1869:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1870:FreeRTOS/Source/tasks.c **** 	{
1871:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1872:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
1873:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1874:FreeRTOS/Source/tasks.c **** 
1875:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1876:FreeRTOS/Source/tasks.c **** 
1877:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1878:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1879:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1880:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1881:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1882:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1883:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1884:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1885:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1886:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1887:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1888:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1889:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1890:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1891:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1892:FreeRTOS/Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1893:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1894:FreeRTOS/Source/tasks.c **** 
1895:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1896:FreeRTOS/Source/tasks.c **** 		{
1897:FreeRTOS/Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1898:FreeRTOS/Source/tasks.c **** 			{
1899:FreeRTOS/Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1900:FreeRTOS/Source/tasks.c **** 
1901:FreeRTOS/Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1902:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1903:FreeRTOS/Source/tasks.c **** 				{
1904:FreeRTOS/Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1905:FreeRTOS/Source/tasks.c **** 					suspended list to the ready list directly. */
1906:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1907:FreeRTOS/Source/tasks.c **** 					{
1908:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1909:FreeRTOS/Source/tasks.c **** 					}
1910:FreeRTOS/Source/tasks.c **** 					else
1911:FreeRTOS/Source/tasks.c **** 					{
1912:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1913:FreeRTOS/Source/tasks.c **** 					}
1914:FreeRTOS/Source/tasks.c **** 
1915:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1916:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1917:FreeRTOS/Source/tasks.c **** 				}
1918:FreeRTOS/Source/tasks.c **** 				else
1919:FreeRTOS/Source/tasks.c **** 				{
1920:FreeRTOS/Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1921:FreeRTOS/Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1922:FreeRTOS/Source/tasks.c **** 					unsuspended. */
1923:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1924:FreeRTOS/Source/tasks.c **** 				}
1925:FreeRTOS/Source/tasks.c **** 			}
1926:FreeRTOS/Source/tasks.c **** 			else
1927:FreeRTOS/Source/tasks.c **** 			{
1928:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1929:FreeRTOS/Source/tasks.c **** 			}
1930:FreeRTOS/Source/tasks.c **** 		}
1931:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1932:FreeRTOS/Source/tasks.c **** 
1933:FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
1934:FreeRTOS/Source/tasks.c **** 	}
1935:FreeRTOS/Source/tasks.c **** 
1936:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1937:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1938:FreeRTOS/Source/tasks.c **** 
1939:FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1940:FreeRTOS/Source/tasks.c **** {
1941:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
1942:FreeRTOS/Source/tasks.c **** 
1943:FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1944:FreeRTOS/Source/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1945:FreeRTOS/Source/tasks.c **** 	{
1946:FreeRTOS/Source/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1947:FreeRTOS/Source/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1948:FreeRTOS/Source/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1949:FreeRTOS/Source/tasks.c **** 
1950:FreeRTOS/Source/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1951:FreeRTOS/Source/tasks.c **** 		address of the RAM then create the idle task. */
1952:FreeRTOS/Source/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1953:FreeRTOS/Source/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1954:FreeRTOS/Source/tasks.c **** 												configIDLE_TASK_NAME,
1955:FreeRTOS/Source/tasks.c **** 												ulIdleTaskStackSize,
1956:FreeRTOS/Source/tasks.c **** 												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
1957:FreeRTOS/Source/tasks.c **** 												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_P
1958:FreeRTOS/Source/tasks.c **** 												pxIdleTaskStackBuffer,
1959:FreeRTOS/Source/tasks.c **** 												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant
1960:FreeRTOS/Source/tasks.c **** 
1961:FreeRTOS/Source/tasks.c **** 		if( xIdleTaskHandle != NULL )
1962:FreeRTOS/Source/tasks.c **** 		{
1963:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
1964:FreeRTOS/Source/tasks.c **** 		}
1965:FreeRTOS/Source/tasks.c **** 		else
1966:FreeRTOS/Source/tasks.c **** 		{
1967:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
1968:FreeRTOS/Source/tasks.c **** 		}
1969:FreeRTOS/Source/tasks.c **** 	}
1970:FreeRTOS/Source/tasks.c **** 	#else
1971:FreeRTOS/Source/tasks.c **** 	{
1972:FreeRTOS/Source/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
1973:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate(	prvIdleTask,
1974:FreeRTOS/Source/tasks.c **** 								configIDLE_TASK_NAME,
1975:FreeRTOS/Source/tasks.c **** 								configMINIMAL_STACK_SIZE,
1976:FreeRTOS/Source/tasks.c **** 								( void * ) NULL,
1977:FreeRTOS/Source/tasks.c **** 								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIOR
1978:FreeRTOS/Source/tasks.c **** 								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explic
1979:FreeRTOS/Source/tasks.c **** 	}
1980:FreeRTOS/Source/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
1981:FreeRTOS/Source/tasks.c **** 
1982:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1983:FreeRTOS/Source/tasks.c **** 	{
1984:FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1985:FreeRTOS/Source/tasks.c **** 		{
1986:FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1987:FreeRTOS/Source/tasks.c **** 		}
1988:FreeRTOS/Source/tasks.c **** 		else
1989:FreeRTOS/Source/tasks.c **** 		{
1990:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1991:FreeRTOS/Source/tasks.c **** 		}
1992:FreeRTOS/Source/tasks.c **** 	}
1993:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1994:FreeRTOS/Source/tasks.c **** 
1995:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
1996:FreeRTOS/Source/tasks.c **** 	{
1997:FreeRTOS/Source/tasks.c **** 		/* freertos_tasks_c_additions_init() should only be called if the user
1998:FreeRTOS/Source/tasks.c **** 		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
1999:FreeRTOS/Source/tasks.c **** 		the only macro called by the function. */
2000:FreeRTOS/Source/tasks.c **** 		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
2001:FreeRTOS/Source/tasks.c **** 		{
2002:FreeRTOS/Source/tasks.c **** 			freertos_tasks_c_additions_init();
2003:FreeRTOS/Source/tasks.c **** 		}
2004:FreeRTOS/Source/tasks.c **** 		#endif
2005:FreeRTOS/Source/tasks.c **** 
2006:FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
2007:FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
2008:FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
2009:FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
2010:FreeRTOS/Source/tasks.c **** 		starts to run. */
2011:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
2012:FreeRTOS/Source/tasks.c **** 
2013:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2014:FreeRTOS/Source/tasks.c **** 		{
2015:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2016:FreeRTOS/Source/tasks.c **** 			structure specific to the task that will run first. */
2017:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2018:FreeRTOS/Source/tasks.c **** 		}
2019:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2020:FreeRTOS/Source/tasks.c **** 
2021:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
2022:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
2023:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
2024:FreeRTOS/Source/tasks.c **** 
2025:FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
2026:FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
2027:FreeRTOS/Source/tasks.c **** 		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2028:FreeRTOS/Source/tasks.c **** 		is set to 0 and the following line fails to build then ensure you do not
2029:FreeRTOS/Source/tasks.c **** 		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2030:FreeRTOS/Source/tasks.c **** 		FreeRTOSConfig.h file. */
2031:FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
2032:FreeRTOS/Source/tasks.c **** 
2033:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2034:FreeRTOS/Source/tasks.c **** 
2035:FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
2036:FreeRTOS/Source/tasks.c **** 		portable interface. */
2037:FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
2038:FreeRTOS/Source/tasks.c **** 		{
2039:FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
2040:FreeRTOS/Source/tasks.c **** 			function will not return. */
2041:FreeRTOS/Source/tasks.c **** 		}
2042:FreeRTOS/Source/tasks.c **** 		else
2043:FreeRTOS/Source/tasks.c **** 		{
2044:FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
2045:FreeRTOS/Source/tasks.c **** 		}
2046:FreeRTOS/Source/tasks.c **** 	}
2047:FreeRTOS/Source/tasks.c **** 	else
2048:FreeRTOS/Source/tasks.c **** 	{
2049:FreeRTOS/Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
2050:FreeRTOS/Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
2051:FreeRTOS/Source/tasks.c **** 		or the timer task. */
2052:FreeRTOS/Source/tasks.c **** 		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2053:FreeRTOS/Source/tasks.c **** 	}
2054:FreeRTOS/Source/tasks.c **** 
2055:FreeRTOS/Source/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2056:FreeRTOS/Source/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
2057:FreeRTOS/Source/tasks.c **** 	( void ) xIdleTaskHandle;
2058:FreeRTOS/Source/tasks.c **** }
2059:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2060:FreeRTOS/Source/tasks.c **** 
2061:FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
2062:FreeRTOS/Source/tasks.c **** {
2063:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
2064:FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
2065:FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
2066:FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
2067:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
2068:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
2069:FreeRTOS/Source/tasks.c **** }
2070:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2071:FreeRTOS/Source/tasks.c **** 
2072:FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
2073:FreeRTOS/Source/tasks.c **** {
2074:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
2075:FreeRTOS/Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
2076:FreeRTOS/Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
2077:FreeRTOS/Source/tasks.c **** 	http://goo.gl/wu4acr */
2078:FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
2079:FreeRTOS/Source/tasks.c **** }
2080:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2081:FreeRTOS/Source/tasks.c **** 
2082:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2083:FreeRTOS/Source/tasks.c **** 
2084:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
2085:FreeRTOS/Source/tasks.c **** 	{
2086:FreeRTOS/Source/tasks.c **** 	TickType_t xReturn;
2087:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2088:FreeRTOS/Source/tasks.c **** 
2089:FreeRTOS/Source/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
2090:FreeRTOS/Source/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2091:FreeRTOS/Source/tasks.c **** 		task that are in the Ready state, even though the idle task is
2092:FreeRTOS/Source/tasks.c **** 		running. */
2093:FreeRTOS/Source/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2094:FreeRTOS/Source/tasks.c **** 		{
2095:FreeRTOS/Source/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
2096:FreeRTOS/Source/tasks.c **** 			{
2097:FreeRTOS/Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2098:FreeRTOS/Source/tasks.c **** 			}
2099:FreeRTOS/Source/tasks.c **** 		}
2100:FreeRTOS/Source/tasks.c **** 		#else
2101:FreeRTOS/Source/tasks.c **** 		{
2102:FreeRTOS/Source/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2103:FreeRTOS/Source/tasks.c **** 
2104:FreeRTOS/Source/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
2105:FreeRTOS/Source/tasks.c **** 			variable is used as a bit map.  If bits other than the least
2106:FreeRTOS/Source/tasks.c **** 			significant bit are set then there are tasks that have a priority
2107:FreeRTOS/Source/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
2108:FreeRTOS/Source/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
2109:FreeRTOS/Source/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
2110:FreeRTOS/Source/tasks.c **** 			{
2111:FreeRTOS/Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2112:FreeRTOS/Source/tasks.c **** 			}
2113:FreeRTOS/Source/tasks.c **** 		}
2114:FreeRTOS/Source/tasks.c **** 		#endif
2115:FreeRTOS/Source/tasks.c **** 
2116:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2117:FreeRTOS/Source/tasks.c **** 		{
2118:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2119:FreeRTOS/Source/tasks.c **** 		}
2120:FreeRTOS/Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2121:FreeRTOS/Source/tasks.c **** 		{
2122:FreeRTOS/Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
2123:FreeRTOS/Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
2124:FreeRTOS/Source/tasks.c **** 			processed. */
2125:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2126:FreeRTOS/Source/tasks.c **** 		}
2127:FreeRTOS/Source/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
2128:FreeRTOS/Source/tasks.c **** 		{
2129:FreeRTOS/Source/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
2130:FreeRTOS/Source/tasks.c **** 			idle priority.  This path can only be reached if
2131:FreeRTOS/Source/tasks.c **** 			configUSE_PREEMPTION is 0. */
2132:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2133:FreeRTOS/Source/tasks.c **** 		}
2134:FreeRTOS/Source/tasks.c **** 		else
2135:FreeRTOS/Source/tasks.c **** 		{
2136:FreeRTOS/Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
2137:FreeRTOS/Source/tasks.c **** 		}
2138:FreeRTOS/Source/tasks.c **** 
2139:FreeRTOS/Source/tasks.c **** 		return xReturn;
2140:FreeRTOS/Source/tasks.c **** 	}
2141:FreeRTOS/Source/tasks.c **** 
2142:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2143:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2144:FreeRTOS/Source/tasks.c **** 
2145:FreeRTOS/Source/tasks.c **** BaseType_t xTaskResumeAll( void )
2146:FreeRTOS/Source/tasks.c **** {
2147:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB = NULL;
2148:FreeRTOS/Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
2149:FreeRTOS/Source/tasks.c **** 
2150:FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
2151:FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
2152:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
2153:FreeRTOS/Source/tasks.c **** 
2154:FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
2155:FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
2156:FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
2157:FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
2158:FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
2159:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
2160:FreeRTOS/Source/tasks.c **** 	{
2161:FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
2162:FreeRTOS/Source/tasks.c **** 
2163:FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2164:FreeRTOS/Source/tasks.c **** 		{
2165:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
2166:FreeRTOS/Source/tasks.c **** 			{
2167:FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
2168:FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
2169:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
2170:FreeRTOS/Source/tasks.c **** 				{
2171:FreeRTOS/Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as
2172:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2173:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2174:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2175:FreeRTOS/Source/tasks.c **** 
2176:FreeRTOS/Source/tasks.c **** 					/* If the moved task has a priority higher than the current
2177:FreeRTOS/Source/tasks.c **** 					task then a yield must be performed. */
2178:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2179:FreeRTOS/Source/tasks.c **** 					{
2180:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
2181:FreeRTOS/Source/tasks.c **** 					}
2182:FreeRTOS/Source/tasks.c **** 					else
2183:FreeRTOS/Source/tasks.c **** 					{
2184:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2185:FreeRTOS/Source/tasks.c **** 					}
2186:FreeRTOS/Source/tasks.c **** 				}
2187:FreeRTOS/Source/tasks.c **** 
2188:FreeRTOS/Source/tasks.c **** 				if( pxTCB != NULL )
2189:FreeRTOS/Source/tasks.c **** 				{
2190:FreeRTOS/Source/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
2191:FreeRTOS/Source/tasks.c **** 					which may have prevented the next unblock time from being
2192:FreeRTOS/Source/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
2193:FreeRTOS/Source/tasks.c **** 					important for low power tickless implementations, where
2194:FreeRTOS/Source/tasks.c **** 					this can prevent an unnecessary exit from low power
2195:FreeRTOS/Source/tasks.c **** 					state. */
2196:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
2197:FreeRTOS/Source/tasks.c **** 				}
2198:FreeRTOS/Source/tasks.c **** 
2199:FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
2200:FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
2201:FreeRTOS/Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
2202:FreeRTOS/Source/tasks.c **** 				time. */
2203:FreeRTOS/Source/tasks.c **** 				{
2204:FreeRTOS/Source/tasks.c **** 					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
2205:FreeRTOS/Source/tasks.c **** 
2206:FreeRTOS/Source/tasks.c **** 					if( uxPendedCounts > ( UBaseType_t ) 0U )
2207:FreeRTOS/Source/tasks.c **** 					{
2208:FreeRTOS/Source/tasks.c **** 						do
2209:FreeRTOS/Source/tasks.c **** 						{
2210:FreeRTOS/Source/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
2211:FreeRTOS/Source/tasks.c **** 							{
2212:FreeRTOS/Source/tasks.c **** 								xYieldPending = pdTRUE;
2213:FreeRTOS/Source/tasks.c **** 							}
2214:FreeRTOS/Source/tasks.c **** 							else
2215:FreeRTOS/Source/tasks.c **** 							{
2216:FreeRTOS/Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2217:FreeRTOS/Source/tasks.c **** 							}
2218:FreeRTOS/Source/tasks.c **** 							--uxPendedCounts;
2219:FreeRTOS/Source/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
2220:FreeRTOS/Source/tasks.c **** 
2221:FreeRTOS/Source/tasks.c **** 						uxPendedTicks = 0;
2222:FreeRTOS/Source/tasks.c **** 					}
2223:FreeRTOS/Source/tasks.c **** 					else
2224:FreeRTOS/Source/tasks.c **** 					{
2225:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2226:FreeRTOS/Source/tasks.c **** 					}
2227:FreeRTOS/Source/tasks.c **** 				}
2228:FreeRTOS/Source/tasks.c **** 
2229:FreeRTOS/Source/tasks.c **** 				if( xYieldPending != pdFALSE )
2230:FreeRTOS/Source/tasks.c **** 				{
2231:FreeRTOS/Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
2232:FreeRTOS/Source/tasks.c **** 					{
2233:FreeRTOS/Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
2234:FreeRTOS/Source/tasks.c **** 					}
2235:FreeRTOS/Source/tasks.c **** 					#endif
2236:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
2237:FreeRTOS/Source/tasks.c **** 				}
2238:FreeRTOS/Source/tasks.c **** 				else
2239:FreeRTOS/Source/tasks.c **** 				{
2240:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2241:FreeRTOS/Source/tasks.c **** 				}
2242:FreeRTOS/Source/tasks.c **** 			}
2243:FreeRTOS/Source/tasks.c **** 		}
2244:FreeRTOS/Source/tasks.c **** 		else
2245:FreeRTOS/Source/tasks.c **** 		{
2246:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2247:FreeRTOS/Source/tasks.c **** 		}
2248:FreeRTOS/Source/tasks.c **** 	}
2249:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
2250:FreeRTOS/Source/tasks.c **** 
2251:FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
2252:FreeRTOS/Source/tasks.c **** }
2253:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2254:FreeRTOS/Source/tasks.c **** 
2255:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCount( void )
2256:FreeRTOS/Source/tasks.c **** {
2257:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
2258:FreeRTOS/Source/tasks.c **** 
2259:FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2260:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2261:FreeRTOS/Source/tasks.c **** 	{
2262:FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
2263:FreeRTOS/Source/tasks.c **** 	}
2264:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2265:FreeRTOS/Source/tasks.c **** 
2266:FreeRTOS/Source/tasks.c **** 	return xTicks;
2267:FreeRTOS/Source/tasks.c **** }
2268:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2269:FreeRTOS/Source/tasks.c **** 
2270:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2271:FreeRTOS/Source/tasks.c **** {
2272:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
2273:FreeRTOS/Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2274:FreeRTOS/Source/tasks.c **** 
2275:FreeRTOS/Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2276:FreeRTOS/Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2277:FreeRTOS/Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2278:FreeRTOS/Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2279:FreeRTOS/Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2280:FreeRTOS/Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2281:FreeRTOS/Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2282:FreeRTOS/Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2283:FreeRTOS/Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2284:FreeRTOS/Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2285:FreeRTOS/Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2286:FreeRTOS/Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2287:FreeRTOS/Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2288:FreeRTOS/Source/tasks.c **** 	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
2289:FreeRTOS/Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2290:FreeRTOS/Source/tasks.c **** 
2291:FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2292:FreeRTOS/Source/tasks.c **** 	{
2293:FreeRTOS/Source/tasks.c **** 		xReturn = xTickCount;
2294:FreeRTOS/Source/tasks.c **** 	}
2295:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2296:FreeRTOS/Source/tasks.c **** 
2297:FreeRTOS/Source/tasks.c **** 	return xReturn;
2298:FreeRTOS/Source/tasks.c **** }
2299:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2300:FreeRTOS/Source/tasks.c **** 
2301:FreeRTOS/Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2302:FreeRTOS/Source/tasks.c **** {
2303:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
2304:FreeRTOS/Source/tasks.c **** 	BaseType_t. */
2305:FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
2306:FreeRTOS/Source/tasks.c **** }
2307:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2308:FreeRTOS/Source/tasks.c **** 
2309:FreeRTOS/Source/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2310:FreeRTOS/Source/tasks.c **** {
2311:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
2312:FreeRTOS/Source/tasks.c **** 
2313:FreeRTOS/Source/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2314:FreeRTOS/Source/tasks.c **** 	queried. */
2315:FreeRTOS/Source/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2316:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
2317:FreeRTOS/Source/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
2318:FreeRTOS/Source/tasks.c **** }
2319:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2320:FreeRTOS/Source/tasks.c **** 
2321:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2322:FreeRTOS/Source/tasks.c **** 
2323:FreeRTOS/Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2324:FreeRTOS/Source/tasks.c **** 	{
2325:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2326:FreeRTOS/Source/tasks.c **** 	UBaseType_t x;
2327:FreeRTOS/Source/tasks.c **** 	char cNextChar;
2328:FreeRTOS/Source/tasks.c **** 	BaseType_t xBreakLoop;
2329:FreeRTOS/Source/tasks.c **** 
2330:FreeRTOS/Source/tasks.c **** 		/* This function is called with the scheduler suspended. */
2331:FreeRTOS/Source/tasks.c **** 
2332:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2333:FreeRTOS/Source/tasks.c **** 		{
2334:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro i
2335:FreeRTOS/Source/tasks.c **** 
2336:FreeRTOS/Source/tasks.c **** 			do
2337:FreeRTOS/Source/tasks.c **** 			{
2338:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
2339:FreeRTOS/Source/tasks.c **** 
2340:FreeRTOS/Source/tasks.c **** 				/* Check each character in the name looking for a match or
2341:FreeRTOS/Source/tasks.c **** 				mismatch. */
2342:FreeRTOS/Source/tasks.c **** 				xBreakLoop = pdFALSE;
2343:FreeRTOS/Source/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2344:FreeRTOS/Source/tasks.c **** 				{
2345:FreeRTOS/Source/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2346:FreeRTOS/Source/tasks.c **** 
2347:FreeRTOS/Source/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2348:FreeRTOS/Source/tasks.c **** 					{
2349:FreeRTOS/Source/tasks.c **** 						/* Characters didn't match. */
2350:FreeRTOS/Source/tasks.c **** 						xBreakLoop = pdTRUE;
2351:FreeRTOS/Source/tasks.c **** 					}
2352:FreeRTOS/Source/tasks.c **** 					else if( cNextChar == ( char ) 0x00 )
2353:FreeRTOS/Source/tasks.c **** 					{
2354:FreeRTOS/Source/tasks.c **** 						/* Both strings terminated, a match must have been
2355:FreeRTOS/Source/tasks.c **** 						found. */
2356:FreeRTOS/Source/tasks.c **** 						pxReturn = pxNextTCB;
2357:FreeRTOS/Source/tasks.c **** 						xBreakLoop = pdTRUE;
2358:FreeRTOS/Source/tasks.c **** 					}
2359:FreeRTOS/Source/tasks.c **** 					else
2360:FreeRTOS/Source/tasks.c **** 					{
2361:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2362:FreeRTOS/Source/tasks.c **** 					}
2363:FreeRTOS/Source/tasks.c **** 
2364:FreeRTOS/Source/tasks.c **** 					if( xBreakLoop != pdFALSE )
2365:FreeRTOS/Source/tasks.c **** 					{
2366:FreeRTOS/Source/tasks.c **** 						break;
2367:FreeRTOS/Source/tasks.c **** 					}
2368:FreeRTOS/Source/tasks.c **** 				}
2369:FreeRTOS/Source/tasks.c **** 
2370:FreeRTOS/Source/tasks.c **** 				if( pxReturn != NULL )
2371:FreeRTOS/Source/tasks.c **** 				{
2372:FreeRTOS/Source/tasks.c **** 					/* The handle has been found. */
2373:FreeRTOS/Source/tasks.c **** 					break;
2374:FreeRTOS/Source/tasks.c **** 				}
2375:FreeRTOS/Source/tasks.c **** 
2376:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2377:FreeRTOS/Source/tasks.c **** 		}
2378:FreeRTOS/Source/tasks.c **** 		else
2379:FreeRTOS/Source/tasks.c **** 		{
2380:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2381:FreeRTOS/Source/tasks.c **** 		}
2382:FreeRTOS/Source/tasks.c **** 
2383:FreeRTOS/Source/tasks.c **** 		return pxReturn;
2384:FreeRTOS/Source/tasks.c **** 	}
2385:FreeRTOS/Source/tasks.c **** 
2386:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2387:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2388:FreeRTOS/Source/tasks.c **** 
2389:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2390:FreeRTOS/Source/tasks.c **** 
2391:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2392:FreeRTOS/Source/tasks.c **** 	{
2393:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2394:FreeRTOS/Source/tasks.c **** 	TCB_t* pxTCB;
2395:FreeRTOS/Source/tasks.c **** 
2396:FreeRTOS/Source/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2397:FreeRTOS/Source/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2398:FreeRTOS/Source/tasks.c **** 
2399:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2400:FreeRTOS/Source/tasks.c **** 		{
2401:FreeRTOS/Source/tasks.c **** 			/* Search the ready lists. */
2402:FreeRTOS/Source/tasks.c **** 			do
2403:FreeRTOS/Source/tasks.c **** 			{
2404:FreeRTOS/Source/tasks.c **** 				uxQueue--;
2405:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2406:FreeRTOS/Source/tasks.c **** 
2407:FreeRTOS/Source/tasks.c **** 				if( pxTCB != NULL )
2408:FreeRTOS/Source/tasks.c **** 				{
2409:FreeRTOS/Source/tasks.c **** 					/* Found the handle. */
2410:FreeRTOS/Source/tasks.c **** 					break;
2411:FreeRTOS/Source/tasks.c **** 				}
2412:FreeRTOS/Source/tasks.c **** 
2413:FreeRTOS/Source/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2414:FreeRTOS/Source/tasks.c **** 
2415:FreeRTOS/Source/tasks.c **** 			/* Search the delayed lists. */
2416:FreeRTOS/Source/tasks.c **** 			if( pxTCB == NULL )
2417:FreeRTOS/Source/tasks.c **** 			{
2418:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2419:FreeRTOS/Source/tasks.c **** 			}
2420:FreeRTOS/Source/tasks.c **** 
2421:FreeRTOS/Source/tasks.c **** 			if( pxTCB == NULL )
2422:FreeRTOS/Source/tasks.c **** 			{
2423:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2424:FreeRTOS/Source/tasks.c **** 			}
2425:FreeRTOS/Source/tasks.c **** 
2426:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2427:FreeRTOS/Source/tasks.c **** 			{
2428:FreeRTOS/Source/tasks.c **** 				if( pxTCB == NULL )
2429:FreeRTOS/Source/tasks.c **** 				{
2430:FreeRTOS/Source/tasks.c **** 					/* Search the suspended list. */
2431:FreeRTOS/Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2432:FreeRTOS/Source/tasks.c **** 				}
2433:FreeRTOS/Source/tasks.c **** 			}
2434:FreeRTOS/Source/tasks.c **** 			#endif
2435:FreeRTOS/Source/tasks.c **** 
2436:FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2437:FreeRTOS/Source/tasks.c **** 			{
2438:FreeRTOS/Source/tasks.c **** 				if( pxTCB == NULL )
2439:FreeRTOS/Source/tasks.c **** 				{
2440:FreeRTOS/Source/tasks.c **** 					/* Search the deleted list. */
2441:FreeRTOS/Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2442:FreeRTOS/Source/tasks.c **** 				}
2443:FreeRTOS/Source/tasks.c **** 			}
2444:FreeRTOS/Source/tasks.c **** 			#endif
2445:FreeRTOS/Source/tasks.c **** 		}
2446:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2447:FreeRTOS/Source/tasks.c **** 
2448:FreeRTOS/Source/tasks.c **** 		return pxTCB;
2449:FreeRTOS/Source/tasks.c **** 	}
2450:FreeRTOS/Source/tasks.c **** 
2451:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2452:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2453:FreeRTOS/Source/tasks.c **** 
2454:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2455:FreeRTOS/Source/tasks.c **** 
2456:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2457:FreeRTOS/Source/tasks.c **** 	{
2458:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2459:FreeRTOS/Source/tasks.c **** 
2460:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2461:FreeRTOS/Source/tasks.c **** 		{
2462:FreeRTOS/Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2463:FreeRTOS/Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2464:FreeRTOS/Source/tasks.c **** 			{
2465:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2466:FreeRTOS/Source/tasks.c **** 				task in the Ready state. */
2467:FreeRTOS/Source/tasks.c **** 				do
2468:FreeRTOS/Source/tasks.c **** 				{
2469:FreeRTOS/Source/tasks.c **** 					uxQueue--;
2470:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2471:FreeRTOS/Source/tasks.c **** 
2472:FreeRTOS/Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2473:FreeRTOS/Source/tasks.c **** 
2474:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2475:FreeRTOS/Source/tasks.c **** 				task in the Blocked state. */
2476:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2477:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2478:FreeRTOS/Source/tasks.c **** 
2479:FreeRTOS/Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2480:FreeRTOS/Source/tasks.c **** 				{
2481:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2482:FreeRTOS/Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2483:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2484:FreeRTOS/Source/tasks.c **** 				}
2485:FreeRTOS/Source/tasks.c **** 				#endif
2486:FreeRTOS/Source/tasks.c **** 
2487:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2488:FreeRTOS/Source/tasks.c **** 				{
2489:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2490:FreeRTOS/Source/tasks.c **** 					each task in the Suspended state. */
2491:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
2492:FreeRTOS/Source/tasks.c **** 				}
2493:FreeRTOS/Source/tasks.c **** 				#endif
2494:FreeRTOS/Source/tasks.c **** 
2495:FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2496:FreeRTOS/Source/tasks.c **** 				{
2497:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2498:FreeRTOS/Source/tasks.c **** 					{
2499:FreeRTOS/Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2500:FreeRTOS/Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2501:FreeRTOS/Source/tasks.c **** 						#else
2502:FreeRTOS/Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2503:FreeRTOS/Source/tasks.c **** 						#endif
2504:FreeRTOS/Source/tasks.c **** 					}
2505:FreeRTOS/Source/tasks.c **** 				}
2506:FreeRTOS/Source/tasks.c **** 				#else
2507:FreeRTOS/Source/tasks.c **** 				{
2508:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2509:FreeRTOS/Source/tasks.c **** 					{
2510:FreeRTOS/Source/tasks.c **** 						*pulTotalRunTime = 0;
2511:FreeRTOS/Source/tasks.c **** 					}
2512:FreeRTOS/Source/tasks.c **** 				}
2513:FreeRTOS/Source/tasks.c **** 				#endif
2514:FreeRTOS/Source/tasks.c **** 			}
2515:FreeRTOS/Source/tasks.c **** 			else
2516:FreeRTOS/Source/tasks.c **** 			{
2517:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2518:FreeRTOS/Source/tasks.c **** 			}
2519:FreeRTOS/Source/tasks.c **** 		}
2520:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2521:FreeRTOS/Source/tasks.c **** 
2522:FreeRTOS/Source/tasks.c **** 		return uxTask;
2523:FreeRTOS/Source/tasks.c **** 	}
2524:FreeRTOS/Source/tasks.c **** 
2525:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2526:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2527:FreeRTOS/Source/tasks.c **** 
2528:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2529:FreeRTOS/Source/tasks.c **** 
2530:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2531:FreeRTOS/Source/tasks.c **** 	{
2532:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2533:FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2534:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2535:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
2536:FreeRTOS/Source/tasks.c **** 	}
2537:FreeRTOS/Source/tasks.c **** 
2538:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2539:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2540:FreeRTOS/Source/tasks.c **** 
2541:FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2542:FreeRTOS/Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2543:FreeRTOS/Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2544:FreeRTOS/Source/tasks.c **** 1. */
2545:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2546:FreeRTOS/Source/tasks.c **** 
2547:FreeRTOS/Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2548:FreeRTOS/Source/tasks.c **** 	{
2549:FreeRTOS/Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2550:FreeRTOS/Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2551:FreeRTOS/Source/tasks.c **** 		each stepped tick. */
2552:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2553:FreeRTOS/Source/tasks.c **** 		xTickCount += xTicksToJump;
2554:FreeRTOS/Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2555:FreeRTOS/Source/tasks.c **** 	}
2556:FreeRTOS/Source/tasks.c **** 
2557:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2558:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2559:FreeRTOS/Source/tasks.c **** 
2560:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2561:FreeRTOS/Source/tasks.c **** 
2562:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2563:FreeRTOS/Source/tasks.c **** 	{
2564:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB = xTask;
2565:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2566:FreeRTOS/Source/tasks.c **** 
2567:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
2568:FreeRTOS/Source/tasks.c **** 
2569:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2570:FreeRTOS/Source/tasks.c **** 		{
2571:FreeRTOS/Source/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2572:FreeRTOS/Source/tasks.c **** 			it is actually in the Blocked state. */
2573:FreeRTOS/Source/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2574:FreeRTOS/Source/tasks.c **** 			{
2575:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
2576:FreeRTOS/Source/tasks.c **** 
2577:FreeRTOS/Source/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2578:FreeRTOS/Source/tasks.c **** 				interrupt won't touch the xStateListItem because the
2579:FreeRTOS/Source/tasks.c **** 				scheduler is suspended. */
2580:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2581:FreeRTOS/Source/tasks.c **** 
2582:FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2583:FreeRTOS/Source/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2584:FreeRTOS/Source/tasks.c **** 				even though the scheduler is suspended, so a critical section
2585:FreeRTOS/Source/tasks.c **** 				is used. */
2586:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
2587:FreeRTOS/Source/tasks.c **** 				{
2588:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2589:FreeRTOS/Source/tasks.c **** 					{
2590:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2591:FreeRTOS/Source/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2592:FreeRTOS/Source/tasks.c **** 					}
2593:FreeRTOS/Source/tasks.c **** 					else
2594:FreeRTOS/Source/tasks.c **** 					{
2595:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2596:FreeRTOS/Source/tasks.c **** 					}
2597:FreeRTOS/Source/tasks.c **** 				}
2598:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
2599:FreeRTOS/Source/tasks.c **** 
2600:FreeRTOS/Source/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2601:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2602:FreeRTOS/Source/tasks.c **** 
2603:FreeRTOS/Source/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2604:FreeRTOS/Source/tasks.c **** 				switch if preemption is turned off. */
2605:FreeRTOS/Source/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2606:FreeRTOS/Source/tasks.c **** 				{
2607:FreeRTOS/Source/tasks.c **** 					/* Preemption is on, but a context switch should only be
2608:FreeRTOS/Source/tasks.c **** 					performed if the unblocked task has a priority that is
2609:FreeRTOS/Source/tasks.c **** 					equal to or higher than the currently executing task. */
2610:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2611:FreeRTOS/Source/tasks.c **** 					{
2612:FreeRTOS/Source/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2613:FreeRTOS/Source/tasks.c **** 						is unsuspended. */
2614:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
2615:FreeRTOS/Source/tasks.c **** 					}
2616:FreeRTOS/Source/tasks.c **** 					else
2617:FreeRTOS/Source/tasks.c **** 					{
2618:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2619:FreeRTOS/Source/tasks.c **** 					}
2620:FreeRTOS/Source/tasks.c **** 				}
2621:FreeRTOS/Source/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2622:FreeRTOS/Source/tasks.c **** 			}
2623:FreeRTOS/Source/tasks.c **** 			else
2624:FreeRTOS/Source/tasks.c **** 			{
2625:FreeRTOS/Source/tasks.c **** 				xReturn = pdFAIL;
2626:FreeRTOS/Source/tasks.c **** 			}
2627:FreeRTOS/Source/tasks.c **** 		}
2628:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2629:FreeRTOS/Source/tasks.c **** 
2630:FreeRTOS/Source/tasks.c **** 		return xReturn;
2631:FreeRTOS/Source/tasks.c **** 	}
2632:FreeRTOS/Source/tasks.c **** 
2633:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2634:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2635:FreeRTOS/Source/tasks.c **** 
2636:FreeRTOS/Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
2637:FreeRTOS/Source/tasks.c **** {
2638:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
2639:FreeRTOS/Source/tasks.c **** TickType_t xItemValue;
2640:FreeRTOS/Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
2641:FreeRTOS/Source/tasks.c **** 
2642:FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2643:FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2644:FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
2645:FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2646:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2647:FreeRTOS/Source/tasks.c **** 	{
2648:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2649:FreeRTOS/Source/tasks.c **** 		block. */
2650:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
2651:FreeRTOS/Source/tasks.c **** 
2652:FreeRTOS/Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2653:FreeRTOS/Source/tasks.c **** 		delayed lists if it wraps to 0. */
2654:FreeRTOS/Source/tasks.c **** 		xTickCount = xConstTickCount;
2655:FreeRTOS/Source/tasks.c **** 
2656:FreeRTOS/Source/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as
2657:FreeRTOS/Source/tasks.c **** 		{
2658:FreeRTOS/Source/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
2659:FreeRTOS/Source/tasks.c **** 		}
2660:FreeRTOS/Source/tasks.c **** 		else
2661:FreeRTOS/Source/tasks.c **** 		{
2662:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2663:FreeRTOS/Source/tasks.c **** 		}
2664:FreeRTOS/Source/tasks.c **** 
2665:FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2666:FreeRTOS/Source/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2667:FreeRTOS/Source/tasks.c **** 		has been found whose block time has not expired there is no need to
2668:FreeRTOS/Source/tasks.c **** 		look any further down the list. */
2669:FreeRTOS/Source/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
2670:FreeRTOS/Source/tasks.c **** 		{
2671:FreeRTOS/Source/tasks.c **** 			for( ;; )
2672:FreeRTOS/Source/tasks.c **** 			{
2673:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2674:FreeRTOS/Source/tasks.c **** 				{
2675:FreeRTOS/Source/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2676:FreeRTOS/Source/tasks.c **** 					to the maximum possible value so it is extremely
2677:FreeRTOS/Source/tasks.c **** 					unlikely that the
2678:FreeRTOS/Source/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2679:FreeRTOS/Source/tasks.c **** 					next time through. */
2680:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
2681:FreeRTOS/Source/tasks.c **** 					break;
2682:FreeRTOS/Source/tasks.c **** 				}
2683:FreeRTOS/Source/tasks.c **** 				else
2684:FreeRTOS/Source/tasks.c **** 				{
2685:FreeRTOS/Source/tasks.c **** 					/* The delayed list is not empty, get the value of the
2686:FreeRTOS/Source/tasks.c **** 					item at the head of the delayed list.  This is the time
2687:FreeRTOS/Source/tasks.c **** 					at which the task at the head of the delayed list must
2688:FreeRTOS/Source/tasks.c **** 					be removed from the Blocked state. */
2689:FreeRTOS/Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this
2690:FreeRTOS/Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
2691:FreeRTOS/Source/tasks.c **** 
2692:FreeRTOS/Source/tasks.c **** 					if( xConstTickCount < xItemValue )
2693:FreeRTOS/Source/tasks.c **** 					{
2694:FreeRTOS/Source/tasks.c **** 						/* It is not time to unblock this item yet, but the
2695:FreeRTOS/Source/tasks.c **** 						item value is the time at which the task at the head
2696:FreeRTOS/Source/tasks.c **** 						of the blocked list must be removed from the Blocked
2697:FreeRTOS/Source/tasks.c **** 						state -	so record the item value in
2698:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime. */
2699:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
2700:FreeRTOS/Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
2701:FreeRTOS/Source/tasks.c **** 					}
2702:FreeRTOS/Source/tasks.c **** 					else
2703:FreeRTOS/Source/tasks.c **** 					{
2704:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2705:FreeRTOS/Source/tasks.c **** 					}
2706:FreeRTOS/Source/tasks.c **** 
2707:FreeRTOS/Source/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2708:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2709:FreeRTOS/Source/tasks.c **** 
2710:FreeRTOS/Source/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2711:FreeRTOS/Source/tasks.c **** 					it from the event list. */
2712:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2713:FreeRTOS/Source/tasks.c **** 					{
2714:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2715:FreeRTOS/Source/tasks.c **** 					}
2716:FreeRTOS/Source/tasks.c **** 					else
2717:FreeRTOS/Source/tasks.c **** 					{
2718:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2719:FreeRTOS/Source/tasks.c **** 					}
2720:FreeRTOS/Source/tasks.c **** 
2721:FreeRTOS/Source/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2722:FreeRTOS/Source/tasks.c **** 					list. */
2723:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
2724:FreeRTOS/Source/tasks.c **** 
2725:FreeRTOS/Source/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2726:FreeRTOS/Source/tasks.c **** 					context switch if preemption is turned off. */
2727:FreeRTOS/Source/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2728:FreeRTOS/Source/tasks.c **** 					{
2729:FreeRTOS/Source/tasks.c **** 						/* Preemption is on, but a context switch should
2730:FreeRTOS/Source/tasks.c **** 						only be performed if the unblocked task has a
2731:FreeRTOS/Source/tasks.c **** 						priority that is equal to or higher than the
2732:FreeRTOS/Source/tasks.c **** 						currently executing task. */
2733:FreeRTOS/Source/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2734:FreeRTOS/Source/tasks.c **** 						{
2735:FreeRTOS/Source/tasks.c **** 							xSwitchRequired = pdTRUE;
2736:FreeRTOS/Source/tasks.c **** 						}
2737:FreeRTOS/Source/tasks.c **** 						else
2738:FreeRTOS/Source/tasks.c **** 						{
2739:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2740:FreeRTOS/Source/tasks.c **** 						}
2741:FreeRTOS/Source/tasks.c **** 					}
2742:FreeRTOS/Source/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2743:FreeRTOS/Source/tasks.c **** 				}
2744:FreeRTOS/Source/tasks.c **** 			}
2745:FreeRTOS/Source/tasks.c **** 		}
2746:FreeRTOS/Source/tasks.c **** 
2747:FreeRTOS/Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2748:FreeRTOS/Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2749:FreeRTOS/Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
2750:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2751:FreeRTOS/Source/tasks.c **** 		{
2752:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2753:FreeRTOS/Source/tasks.c **** 			{
2754:FreeRTOS/Source/tasks.c **** 				xSwitchRequired = pdTRUE;
2755:FreeRTOS/Source/tasks.c **** 			}
2756:FreeRTOS/Source/tasks.c **** 			else
2757:FreeRTOS/Source/tasks.c **** 			{
2758:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2759:FreeRTOS/Source/tasks.c **** 			}
2760:FreeRTOS/Source/tasks.c **** 		}
2761:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2762:FreeRTOS/Source/tasks.c **** 
2763:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2764:FreeRTOS/Source/tasks.c **** 		{
2765:FreeRTOS/Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2766:FreeRTOS/Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2767:FreeRTOS/Source/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
2768:FreeRTOS/Source/tasks.c **** 			{
2769:FreeRTOS/Source/tasks.c **** 				vApplicationTickHook();
2770:FreeRTOS/Source/tasks.c **** 			}
2771:FreeRTOS/Source/tasks.c **** 			else
2772:FreeRTOS/Source/tasks.c **** 			{
2773:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2774:FreeRTOS/Source/tasks.c **** 			}
2775:FreeRTOS/Source/tasks.c **** 		}
2776:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2777:FreeRTOS/Source/tasks.c **** 	}
2778:FreeRTOS/Source/tasks.c **** 	else
2779:FreeRTOS/Source/tasks.c **** 	{
2780:FreeRTOS/Source/tasks.c **** 		++uxPendedTicks;
2781:FreeRTOS/Source/tasks.c **** 
2782:FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2783:FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
2784:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2785:FreeRTOS/Source/tasks.c **** 		{
2786:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
2787:FreeRTOS/Source/tasks.c **** 		}
2788:FreeRTOS/Source/tasks.c **** 		#endif
2789:FreeRTOS/Source/tasks.c **** 	}
2790:FreeRTOS/Source/tasks.c **** 
2791:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2792:FreeRTOS/Source/tasks.c **** 	{
2793:FreeRTOS/Source/tasks.c **** 		if( xYieldPending != pdFALSE )
2794:FreeRTOS/Source/tasks.c **** 		{
2795:FreeRTOS/Source/tasks.c **** 			xSwitchRequired = pdTRUE;
2796:FreeRTOS/Source/tasks.c **** 		}
2797:FreeRTOS/Source/tasks.c **** 		else
2798:FreeRTOS/Source/tasks.c **** 		{
2799:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2800:FreeRTOS/Source/tasks.c **** 		}
2801:FreeRTOS/Source/tasks.c **** 	}
2802:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2803:FreeRTOS/Source/tasks.c **** 
2804:FreeRTOS/Source/tasks.c **** 	return xSwitchRequired;
2805:FreeRTOS/Source/tasks.c **** }
2806:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2807:FreeRTOS/Source/tasks.c **** 
2808:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2809:FreeRTOS/Source/tasks.c **** 
2810:FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2811:FreeRTOS/Source/tasks.c **** 	{
2812:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2813:FreeRTOS/Source/tasks.c **** 
2814:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2815:FreeRTOS/Source/tasks.c **** 		getting set. */
2816:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2817:FreeRTOS/Source/tasks.c **** 		{
2818:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2819:FreeRTOS/Source/tasks.c **** 		}
2820:FreeRTOS/Source/tasks.c **** 		else
2821:FreeRTOS/Source/tasks.c **** 		{
2822:FreeRTOS/Source/tasks.c **** 			xTCB = xTask;
2823:FreeRTOS/Source/tasks.c **** 		}
2824:FreeRTOS/Source/tasks.c **** 
2825:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2826:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2827:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2828:FreeRTOS/Source/tasks.c **** 		{
2829:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2830:FreeRTOS/Source/tasks.c **** 		}
2831:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2832:FreeRTOS/Source/tasks.c **** 	}
2833:FreeRTOS/Source/tasks.c **** 
2834:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2835:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2836:FreeRTOS/Source/tasks.c **** 
2837:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2838:FreeRTOS/Source/tasks.c **** 
2839:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2840:FreeRTOS/Source/tasks.c **** 	{
2841:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2842:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xReturn;
2843:FreeRTOS/Source/tasks.c **** 
2844:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2845:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2846:FreeRTOS/Source/tasks.c **** 		{
2847:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2848:FreeRTOS/Source/tasks.c **** 		}
2849:FreeRTOS/Source/tasks.c **** 		else
2850:FreeRTOS/Source/tasks.c **** 		{
2851:FreeRTOS/Source/tasks.c **** 			xTCB = xTask;
2852:FreeRTOS/Source/tasks.c **** 		}
2853:FreeRTOS/Source/tasks.c **** 
2854:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2855:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2856:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2857:FreeRTOS/Source/tasks.c **** 		{
2858:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2859:FreeRTOS/Source/tasks.c **** 		}
2860:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2861:FreeRTOS/Source/tasks.c **** 
2862:FreeRTOS/Source/tasks.c **** 		return xReturn;
2863:FreeRTOS/Source/tasks.c **** 	}
2864:FreeRTOS/Source/tasks.c **** 
2865:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2866:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2867:FreeRTOS/Source/tasks.c **** 
2868:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2869:FreeRTOS/Source/tasks.c **** 
2870:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2871:FreeRTOS/Source/tasks.c **** 	{
2872:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2873:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2874:FreeRTOS/Source/tasks.c **** 
2875:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2876:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2877:FreeRTOS/Source/tasks.c **** 		{
2878:FreeRTOS/Source/tasks.c **** 			xTCB = pxCurrentTCB;
2879:FreeRTOS/Source/tasks.c **** 		}
2880:FreeRTOS/Source/tasks.c **** 		else
2881:FreeRTOS/Source/tasks.c **** 		{
2882:FreeRTOS/Source/tasks.c **** 			xTCB = xTask;
2883:FreeRTOS/Source/tasks.c **** 		}
2884:FreeRTOS/Source/tasks.c **** 
2885:FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2886:FreeRTOS/Source/tasks.c **** 		{
2887:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2888:FreeRTOS/Source/tasks.c **** 		}
2889:FreeRTOS/Source/tasks.c **** 		else
2890:FreeRTOS/Source/tasks.c **** 		{
2891:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
2892:FreeRTOS/Source/tasks.c **** 		}
2893:FreeRTOS/Source/tasks.c **** 
2894:FreeRTOS/Source/tasks.c **** 		return xReturn;
2895:FreeRTOS/Source/tasks.c **** 	}
2896:FreeRTOS/Source/tasks.c **** 
2897:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2898:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2899:FreeRTOS/Source/tasks.c **** 
2900:FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
2901:FreeRTOS/Source/tasks.c **** {
2902:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
2903:FreeRTOS/Source/tasks.c **** 	{
2904:FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2905:FreeRTOS/Source/tasks.c **** 		switch. */
2906:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2907:FreeRTOS/Source/tasks.c **** 	}
2908:FreeRTOS/Source/tasks.c **** 	else
2909:FreeRTOS/Source/tasks.c **** 	{
2910:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdFALSE;
2911:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
2912:FreeRTOS/Source/tasks.c **** 
2913:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2914:FreeRTOS/Source/tasks.c **** 		{
2915:FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2916:FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2917:FreeRTOS/Source/tasks.c **** 				#else
2918:FreeRTOS/Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2919:FreeRTOS/Source/tasks.c **** 				#endif
2920:FreeRTOS/Source/tasks.c **** 
2921:FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the
2922:FreeRTOS/Source/tasks.c **** 				accumulated time so far.  The time the task started running was
2923:FreeRTOS/Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2924:FreeRTOS/Source/tasks.c **** 				protection here so count values are only valid until the timer
2925:FreeRTOS/Source/tasks.c **** 				overflows.  The guard against negative values is to protect
2926:FreeRTOS/Source/tasks.c **** 				against suspect run time stat counter implementations - which
2927:FreeRTOS/Source/tasks.c **** 				are provided by the application, not the kernel. */
2928:FreeRTOS/Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2929:FreeRTOS/Source/tasks.c **** 				{
2930:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2931:FreeRTOS/Source/tasks.c **** 				}
2932:FreeRTOS/Source/tasks.c **** 				else
2933:FreeRTOS/Source/tasks.c **** 				{
2934:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2935:FreeRTOS/Source/tasks.c **** 				}
2936:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2937:FreeRTOS/Source/tasks.c **** 		}
2938:FreeRTOS/Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2939:FreeRTOS/Source/tasks.c **** 
2940:FreeRTOS/Source/tasks.c **** 		/* Check for stack overflow, if configured. */
2941:FreeRTOS/Source/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
2942:FreeRTOS/Source/tasks.c **** 
2943:FreeRTOS/Source/tasks.c **** 		/* Before the currently running task is switched out, save its errno. */
2944:FreeRTOS/Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
2945:FreeRTOS/Source/tasks.c **** 		{
2946:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
2947:FreeRTOS/Source/tasks.c **** 		}
2948:FreeRTOS/Source/tasks.c **** 		#endif
2949:FreeRTOS/Source/tasks.c **** 
2950:FreeRTOS/Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
2951:FreeRTOS/Source/tasks.c **** 		optimised asm code. */
2952:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timer
2953:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2954:FreeRTOS/Source/tasks.c **** 
2955:FreeRTOS/Source/tasks.c **** 		/* After the new task is switched in, update the global errno. */
2956:FreeRTOS/Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
2957:FreeRTOS/Source/tasks.c **** 		{
2958:FreeRTOS/Source/tasks.c **** 			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
2959:FreeRTOS/Source/tasks.c **** 		}
2960:FreeRTOS/Source/tasks.c **** 		#endif
2961:FreeRTOS/Source/tasks.c **** 
2962:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2963:FreeRTOS/Source/tasks.c **** 		{
2964:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2965:FreeRTOS/Source/tasks.c **** 			structure specific to this task. */
2966:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2967:FreeRTOS/Source/tasks.c **** 		}
2968:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2969:FreeRTOS/Source/tasks.c **** 	}
2970:FreeRTOS/Source/tasks.c **** }
2971:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2972:FreeRTOS/Source/tasks.c **** 
2973:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2974:FreeRTOS/Source/tasks.c **** {
2975:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2976:FreeRTOS/Source/tasks.c **** 
2977:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2978:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2979:FreeRTOS/Source/tasks.c **** 
2980:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2981:FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2982:FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2983:FreeRTOS/Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2984:FreeRTOS/Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2985:FreeRTOS/Source/tasks.c **** 
2986:FreeRTOS/Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
2987:FreeRTOS/Source/tasks.c **** }
2988:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2989:FreeRTOS/Source/tasks.c **** 
2990:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2991:FreeRTOS/Source/tasks.c **** {
2992:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2993:FreeRTOS/Source/tasks.c **** 
2994:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2995:FreeRTOS/Source/tasks.c **** 	the event groups implementation. */
2996:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
2997:FreeRTOS/Source/tasks.c **** 
2998:FreeRTOS/Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2999:FreeRTOS/Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
3000:FreeRTOS/Source/tasks.c **** 	task that is not in the Blocked state. */
3001:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
3002:FreeRTOS/Source/tasks.c **** 
3003:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
3004:FreeRTOS/Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
3005:FreeRTOS/Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
3006:FreeRTOS/Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
3007:FreeRTOS/Source/tasks.c **** 	the task level). */
3008:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3009:FreeRTOS/Source/tasks.c **** 
3010:FreeRTOS/Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
3011:FreeRTOS/Source/tasks.c **** }
3012:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3013:FreeRTOS/Source/tasks.c **** 
3014:FreeRTOS/Source/tasks.c **** #if( configUSE_TIMERS == 1 )
3015:FreeRTOS/Source/tasks.c **** 
3016:FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
3017:FreeRTOS/Source/tasks.c **** 	{
3018:FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
3019:FreeRTOS/Source/tasks.c **** 
3020:FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
3021:FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
3022:FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
3023:FreeRTOS/Source/tasks.c **** 		it should be called with the scheduler suspended. */
3024:FreeRTOS/Source/tasks.c **** 
3025:FreeRTOS/Source/tasks.c **** 
3026:FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
3027:FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
3028:FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
3029:FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
3030:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3031:FreeRTOS/Source/tasks.c **** 
3032:FreeRTOS/Source/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
3033:FreeRTOS/Source/tasks.c **** 		value that will be recognised as an indefinite delay inside the
3034:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
3035:FreeRTOS/Source/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
3036:FreeRTOS/Source/tasks.c **** 		{
3037:FreeRTOS/Source/tasks.c **** 			xTicksToWait = portMAX_DELAY;
3038:FreeRTOS/Source/tasks.c **** 		}
3039:FreeRTOS/Source/tasks.c **** 
3040:FreeRTOS/Source/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3041:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
3042:FreeRTOS/Source/tasks.c **** 	}
3043:FreeRTOS/Source/tasks.c **** 
3044:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
3045:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3046:FreeRTOS/Source/tasks.c **** 
3047:FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3048:FreeRTOS/Source/tasks.c **** {
3049:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
3050:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
3051:FreeRTOS/Source/tasks.c **** 
3052:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3053:FreeRTOS/Source/tasks.c **** 	called from a critical section within an ISR. */
3054:FreeRTOS/Source/tasks.c **** 
3055:FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
3056:FreeRTOS/Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
3057:FreeRTOS/Source/tasks.c **** 	the delayed list, and add it to the ready list.
3058:FreeRTOS/Source/tasks.c **** 
3059:FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
3060:FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
3061:FreeRTOS/Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
3062:FreeRTOS/Source/tasks.c **** 
3063:FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
3064:FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
3065:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this 
3066:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3067:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
3068:FreeRTOS/Source/tasks.c **** 
3069:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3070:FreeRTOS/Source/tasks.c **** 	{
3071:FreeRTOS/Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3072:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
3073:FreeRTOS/Source/tasks.c **** 	}
3074:FreeRTOS/Source/tasks.c **** 	else
3075:FreeRTOS/Source/tasks.c **** 	{
3076:FreeRTOS/Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
3077:FreeRTOS/Source/tasks.c **** 		pending until the scheduler is resumed. */
3078:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
3079:FreeRTOS/Source/tasks.c **** 	}
3080:FreeRTOS/Source/tasks.c **** 
3081:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3082:FreeRTOS/Source/tasks.c **** 	{
3083:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
3084:FreeRTOS/Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
3085:FreeRTOS/Source/tasks.c **** 		it should force a context switch now. */
3086:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
3087:FreeRTOS/Source/tasks.c **** 
3088:FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
3089:FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3090:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
3091:FreeRTOS/Source/tasks.c **** 	}
3092:FreeRTOS/Source/tasks.c **** 	else
3093:FreeRTOS/Source/tasks.c **** 	{
3094:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
3095:FreeRTOS/Source/tasks.c **** 	}
3096:FreeRTOS/Source/tasks.c **** 
3097:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
3098:FreeRTOS/Source/tasks.c **** 	{
3099:FreeRTOS/Source/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3100:FreeRTOS/Source/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
3101:FreeRTOS/Source/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
3102:FreeRTOS/Source/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
3103:FreeRTOS/Source/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
3104:FreeRTOS/Source/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
3105:FreeRTOS/Source/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
3106:FreeRTOS/Source/tasks.c **** 		ensure it is updated at the earliest possible time. */
3107:FreeRTOS/Source/tasks.c **** 		prvResetNextTaskUnblockTime();
3108:FreeRTOS/Source/tasks.c **** 	}
3109:FreeRTOS/Source/tasks.c **** 	#endif
3110:FreeRTOS/Source/tasks.c **** 
3111:FreeRTOS/Source/tasks.c **** 	return xReturn;
3112:FreeRTOS/Source/tasks.c **** }
3113:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3114:FreeRTOS/Source/tasks.c **** 
3115:FreeRTOS/Source/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
3116:FreeRTOS/Source/tasks.c **** {
3117:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
3118:FreeRTOS/Source/tasks.c **** 
3119:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3120:FreeRTOS/Source/tasks.c **** 	the event flags implementation. */
3121:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
3122:FreeRTOS/Source/tasks.c **** 
3123:FreeRTOS/Source/tasks.c **** 	/* Store the new item value in the event list. */
3124:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
3125:FreeRTOS/Source/tasks.c **** 
3126:FreeRTOS/Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
3127:FreeRTOS/Source/tasks.c **** 	event flags. */
3128:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this 
3129:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3130:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
3131:FreeRTOS/Source/tasks.c **** 
3132:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
3133:FreeRTOS/Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
3134:FreeRTOS/Source/tasks.c **** 	lists. */
3135:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
3136:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
3137:FreeRTOS/Source/tasks.c **** 
3138:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3139:FreeRTOS/Source/tasks.c **** 	{
3140:FreeRTOS/Source/tasks.c **** 		/* The unblocked task has a priority above that of the calling task, so
3141:FreeRTOS/Source/tasks.c **** 		a context switch is required.  This function is called with the
3142:FreeRTOS/Source/tasks.c **** 		scheduler suspended so xYieldPending is set so the context switch
3143:FreeRTOS/Source/tasks.c **** 		occurs immediately that the scheduler is resumed (unsuspended). */
3144:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
3145:FreeRTOS/Source/tasks.c **** 	}
3146:FreeRTOS/Source/tasks.c **** }
3147:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3148:FreeRTOS/Source/tasks.c **** 
3149:FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3150:FreeRTOS/Source/tasks.c **** {
3151:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
3152:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
3153:FreeRTOS/Source/tasks.c **** 	{
3154:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xOverflowCount = xNumOfOverflows;
3155:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
3156:FreeRTOS/Source/tasks.c **** 	}
3157:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
3158:FreeRTOS/Source/tasks.c **** }
3159:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3160:FreeRTOS/Source/tasks.c **** 
3161:FreeRTOS/Source/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3162:FreeRTOS/Source/tasks.c **** {
3163:FreeRTOS/Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
3164:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
3165:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
3166:FreeRTOS/Source/tasks.c **** }
3167:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3168:FreeRTOS/Source/tasks.c **** 
3169:FreeRTOS/Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3170:FreeRTOS/Source/tasks.c **** {
3171:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
3172:FreeRTOS/Source/tasks.c **** 
3173:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
3174:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
3175:FreeRTOS/Source/tasks.c **** 
3176:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
3177:FreeRTOS/Source/tasks.c **** 	{
3178:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
3179:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
3180:FreeRTOS/Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
3181:FreeRTOS/Source/tasks.c **** 
3182:FreeRTOS/Source/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
3183:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
3184:FreeRTOS/Source/tasks.c **** 			{
3185:FreeRTOS/Source/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
3186:FreeRTOS/Source/tasks.c **** 				but has the same result. */
3187:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
3188:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
3189:FreeRTOS/Source/tasks.c **** 			}
3190:FreeRTOS/Source/tasks.c **** 			else
3191:FreeRTOS/Source/tasks.c **** 		#endif
3192:FreeRTOS/Source/tasks.c **** 
3193:FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3194:FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
3195:FreeRTOS/Source/tasks.c **** 			{
3196:FreeRTOS/Source/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3197:FreeRTOS/Source/tasks.c **** 				specified is the maximum block time then the task should block
3198:FreeRTOS/Source/tasks.c **** 				indefinitely, and therefore never time out. */
3199:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
3200:FreeRTOS/Source/tasks.c **** 			}
3201:FreeRTOS/Source/tasks.c **** 			else
3202:FreeRTOS/Source/tasks.c **** 		#endif
3203:FreeRTOS/Source/tasks.c **** 
3204:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
3205:FreeRTOS/Source/tasks.c **** 		{
3206:FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which
3207:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
3208:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
3209:FreeRTOS/Source/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
3210:FreeRTOS/Source/tasks.c **** 			was called. */
3211:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
3212:FreeRTOS/Source/tasks.c **** 		}
3213:FreeRTOS/Source/tasks.c **** 		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with som
3214:FreeRTOS/Source/tasks.c **** 		{
3215:FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
3216:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= xElapsedTime;
3217:FreeRTOS/Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
3218:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
3219:FreeRTOS/Source/tasks.c **** 		}
3220:FreeRTOS/Source/tasks.c **** 		else
3221:FreeRTOS/Source/tasks.c **** 		{
3222:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait = 0;
3223:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
3224:FreeRTOS/Source/tasks.c **** 		}
3225:FreeRTOS/Source/tasks.c **** 	}
3226:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
3227:FreeRTOS/Source/tasks.c **** 
3228:FreeRTOS/Source/tasks.c **** 	return xReturn;
3229:FreeRTOS/Source/tasks.c **** }
3230:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3231:FreeRTOS/Source/tasks.c **** 
3232:FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
3233:FreeRTOS/Source/tasks.c **** {
3234:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
3235:FreeRTOS/Source/tasks.c **** }
3236:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3237:FreeRTOS/Source/tasks.c **** 
3238:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3239:FreeRTOS/Source/tasks.c **** 
3240:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3241:FreeRTOS/Source/tasks.c **** 	{
3242:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3243:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
3244:FreeRTOS/Source/tasks.c **** 
3245:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
3246:FreeRTOS/Source/tasks.c **** 		{
3247:FreeRTOS/Source/tasks.c **** 			pxTCB = xTask;
3248:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
3249:FreeRTOS/Source/tasks.c **** 		}
3250:FreeRTOS/Source/tasks.c **** 		else
3251:FreeRTOS/Source/tasks.c **** 		{
3252:FreeRTOS/Source/tasks.c **** 			uxReturn = 0U;
3253:FreeRTOS/Source/tasks.c **** 		}
3254:FreeRTOS/Source/tasks.c **** 
3255:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3256:FreeRTOS/Source/tasks.c **** 	}
3257:FreeRTOS/Source/tasks.c **** 
3258:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3259:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3260:FreeRTOS/Source/tasks.c **** 
3261:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3262:FreeRTOS/Source/tasks.c **** 
3263:FreeRTOS/Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3264:FreeRTOS/Source/tasks.c **** 	{
3265:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
3266:FreeRTOS/Source/tasks.c **** 
3267:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
3268:FreeRTOS/Source/tasks.c **** 		{
3269:FreeRTOS/Source/tasks.c **** 			pxTCB = xTask;
3270:FreeRTOS/Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3271:FreeRTOS/Source/tasks.c **** 		}
3272:FreeRTOS/Source/tasks.c **** 	}
3273:FreeRTOS/Source/tasks.c **** 
3274:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3275:FreeRTOS/Source/tasks.c **** 
3276:FreeRTOS/Source/tasks.c **** /*
3277:FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
3278:FreeRTOS/Source/tasks.c ****  * The Idle task.
3279:FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
3280:FreeRTOS/Source/tasks.c ****  *
3281:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3282:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3283:FreeRTOS/Source/tasks.c ****  *
3284:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
3285:FreeRTOS/Source/tasks.c ****  *
3286:FreeRTOS/Source/tasks.c ****  */
3287:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3288:FreeRTOS/Source/tasks.c **** {
3289:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
3290:FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
3291:FreeRTOS/Source/tasks.c **** 
3292:FreeRTOS/Source/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3293:FreeRTOS/Source/tasks.c **** 	SCHEDULER IS STARTED. **/
3294:FreeRTOS/Source/tasks.c **** 
3295:FreeRTOS/Source/tasks.c **** 	/* In case a task that has a secure context deletes itself, in which case
3296:FreeRTOS/Source/tasks.c **** 	the idle task is responsible for deleting the task's secure context, if
3297:FreeRTOS/Source/tasks.c **** 	any. */
3298:FreeRTOS/Source/tasks.c **** 	portTASK_CALLS_SECURE_FUNCTIONS();
3299:FreeRTOS/Source/tasks.c **** 
3300:FreeRTOS/Source/tasks.c **** 	for( ;; )
3301:FreeRTOS/Source/tasks.c **** 	{
3302:FreeRTOS/Source/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3303:FreeRTOS/Source/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3304:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
3305:FreeRTOS/Source/tasks.c **** 
3306:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3307:FreeRTOS/Source/tasks.c **** 		{
3308:FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3309:FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
3310:FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
3311:FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
3312:FreeRTOS/Source/tasks.c **** 			taskYIELD();
3313:FreeRTOS/Source/tasks.c **** 		}
3314:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3315:FreeRTOS/Source/tasks.c **** 
3316:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3317:FreeRTOS/Source/tasks.c **** 		{
3318:FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
3319:FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3320:FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
3321:FreeRTOS/Source/tasks.c **** 			timeslice.
3322:FreeRTOS/Source/tasks.c **** 
3323:FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
3324:FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3325:FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
3326:FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
3327:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
3328:FreeRTOS/Source/tasks.c **** 			{
3329:FreeRTOS/Source/tasks.c **** 				taskYIELD();
3330:FreeRTOS/Source/tasks.c **** 			}
3331:FreeRTOS/Source/tasks.c **** 			else
3332:FreeRTOS/Source/tasks.c **** 			{
3333:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3334:FreeRTOS/Source/tasks.c **** 			}
3335:FreeRTOS/Source/tasks.c **** 		}
3336:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3337:FreeRTOS/Source/tasks.c **** 
3338:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3339:FreeRTOS/Source/tasks.c **** 		{
3340:FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
3341:FreeRTOS/Source/tasks.c **** 
3342:FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3343:FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
3344:FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
3345:FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3346:FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3347:FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
3348:FreeRTOS/Source/tasks.c **** 		}
3349:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3350:FreeRTOS/Source/tasks.c **** 
3351:FreeRTOS/Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3352:FreeRTOS/Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3353:FreeRTOS/Source/tasks.c **** 		user defined low power mode	implementations require
3354:FreeRTOS/Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3355:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3356:FreeRTOS/Source/tasks.c **** 		{
3357:FreeRTOS/Source/tasks.c **** 		TickType_t xExpectedIdleTime;
3358:FreeRTOS/Source/tasks.c **** 
3359:FreeRTOS/Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3360:FreeRTOS/Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3361:FreeRTOS/Source/tasks.c **** 			test of the expected idle time is performed without the
3362:FreeRTOS/Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3363:FreeRTOS/Source/tasks.c **** 			valid. */
3364:FreeRTOS/Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3365:FreeRTOS/Source/tasks.c **** 
3366:FreeRTOS/Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3367:FreeRTOS/Source/tasks.c **** 			{
3368:FreeRTOS/Source/tasks.c **** 				vTaskSuspendAll();
3369:FreeRTOS/Source/tasks.c **** 				{
3370:FreeRTOS/Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3371:FreeRTOS/Source/tasks.c **** 					time can be sampled again, and this time its value can
3372:FreeRTOS/Source/tasks.c **** 					be used. */
3373:FreeRTOS/Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3374:FreeRTOS/Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3375:FreeRTOS/Source/tasks.c **** 
3376:FreeRTOS/Source/tasks.c **** 					/* Define the following macro to set xExpectedIdleTime to 0
3377:FreeRTOS/Source/tasks.c **** 					if the application does not want
3378:FreeRTOS/Source/tasks.c **** 					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3379:FreeRTOS/Source/tasks.c **** 					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3380:FreeRTOS/Source/tasks.c **** 
3381:FreeRTOS/Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3382:FreeRTOS/Source/tasks.c **** 					{
3383:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3384:FreeRTOS/Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3385:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
3386:FreeRTOS/Source/tasks.c **** 					}
3387:FreeRTOS/Source/tasks.c **** 					else
3388:FreeRTOS/Source/tasks.c **** 					{
3389:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3390:FreeRTOS/Source/tasks.c **** 					}
3391:FreeRTOS/Source/tasks.c **** 				}
3392:FreeRTOS/Source/tasks.c **** 				( void ) xTaskResumeAll();
3393:FreeRTOS/Source/tasks.c **** 			}
3394:FreeRTOS/Source/tasks.c **** 			else
3395:FreeRTOS/Source/tasks.c **** 			{
3396:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3397:FreeRTOS/Source/tasks.c **** 			}
3398:FreeRTOS/Source/tasks.c **** 		}
3399:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3400:FreeRTOS/Source/tasks.c **** 	}
3401:FreeRTOS/Source/tasks.c **** }
3402:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3403:FreeRTOS/Source/tasks.c **** 
3404:FreeRTOS/Source/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3405:FreeRTOS/Source/tasks.c **** 
3406:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3407:FreeRTOS/Source/tasks.c **** 	{
3408:FreeRTOS/Source/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3409:FreeRTOS/Source/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3410:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3411:FreeRTOS/Source/tasks.c **** 
3412:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3413:FreeRTOS/Source/tasks.c **** 		{
3414:FreeRTOS/Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3415:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
3416:FreeRTOS/Source/tasks.c **** 		}
3417:FreeRTOS/Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
3418:FreeRTOS/Source/tasks.c **** 		{
3419:FreeRTOS/Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3420:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
3421:FreeRTOS/Source/tasks.c **** 		}
3422:FreeRTOS/Source/tasks.c **** 		else
3423:FreeRTOS/Source/tasks.c **** 		{
3424:FreeRTOS/Source/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3425:FreeRTOS/Source/tasks.c **** 			have an infinite block time rather than actually being suspended)
3426:FreeRTOS/Source/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3427:FreeRTOS/Source/tasks.c **** 			interrupts. */
3428:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3429:FreeRTOS/Source/tasks.c **** 			{
3430:FreeRTOS/Source/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3431:FreeRTOS/Source/tasks.c **** 			}
3432:FreeRTOS/Source/tasks.c **** 			else
3433:FreeRTOS/Source/tasks.c **** 			{
3434:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3435:FreeRTOS/Source/tasks.c **** 			}
3436:FreeRTOS/Source/tasks.c **** 		}
3437:FreeRTOS/Source/tasks.c **** 
3438:FreeRTOS/Source/tasks.c **** 		return eReturn;
3439:FreeRTOS/Source/tasks.c **** 	}
3440:FreeRTOS/Source/tasks.c **** 
3441:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3442:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3443:FreeRTOS/Source/tasks.c **** 
3444:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3445:FreeRTOS/Source/tasks.c **** 
3446:FreeRTOS/Source/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3447:FreeRTOS/Source/tasks.c **** 	{
3448:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3449:FreeRTOS/Source/tasks.c **** 
3450:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3451:FreeRTOS/Source/tasks.c **** 		{
3452:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3453:FreeRTOS/Source/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3454:FreeRTOS/Source/tasks.c **** 		}
3455:FreeRTOS/Source/tasks.c **** 	}
3456:FreeRTOS/Source/tasks.c **** 
3457:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3458:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3459:FreeRTOS/Source/tasks.c **** 
3460:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3461:FreeRTOS/Source/tasks.c **** 
3462:FreeRTOS/Source/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3463:FreeRTOS/Source/tasks.c **** 	{
3464:FreeRTOS/Source/tasks.c **** 	void *pvReturn = NULL;
3465:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3466:FreeRTOS/Source/tasks.c **** 
3467:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3468:FreeRTOS/Source/tasks.c **** 		{
3469:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3470:FreeRTOS/Source/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3471:FreeRTOS/Source/tasks.c **** 		}
3472:FreeRTOS/Source/tasks.c **** 		else
3473:FreeRTOS/Source/tasks.c **** 		{
3474:FreeRTOS/Source/tasks.c **** 			pvReturn = NULL;
3475:FreeRTOS/Source/tasks.c **** 		}
3476:FreeRTOS/Source/tasks.c **** 
3477:FreeRTOS/Source/tasks.c **** 		return pvReturn;
3478:FreeRTOS/Source/tasks.c **** 	}
3479:FreeRTOS/Source/tasks.c **** 
3480:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3481:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3482:FreeRTOS/Source/tasks.c **** 
3483:FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3484:FreeRTOS/Source/tasks.c **** 
3485:FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3486:FreeRTOS/Source/tasks.c **** 	{
3487:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3488:FreeRTOS/Source/tasks.c **** 
3489:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3490:FreeRTOS/Source/tasks.c **** 		the calling task. */
3491:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3492:FreeRTOS/Source/tasks.c **** 
3493:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3494:FreeRTOS/Source/tasks.c **** 	}
3495:FreeRTOS/Source/tasks.c **** 
3496:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3497:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3498:FreeRTOS/Source/tasks.c **** 
3499:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
3500:FreeRTOS/Source/tasks.c **** {
3501:FreeRTOS/Source/tasks.c **** UBaseType_t uxPriority;
3502:FreeRTOS/Source/tasks.c **** 
3503:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
3504:FreeRTOS/Source/tasks.c **** 	{
3505:FreeRTOS/Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
3506:FreeRTOS/Source/tasks.c **** 	}
3507:FreeRTOS/Source/tasks.c **** 
3508:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
3509:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
3510:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
3511:FreeRTOS/Source/tasks.c **** 
3512:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3513:FreeRTOS/Source/tasks.c **** 	{
3514:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
3515:FreeRTOS/Source/tasks.c **** 	}
3516:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3517:FreeRTOS/Source/tasks.c **** 
3518:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3519:FreeRTOS/Source/tasks.c **** 	{
3520:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
3521:FreeRTOS/Source/tasks.c **** 	}
3522:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3523:FreeRTOS/Source/tasks.c **** 
3524:FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3525:FreeRTOS/Source/tasks.c **** 	using list2. */
3526:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
3527:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
3528:FreeRTOS/Source/tasks.c **** }
3529:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3530:FreeRTOS/Source/tasks.c **** 
3531:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3532:FreeRTOS/Source/tasks.c **** {
3533:FreeRTOS/Source/tasks.c **** 
3534:FreeRTOS/Source/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3535:FreeRTOS/Source/tasks.c **** 
3536:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3537:FreeRTOS/Source/tasks.c **** 	{
3538:FreeRTOS/Source/tasks.c **** 		TCB_t *pxTCB;
3539:FreeRTOS/Source/tasks.c **** 
3540:FreeRTOS/Source/tasks.c **** 		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
3541:FreeRTOS/Source/tasks.c **** 		being called too often in the idle task. */
3542:FreeRTOS/Source/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
3543:FreeRTOS/Source/tasks.c **** 		{
3544:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
3545:FreeRTOS/Source/tasks.c **** 			{
3546:FreeRTOS/Source/tasks.c **** 				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is u
3547:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
3548:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
3549:FreeRTOS/Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
3550:FreeRTOS/Source/tasks.c **** 			}
3551:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
3552:FreeRTOS/Source/tasks.c **** 
3553:FreeRTOS/Source/tasks.c **** 			prvDeleteTCB( pxTCB );
3554:FreeRTOS/Source/tasks.c **** 		}
3555:FreeRTOS/Source/tasks.c **** 	}
3556:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3557:FreeRTOS/Source/tasks.c **** }
3558:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3559:FreeRTOS/Source/tasks.c **** 
3560:FreeRTOS/Source/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3561:FreeRTOS/Source/tasks.c **** 
3562:FreeRTOS/Source/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3563:FreeRTOS/Source/tasks.c **** 	{
3564:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3565:FreeRTOS/Source/tasks.c **** 
3566:FreeRTOS/Source/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3567:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3568:FreeRTOS/Source/tasks.c **** 
3569:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3570:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3571:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3572:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3573:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3574:FreeRTOS/Source/tasks.c **** 
3575:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3576:FreeRTOS/Source/tasks.c **** 		{
3577:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3578:FreeRTOS/Source/tasks.c **** 		}
3579:FreeRTOS/Source/tasks.c **** 		#else
3580:FreeRTOS/Source/tasks.c **** 		{
3581:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3582:FreeRTOS/Source/tasks.c **** 		}
3583:FreeRTOS/Source/tasks.c **** 		#endif
3584:FreeRTOS/Source/tasks.c **** 
3585:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3586:FreeRTOS/Source/tasks.c **** 		{
3587:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3588:FreeRTOS/Source/tasks.c **** 		}
3589:FreeRTOS/Source/tasks.c **** 		#else
3590:FreeRTOS/Source/tasks.c **** 		{
3591:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3592:FreeRTOS/Source/tasks.c **** 		}
3593:FreeRTOS/Source/tasks.c **** 		#endif
3594:FreeRTOS/Source/tasks.c **** 
3595:FreeRTOS/Source/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the
3596:FreeRTOS/Source/tasks.c **** 		value of eState passed into this function is eInvalid - otherwise the
3597:FreeRTOS/Source/tasks.c **** 		state is just set to whatever is passed in. */
3598:FreeRTOS/Source/tasks.c **** 		if( eState != eInvalid )
3599:FreeRTOS/Source/tasks.c **** 		{
3600:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
3601:FreeRTOS/Source/tasks.c **** 			{
3602:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->eCurrentState = eRunning;
3603:FreeRTOS/Source/tasks.c **** 			}
3604:FreeRTOS/Source/tasks.c **** 			else
3605:FreeRTOS/Source/tasks.c **** 			{
3606:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->eCurrentState = eState;
3607:FreeRTOS/Source/tasks.c **** 
3608:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3609:FreeRTOS/Source/tasks.c **** 				{
3610:FreeRTOS/Source/tasks.c **** 					/* If the task is in the suspended list then there is a
3611:FreeRTOS/Source/tasks.c **** 					chance it is actually just blocked indefinitely - so really
3612:FreeRTOS/Source/tasks.c **** 					it should be reported as being in the Blocked state. */
3613:FreeRTOS/Source/tasks.c **** 					if( eState == eSuspended )
3614:FreeRTOS/Source/tasks.c **** 					{
3615:FreeRTOS/Source/tasks.c **** 						vTaskSuspendAll();
3616:FreeRTOS/Source/tasks.c **** 						{
3617:FreeRTOS/Source/tasks.c **** 							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3618:FreeRTOS/Source/tasks.c **** 							{
3619:FreeRTOS/Source/tasks.c **** 								pxTaskStatus->eCurrentState = eBlocked;
3620:FreeRTOS/Source/tasks.c **** 							}
3621:FreeRTOS/Source/tasks.c **** 						}
3622:FreeRTOS/Source/tasks.c **** 						( void ) xTaskResumeAll();
3623:FreeRTOS/Source/tasks.c **** 					}
3624:FreeRTOS/Source/tasks.c **** 				}
3625:FreeRTOS/Source/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3626:FreeRTOS/Source/tasks.c **** 			}
3627:FreeRTOS/Source/tasks.c **** 		}
3628:FreeRTOS/Source/tasks.c **** 		else
3629:FreeRTOS/Source/tasks.c **** 		{
3630:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3631:FreeRTOS/Source/tasks.c **** 		}
3632:FreeRTOS/Source/tasks.c **** 
3633:FreeRTOS/Source/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3634:FreeRTOS/Source/tasks.c **** 		parameter is provided to allow it to be skipped. */
3635:FreeRTOS/Source/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3636:FreeRTOS/Source/tasks.c **** 		{
3637:FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3638:FreeRTOS/Source/tasks.c **** 			{
3639:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3640:FreeRTOS/Source/tasks.c **** 			}
3641:FreeRTOS/Source/tasks.c **** 			#else
3642:FreeRTOS/Source/tasks.c **** 			{
3643:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3644:FreeRTOS/Source/tasks.c **** 			}
3645:FreeRTOS/Source/tasks.c **** 			#endif
3646:FreeRTOS/Source/tasks.c **** 		}
3647:FreeRTOS/Source/tasks.c **** 		else
3648:FreeRTOS/Source/tasks.c **** 		{
3649:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3650:FreeRTOS/Source/tasks.c **** 		}
3651:FreeRTOS/Source/tasks.c **** 	}
3652:FreeRTOS/Source/tasks.c **** 
3653:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3654:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3655:FreeRTOS/Source/tasks.c **** 
3656:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3657:FreeRTOS/Source/tasks.c **** 
3658:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3659:FreeRTOS/Source/tasks.c **** 	{
3660:FreeRTOS/Source/tasks.c **** 	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
3661:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0;
3662:FreeRTOS/Source/tasks.c **** 
3663:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3664:FreeRTOS/Source/tasks.c **** 		{
3665:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is
3666:FreeRTOS/Source/tasks.c **** 
3667:FreeRTOS/Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3668:FreeRTOS/Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3669:FreeRTOS/Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3670:FreeRTOS/Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3671:FreeRTOS/Source/tasks.c **** 			do
3672:FreeRTOS/Source/tasks.c **** 			{
3673:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
3674:FreeRTOS/Source/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3675:FreeRTOS/Source/tasks.c **** 				uxTask++;
3676:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3677:FreeRTOS/Source/tasks.c **** 		}
3678:FreeRTOS/Source/tasks.c **** 		else
3679:FreeRTOS/Source/tasks.c **** 		{
3680:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3681:FreeRTOS/Source/tasks.c **** 		}
3682:FreeRTOS/Source/tasks.c **** 
3683:FreeRTOS/Source/tasks.c **** 		return uxTask;
3684:FreeRTOS/Source/tasks.c **** 	}
3685:FreeRTOS/Source/tasks.c **** 
3686:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3687:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3688:FreeRTOS/Source/tasks.c **** 
3689:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3690:FreeRTOS/Source/tasks.c **** 
3691:FreeRTOS/Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3692:FreeRTOS/Source/tasks.c **** 	{
3693:FreeRTOS/Source/tasks.c **** 	uint32_t ulCount = 0U;
3694:FreeRTOS/Source/tasks.c **** 
3695:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3696:FreeRTOS/Source/tasks.c **** 		{
3697:FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
3698:FreeRTOS/Source/tasks.c **** 			ulCount++;
3699:FreeRTOS/Source/tasks.c **** 		}
3700:FreeRTOS/Source/tasks.c **** 
3701:FreeRTOS/Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
3702:FreeRTOS/Source/tasks.c **** 
3703:FreeRTOS/Source/tasks.c **** 		return ( configSTACK_DEPTH_TYPE ) ulCount;
3704:FreeRTOS/Source/tasks.c **** 	}
3705:FreeRTOS/Source/tasks.c **** 
3706:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3707:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3708:FreeRTOS/Source/tasks.c **** 
3709:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3710:FreeRTOS/Source/tasks.c **** 
3711:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3712:FreeRTOS/Source/tasks.c **** 	{
3713:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3714:FreeRTOS/Source/tasks.c **** 	uint8_t *pucEndOfStack;
3715:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3716:FreeRTOS/Source/tasks.c **** 
3717:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3718:FreeRTOS/Source/tasks.c **** 
3719:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3720:FreeRTOS/Source/tasks.c **** 		{
3721:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3722:FreeRTOS/Source/tasks.c **** 		}
3723:FreeRTOS/Source/tasks.c **** 		#else
3724:FreeRTOS/Source/tasks.c **** 		{
3725:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3726:FreeRTOS/Source/tasks.c **** 		}
3727:FreeRTOS/Source/tasks.c **** 		#endif
3728:FreeRTOS/Source/tasks.c **** 
3729:FreeRTOS/Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3730:FreeRTOS/Source/tasks.c **** 
3731:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3732:FreeRTOS/Source/tasks.c **** 	}
3733:FreeRTOS/Source/tasks.c **** 
3734:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3735:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3736:FreeRTOS/Source/tasks.c **** 
3737:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3738:FreeRTOS/Source/tasks.c **** 
3739:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3740:FreeRTOS/Source/tasks.c **** 	{
3741:FreeRTOS/Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3742:FreeRTOS/Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3743:FreeRTOS/Source/tasks.c **** 		want to allocate and clean RAM statically. */
3744:FreeRTOS/Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3745:FreeRTOS/Source/tasks.c **** 
3746:FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3747:FreeRTOS/Source/tasks.c **** 		to the task to free any memory allocated at the application level. */
3748:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3749:FreeRTOS/Source/tasks.c **** 		{
3750:FreeRTOS/Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3751:FreeRTOS/Source/tasks.c **** 		}
3752:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3753:FreeRTOS/Source/tasks.c **** 
3754:FreeRTOS/Source/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( p
3755:FreeRTOS/Source/tasks.c **** 		{
3756:FreeRTOS/Source/tasks.c **** 			/* The task can only have been allocated dynamically - free both
3757:FreeRTOS/Source/tasks.c **** 			the stack and TCB. */
3758:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB->pxStack );
3759:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
3760:FreeRTOS/Source/tasks.c **** 		}
3761:FreeRTOS/Source/tasks.c **** 		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consol
3762:FreeRTOS/Source/tasks.c **** 		{
3763:FreeRTOS/Source/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3764:FreeRTOS/Source/tasks.c **** 			check what was statically allocated before trying to free the
3765:FreeRTOS/Source/tasks.c **** 			memory. */
3766:FreeRTOS/Source/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3767:FreeRTOS/Source/tasks.c **** 			{
3768:FreeRTOS/Source/tasks.c **** 				/* Both the stack and TCB were allocated dynamically, so both
3769:FreeRTOS/Source/tasks.c **** 				must be freed. */
3770:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB->pxStack );
3771:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB );
3772:FreeRTOS/Source/tasks.c **** 			}
3773:FreeRTOS/Source/tasks.c **** 			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3774:FreeRTOS/Source/tasks.c **** 			{
3775:FreeRTOS/Source/tasks.c **** 				/* Only the stack was statically allocated, so the TCB is the
3776:FreeRTOS/Source/tasks.c **** 				only memory that must be freed. */
3777:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB );
3778:FreeRTOS/Source/tasks.c **** 			}
3779:FreeRTOS/Source/tasks.c **** 			else
3780:FreeRTOS/Source/tasks.c **** 			{
3781:FreeRTOS/Source/tasks.c **** 				/* Neither the stack nor the TCB were allocated dynamically, so
3782:FreeRTOS/Source/tasks.c **** 				nothing needs to be freed. */
3783:FreeRTOS/Source/tasks.c **** 				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
3784:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3785:FreeRTOS/Source/tasks.c **** 			}
3786:FreeRTOS/Source/tasks.c **** 		}
3787:FreeRTOS/Source/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3788:FreeRTOS/Source/tasks.c **** 	}
3789:FreeRTOS/Source/tasks.c **** 
3790:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3791:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3792:FreeRTOS/Source/tasks.c **** 
3793:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3794:FreeRTOS/Source/tasks.c **** {
 186               	.LM0:
 187               	.LFBB1:
 188               	/* prologue: function */
 189               	/* frame size = 0 */
 190               	/* stack size = 0 */
 191               	.L__stack_usage = 0
3795:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
3796:FreeRTOS/Source/tasks.c **** 
3797:FreeRTOS/Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 193               	.LM1:
 194 0000 E091 0000 		lds r30,pxDelayedTaskList
 195 0004 F091 0000 		lds r31,pxDelayedTaskList+1
 196 0008 8081      		ld r24,Z
 197 000a 8111      		cpse r24,__zero_reg__
 198 000c 00C0      		rjmp .L2
3798:FreeRTOS/Source/tasks.c **** 	{
3799:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3800:FreeRTOS/Source/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3801:FreeRTOS/Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3802:FreeRTOS/Source/tasks.c **** 		there is an item in the delayed list. */
3803:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 200               	.LM2:
 201 000e 8FEF      		ldi r24,lo8(-1)
 202 0010 9FEF      		ldi r25,lo8(-1)
 203 0012 00C0      		rjmp .L4
 204               	.L2:
 205               	.LBB6:
 206               	.LBB7:
3804:FreeRTOS/Source/tasks.c **** 	}
3805:FreeRTOS/Source/tasks.c **** 	else
3806:FreeRTOS/Source/tasks.c **** 	{
3807:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3808:FreeRTOS/Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3809:FreeRTOS/Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3810:FreeRTOS/Source/tasks.c **** 		from the Blocked state. */
3811:FreeRTOS/Source/tasks.c **** 		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as thi
 208               	.LM3:
 209 0014 E091 0000 		lds r30,pxDelayedTaskList
 210 0018 F091 0000 		lds r31,pxDelayedTaskList+1
 211 001c 0580      		ldd __tmp_reg__,Z+5
 212 001e F681      		ldd r31,Z+6
 213 0020 E02D      		mov r30,__tmp_reg__
3812:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 215               	.LM4:
 216 0022 0680      		ldd __tmp_reg__,Z+6
 217 0024 F781      		ldd r31,Z+7
 218 0026 E02D      		mov r30,__tmp_reg__
 219 0028 8281      		ldd r24,Z+2
 220 002a 9381      		ldd r25,Z+3
 221               	.L4:
 222 002c 9093 0000 		sts xNextTaskUnblockTime+1,r25
 223 0030 8093 0000 		sts xNextTaskUnblockTime,r24
 224 0034 0895      		ret
 225               	.LBE7:
 226               	.LBE6:
 228               	.Lscope1:
 230               		.stabd	78,0,0
 235               	prvAddCurrentTaskToDelayedList:
 236               		.stabd	46,0,0
3813:FreeRTOS/Source/tasks.c **** 	}
3814:FreeRTOS/Source/tasks.c **** }
3815:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3816:FreeRTOS/Source/tasks.c **** 
3817:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3818:FreeRTOS/Source/tasks.c **** 
3819:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3820:FreeRTOS/Source/tasks.c **** 	{
3821:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
3822:FreeRTOS/Source/tasks.c **** 
3823:FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
3824:FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3825:FreeRTOS/Source/tasks.c **** 		individual execution thread. */
3826:FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
3827:FreeRTOS/Source/tasks.c **** 
3828:FreeRTOS/Source/tasks.c **** 		return xReturn;
3829:FreeRTOS/Source/tasks.c **** 	}
3830:FreeRTOS/Source/tasks.c **** 
3831:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3832:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3833:FreeRTOS/Source/tasks.c **** 
3834:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3835:FreeRTOS/Source/tasks.c **** 
3836:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3837:FreeRTOS/Source/tasks.c **** 	{
3838:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
3839:FreeRTOS/Source/tasks.c **** 
3840:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3841:FreeRTOS/Source/tasks.c **** 		{
3842:FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3843:FreeRTOS/Source/tasks.c **** 		}
3844:FreeRTOS/Source/tasks.c **** 		else
3845:FreeRTOS/Source/tasks.c **** 		{
3846:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3847:FreeRTOS/Source/tasks.c **** 			{
3848:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3849:FreeRTOS/Source/tasks.c **** 			}
3850:FreeRTOS/Source/tasks.c **** 			else
3851:FreeRTOS/Source/tasks.c **** 			{
3852:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
3853:FreeRTOS/Source/tasks.c **** 			}
3854:FreeRTOS/Source/tasks.c **** 		}
3855:FreeRTOS/Source/tasks.c **** 
3856:FreeRTOS/Source/tasks.c **** 		return xReturn;
3857:FreeRTOS/Source/tasks.c **** 	}
3858:FreeRTOS/Source/tasks.c **** 
3859:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3860:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3861:FreeRTOS/Source/tasks.c **** 
3862:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3863:FreeRTOS/Source/tasks.c **** 
3864:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3865:FreeRTOS/Source/tasks.c **** 	{
3866:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
3867:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3868:FreeRTOS/Source/tasks.c **** 
3869:FreeRTOS/Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3870:FreeRTOS/Source/tasks.c **** 		locked then the mutex holder might now be NULL.  _RB_ Is this still
3871:FreeRTOS/Source/tasks.c **** 		needed as interrupts can no longer use mutexes? */
3872:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
3873:FreeRTOS/Source/tasks.c **** 		{
3874:FreeRTOS/Source/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
3875:FreeRTOS/Source/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
3876:FreeRTOS/Source/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
3877:FreeRTOS/Source/tasks.c **** 			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
3878:FreeRTOS/Source/tasks.c **** 			{
3879:FreeRTOS/Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3880:FreeRTOS/Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
3881:FreeRTOS/Source/tasks.c **** 				not being used for anything else. */
3882:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VA
3883:FreeRTOS/Source/tasks.c **** 				{
3884:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIOR
3885:FreeRTOS/Source/tasks.c **** 				}
3886:FreeRTOS/Source/tasks.c **** 				else
3887:FreeRTOS/Source/tasks.c **** 				{
3888:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3889:FreeRTOS/Source/tasks.c **** 				}
3890:FreeRTOS/Source/tasks.c **** 
3891:FreeRTOS/Source/tasks.c **** 				/* If the task being modified is in the ready state it will need
3892:FreeRTOS/Source/tasks.c **** 				to be moved into a new list. */
3893:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutex
3894:FreeRTOS/Source/tasks.c **** 				{
3895:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3896:FreeRTOS/Source/tasks.c **** 					{
3897:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
3898:FreeRTOS/Source/tasks.c **** 					}
3899:FreeRTOS/Source/tasks.c **** 					else
3900:FreeRTOS/Source/tasks.c **** 					{
3901:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3902:FreeRTOS/Source/tasks.c **** 					}
3903:FreeRTOS/Source/tasks.c **** 
3904:FreeRTOS/Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3905:FreeRTOS/Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3906:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
3907:FreeRTOS/Source/tasks.c **** 				}
3908:FreeRTOS/Source/tasks.c **** 				else
3909:FreeRTOS/Source/tasks.c **** 				{
3910:FreeRTOS/Source/tasks.c **** 					/* Just inherit the priority. */
3911:FreeRTOS/Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
3912:FreeRTOS/Source/tasks.c **** 				}
3913:FreeRTOS/Source/tasks.c **** 
3914:FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
3915:FreeRTOS/Source/tasks.c **** 
3916:FreeRTOS/Source/tasks.c **** 				/* Inheritance occurred. */
3917:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
3918:FreeRTOS/Source/tasks.c **** 			}
3919:FreeRTOS/Source/tasks.c **** 			else
3920:FreeRTOS/Source/tasks.c **** 			{
3921:FreeRTOS/Source/tasks.c **** 				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
3922:FreeRTOS/Source/tasks.c **** 				{
3923:FreeRTOS/Source/tasks.c **** 					/* The base priority of the mutex holder is lower than the
3924:FreeRTOS/Source/tasks.c **** 					priority of the task attempting to take the mutex, but the
3925:FreeRTOS/Source/tasks.c **** 					current priority of the mutex holder is not lower than the
3926:FreeRTOS/Source/tasks.c **** 					priority of the task attempting to take the mutex.
3927:FreeRTOS/Source/tasks.c **** 					Therefore the mutex holder must have already inherited a
3928:FreeRTOS/Source/tasks.c **** 					priority, but inheritance would have occurred if that had
3929:FreeRTOS/Source/tasks.c **** 					not been the case. */
3930:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
3931:FreeRTOS/Source/tasks.c **** 				}
3932:FreeRTOS/Source/tasks.c **** 				else
3933:FreeRTOS/Source/tasks.c **** 				{
3934:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3935:FreeRTOS/Source/tasks.c **** 				}
3936:FreeRTOS/Source/tasks.c **** 			}
3937:FreeRTOS/Source/tasks.c **** 		}
3938:FreeRTOS/Source/tasks.c **** 		else
3939:FreeRTOS/Source/tasks.c **** 		{
3940:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3941:FreeRTOS/Source/tasks.c **** 		}
3942:FreeRTOS/Source/tasks.c **** 
3943:FreeRTOS/Source/tasks.c **** 		return xReturn;
3944:FreeRTOS/Source/tasks.c **** 	}
3945:FreeRTOS/Source/tasks.c **** 
3946:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3947:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3948:FreeRTOS/Source/tasks.c **** 
3949:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3950:FreeRTOS/Source/tasks.c **** 
3951:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3952:FreeRTOS/Source/tasks.c **** 	{
3953:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
3954:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3955:FreeRTOS/Source/tasks.c **** 
3956:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
3957:FreeRTOS/Source/tasks.c **** 		{
3958:FreeRTOS/Source/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
3959:FreeRTOS/Source/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
3960:FreeRTOS/Source/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
3961:FreeRTOS/Source/tasks.c **** 			be the running state task. */
3962:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
3963:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
3964:FreeRTOS/Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
3965:FreeRTOS/Source/tasks.c **** 
3966:FreeRTOS/Source/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
3967:FreeRTOS/Source/tasks.c **** 			task? */
3968:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
3969:FreeRTOS/Source/tasks.c **** 			{
3970:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3971:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
3972:FreeRTOS/Source/tasks.c **** 				{
3973:FreeRTOS/Source/tasks.c **** 					/* A task can only have an inherited priority if it holds
3974:FreeRTOS/Source/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3975:FreeRTOS/Source/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3976:FreeRTOS/Source/tasks.c **** 					holding task then it must be the running state task.  Remove
3977:FreeRTOS/Source/tasks.c **** 					the holding task from the ready list. */
3978:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
3979:FreeRTOS/Source/tasks.c **** 					{
3980:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3981:FreeRTOS/Source/tasks.c **** 					}
3982:FreeRTOS/Source/tasks.c **** 					else
3983:FreeRTOS/Source/tasks.c **** 					{
3984:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3985:FreeRTOS/Source/tasks.c **** 					}
3986:FreeRTOS/Source/tasks.c **** 
3987:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority before adding the task into the
3988:FreeRTOS/Source/tasks.c **** 					new	ready list. */
3989:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3990:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
3991:FreeRTOS/Source/tasks.c **** 
3992:FreeRTOS/Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3993:FreeRTOS/Source/tasks.c **** 					any other purpose if this task is running, and it must be
3994:FreeRTOS/Source/tasks.c **** 					running to give back the mutex. */
3995:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
3996:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
3997:FreeRTOS/Source/tasks.c **** 
3998:FreeRTOS/Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
3999:FreeRTOS/Source/tasks.c **** 					This is only actually required in the corner case whereby
4000:FreeRTOS/Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
4001:FreeRTOS/Source/tasks.c **** 					in an order different to that in which they were taken.
4002:FreeRTOS/Source/tasks.c **** 					If a context switch did not occur when the first mutex was
4003:FreeRTOS/Source/tasks.c **** 					returned, even if a task was waiting on it, then a context
4004:FreeRTOS/Source/tasks.c **** 					switch should occur when the last mutex is returned whether
4005:FreeRTOS/Source/tasks.c **** 					a task is waiting on it or not. */
4006:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
4007:FreeRTOS/Source/tasks.c **** 				}
4008:FreeRTOS/Source/tasks.c **** 				else
4009:FreeRTOS/Source/tasks.c **** 				{
4010:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4011:FreeRTOS/Source/tasks.c **** 				}
4012:FreeRTOS/Source/tasks.c **** 			}
4013:FreeRTOS/Source/tasks.c **** 			else
4014:FreeRTOS/Source/tasks.c **** 			{
4015:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4016:FreeRTOS/Source/tasks.c **** 			}
4017:FreeRTOS/Source/tasks.c **** 		}
4018:FreeRTOS/Source/tasks.c **** 		else
4019:FreeRTOS/Source/tasks.c **** 		{
4020:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4021:FreeRTOS/Source/tasks.c **** 		}
4022:FreeRTOS/Source/tasks.c **** 
4023:FreeRTOS/Source/tasks.c **** 		return xReturn;
4024:FreeRTOS/Source/tasks.c **** 	}
4025:FreeRTOS/Source/tasks.c **** 
4026:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4027:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4028:FreeRTOS/Source/tasks.c **** 
4029:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4030:FreeRTOS/Source/tasks.c **** 
4031:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestP
4032:FreeRTOS/Source/tasks.c **** 	{
4033:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
4034:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4035:FreeRTOS/Source/tasks.c **** 	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
4036:FreeRTOS/Source/tasks.c **** 
4037:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
4038:FreeRTOS/Source/tasks.c **** 		{
4039:FreeRTOS/Source/tasks.c **** 			/* If pxMutexHolder is not NULL then the holder must hold at least
4040:FreeRTOS/Source/tasks.c **** 			one mutex. */
4041:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4042:FreeRTOS/Source/tasks.c **** 
4043:FreeRTOS/Source/tasks.c **** 			/* Determine the priority to which the priority of the task that
4044:FreeRTOS/Source/tasks.c **** 			holds the mutex should be set.  This will be the greater of the
4045:FreeRTOS/Source/tasks.c **** 			holding task's base priority and the priority of the highest
4046:FreeRTOS/Source/tasks.c **** 			priority task that is waiting to obtain the mutex. */
4047:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4048:FreeRTOS/Source/tasks.c **** 			{
4049:FreeRTOS/Source/tasks.c **** 				uxPriorityToUse = uxHighestPriorityWaitingTask;
4050:FreeRTOS/Source/tasks.c **** 			}
4051:FreeRTOS/Source/tasks.c **** 			else
4052:FreeRTOS/Source/tasks.c **** 			{
4053:FreeRTOS/Source/tasks.c **** 				uxPriorityToUse = pxTCB->uxBasePriority;
4054:FreeRTOS/Source/tasks.c **** 			}
4055:FreeRTOS/Source/tasks.c **** 
4056:FreeRTOS/Source/tasks.c **** 			/* Does the priority need to change? */
4057:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != uxPriorityToUse )
4058:FreeRTOS/Source/tasks.c **** 			{
4059:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held.  This is a
4060:FreeRTOS/Source/tasks.c **** 				simplification in the priority inheritance implementation.  If
4061:FreeRTOS/Source/tasks.c **** 				the task that holds the mutex is also holding other mutexes then
4062:FreeRTOS/Source/tasks.c **** 				the other mutexes may have caused the priority inheritance. */
4063:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4064:FreeRTOS/Source/tasks.c **** 				{
4065:FreeRTOS/Source/tasks.c **** 					/* If a task has timed out because it already holds the
4066:FreeRTOS/Source/tasks.c **** 					mutex it was trying to obtain then it cannot of inherited
4067:FreeRTOS/Source/tasks.c **** 					its own priority. */
4068:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB != pxCurrentTCB );
4069:FreeRTOS/Source/tasks.c **** 
4070:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority, remembering the previous
4071:FreeRTOS/Source/tasks.c **** 					priority to facilitate determining the subject task's
4072:FreeRTOS/Source/tasks.c **** 					state. */
4073:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4074:FreeRTOS/Source/tasks.c **** 					uxPriorityUsedOnEntry = pxTCB->uxPriority;
4075:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxPriorityToUse;
4076:FreeRTOS/Source/tasks.c **** 
4077:FreeRTOS/Source/tasks.c **** 					/* Only reset the event list item value if the value is not
4078:FreeRTOS/Source/tasks.c **** 					being used for anything else. */
4079:FreeRTOS/Source/tasks.c **** 					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE
4080:FreeRTOS/Source/tasks.c **** 					{
4081:FreeRTOS/Source/tasks.c **** 						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( 
4082:FreeRTOS/Source/tasks.c **** 					}
4083:FreeRTOS/Source/tasks.c **** 					else
4084:FreeRTOS/Source/tasks.c **** 					{
4085:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4086:FreeRTOS/Source/tasks.c **** 					}
4087:FreeRTOS/Source/tasks.c **** 
4088:FreeRTOS/Source/tasks.c **** 					/* If the running task is not the task that holds the mutex
4089:FreeRTOS/Source/tasks.c **** 					then the task that holds the mutex could be in either the
4090:FreeRTOS/Source/tasks.c **** 					Ready, Blocked or Suspended states.  Only remove the task
4091:FreeRTOS/Source/tasks.c **** 					from its current state list if it is in the Ready state as
4092:FreeRTOS/Source/tasks.c **** 					the task's priority is going to change and there is one
4093:FreeRTOS/Source/tasks.c **** 					Ready list per priority. */
4094:FreeRTOS/Source/tasks.c **** 					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xState
4095:FreeRTOS/Source/tasks.c **** 					{
4096:FreeRTOS/Source/tasks.c **** 						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4097:FreeRTOS/Source/tasks.c **** 						{
4098:FreeRTOS/Source/tasks.c **** 							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
4099:FreeRTOS/Source/tasks.c **** 						}
4100:FreeRTOS/Source/tasks.c **** 						else
4101:FreeRTOS/Source/tasks.c **** 						{
4102:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
4103:FreeRTOS/Source/tasks.c **** 						}
4104:FreeRTOS/Source/tasks.c **** 
4105:FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
4106:FreeRTOS/Source/tasks.c **** 					}
4107:FreeRTOS/Source/tasks.c **** 					else
4108:FreeRTOS/Source/tasks.c **** 					{
4109:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4110:FreeRTOS/Source/tasks.c **** 					}
4111:FreeRTOS/Source/tasks.c **** 				}
4112:FreeRTOS/Source/tasks.c **** 				else
4113:FreeRTOS/Source/tasks.c **** 				{
4114:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4115:FreeRTOS/Source/tasks.c **** 				}
4116:FreeRTOS/Source/tasks.c **** 			}
4117:FreeRTOS/Source/tasks.c **** 			else
4118:FreeRTOS/Source/tasks.c **** 			{
4119:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4120:FreeRTOS/Source/tasks.c **** 			}
4121:FreeRTOS/Source/tasks.c **** 		}
4122:FreeRTOS/Source/tasks.c **** 		else
4123:FreeRTOS/Source/tasks.c **** 		{
4124:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4125:FreeRTOS/Source/tasks.c **** 		}
4126:FreeRTOS/Source/tasks.c **** 	}
4127:FreeRTOS/Source/tasks.c **** 
4128:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4129:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4130:FreeRTOS/Source/tasks.c **** 
4131:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4132:FreeRTOS/Source/tasks.c **** 
4133:FreeRTOS/Source/tasks.c **** 	void vTaskEnterCritical( void )
4134:FreeRTOS/Source/tasks.c **** 	{
4135:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
4136:FreeRTOS/Source/tasks.c **** 
4137:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4138:FreeRTOS/Source/tasks.c **** 		{
4139:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
4140:FreeRTOS/Source/tasks.c **** 
4141:FreeRTOS/Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
4142:FreeRTOS/Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
4143:FreeRTOS/Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
4144:FreeRTOS/Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
4145:FreeRTOS/Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
4146:FreeRTOS/Source/tasks.c **** 			critical section. */
4147:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
4148:FreeRTOS/Source/tasks.c **** 			{
4149:FreeRTOS/Source/tasks.c **** 				portASSERT_IF_IN_ISR();
4150:FreeRTOS/Source/tasks.c **** 			}
4151:FreeRTOS/Source/tasks.c **** 		}
4152:FreeRTOS/Source/tasks.c **** 		else
4153:FreeRTOS/Source/tasks.c **** 		{
4154:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4155:FreeRTOS/Source/tasks.c **** 		}
4156:FreeRTOS/Source/tasks.c **** 	}
4157:FreeRTOS/Source/tasks.c **** 
4158:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4159:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4160:FreeRTOS/Source/tasks.c **** 
4161:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4162:FreeRTOS/Source/tasks.c **** 
4163:FreeRTOS/Source/tasks.c **** 	void vTaskExitCritical( void )
4164:FreeRTOS/Source/tasks.c **** 	{
4165:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4166:FreeRTOS/Source/tasks.c **** 		{
4167:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
4168:FreeRTOS/Source/tasks.c **** 			{
4169:FreeRTOS/Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
4170:FreeRTOS/Source/tasks.c **** 
4171:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
4172:FreeRTOS/Source/tasks.c **** 				{
4173:FreeRTOS/Source/tasks.c **** 					portENABLE_INTERRUPTS();
4174:FreeRTOS/Source/tasks.c **** 				}
4175:FreeRTOS/Source/tasks.c **** 				else
4176:FreeRTOS/Source/tasks.c **** 				{
4177:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4178:FreeRTOS/Source/tasks.c **** 				}
4179:FreeRTOS/Source/tasks.c **** 			}
4180:FreeRTOS/Source/tasks.c **** 			else
4181:FreeRTOS/Source/tasks.c **** 			{
4182:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4183:FreeRTOS/Source/tasks.c **** 			}
4184:FreeRTOS/Source/tasks.c **** 		}
4185:FreeRTOS/Source/tasks.c **** 		else
4186:FreeRTOS/Source/tasks.c **** 		{
4187:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4188:FreeRTOS/Source/tasks.c **** 		}
4189:FreeRTOS/Source/tasks.c **** 	}
4190:FreeRTOS/Source/tasks.c **** 
4191:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4192:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4193:FreeRTOS/Source/tasks.c **** 
4194:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4195:FreeRTOS/Source/tasks.c **** 
4196:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
4197:FreeRTOS/Source/tasks.c **** 	{
4198:FreeRTOS/Source/tasks.c **** 	size_t x;
4199:FreeRTOS/Source/tasks.c **** 
4200:FreeRTOS/Source/tasks.c **** 		/* Start by copying the entire string. */
4201:FreeRTOS/Source/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
4202:FreeRTOS/Source/tasks.c **** 
4203:FreeRTOS/Source/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
4204:FreeRTOS/Source/tasks.c **** 		printed out. */
4205:FreeRTOS/Source/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4206:FreeRTOS/Source/tasks.c **** 		{
4207:FreeRTOS/Source/tasks.c **** 			pcBuffer[ x ] = ' ';
4208:FreeRTOS/Source/tasks.c **** 		}
4209:FreeRTOS/Source/tasks.c **** 
4210:FreeRTOS/Source/tasks.c **** 		/* Terminate. */
4211:FreeRTOS/Source/tasks.c **** 		pcBuffer[ x ] = ( char ) 0x00;
4212:FreeRTOS/Source/tasks.c **** 
4213:FreeRTOS/Source/tasks.c **** 		/* Return the new end of string. */
4214:FreeRTOS/Source/tasks.c **** 		return &( pcBuffer[ x ] );
4215:FreeRTOS/Source/tasks.c **** 	}
4216:FreeRTOS/Source/tasks.c **** 
4217:FreeRTOS/Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4218:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4219:FreeRTOS/Source/tasks.c **** 
4220:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
4221:FreeRTOS/Source/tasks.c **** 
4222:FreeRTOS/Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
4223:FreeRTOS/Source/tasks.c **** 	{
4224:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4225:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4226:FreeRTOS/Source/tasks.c **** 	char cStatus;
4227:FreeRTOS/Source/tasks.c **** 
4228:FreeRTOS/Source/tasks.c **** 		/*
4229:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
4230:FreeRTOS/Source/tasks.c **** 		 *
4231:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4232:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4233:FreeRTOS/Source/tasks.c **** 		 * scheduler.
4234:FreeRTOS/Source/tasks.c **** 		 *
4235:FreeRTOS/Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4236:FreeRTOS/Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
4237:FreeRTOS/Source/tasks.c **** 		 * displays task names, states and stack usage.
4238:FreeRTOS/Source/tasks.c **** 		 *
4239:FreeRTOS/Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
4240:FreeRTOS/Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
4241:FreeRTOS/Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
4242:FreeRTOS/Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
4243:FreeRTOS/Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
4244:FreeRTOS/Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
4245:FreeRTOS/Source/tasks.c **** 		 * snprintf() implementation!).
4246:FreeRTOS/Source/tasks.c **** 		 *
4247:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4248:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4249:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskList().
4250:FreeRTOS/Source/tasks.c **** 		 */
4251:FreeRTOS/Source/tasks.c **** 
4252:FreeRTOS/Source/tasks.c **** 
4253:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4254:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4255:FreeRTOS/Source/tasks.c **** 
4256:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4257:FreeRTOS/Source/tasks.c **** 		function is executing. */
4258:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4259:FreeRTOS/Source/tasks.c **** 
4260:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
4261:FreeRTOS/Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4262:FreeRTOS/Source/tasks.c **** 		equate to NULL. */
4263:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4264:FreeRTOS/Source/tasks.c **** 
4265:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4266:FreeRTOS/Source/tasks.c **** 		{
4267:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
4268:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4269:FreeRTOS/Source/tasks.c **** 
4270:FreeRTOS/Source/tasks.c **** 			/* Create a human readable table from the binary data. */
4271:FreeRTOS/Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
4272:FreeRTOS/Source/tasks.c **** 			{
4273:FreeRTOS/Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
4274:FreeRTOS/Source/tasks.c **** 				{
4275:FreeRTOS/Source/tasks.c **** 					case eRunning:		cStatus = tskRUNNING_CHAR;
4276:FreeRTOS/Source/tasks.c **** 										break;
4277:FreeRTOS/Source/tasks.c **** 
4278:FreeRTOS/Source/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
4279:FreeRTOS/Source/tasks.c **** 										break;
4280:FreeRTOS/Source/tasks.c **** 
4281:FreeRTOS/Source/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
4282:FreeRTOS/Source/tasks.c **** 										break;
4283:FreeRTOS/Source/tasks.c **** 
4284:FreeRTOS/Source/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4285:FreeRTOS/Source/tasks.c **** 										break;
4286:FreeRTOS/Source/tasks.c **** 
4287:FreeRTOS/Source/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
4288:FreeRTOS/Source/tasks.c **** 										break;
4289:FreeRTOS/Source/tasks.c **** 
4290:FreeRTOS/Source/tasks.c **** 					case eInvalid:		/* Fall through. */
4291:FreeRTOS/Source/tasks.c **** 					default:			/* Should not get here, but it is included
4292:FreeRTOS/Source/tasks.c **** 										to prevent static checking errors. */
4293:FreeRTOS/Source/tasks.c **** 										cStatus = ( char ) 0x00;
4294:FreeRTOS/Source/tasks.c **** 										break;
4295:FreeRTOS/Source/tasks.c **** 				}
4296:FreeRTOS/Source/tasks.c **** 
4297:FreeRTOS/Source/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
4298:FreeRTOS/Source/tasks.c **** 				can be printed in tabular form more easily. */
4299:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4300:FreeRTOS/Source/tasks.c **** 
4301:FreeRTOS/Source/tasks.c **** 				/* Write the rest of the string. */
4302:FreeRTOS/Source/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
4303:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers 
4304:FreeRTOS/Source/tasks.c **** 			}
4305:FreeRTOS/Source/tasks.c **** 
4306:FreeRTOS/Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4307:FreeRTOS/Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4308:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4309:FreeRTOS/Source/tasks.c **** 		}
4310:FreeRTOS/Source/tasks.c **** 		else
4311:FreeRTOS/Source/tasks.c **** 		{
4312:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4313:FreeRTOS/Source/tasks.c **** 		}
4314:FreeRTOS/Source/tasks.c **** 	}
4315:FreeRTOS/Source/tasks.c **** 
4316:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( 
4317:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
4318:FreeRTOS/Source/tasks.c **** 
4319:FreeRTOS/Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4320:FreeRTOS/Source/tasks.c **** 
4321:FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4322:FreeRTOS/Source/tasks.c **** 	{
4323:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4324:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4325:FreeRTOS/Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
4326:FreeRTOS/Source/tasks.c **** 
4327:FreeRTOS/Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
4328:FreeRTOS/Source/tasks.c **** 		{
4329:FreeRTOS/Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
4330:FreeRTOS/Source/tasks.c **** 		}
4331:FreeRTOS/Source/tasks.c **** 		#endif
4332:FreeRTOS/Source/tasks.c **** 
4333:FreeRTOS/Source/tasks.c **** 		/*
4334:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
4335:FreeRTOS/Source/tasks.c **** 		 *
4336:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4337:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4338:FreeRTOS/Source/tasks.c **** 		 * scheduler.
4339:FreeRTOS/Source/tasks.c **** 		 *
4340:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4341:FreeRTOS/Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
4342:FreeRTOS/Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
4343:FreeRTOS/Source/tasks.c **** 		 * in both absolute and percentage terms.
4344:FreeRTOS/Source/tasks.c **** 		 *
4345:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4346:FreeRTOS/Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
4347:FreeRTOS/Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
4348:FreeRTOS/Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
4349:FreeRTOS/Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4350:FreeRTOS/Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4351:FreeRTOS/Source/tasks.c **** 		 * a full snprintf() implementation!).
4352:FreeRTOS/Source/tasks.c **** 		 *
4353:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4354:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4355:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
4356:FreeRTOS/Source/tasks.c **** 		 */
4357:FreeRTOS/Source/tasks.c **** 
4358:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4359:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4360:FreeRTOS/Source/tasks.c **** 
4361:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4362:FreeRTOS/Source/tasks.c **** 		function is executing. */
4363:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4364:FreeRTOS/Source/tasks.c **** 
4365:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
4366:FreeRTOS/Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4367:FreeRTOS/Source/tasks.c **** 		equate to NULL. */
4368:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4369:FreeRTOS/Source/tasks.c **** 
4370:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4371:FreeRTOS/Source/tasks.c **** 		{
4372:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
4373:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4374:FreeRTOS/Source/tasks.c **** 
4375:FreeRTOS/Source/tasks.c **** 			/* For percentage calculations. */
4376:FreeRTOS/Source/tasks.c **** 			ulTotalTime /= 100UL;
4377:FreeRTOS/Source/tasks.c **** 
4378:FreeRTOS/Source/tasks.c **** 			/* Avoid divide by zero errors. */
4379:FreeRTOS/Source/tasks.c **** 			if( ulTotalTime > 0UL )
4380:FreeRTOS/Source/tasks.c **** 			{
4381:FreeRTOS/Source/tasks.c **** 				/* Create a human readable table from the binary data. */
4382:FreeRTOS/Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
4383:FreeRTOS/Source/tasks.c **** 				{
4384:FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
4385:FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
4386:FreeRTOS/Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
4387:FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4388:FreeRTOS/Source/tasks.c **** 
4389:FreeRTOS/Source/tasks.c **** 					/* Write the task name to the string, padding with
4390:FreeRTOS/Source/tasks.c **** 					spaces so it can be printed in tabular form more
4391:FreeRTOS/Source/tasks.c **** 					easily. */
4392:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4393:FreeRTOS/Source/tasks.c **** 
4394:FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
4395:FreeRTOS/Source/tasks.c **** 					{
4396:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4397:FreeRTOS/Source/tasks.c **** 						{
4398:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
4399:FreeRTOS/Source/tasks.c **** 						}
4400:FreeRTOS/Source/tasks.c **** 						#else
4401:FreeRTOS/Source/tasks.c **** 						{
4402:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4403:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
4404:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4405:FreeRTOS/Source/tasks.c **** 						}
4406:FreeRTOS/Source/tasks.c **** 						#endif
4407:FreeRTOS/Source/tasks.c **** 					}
4408:FreeRTOS/Source/tasks.c **** 					else
4409:FreeRTOS/Source/tasks.c **** 					{
4410:FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
4411:FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
4412:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4413:FreeRTOS/Source/tasks.c **** 						{
4414:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4415:FreeRTOS/Source/tasks.c **** 						}
4416:FreeRTOS/Source/tasks.c **** 						#else
4417:FreeRTOS/Source/tasks.c **** 						{
4418:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4419:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
4420:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4421:FreeRTOS/Source/tasks.c **** 						}
4422:FreeRTOS/Source/tasks.c **** 						#endif
4423:FreeRTOS/Source/tasks.c **** 					}
4424:FreeRTOS/Source/tasks.c **** 
4425:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers
4426:FreeRTOS/Source/tasks.c **** 				}
4427:FreeRTOS/Source/tasks.c **** 			}
4428:FreeRTOS/Source/tasks.c **** 			else
4429:FreeRTOS/Source/tasks.c **** 			{
4430:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4431:FreeRTOS/Source/tasks.c **** 			}
4432:FreeRTOS/Source/tasks.c **** 
4433:FreeRTOS/Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4434:FreeRTOS/Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4435:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4436:FreeRTOS/Source/tasks.c **** 		}
4437:FreeRTOS/Source/tasks.c **** 		else
4438:FreeRTOS/Source/tasks.c **** 		{
4439:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4440:FreeRTOS/Source/tasks.c **** 		}
4441:FreeRTOS/Source/tasks.c **** 	}
4442:FreeRTOS/Source/tasks.c **** 
4443:FreeRTOS/Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4444:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4445:FreeRTOS/Source/tasks.c **** 
4446:FreeRTOS/Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4447:FreeRTOS/Source/tasks.c **** {
4448:FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
4449:FreeRTOS/Source/tasks.c **** 
4450:FreeRTOS/Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
4451:FreeRTOS/Source/tasks.c **** 
4452:FreeRTOS/Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4453:FreeRTOS/Source/tasks.c **** 	queues and semaphores. */
4454:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
4455:FreeRTOS/Source/tasks.c **** 
4456:FreeRTOS/Source/tasks.c **** 	return uxReturn;
4457:FreeRTOS/Source/tasks.c **** }
4458:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4459:FreeRTOS/Source/tasks.c **** 
4460:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4461:FreeRTOS/Source/tasks.c **** 
4462:FreeRTOS/Source/tasks.c **** 	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
4463:FreeRTOS/Source/tasks.c **** 	{
4464:FreeRTOS/Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4465:FreeRTOS/Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
4466:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB != NULL )
4467:FreeRTOS/Source/tasks.c **** 		{
4468:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
4469:FreeRTOS/Source/tasks.c **** 		}
4470:FreeRTOS/Source/tasks.c **** 
4471:FreeRTOS/Source/tasks.c **** 		return pxCurrentTCB;
4472:FreeRTOS/Source/tasks.c **** 	}
4473:FreeRTOS/Source/tasks.c **** 
4474:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4475:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4476:FreeRTOS/Source/tasks.c **** 
4477:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4478:FreeRTOS/Source/tasks.c **** 
4479:FreeRTOS/Source/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4480:FreeRTOS/Source/tasks.c **** 	{
4481:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
4482:FreeRTOS/Source/tasks.c **** 
4483:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4484:FreeRTOS/Source/tasks.c **** 		{
4485:FreeRTOS/Source/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4486:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
4487:FreeRTOS/Source/tasks.c **** 			{
4488:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4489:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4490:FreeRTOS/Source/tasks.c **** 
4491:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4492:FreeRTOS/Source/tasks.c **** 				{
4493:FreeRTOS/Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4494:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4495:FreeRTOS/Source/tasks.c **** 
4496:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4497:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
4498:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
4499:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
4500:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
4501:FreeRTOS/Source/tasks.c **** 				}
4502:FreeRTOS/Source/tasks.c **** 				else
4503:FreeRTOS/Source/tasks.c **** 				{
4504:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4505:FreeRTOS/Source/tasks.c **** 				}
4506:FreeRTOS/Source/tasks.c **** 			}
4507:FreeRTOS/Source/tasks.c **** 			else
4508:FreeRTOS/Source/tasks.c **** 			{
4509:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4510:FreeRTOS/Source/tasks.c **** 			}
4511:FreeRTOS/Source/tasks.c **** 		}
4512:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4513:FreeRTOS/Source/tasks.c **** 
4514:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4515:FreeRTOS/Source/tasks.c **** 		{
4516:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4517:FreeRTOS/Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
4518:FreeRTOS/Source/tasks.c **** 
4519:FreeRTOS/Source/tasks.c **** 			if( ulReturn != 0UL )
4520:FreeRTOS/Source/tasks.c **** 			{
4521:FreeRTOS/Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
4522:FreeRTOS/Source/tasks.c **** 				{
4523:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
4524:FreeRTOS/Source/tasks.c **** 				}
4525:FreeRTOS/Source/tasks.c **** 				else
4526:FreeRTOS/Source/tasks.c **** 				{
4527:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
4528:FreeRTOS/Source/tasks.c **** 				}
4529:FreeRTOS/Source/tasks.c **** 			}
4530:FreeRTOS/Source/tasks.c **** 			else
4531:FreeRTOS/Source/tasks.c **** 			{
4532:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4533:FreeRTOS/Source/tasks.c **** 			}
4534:FreeRTOS/Source/tasks.c **** 
4535:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4536:FreeRTOS/Source/tasks.c **** 		}
4537:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4538:FreeRTOS/Source/tasks.c **** 
4539:FreeRTOS/Source/tasks.c **** 		return ulReturn;
4540:FreeRTOS/Source/tasks.c **** 	}
4541:FreeRTOS/Source/tasks.c **** 
4542:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4543:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4544:FreeRTOS/Source/tasks.c **** 
4545:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4546:FreeRTOS/Source/tasks.c **** 
4547:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4548:FreeRTOS/Source/tasks.c **** 	{
4549:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
4550:FreeRTOS/Source/tasks.c **** 
4551:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4552:FreeRTOS/Source/tasks.c **** 		{
4553:FreeRTOS/Source/tasks.c **** 			/* Only block if a notification is not already pending. */
4554:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4555:FreeRTOS/Source/tasks.c **** 			{
4556:FreeRTOS/Source/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4557:FreeRTOS/Source/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4558:FreeRTOS/Source/tasks.c **** 				clear the value to zero. */
4559:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
4560:FreeRTOS/Source/tasks.c **** 
4561:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4562:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
4563:FreeRTOS/Source/tasks.c **** 
4564:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
4565:FreeRTOS/Source/tasks.c **** 				{
4566:FreeRTOS/Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4567:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4568:FreeRTOS/Source/tasks.c **** 
4569:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4570:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
4571:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
4572:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
4573:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
4574:FreeRTOS/Source/tasks.c **** 				}
4575:FreeRTOS/Source/tasks.c **** 				else
4576:FreeRTOS/Source/tasks.c **** 				{
4577:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4578:FreeRTOS/Source/tasks.c **** 				}
4579:FreeRTOS/Source/tasks.c **** 			}
4580:FreeRTOS/Source/tasks.c **** 			else
4581:FreeRTOS/Source/tasks.c **** 			{
4582:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4583:FreeRTOS/Source/tasks.c **** 			}
4584:FreeRTOS/Source/tasks.c **** 		}
4585:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4586:FreeRTOS/Source/tasks.c **** 
4587:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4588:FreeRTOS/Source/tasks.c **** 		{
4589:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4590:FreeRTOS/Source/tasks.c **** 
4591:FreeRTOS/Source/tasks.c **** 			if( pulNotificationValue != NULL )
4592:FreeRTOS/Source/tasks.c **** 			{
4593:FreeRTOS/Source/tasks.c **** 				/* Output the current notification value, which may or may not
4594:FreeRTOS/Source/tasks.c **** 				have changed. */
4595:FreeRTOS/Source/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
4596:FreeRTOS/Source/tasks.c **** 			}
4597:FreeRTOS/Source/tasks.c **** 
4598:FreeRTOS/Source/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4599:FreeRTOS/Source/tasks.c **** 			blocked state (because a notification was already pending) or the
4600:FreeRTOS/Source/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4601:FreeRTOS/Source/tasks.c **** 			unblocked because of a timeout. */
4602:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
4603:FreeRTOS/Source/tasks.c **** 			{
4604:FreeRTOS/Source/tasks.c **** 				/* A notification was not received. */
4605:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
4606:FreeRTOS/Source/tasks.c **** 			}
4607:FreeRTOS/Source/tasks.c **** 			else
4608:FreeRTOS/Source/tasks.c **** 			{
4609:FreeRTOS/Source/tasks.c **** 				/* A notification was already pending or a notification was
4610:FreeRTOS/Source/tasks.c **** 				received while the task was waiting. */
4611:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
4612:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
4613:FreeRTOS/Source/tasks.c **** 			}
4614:FreeRTOS/Source/tasks.c **** 
4615:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4616:FreeRTOS/Source/tasks.c **** 		}
4617:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4618:FreeRTOS/Source/tasks.c **** 
4619:FreeRTOS/Source/tasks.c **** 		return xReturn;
4620:FreeRTOS/Source/tasks.c **** 	}
4621:FreeRTOS/Source/tasks.c **** 
4622:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4623:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4624:FreeRTOS/Source/tasks.c **** 
4625:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4626:FreeRTOS/Source/tasks.c **** 
4627:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4628:FreeRTOS/Source/tasks.c **** 	{
4629:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4630:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4631:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4632:FreeRTOS/Source/tasks.c **** 
4633:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4634:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
4635:FreeRTOS/Source/tasks.c **** 
4636:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4637:FreeRTOS/Source/tasks.c **** 		{
4638:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4639:FreeRTOS/Source/tasks.c **** 			{
4640:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4641:FreeRTOS/Source/tasks.c **** 			}
4642:FreeRTOS/Source/tasks.c **** 
4643:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4644:FreeRTOS/Source/tasks.c **** 
4645:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4646:FreeRTOS/Source/tasks.c **** 
4647:FreeRTOS/Source/tasks.c **** 			switch( eAction )
4648:FreeRTOS/Source/tasks.c **** 			{
4649:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4650:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4651:FreeRTOS/Source/tasks.c **** 					break;
4652:FreeRTOS/Source/tasks.c **** 
4653:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4654:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4655:FreeRTOS/Source/tasks.c **** 					break;
4656:FreeRTOS/Source/tasks.c **** 
4657:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4658:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4659:FreeRTOS/Source/tasks.c **** 					break;
4660:FreeRTOS/Source/tasks.c **** 
4661:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4662:FreeRTOS/Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4663:FreeRTOS/Source/tasks.c **** 					{
4664:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4665:FreeRTOS/Source/tasks.c **** 					}
4666:FreeRTOS/Source/tasks.c **** 					else
4667:FreeRTOS/Source/tasks.c **** 					{
4668:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4669:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4670:FreeRTOS/Source/tasks.c **** 					}
4671:FreeRTOS/Source/tasks.c **** 					break;
4672:FreeRTOS/Source/tasks.c **** 
4673:FreeRTOS/Source/tasks.c **** 				case eNoAction:
4674:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4675:FreeRTOS/Source/tasks.c **** 					updated. */
4676:FreeRTOS/Source/tasks.c **** 					break;
4677:FreeRTOS/Source/tasks.c **** 
4678:FreeRTOS/Source/tasks.c **** 				default:
4679:FreeRTOS/Source/tasks.c **** 					/* Should not get here if all enums are handled.
4680:FreeRTOS/Source/tasks.c **** 					Artificially force an assert by testing a value the
4681:FreeRTOS/Source/tasks.c **** 					compiler can't assume is const. */
4682:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4683:FreeRTOS/Source/tasks.c **** 
4684:FreeRTOS/Source/tasks.c **** 					break;
4685:FreeRTOS/Source/tasks.c **** 			}
4686:FreeRTOS/Source/tasks.c **** 
4687:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY();
4688:FreeRTOS/Source/tasks.c **** 
4689:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4690:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4691:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4692:FreeRTOS/Source/tasks.c **** 			{
4693:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4694:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
4695:FreeRTOS/Source/tasks.c **** 
4696:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4697:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4698:FreeRTOS/Source/tasks.c **** 
4699:FreeRTOS/Source/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4700:FreeRTOS/Source/tasks.c **** 				{
4701:FreeRTOS/Source/tasks.c **** 					/* If a task is blocked waiting for a notification then
4702:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4703:FreeRTOS/Source/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4704:FreeRTOS/Source/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4705:FreeRTOS/Source/tasks.c **** 					because it will automatically get reset to a new value when
4706:FreeRTOS/Source/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4707:FreeRTOS/Source/tasks.c **** 					tickless idling is used it might be more important to enter
4708:FreeRTOS/Source/tasks.c **** 					sleep mode at the earliest possible time - so reset
4709:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4710:FreeRTOS/Source/tasks.c **** 					earliest possible time. */
4711:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
4712:FreeRTOS/Source/tasks.c **** 				}
4713:FreeRTOS/Source/tasks.c **** 				#endif
4714:FreeRTOS/Source/tasks.c **** 
4715:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4716:FreeRTOS/Source/tasks.c **** 				{
4717:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4718:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4719:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
4720:FreeRTOS/Source/tasks.c **** 				}
4721:FreeRTOS/Source/tasks.c **** 				else
4722:FreeRTOS/Source/tasks.c **** 				{
4723:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4724:FreeRTOS/Source/tasks.c **** 				}
4725:FreeRTOS/Source/tasks.c **** 			}
4726:FreeRTOS/Source/tasks.c **** 			else
4727:FreeRTOS/Source/tasks.c **** 			{
4728:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4729:FreeRTOS/Source/tasks.c **** 			}
4730:FreeRTOS/Source/tasks.c **** 		}
4731:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4732:FreeRTOS/Source/tasks.c **** 
4733:FreeRTOS/Source/tasks.c **** 		return xReturn;
4734:FreeRTOS/Source/tasks.c **** 	}
4735:FreeRTOS/Source/tasks.c **** 
4736:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4737:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4738:FreeRTOS/Source/tasks.c **** 
4739:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4740:FreeRTOS/Source/tasks.c **** 
4741:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4742:FreeRTOS/Source/tasks.c **** 	{
4743:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4744:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4745:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4746:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4747:FreeRTOS/Source/tasks.c **** 
4748:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4749:FreeRTOS/Source/tasks.c **** 
4750:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4751:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4752:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4753:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4754:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4755:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4756:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4757:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4758:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4759:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4760:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4761:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4762:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4763:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4764:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4765:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4766:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4767:FreeRTOS/Source/tasks.c **** 
4768:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
4769:FreeRTOS/Source/tasks.c **** 
4770:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4771:FreeRTOS/Source/tasks.c **** 		{
4772:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
4773:FreeRTOS/Source/tasks.c **** 			{
4774:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
4775:FreeRTOS/Source/tasks.c **** 			}
4776:FreeRTOS/Source/tasks.c **** 
4777:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4778:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4779:FreeRTOS/Source/tasks.c **** 
4780:FreeRTOS/Source/tasks.c **** 			switch( eAction )
4781:FreeRTOS/Source/tasks.c **** 			{
4782:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4783:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4784:FreeRTOS/Source/tasks.c **** 					break;
4785:FreeRTOS/Source/tasks.c **** 
4786:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4787:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4788:FreeRTOS/Source/tasks.c **** 					break;
4789:FreeRTOS/Source/tasks.c **** 
4790:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4791:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4792:FreeRTOS/Source/tasks.c **** 					break;
4793:FreeRTOS/Source/tasks.c **** 
4794:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4795:FreeRTOS/Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4796:FreeRTOS/Source/tasks.c **** 					{
4797:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
4798:FreeRTOS/Source/tasks.c **** 					}
4799:FreeRTOS/Source/tasks.c **** 					else
4800:FreeRTOS/Source/tasks.c **** 					{
4801:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4802:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4803:FreeRTOS/Source/tasks.c **** 					}
4804:FreeRTOS/Source/tasks.c **** 					break;
4805:FreeRTOS/Source/tasks.c **** 
4806:FreeRTOS/Source/tasks.c **** 				case eNoAction :
4807:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4808:FreeRTOS/Source/tasks.c **** 					updated. */
4809:FreeRTOS/Source/tasks.c **** 					break;
4810:FreeRTOS/Source/tasks.c **** 
4811:FreeRTOS/Source/tasks.c **** 				default:
4812:FreeRTOS/Source/tasks.c **** 					/* Should not get here if all enums are handled.
4813:FreeRTOS/Source/tasks.c **** 					Artificially force an assert by testing a value the
4814:FreeRTOS/Source/tasks.c **** 					compiler can't assume is const. */
4815:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4816:FreeRTOS/Source/tasks.c **** 					break;
4817:FreeRTOS/Source/tasks.c **** 			}
4818:FreeRTOS/Source/tasks.c **** 
4819:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4820:FreeRTOS/Source/tasks.c **** 
4821:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4822:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4823:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4824:FreeRTOS/Source/tasks.c **** 			{
4825:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4826:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4827:FreeRTOS/Source/tasks.c **** 
4828:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4829:FreeRTOS/Source/tasks.c **** 				{
4830:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4831:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4832:FreeRTOS/Source/tasks.c **** 				}
4833:FreeRTOS/Source/tasks.c **** 				else
4834:FreeRTOS/Source/tasks.c **** 				{
4835:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4836:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4837:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4838:FreeRTOS/Source/tasks.c **** 				}
4839:FreeRTOS/Source/tasks.c **** 
4840:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4841:FreeRTOS/Source/tasks.c **** 				{
4842:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4843:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4844:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4845:FreeRTOS/Source/tasks.c **** 					{
4846:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4847:FreeRTOS/Source/tasks.c **** 					}
4848:FreeRTOS/Source/tasks.c **** 
4849:FreeRTOS/Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
4850:FreeRTOS/Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter to an ISR
4851:FreeRTOS/Source/tasks.c **** 					safe FreeRTOS function. */
4852:FreeRTOS/Source/tasks.c **** 					xYieldPending = pdTRUE;
4853:FreeRTOS/Source/tasks.c **** 				}
4854:FreeRTOS/Source/tasks.c **** 				else
4855:FreeRTOS/Source/tasks.c **** 				{
4856:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4857:FreeRTOS/Source/tasks.c **** 				}
4858:FreeRTOS/Source/tasks.c **** 			}
4859:FreeRTOS/Source/tasks.c **** 		}
4860:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4861:FreeRTOS/Source/tasks.c **** 
4862:FreeRTOS/Source/tasks.c **** 		return xReturn;
4863:FreeRTOS/Source/tasks.c **** 	}
4864:FreeRTOS/Source/tasks.c **** 
4865:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4866:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4867:FreeRTOS/Source/tasks.c **** 
4868:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4869:FreeRTOS/Source/tasks.c **** 
4870:FreeRTOS/Source/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4871:FreeRTOS/Source/tasks.c **** 	{
4872:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4873:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4874:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4875:FreeRTOS/Source/tasks.c **** 
4876:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4877:FreeRTOS/Source/tasks.c **** 
4878:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4879:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4880:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4881:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4882:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4883:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4884:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4885:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4886:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4887:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4888:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4889:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4890:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4891:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4892:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4893:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4894:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4895:FreeRTOS/Source/tasks.c **** 
4896:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
4897:FreeRTOS/Source/tasks.c **** 
4898:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
4899:FreeRTOS/Source/tasks.c **** 		{
4900:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
4901:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
4902:FreeRTOS/Source/tasks.c **** 
4903:FreeRTOS/Source/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4904:FreeRTOS/Source/tasks.c **** 			semaphore. */
4905:FreeRTOS/Source/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
4906:FreeRTOS/Source/tasks.c **** 
4907:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
4908:FreeRTOS/Source/tasks.c **** 
4909:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4910:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4911:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4912:FreeRTOS/Source/tasks.c **** 			{
4913:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4914:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4915:FreeRTOS/Source/tasks.c **** 
4916:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4917:FreeRTOS/Source/tasks.c **** 				{
4918:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
4919:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4920:FreeRTOS/Source/tasks.c **** 				}
4921:FreeRTOS/Source/tasks.c **** 				else
4922:FreeRTOS/Source/tasks.c **** 				{
4923:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4924:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4925:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4926:FreeRTOS/Source/tasks.c **** 				}
4927:FreeRTOS/Source/tasks.c **** 
4928:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4929:FreeRTOS/Source/tasks.c **** 				{
4930:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4931:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4932:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4933:FreeRTOS/Source/tasks.c **** 					{
4934:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4935:FreeRTOS/Source/tasks.c **** 					}
4936:FreeRTOS/Source/tasks.c **** 
4937:FreeRTOS/Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
4938:FreeRTOS/Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter in an ISR
4939:FreeRTOS/Source/tasks.c **** 					safe FreeRTOS function. */
4940:FreeRTOS/Source/tasks.c **** 					xYieldPending = pdTRUE;
4941:FreeRTOS/Source/tasks.c **** 				}
4942:FreeRTOS/Source/tasks.c **** 				else
4943:FreeRTOS/Source/tasks.c **** 				{
4944:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4945:FreeRTOS/Source/tasks.c **** 				}
4946:FreeRTOS/Source/tasks.c **** 			}
4947:FreeRTOS/Source/tasks.c **** 		}
4948:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4949:FreeRTOS/Source/tasks.c **** 	}
4950:FreeRTOS/Source/tasks.c **** 
4951:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4952:FreeRTOS/Source/tasks.c **** 
4953:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4954:FreeRTOS/Source/tasks.c **** 
4955:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4956:FreeRTOS/Source/tasks.c **** 
4957:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4958:FreeRTOS/Source/tasks.c **** 	{
4959:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
4960:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
4961:FreeRTOS/Source/tasks.c **** 
4962:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
4963:FreeRTOS/Source/tasks.c **** 		its notification state cleared. */
4964:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
4965:FreeRTOS/Source/tasks.c **** 
4966:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4967:FreeRTOS/Source/tasks.c **** 		{
4968:FreeRTOS/Source/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
4969:FreeRTOS/Source/tasks.c **** 			{
4970:FreeRTOS/Source/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
4971:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
4972:FreeRTOS/Source/tasks.c **** 			}
4973:FreeRTOS/Source/tasks.c **** 			else
4974:FreeRTOS/Source/tasks.c **** 			{
4975:FreeRTOS/Source/tasks.c **** 				xReturn = pdFAIL;
4976:FreeRTOS/Source/tasks.c **** 			}
4977:FreeRTOS/Source/tasks.c **** 		}
4978:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
4979:FreeRTOS/Source/tasks.c **** 
4980:FreeRTOS/Source/tasks.c **** 		return xReturn;
4981:FreeRTOS/Source/tasks.c **** 	}
4982:FreeRTOS/Source/tasks.c **** 
4983:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4984:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4985:FreeRTOS/Source/tasks.c **** 
4986:FreeRTOS/Source/tasks.c **** 
4987:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
4988:FreeRTOS/Source/tasks.c **** {
 238               	.LM5:
 239               	.LFBB2:
 240 0036 FF92      		push r15
 241 0038 0F93      		push r16
 242 003a 1F93      		push r17
 243 003c CF93      		push r28
 244 003e DF93      		push r29
 245               	/* prologue: function */
 246               	/* frame size = 0 */
 247               	/* stack size = 5 */
 248               	.L__stack_usage = 5
 249 0040 EC01      		movw r28,r24
 250 0042 F62E      		mov r15,r22
4989:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
4990:FreeRTOS/Source/tasks.c **** const TickType_t xConstTickCount = xTickCount;
 252               	.LM6:
 253 0044 0091 0000 		lds r16,xTickCount
 254 0048 1091 0000 		lds r17,xTickCount+1
4991:FreeRTOS/Source/tasks.c **** 
4992:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
4993:FreeRTOS/Source/tasks.c **** 	{
4994:FreeRTOS/Source/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4995:FreeRTOS/Source/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
4996:FreeRTOS/Source/tasks.c **** 		when the task leaves the Blocked state. */
4997:FreeRTOS/Source/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
4998:FreeRTOS/Source/tasks.c **** 	}
4999:FreeRTOS/Source/tasks.c **** 	#endif
5000:FreeRTOS/Source/tasks.c **** 
5001:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
5002:FreeRTOS/Source/tasks.c **** 	as the same list item is used for both lists. */
5003:FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 256               	.LM7:
 257 004c 8091 0000 		lds r24,pxCurrentTCB
 258 0050 9091 0000 		lds r25,pxCurrentTCB+1
 259 0054 0296      		adiw r24,2
 260 0056 0E94 0000 		call uxListRemove
5004:FreeRTOS/Source/tasks.c **** 	{
5005:FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
5006:FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
5007:FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentT
5008:FreeRTOS/Source/tasks.c **** 	}
5009:FreeRTOS/Source/tasks.c **** 	else
5010:FreeRTOS/Source/tasks.c **** 	{
5011:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
5012:FreeRTOS/Source/tasks.c **** 	}
5013:FreeRTOS/Source/tasks.c **** 
5014:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
5015:FreeRTOS/Source/tasks.c **** 	{
5016:FreeRTOS/Source/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 262               	.LM8:
 263 005a CF3F      		cpi r28,-1
 264 005c 8FEF      		ldi r24,-1
 265 005e D807      		cpc r29,r24
 266 0060 01F4      		brne .L7
 268               	.LM9:
 269 0062 FF20      		tst r15
 270 0064 01F0      		breq .L7
 271               	.LBB10:
 272               	.LBB11:
5017:FreeRTOS/Source/tasks.c **** 		{
5018:FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
5019:FreeRTOS/Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
5020:FreeRTOS/Source/tasks.c **** 			indefinitely. */
5021:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 274               	.LM10:
 275 0066 6091 0000 		lds r22,pxCurrentTCB
 276 006a 7091 0000 		lds r23,pxCurrentTCB+1
 277 006e 6E5F      		subi r22,-2
 278 0070 7F4F      		sbci r23,-1
 279 0072 80E0      		ldi r24,lo8(xSuspendedTaskList)
 280 0074 90E0      		ldi r25,hi8(xSuspendedTaskList)
 281               	/* epilogue start */
 282               	.LBE11:
 283               	.LBE10:
5022:FreeRTOS/Source/tasks.c **** 		}
5023:FreeRTOS/Source/tasks.c **** 		else
5024:FreeRTOS/Source/tasks.c **** 		{
5025:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
5026:FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
5027:FreeRTOS/Source/tasks.c **** 			kernel will manage it correctly. */
5028:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
5029:FreeRTOS/Source/tasks.c **** 
5030:FreeRTOS/Source/tasks.c **** 			/* The list item will be inserted in wake time order. */
5031:FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5032:FreeRTOS/Source/tasks.c **** 
5033:FreeRTOS/Source/tasks.c **** 			if( xTimeToWake < xConstTickCount )
5034:FreeRTOS/Source/tasks.c **** 			{
5035:FreeRTOS/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
5036:FreeRTOS/Source/tasks.c **** 				list. */
5037:FreeRTOS/Source/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5038:FreeRTOS/Source/tasks.c **** 			}
5039:FreeRTOS/Source/tasks.c **** 			else
5040:FreeRTOS/Source/tasks.c **** 			{
5041:FreeRTOS/Source/tasks.c **** 				/* The wake time has not overflowed, so the current block list
5042:FreeRTOS/Source/tasks.c **** 				is used. */
5043:FreeRTOS/Source/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5044:FreeRTOS/Source/tasks.c **** 
5045:FreeRTOS/Source/tasks.c **** 				/* If the task entering the blocked state was placed at the
5046:FreeRTOS/Source/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
5047:FreeRTOS/Source/tasks.c **** 				needs to be updated too. */
5048:FreeRTOS/Source/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
5049:FreeRTOS/Source/tasks.c **** 				{
5050:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
5051:FreeRTOS/Source/tasks.c **** 				}
5052:FreeRTOS/Source/tasks.c **** 				else
5053:FreeRTOS/Source/tasks.c **** 				{
5054:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5055:FreeRTOS/Source/tasks.c **** 				}
5056:FreeRTOS/Source/tasks.c **** 			}
5057:FreeRTOS/Source/tasks.c **** 		}
5058:FreeRTOS/Source/tasks.c **** 	}
5059:FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
5060:FreeRTOS/Source/tasks.c **** 	{
5061:FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event
5062:FreeRTOS/Source/tasks.c **** 		does not occur.  This may overflow but this doesn't matter, the kernel
5063:FreeRTOS/Source/tasks.c **** 		will manage it correctly. */
5064:FreeRTOS/Source/tasks.c **** 		xTimeToWake = xConstTickCount + xTicksToWait;
5065:FreeRTOS/Source/tasks.c **** 
5066:FreeRTOS/Source/tasks.c **** 		/* The list item will be inserted in wake time order. */
5067:FreeRTOS/Source/tasks.c **** 		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5068:FreeRTOS/Source/tasks.c **** 
5069:FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xConstTickCount )
5070:FreeRTOS/Source/tasks.c **** 		{
5071:FreeRTOS/Source/tasks.c **** 			/* Wake time has overflowed.  Place this item in the overflow list. */
5072:FreeRTOS/Source/tasks.c **** 			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5073:FreeRTOS/Source/tasks.c **** 		}
5074:FreeRTOS/Source/tasks.c **** 		else
5075:FreeRTOS/Source/tasks.c **** 		{
5076:FreeRTOS/Source/tasks.c **** 			/* The wake time has not overflowed, so the current block list is used. */
5077:FreeRTOS/Source/tasks.c **** 			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5078:FreeRTOS/Source/tasks.c **** 
5079:FreeRTOS/Source/tasks.c **** 			/* If the task entering the blocked state was placed at the head of the
5080:FreeRTOS/Source/tasks.c **** 			list of blocked tasks then xNextTaskUnblockTime needs to be updated
5081:FreeRTOS/Source/tasks.c **** 			too. */
5082:FreeRTOS/Source/tasks.c **** 			if( xTimeToWake < xNextTaskUnblockTime )
5083:FreeRTOS/Source/tasks.c **** 			{
5084:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = xTimeToWake;
5085:FreeRTOS/Source/tasks.c **** 			}
5086:FreeRTOS/Source/tasks.c **** 			else
5087:FreeRTOS/Source/tasks.c **** 			{
5088:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
5089:FreeRTOS/Source/tasks.c **** 			}
5090:FreeRTOS/Source/tasks.c **** 		}
5091:FreeRTOS/Source/tasks.c **** 
5092:FreeRTOS/Source/tasks.c **** 		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
5093:FreeRTOS/Source/tasks.c **** 		( void ) xCanBlockIndefinitely;
5094:FreeRTOS/Source/tasks.c **** 	}
5095:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
5096:FreeRTOS/Source/tasks.c **** }
 285               	.LM11:
 286 0076 DF91      		pop r29
 287 0078 CF91      		pop r28
 288 007a 1F91      		pop r17
 289 007c 0F91      		pop r16
 290 007e FF90      		pop r15
 291               	.LBB13:
 292               	.LBB12:
5021:FreeRTOS/Source/tasks.c **** 		}
 294               	.LM12:
 295 0080 0C94 0000 		jmp vListInsertEnd
 296               	.L7:
 297               	.LBE12:
 298               	.LBE13:
5028:FreeRTOS/Source/tasks.c **** 
 300               	.LM13:
 301 0084 C00F      		add r28,r16
 302 0086 D11F      		adc r29,r17
5031:FreeRTOS/Source/tasks.c **** 
 304               	.LM14:
 305 0088 E091 0000 		lds r30,pxCurrentTCB
 306 008c F091 0000 		lds r31,pxCurrentTCB+1
 307 0090 D383      		std Z+3,r29
 308 0092 C283      		std Z+2,r28
5037:FreeRTOS/Source/tasks.c **** 			}
 310               	.LM15:
 311 0094 6091 0000 		lds r22,pxCurrentTCB
 312 0098 7091 0000 		lds r23,pxCurrentTCB+1
5033:FreeRTOS/Source/tasks.c **** 			{
 314               	.LM16:
 315 009c C017      		cp r28,r16
 316 009e D107      		cpc r29,r17
 317 00a0 00F4      		brsh .L8
5037:FreeRTOS/Source/tasks.c **** 			}
 319               	.LM17:
 320 00a2 8091 0000 		lds r24,pxOverflowDelayedTaskList
 321 00a6 9091 0000 		lds r25,pxOverflowDelayedTaskList+1
 322 00aa 6E5F      		subi r22,-2
 323 00ac 7F4F      		sbci r23,-1
 324               	/* epilogue start */
 326               	.LM18:
 327 00ae DF91      		pop r29
 328 00b0 CF91      		pop r28
 329 00b2 1F91      		pop r17
 330 00b4 0F91      		pop r16
 331 00b6 FF90      		pop r15
5037:FreeRTOS/Source/tasks.c **** 			}
 333               	.LM19:
 334 00b8 0C94 0000 		jmp vListInsert
 335               	.L8:
5043:FreeRTOS/Source/tasks.c **** 
 337               	.LM20:
 338 00bc 8091 0000 		lds r24,pxDelayedTaskList
 339 00c0 9091 0000 		lds r25,pxDelayedTaskList+1
 340 00c4 6E5F      		subi r22,-2
 341 00c6 7F4F      		sbci r23,-1
 342 00c8 0E94 0000 		call vListInsert
5048:FreeRTOS/Source/tasks.c **** 				{
 344               	.LM21:
 345 00cc 8091 0000 		lds r24,xNextTaskUnblockTime
 346 00d0 9091 0000 		lds r25,xNextTaskUnblockTime+1
 347 00d4 C817      		cp r28,r24
 348 00d6 D907      		cpc r29,r25
 349 00d8 00F4      		brsh .L6
5050:FreeRTOS/Source/tasks.c **** 				}
 351               	.LM22:
 352 00da D093 0000 		sts xNextTaskUnblockTime+1,r29
 353 00de C093 0000 		sts xNextTaskUnblockTime,r28
 354               	.L6:
 355               	/* epilogue start */
 357               	.LM23:
 358 00e2 DF91      		pop r29
 359 00e4 CF91      		pop r28
 360 00e6 1F91      		pop r17
 361 00e8 0F91      		pop r16
 362 00ea FF90      		pop r15
 363 00ec 0895      		ret
 369               	.Lscope2:
 371               		.stabd	78,0,0
 375               	prvIdleTask:
 376               		.stabd	46,0,0
3288:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
 378               	.LM24:
 379               	.LFBB3:
 380               	/* prologue: function */
 381               	/* frame size = 0 */
 382               	/* stack size = 0 */
 383               	.L__stack_usage = 0
 384               	.L14:
 385               	.LBB20:
 386               	.LBB21:
3542:FreeRTOS/Source/tasks.c **** 		{
 388               	.LM25:
 389 00ee 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 390 00f2 8823      		tst r24
 391 00f4 01F0      		breq .L18
3544:FreeRTOS/Source/tasks.c **** 			{
 393               	.LM26:
 394               	/* #APP */
 395               	 ;  3544 "FreeRTOS/Source/tasks.c" 1
 396 00f6 0FB6      		in		__tmp_reg__, __SREG__
 397               	 ;  0 "" 2
 398               	 ;  3544 "FreeRTOS/Source/tasks.c" 1
 399 00f8 F894      		cli
 400               	 ;  0 "" 2
 401               	 ;  3544 "FreeRTOS/Source/tasks.c" 1
 402 00fa 0F92      		push	__tmp_reg__
 403               	 ;  0 "" 2
3546:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 405               	.LM27:
 406               	/* #NOAPP */
 407 00fc E091 0000 		lds r30,xTasksWaitingTermination+5
 408 0100 F091 0000 		lds r31,xTasksWaitingTermination+5+1
 409 0104 C681      		ldd r28,Z+6
 410 0106 D781      		ldd r29,Z+7
3547:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
 412               	.LM28:
 413 0108 CE01      		movw r24,r28
 414 010a 0296      		adiw r24,2
 415 010c 0E94 0000 		call uxListRemove
3548:FreeRTOS/Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
 417               	.LM29:
 418 0110 8091 0000 		lds r24,uxCurrentNumberOfTasks
 419 0114 8150      		subi r24,lo8(-(-1))
 420 0116 8093 0000 		sts uxCurrentNumberOfTasks,r24
3549:FreeRTOS/Source/tasks.c **** 			}
 422               	.LM30:
 423 011a 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 424 011e 8150      		subi r24,lo8(-(-1))
 425 0120 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
3551:FreeRTOS/Source/tasks.c **** 
 427               	.LM31:
 428               	/* #APP */
 429               	 ;  3551 "FreeRTOS/Source/tasks.c" 1
 430 0124 0F90      		pop		__tmp_reg__
 431               	 ;  0 "" 2
 432               	 ;  3551 "FreeRTOS/Source/tasks.c" 1
 433 0126 0FBE      		out		__SREG__, __tmp_reg__
 434               	 ;  0 "" 2
 435               	/* #NOAPP */
 436               	.LBB22:
 437               	.LBB23:
3758:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
 439               	.LM32:
 440 0128 8F89      		ldd r24,Y+23
 441 012a 988D      		ldd r25,Y+24
 442 012c 0E94 0000 		call vPortFree
3759:FreeRTOS/Source/tasks.c **** 		}
 444               	.LM33:
 445 0130 CE01      		movw r24,r28
 446 0132 0E94 0000 		call vPortFree
 447 0136 00C0      		rjmp .L14
 448               	.L18:
 449               	.LBE23:
 450               	.LBE22:
 451               	.LBE21:
 452               	.LBE20:
3327:FreeRTOS/Source/tasks.c **** 			{
 454               	.LM34:
 455 0138 8091 0000 		lds r24,pxReadyTasksLists
 456 013c 8230      		cpi r24,lo8(2)
 457 013e 00F0      		brlo .L16
3329:FreeRTOS/Source/tasks.c **** 			}
 459               	.LM35:
 460 0140 0E94 0000 		call vPortYield
 461               	.L16:
 462               	.LBB24:
3347:FreeRTOS/Source/tasks.c **** 		}
 464               	.LM36:
 465 0144 0E94 0000 		call vApplicationIdleHook
 466               	.LBE24:
3400:FreeRTOS/Source/tasks.c **** }
 468               	.LM37:
 469 0148 00C0      		rjmp .L14
 474               	.Lscope3:
 476               		.stabd	78,0,0
 483               	.global	xTaskCreate
 485               	xTaskCreate:
 486               		.stabd	46,0,0
 753:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 488               	.LM38:
 489               	.LFBB4:
 490 014a 3F92      		push r3
 491 014c 4F92      		push r4
 492 014e 5F92      		push r5
 493 0150 6F92      		push r6
 494 0152 7F92      		push r7
 495 0154 8F92      		push r8
 496 0156 9F92      		push r9
 497 0158 AF92      		push r10
 498 015a BF92      		push r11
 499 015c CF92      		push r12
 500 015e DF92      		push r13
 501 0160 EF92      		push r14
 502 0162 FF92      		push r15
 503 0164 0F93      		push r16
 504 0166 1F93      		push r17
 505 0168 CF93      		push r28
 506 016a DF93      		push r29
 507               	/* prologue: function */
 508               	/* frame size = 0 */
 509               	/* stack size = 17 */
 510               	.L__stack_usage = 17
 511 016c 4C01      		movw r8,r24
 512 016e 162F      		mov r17,r22
 513 0170 372E      		mov r3,r23
 514 0172 6A01      		movw r12,r20
 515 0174 5901      		movw r10,r18
 516               	.LBB32:
 787:FreeRTOS/Source/tasks.c **** 
 518               	.LM39:
 519 0176 CA01      		movw r24,r20
 520 0178 0E94 0000 		call pvPortMalloc
 521 017c 2C01      		movw r4,r24
 789:FreeRTOS/Source/tasks.c **** 			{
 523               	.LM40:
 524 017e 892B      		or r24,r25
 525 0180 01F4      		brne .+2
 526 0182 00C0      		rjmp .L20
 792:FreeRTOS/Source/tasks.c **** 
 528               	.LM41:
 529 0184 86E2      		ldi r24,lo8(38)
 530 0186 90E0      		ldi r25,0
 531 0188 0E94 0000 		call pvPortMalloc
 532 018c EC01      		movw r28,r24
 794:FreeRTOS/Source/tasks.c **** 				{
 534               	.LM42:
 535 018e 892B      		or r24,r25
 536 0190 01F0      		breq .L21
 797:FreeRTOS/Source/tasks.c **** 				}
 538               	.LM43:
 539 0192 588E      		std Y+24,r5
 540 0194 4F8A      		std Y+23,r4
 541               	.LBE32:
 542               	.LBB33:
 543               	.LBB34:
 880:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 545               	.LM44:
 546 0196 C601      		movw r24,r12
 547 0198 0197      		sbiw r24,1
 548 019a 3201      		movw r6,r4
 549 019c 680E      		add r6,r24
 550 019e 791E      		adc r7,r25
 551 01a0 BE01      		movw r22,r28
 552 01a2 675E      		subi r22,-25
 553 01a4 7F4F      		sbci r23,-1
 554 01a6 E12F      		mov r30,r17
 555 01a8 F32D      		mov r31,r3
 556 01aa CF01      		movw r24,r30
 557 01ac 0896      		adiw r24,8
 558 01ae 00C0      		rjmp .L22
 559               	.L21:
 560               	.LBE34:
 561               	.LBE33:
 562               	.LBB36:
 803:FreeRTOS/Source/tasks.c **** 				}
 564               	.LM45:
 565 01b0 C201      		movw r24,r4
 566 01b2 0E94 0000 		call vPortFree
 567 01b6 00C0      		rjmp .L20
 568               	.L45:
 569               	.LBE36:
 570               	.LBB37:
 571               	.LBB35:
 908:FreeRTOS/Source/tasks.c **** 	{
 573               	.LM46:
 574 01b8 E817      		cp r30,r24
 575 01ba F907      		cpc r31,r25
 576 01bc 01F0      		breq .L23
 577               	.L22:
 578 01be 9F01      		movw r18,r30
 910:FreeRTOS/Source/tasks.c **** 
 580               	.LM47:
 581 01c0 4191      		ld r20,Z+
 582 01c2 DB01      		movw r26,r22
 583 01c4 4D93      		st X+,r20
 584 01c6 BD01      		movw r22,r26
 915:FreeRTOS/Source/tasks.c **** 		{
 586               	.LM48:
 587 01c8 D901      		movw r26,r18
 588 01ca 2C91      		ld r18,X
 589 01cc 2111      		cpse r18,__zero_reg__
 590 01ce 00C0      		rjmp .L45
 591               	.L23:
 927:FreeRTOS/Source/tasks.c **** 
 593               	.LM49:
 594 01d0 18A2      		std Y+32,__zero_reg__
 595 01d2 0430      		cpi r16,lo8(4)
 596 01d4 00F0      		brlo .L24
 597 01d6 03E0      		ldi r16,lo8(3)
 598               	.L24:
 940:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 600               	.LM50:
 601 01d8 0E8B      		std Y+22,r16
 948:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 603               	.LM51:
 604 01da 6E01      		movw r12,r28
 605 01dc B2E0      		ldi r27,2
 606 01de CB0E      		add r12,r27
 607 01e0 D11C      		adc r13,__zero_reg__
 608 01e2 C601      		movw r24,r12
 609 01e4 0E94 0000 		call vListInitialiseItem
 949:FreeRTOS/Source/tasks.c **** 
 611               	.LM52:
 612 01e8 CE01      		movw r24,r28
 613 01ea 0C96      		adiw r24,12
 614 01ec 0E94 0000 		call vListInitialiseItem
 953:FreeRTOS/Source/tasks.c **** 
 616               	.LM53:
 617 01f0 D987      		std Y+9,r29
 618 01f2 C887      		std Y+8,r28
 956:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 620               	.LM54:
 621 01f4 84E0      		ldi r24,lo8(4)
 622 01f6 90E0      		ldi r25,0
 623 01f8 801B      		sub r24,r16
 624 01fa 9109      		sbc r25,__zero_reg__
 625 01fc 9D87      		std Y+13,r25
 626 01fe 8C87      		std Y+12,r24
 957:FreeRTOS/Source/tasks.c **** 
 628               	.LM55:
 629 0200 DB8B      		std Y+19,r29
 630 0202 CA8B      		std Y+18,r28
 999:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 632               	.LM56:
 633 0204 19A2      		std Y+33,__zero_reg__
 634 0206 1AA2      		std Y+34,__zero_reg__
 635 0208 1BA2      		std Y+35,__zero_reg__
 636 020a 1CA2      		std Y+36,__zero_reg__
1000:FreeRTOS/Source/tasks.c **** 	}
 638               	.LM57:
 639 020c 1DA2      		std Y+37,__zero_reg__
1027:FreeRTOS/Source/tasks.c **** 	}
 641               	.LM58:
 642 020e A501      		movw r20,r10
 643 0210 B401      		movw r22,r8
 644 0212 C301      		movw r24,r6
 645 0214 0E94 0000 		call pxPortInitialiseStack
 646 0218 9983      		std Y+1,r25
 647 021a 8883      		st Y,r24
1031:FreeRTOS/Source/tasks.c **** 	{
 649               	.LM59:
 650 021c E114      		cp r14,__zero_reg__
 651 021e F104      		cpc r15,__zero_reg__
 652 0220 01F0      		breq .L25
1035:FreeRTOS/Source/tasks.c **** 	}
 654               	.LM60:
 655 0222 F701      		movw r30,r14
 656 0224 D183      		std Z+1,r29
 657 0226 C083      		st Z,r28
 658               	.L25:
 659               	.LBE35:
 660               	.LBE37:
 661               	.LBB38:
 662               	.LBB39:
1048:FreeRTOS/Source/tasks.c **** 	{
 664               	.LM61:
 665               	/* #APP */
 666               	 ;  1048 "FreeRTOS/Source/tasks.c" 1
 667 0228 0FB6      		in		__tmp_reg__, __SREG__
 668               	 ;  0 "" 2
 669               	 ;  1048 "FreeRTOS/Source/tasks.c" 1
 670 022a F894      		cli
 671               	 ;  0 "" 2
 672               	 ;  1048 "FreeRTOS/Source/tasks.c" 1
 673 022c 0F92      		push	__tmp_reg__
 674               	 ;  0 "" 2
1050:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB == NULL )
 676               	.LM62:
 677               	/* #NOAPP */
 678 022e 8091 0000 		lds r24,uxCurrentNumberOfTasks
 679 0232 8F5F      		subi r24,lo8(-(1))
 680 0234 8093 0000 		sts uxCurrentNumberOfTasks,r24
1051:FreeRTOS/Source/tasks.c **** 		{
 682               	.LM63:
 683 0238 8091 0000 		lds r24,pxCurrentTCB
 684 023c 9091 0000 		lds r25,pxCurrentTCB+1
 685 0240 892B      		or r24,r25
 686 0242 01F4      		brne .L26
1055:FreeRTOS/Source/tasks.c **** 
 688               	.LM64:
 689 0244 D093 0000 		sts pxCurrentTCB+1,r29
 690 0248 C093 0000 		sts pxCurrentTCB,r28
1057:FreeRTOS/Source/tasks.c **** 			{
 692               	.LM65:
 693 024c 8091 0000 		lds r24,uxCurrentNumberOfTasks
 694 0250 8130      		cpi r24,lo8(1)
 695 0252 01F0      		breq .+2
 696 0254 00C0      		rjmp .L28
 697               	.LBB40:
 698               	.LBB41:
3505:FreeRTOS/Source/tasks.c **** 	}
 700               	.LM66:
 701 0256 80E0      		ldi r24,lo8(pxReadyTasksLists)
 702 0258 90E0      		ldi r25,hi8(pxReadyTasksLists)
 703 025a 0E94 0000 		call vListInitialise
 704 025e 80E0      		ldi r24,lo8(pxReadyTasksLists+9)
 705 0260 90E0      		ldi r25,hi8(pxReadyTasksLists+9)
 706 0262 0E94 0000 		call vListInitialise
 707 0266 80E0      		ldi r24,lo8(pxReadyTasksLists+18)
 708 0268 90E0      		ldi r25,hi8(pxReadyTasksLists+18)
 709 026a 0E94 0000 		call vListInitialise
 710 026e 80E0      		ldi r24,lo8(pxReadyTasksLists+27)
 711 0270 90E0      		ldi r25,hi8(pxReadyTasksLists+27)
 712 0272 0E94 0000 		call vListInitialise
3508:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 714               	.LM67:
 715 0276 80E0      		ldi r24,lo8(xDelayedTaskList1)
 716 0278 90E0      		ldi r25,hi8(xDelayedTaskList1)
 717 027a 0E94 0000 		call vListInitialise
3509:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 719               	.LM68:
 720 027e 80E0      		ldi r24,lo8(xDelayedTaskList2)
 721 0280 90E0      		ldi r25,hi8(xDelayedTaskList2)
 722 0282 0E94 0000 		call vListInitialise
3510:FreeRTOS/Source/tasks.c **** 
 724               	.LM69:
 725 0286 80E0      		ldi r24,lo8(xPendingReadyList)
 726 0288 90E0      		ldi r25,hi8(xPendingReadyList)
 727 028a 0E94 0000 		call vListInitialise
3514:FreeRTOS/Source/tasks.c **** 	}
 729               	.LM70:
 730 028e 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 731 0290 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 732 0292 0E94 0000 		call vListInitialise
3520:FreeRTOS/Source/tasks.c **** 	}
 734               	.LM71:
 735 0296 80E0      		ldi r24,lo8(xSuspendedTaskList)
 736 0298 90E0      		ldi r25,hi8(xSuspendedTaskList)
 737 029a 0E94 0000 		call vListInitialise
3526:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 739               	.LM72:
 740 029e 80E0      		ldi r24,lo8(xDelayedTaskList1)
 741 02a0 90E0      		ldi r25,hi8(xDelayedTaskList1)
 742 02a2 9093 0000 		sts pxDelayedTaskList+1,r25
 743 02a6 8093 0000 		sts pxDelayedTaskList,r24
3527:FreeRTOS/Source/tasks.c **** }
 745               	.LM73:
 746 02aa 80E0      		ldi r24,lo8(xDelayedTaskList2)
 747 02ac 90E0      		ldi r25,hi8(xDelayedTaskList2)
 748 02ae 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 749 02b2 8093 0000 		sts pxOverflowDelayedTaskList,r24
 750 02b6 00C0      		rjmp .L28
 751               	.L26:
 752               	.LBE41:
 753               	.LBE40:
1074:FreeRTOS/Source/tasks.c **** 			{
 755               	.LM74:
 756 02b8 8091 0000 		lds r24,xSchedulerRunning
 757 02bc 8111      		cpse r24,__zero_reg__
 758 02be 00C0      		rjmp .L28
1076:FreeRTOS/Source/tasks.c **** 				{
 760               	.LM75:
 761 02c0 E091 0000 		lds r30,pxCurrentTCB
 762 02c4 F091 0000 		lds r31,pxCurrentTCB+1
 763 02c8 9689      		ldd r25,Z+22
 764 02ca 8E89      		ldd r24,Y+22
 765 02cc 8917      		cp r24,r25
 766 02ce 00F0      		brlo .L28
1078:FreeRTOS/Source/tasks.c **** 				}
 768               	.LM76:
 769 02d0 D093 0000 		sts pxCurrentTCB+1,r29
 770 02d4 C093 0000 		sts pxCurrentTCB,r28
 771               	.L28:
1091:FreeRTOS/Source/tasks.c **** 
 773               	.LM77:
 774 02d8 8091 0000 		lds r24,uxTaskNumber
 775 02dc 8F5F      		subi r24,lo8(-(1))
 776 02de 8093 0000 		sts uxTaskNumber,r24
1101:FreeRTOS/Source/tasks.c **** 
 778               	.LM78:
 779 02e2 8E89      		ldd r24,Y+22
 780 02e4 9091 0000 		lds r25,uxTopReadyPriority
 781 02e8 9817      		cp r25,r24
 782 02ea 00F4      		brsh .L30
 783 02ec 8093 0000 		sts uxTopReadyPriority,r24
 784               	.L30:
 785 02f0 F9E0      		ldi r31,lo8(9)
 786 02f2 8F9F      		mul r24,r31
 787 02f4 C001      		movw r24,r0
 788 02f6 1124      		clr __zero_reg__
 789 02f8 B601      		movw r22,r12
 790 02fa 8050      		subi r24,lo8(-(pxReadyTasksLists))
 791 02fc 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 792 02fe 0E94 0000 		call vListInsertEnd
1105:FreeRTOS/Source/tasks.c **** 
 794               	.LM79:
 795               	/* #APP */
 796               	 ;  1105 "FreeRTOS/Source/tasks.c" 1
 797 0302 0F90      		pop		__tmp_reg__
 798               	 ;  0 "" 2
 799               	 ;  1105 "FreeRTOS/Source/tasks.c" 1
 800 0304 0FBE      		out		__SREG__, __tmp_reg__
 801               	 ;  0 "" 2
1107:FreeRTOS/Source/tasks.c **** 	{
 803               	.LM80:
 804               	/* #NOAPP */
 805 0306 8091 0000 		lds r24,xSchedulerRunning
 806 030a 8823      		tst r24
 807 030c 01F0      		breq .L33
1111:FreeRTOS/Source/tasks.c **** 		{
 809               	.LM81:
 810 030e E091 0000 		lds r30,pxCurrentTCB
 811 0312 F091 0000 		lds r31,pxCurrentTCB+1
 812 0316 9689      		ldd r25,Z+22
 813 0318 8E89      		ldd r24,Y+22
 814 031a 9817      		cp r25,r24
 815 031c 00F4      		brsh .L33
1113:FreeRTOS/Source/tasks.c **** 		}
 817               	.LM82:
 818 031e 0E94 0000 		call vPortYield
 819               	.L33:
 820               	.LBE39:
 821               	.LBE38:
 825:FreeRTOS/Source/tasks.c **** 		}
 823               	.LM83:
 824 0322 81E0      		ldi r24,lo8(1)
 825 0324 00C0      		rjmp .L44
 826               	.L20:
 829:FreeRTOS/Source/tasks.c **** 		}
 828               	.LM84:
 829 0326 8FEF      		ldi r24,lo8(-1)
 830               	.L44:
 831               	/* epilogue start */
 833:FreeRTOS/Source/tasks.c **** 
 833               	.LM85:
 834 0328 DF91      		pop r29
 835 032a CF91      		pop r28
 836 032c 1F91      		pop r17
 837 032e 0F91      		pop r16
 838 0330 FF90      		pop r15
 839 0332 EF90      		pop r14
 840 0334 DF90      		pop r13
 841 0336 CF90      		pop r12
 842 0338 BF90      		pop r11
 843 033a AF90      		pop r10
 844 033c 9F90      		pop r9
 845 033e 8F90      		pop r8
 846 0340 7F90      		pop r7
 847 0342 6F90      		pop r6
 848 0344 5F90      		pop r5
 849 0346 4F90      		pop r4
 850 0348 3F90      		pop r3
 851 034a 0895      		ret
 869               	.Lscope4:
 871               		.stabd	78,0,0
 874               	.global	vTaskDelete
 876               	vTaskDelete:
 877               		.stabd	46,0,0
1130:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 879               	.LM86:
 880               	.LFBB5:
 881 034c 0F93      		push r16
 882 034e 1F93      		push r17
 883 0350 CF93      		push r28
 884 0352 DF93      		push r29
 885               	/* prologue: function */
 886               	/* frame size = 0 */
 887               	/* stack size = 4 */
 888               	.L__stack_usage = 4
 889 0354 EC01      		movw r28,r24
1133:FreeRTOS/Source/tasks.c **** 		{
 891               	.LM87:
 892               	/* #APP */
 893               	 ;  1133 "FreeRTOS/Source/tasks.c" 1
 894 0356 0FB6      		in		__tmp_reg__, __SREG__
 895               	 ;  0 "" 2
 896               	 ;  1133 "FreeRTOS/Source/tasks.c" 1
 897 0358 F894      		cli
 898               	 ;  0 "" 2
 899               	 ;  1133 "FreeRTOS/Source/tasks.c" 1
 900 035a 0F92      		push	__tmp_reg__
 901               	 ;  0 "" 2
1137:FreeRTOS/Source/tasks.c **** 
 903               	.LM88:
 904               	/* #NOAPP */
 905 035c 892B      		or r24,r25
 906 035e 01F4      		brne .L47
1137:FreeRTOS/Source/tasks.c **** 
 908               	.LM89:
 909 0360 C091 0000 		lds r28,pxCurrentTCB
 910 0364 D091 0000 		lds r29,pxCurrentTCB+1
 911               	.L47:
1140:FreeRTOS/Source/tasks.c **** 			{
 913               	.LM90:
 914 0368 8E01      		movw r16,r28
 915 036a 0E5F      		subi r16,-2
 916 036c 1F4F      		sbci r17,-1
 917 036e C801      		movw r24,r16
 918 0370 0E94 0000 		call uxListRemove
1150:FreeRTOS/Source/tasks.c **** 			{
 920               	.LM91:
 921 0374 8C89      		ldd r24,Y+20
 922 0376 9D89      		ldd r25,Y+21
 923 0378 892B      		or r24,r25
 924 037a 01F0      		breq .L48
1152:FreeRTOS/Source/tasks.c **** 			}
 926               	.LM92:
 927 037c CE01      		movw r24,r28
 928 037e 0C96      		adiw r24,12
 929 0380 0E94 0000 		call uxListRemove
 930               	.L48:
1163:FreeRTOS/Source/tasks.c **** 
 932               	.LM93:
 933 0384 8091 0000 		lds r24,uxTaskNumber
 934 0388 8F5F      		subi r24,lo8(-(1))
 935 038a 8093 0000 		sts uxTaskNumber,r24
1165:FreeRTOS/Source/tasks.c **** 			{
 937               	.LM94:
 938 038e 8091 0000 		lds r24,pxCurrentTCB
 939 0392 9091 0000 		lds r25,pxCurrentTCB+1
 940 0396 C817      		cp r28,r24
 941 0398 D907      		cpc r29,r25
 942 039a 01F4      		brne .L49
1172:FreeRTOS/Source/tasks.c **** 
 944               	.LM95:
 945 039c B801      		movw r22,r16
 946 039e 80E0      		ldi r24,lo8(xTasksWaitingTermination)
 947 03a0 90E0      		ldi r25,hi8(xTasksWaitingTermination)
 948 03a2 0E94 0000 		call vListInsertEnd
1177:FreeRTOS/Source/tasks.c **** 
 950               	.LM96:
 951 03a6 8091 0000 		lds r24,uxDeletedTasksWaitingCleanUp
 952 03aa 8F5F      		subi r24,lo8(-(1))
 953 03ac 8093 0000 		sts uxDeletedTasksWaitingCleanUp,r24
 954 03b0 00C0      		rjmp .L50
 955               	.L49:
1188:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 957               	.LM97:
 958 03b2 8091 0000 		lds r24,uxCurrentNumberOfTasks
 959 03b6 8150      		subi r24,lo8(-(-1))
 960 03b8 8093 0000 		sts uxCurrentNumberOfTasks,r24
 961               	.LBB44:
 962               	.LBB45:
3758:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
 964               	.LM98:
 965 03bc 8F89      		ldd r24,Y+23
 966 03be 988D      		ldd r25,Y+24
 967 03c0 0E94 0000 		call vPortFree
3759:FreeRTOS/Source/tasks.c **** 		}
 969               	.LM99:
 970 03c4 CE01      		movw r24,r28
 971 03c6 0E94 0000 		call vPortFree
 972               	.LBE45:
 973               	.LBE44:
1193:FreeRTOS/Source/tasks.c **** 			}
 975               	.LM100:
 976 03ca 0E94 0000 		call prvResetNextTaskUnblockTime
 977               	.L50:
1198:FreeRTOS/Source/tasks.c **** 
 979               	.LM101:
 980               	/* #APP */
 981               	 ;  1198 "FreeRTOS/Source/tasks.c" 1
 982 03ce 0F90      		pop		__tmp_reg__
 983               	 ;  0 "" 2
 984               	 ;  1198 "FreeRTOS/Source/tasks.c" 1
 985 03d0 0FBE      		out		__SREG__, __tmp_reg__
 986               	 ;  0 "" 2
1202:FreeRTOS/Source/tasks.c **** 		{
 988               	.LM102:
 989               	/* #NOAPP */
 990 03d2 8091 0000 		lds r24,xSchedulerRunning
 991 03d6 8823      		tst r24
 992 03d8 01F0      		breq .L46
1204:FreeRTOS/Source/tasks.c **** 			{
 994               	.LM103:
 995 03da 8091 0000 		lds r24,pxCurrentTCB
 996 03de 9091 0000 		lds r25,pxCurrentTCB+1
 997 03e2 C817      		cp r28,r24
 998 03e4 D907      		cpc r29,r25
 999 03e6 01F4      		brne .L46
1207:FreeRTOS/Source/tasks.c **** 			}
 1001               	.LM104:
 1002 03e8 0E94 0000 		call vPortYield
 1003               	.L46:
 1004               	/* epilogue start */
1214:FreeRTOS/Source/tasks.c **** 
 1006               	.LM105:
 1007 03ec DF91      		pop r29
 1008 03ee CF91      		pop r28
 1009 03f0 1F91      		pop r17
 1010 03f2 0F91      		pop r16
 1011 03f4 0895      		ret
 1013               	.Lscope5:
 1015               		.stabd	78,0,0
 1018               	.global	vTaskResume
 1020               	vTaskResume:
 1021               		.stabd	46,0,0
1816:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1023               	.LM106:
 1024               	.LFBB6:
 1025 03f6 0F93      		push r16
 1026 03f8 1F93      		push r17
 1027 03fa CF93      		push r28
 1028 03fc DF93      		push r29
 1029               	/* prologue: function */
 1030               	/* frame size = 0 */
 1031               	/* stack size = 4 */
 1032               	.L__stack_usage = 4
1824:FreeRTOS/Source/tasks.c **** 		{
 1034               	.LM107:
 1035 03fe 2091 0000 		lds r18,pxCurrentTCB
 1036 0402 3091 0000 		lds r19,pxCurrentTCB+1
 1037 0406 8217      		cp r24,r18
 1038 0408 9307      		cpc r25,r19
 1039 040a 01F0      		breq .L58
1824:FreeRTOS/Source/tasks.c **** 		{
 1041               	.LM108:
 1042 040c 0097      		sbiw r24,0
 1043 040e 01F0      		breq .L58
1826:FreeRTOS/Source/tasks.c **** 			{
 1045               	.LM109:
 1046               	/* #APP */
 1047               	 ;  1826 "FreeRTOS/Source/tasks.c" 1
 1048 0410 0FB6      		in		__tmp_reg__, __SREG__
 1049               	 ;  0 "" 2
 1050               	 ;  1826 "FreeRTOS/Source/tasks.c" 1
 1051 0412 F894      		cli
 1052               	 ;  0 "" 2
 1053               	 ;  1826 "FreeRTOS/Source/tasks.c" 1
 1054 0414 0F92      		push	__tmp_reg__
 1055               	 ;  0 "" 2
 1056               	/* #NOAPP */
 1057               	.LBB50:
 1058               	.LBB51:
1781:FreeRTOS/Source/tasks.c **** 		{
 1060               	.LM110:
 1061 0416 FC01      		movw r30,r24
 1062 0418 2285      		ldd r18,Z+10
 1063 041a 3385      		ldd r19,Z+11
 1064 041c 2050      		subi r18,lo8(xSuspendedTaskList)
 1065 041e 3040      		sbci r19,hi8(xSuspendedTaskList)
 1066 0420 01F4      		brne .L61
 1067               	.LBB52:
 1068               	.LBB53:
1784:FreeRTOS/Source/tasks.c **** 			{
 1070               	.LM111:
 1071 0422 FC01      		movw r30,r24
 1072 0424 2489      		ldd r18,Z+20
 1073 0426 3589      		ldd r19,Z+21
 1074 0428 F0E0      		ldi r31,hi8(xPendingReadyList)
 1075 042a 2030      		cpi r18,lo8(xPendingReadyList)
 1076 042c 3F07      		cpc r19,r31
 1077 042e 01F0      		breq .L61
1788:FreeRTOS/Source/tasks.c **** 				{
 1079               	.LM112:
 1080 0430 232B      		or r18,r19
 1081 0432 01F4      		brne .L61
 1082 0434 EC01      		movw r28,r24
 1083               	.LBE53:
 1084               	.LBE52:
 1085               	.LBE51:
 1086               	.LBE50:
1834:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1088               	.LM113:
 1089 0436 8C01      		movw r16,r24
 1090 0438 0E5F      		subi r16,-2
 1091 043a 1F4F      		sbci r17,-1
 1092 043c C801      		movw r24,r16
 1093 043e 0E94 0000 		call uxListRemove
1835:FreeRTOS/Source/tasks.c **** 
 1095               	.LM114:
 1096 0442 8E89      		ldd r24,Y+22
 1097 0444 9091 0000 		lds r25,uxTopReadyPriority
 1098 0448 9817      		cp r25,r24
 1099 044a 00F4      		brsh .L65
1835:FreeRTOS/Source/tasks.c **** 
 1101               	.LM115:
 1102 044c 8093 0000 		sts uxTopReadyPriority,r24
 1103               	.L65:
1835:FreeRTOS/Source/tasks.c **** 
 1105               	.LM116:
 1106 0450 29E0      		ldi r18,lo8(9)
 1107 0452 829F      		mul r24,r18
 1108 0454 C001      		movw r24,r0
 1109 0456 1124      		clr __zero_reg__
 1110 0458 B801      		movw r22,r16
 1111 045a 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1112 045c 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1113 045e 0E94 0000 		call vListInsertEnd
1838:FreeRTOS/Source/tasks.c **** 					{
 1115               	.LM117:
 1116 0462 E091 0000 		lds r30,pxCurrentTCB
 1117 0466 F091 0000 		lds r31,pxCurrentTCB+1
 1118 046a 9E89      		ldd r25,Y+22
 1119 046c 8689      		ldd r24,Z+22
 1120 046e 9817      		cp r25,r24
 1121 0470 00F0      		brlo .L61
1843:FreeRTOS/Source/tasks.c **** 					}
 1123               	.LM118:
 1124 0472 0E94 0000 		call vPortYield
 1125               	.L61:
1855:FreeRTOS/Source/tasks.c **** 		}
 1127               	.LM119:
 1128               	/* #APP */
 1129               	 ;  1855 "FreeRTOS/Source/tasks.c" 1
 1130 0476 0F90      		pop		__tmp_reg__
 1131               	 ;  0 "" 2
 1132               	 ;  1855 "FreeRTOS/Source/tasks.c" 1
 1133 0478 0FBE      		out		__SREG__, __tmp_reg__
 1134               	 ;  0 "" 2
 1135               	/* #NOAPP */
 1136               	.L58:
 1137               	/* epilogue start */
1861:FreeRTOS/Source/tasks.c **** 
 1139               	.LM120:
 1140 047a DF91      		pop r29
 1141 047c CF91      		pop r28
 1142 047e 1F91      		pop r17
 1143 0480 0F91      		pop r16
 1144 0482 0895      		ret
 1146               	.Lscope6:
 1148               		.stabd	78,0,0
 1151               	.global	xTaskResumeFromISR
 1153               	xTaskResumeFromISR:
 1154               		.stabd	46,0,0
1870:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1156               	.LM121:
 1157               	.LFBB7:
 1158 0484 EF92      		push r14
 1159 0486 FF92      		push r15
 1160 0488 1F93      		push r17
 1161 048a CF93      		push r28
 1162 048c DF93      		push r29
 1163               	/* prologue: function */
 1164               	/* frame size = 0 */
 1165               	/* stack size = 5 */
 1166               	.L__stack_usage = 5
 1167 048e EC01      		movw r28,r24
 1168               	.LBB58:
 1169               	.LBB59:
1781:FreeRTOS/Source/tasks.c **** 		{
 1171               	.LM122:
 1172 0490 8A85      		ldd r24,Y+10
 1173 0492 9B85      		ldd r25,Y+11
 1174 0494 8050      		subi r24,lo8(xSuspendedTaskList)
 1175 0496 9040      		sbci r25,hi8(xSuspendedTaskList)
 1176 0498 01F4      		brne .L80
 1177               	.LBB60:
 1178               	.LBB61:
1784:FreeRTOS/Source/tasks.c **** 			{
 1180               	.LM123:
 1181 049a 8C89      		ldd r24,Y+20
 1182 049c 9D89      		ldd r25,Y+21
 1183 049e 20E0      		ldi r18,hi8(xPendingReadyList)
 1184 04a0 8030      		cpi r24,lo8(xPendingReadyList)
 1185 04a2 9207      		cpc r25,r18
 1186 04a4 01F0      		breq .L80
1788:FreeRTOS/Source/tasks.c **** 				{
 1188               	.LM124:
 1189 04a6 892B      		or r24,r25
 1190 04a8 01F4      		brne .L80
 1191               	.LBE61:
 1192               	.LBE60:
 1193               	.LBE59:
 1194               	.LBE58:
1902:FreeRTOS/Source/tasks.c **** 				{
 1196               	.LM125:
 1197 04aa 8091 0000 		lds r24,uxSchedulerSuspended
 1198 04ae 8823      		tst r24
 1199 04b0 01F0      		breq .L77
1923:FreeRTOS/Source/tasks.c **** 				}
 1201               	.LM126:
 1202 04b2 BE01      		movw r22,r28
 1203 04b4 645F      		subi r22,-12
 1204 04b6 7F4F      		sbci r23,-1
 1205 04b8 80E0      		ldi r24,lo8(xPendingReadyList)
 1206 04ba 90E0      		ldi r25,hi8(xPendingReadyList)
 1207 04bc 0E94 0000 		call vListInsertEnd
 1208               	.L80:
1871:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1210               	.LM127:
 1211 04c0 10E0      		ldi r17,0
1933:FreeRTOS/Source/tasks.c **** 	}
 1213               	.LM128:
 1214 04c2 00C0      		rjmp .L81
 1215               	.L77:
1906:FreeRTOS/Source/tasks.c **** 					{
 1217               	.LM129:
 1218 04c4 E091 0000 		lds r30,pxCurrentTCB
 1219 04c8 F091 0000 		lds r31,pxCurrentTCB+1
1871:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1221               	.LM130:
 1222 04cc 11E0      		ldi r17,lo8(1)
 1223 04ce 9E89      		ldd r25,Y+22
 1224 04d0 8689      		ldd r24,Z+22
 1225 04d2 9817      		cp r25,r24
 1226 04d4 00F4      		brsh .L75
 1227 04d6 10E0      		ldi r17,0
 1228               	.L75:
1915:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1230               	.LM131:
 1231 04d8 7E01      		movw r14,r28
 1232 04da 82E0      		ldi r24,2
 1233 04dc E80E      		add r14,r24
 1234 04de F11C      		adc r15,__zero_reg__
 1235 04e0 C701      		movw r24,r14
 1236 04e2 0E94 0000 		call uxListRemove
1916:FreeRTOS/Source/tasks.c **** 				}
 1238               	.LM132:
 1239 04e6 8E89      		ldd r24,Y+22
 1240 04e8 9091 0000 		lds r25,uxTopReadyPriority
 1241 04ec 9817      		cp r25,r24
 1242 04ee 00F4      		brsh .L76
1916:FreeRTOS/Source/tasks.c **** 				}
 1244               	.LM133:
 1245 04f0 8093 0000 		sts uxTopReadyPriority,r24
 1246               	.L76:
1916:FreeRTOS/Source/tasks.c **** 				}
 1248               	.LM134:
 1249 04f4 29E0      		ldi r18,lo8(9)
 1250 04f6 829F      		mul r24,r18
 1251 04f8 C001      		movw r24,r0
 1252 04fa 1124      		clr __zero_reg__
 1253 04fc B701      		movw r22,r14
 1254 04fe 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1255 0500 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1256 0502 0E94 0000 		call vListInsertEnd
 1257               	.L81:
1934:FreeRTOS/Source/tasks.c **** 
 1259               	.LM135:
 1260 0506 812F      		mov r24,r17
 1261               	/* epilogue start */
 1262 0508 DF91      		pop r29
 1263 050a CF91      		pop r28
 1264 050c 1F91      		pop r17
 1265 050e FF90      		pop r15
 1266 0510 EF90      		pop r14
 1267 0512 0895      		ret
 1272               	.Lscope7:
 1274               		.stabd	78,0,0
 1275               		.section	.rodata.str1.1,"aMS",@progbits,1
 1276               	.LC0:
 1277 0000 4944 4C45 		.string	"IDLE"
 1277      00
 1278               		.text
 1280               	.global	vTaskStartScheduler
 1282               	vTaskStartScheduler:
 1283               		.stabd	46,0,0
1940:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 1285               	.LM136:
 1286               	.LFBB8:
 1287 0514 EF92      		push r14
 1288 0516 FF92      		push r15
 1289 0518 0F93      		push r16
 1290               	/* prologue: function */
 1291               	/* frame size = 0 */
 1292               	/* stack size = 3 */
 1293               	.L__stack_usage = 3
1973:FreeRTOS/Source/tasks.c **** 								configIDLE_TASK_NAME,
 1295               	.LM137:
 1296 051a 80E0      		ldi r24,lo8(xIdleTaskHandle)
 1297 051c E82E      		mov r14,r24
 1298 051e 80E0      		ldi r24,hi8(xIdleTaskHandle)
 1299 0520 F82E      		mov r15,r24
 1300 0522 00E0      		ldi r16,0
 1301 0524 20E0      		ldi r18,0
 1302 0526 30E0      		ldi r19,0
 1303 0528 45E5      		ldi r20,lo8(85)
 1304 052a 50E0      		ldi r21,0
 1305 052c 60E0      		ldi r22,lo8(.LC0)
 1306 052e 70E0      		ldi r23,hi8(.LC0)
 1307 0530 80E0      		ldi r24,lo8(gs(prvIdleTask))
 1308 0532 90E0      		ldi r25,hi8(gs(prvIdleTask))
 1309 0534 0E94 0000 		call xTaskCreate
1995:FreeRTOS/Source/tasks.c **** 	{
 1311               	.LM138:
 1312 0538 8130      		cpi r24,lo8(1)
 1313 053a 01F4      		brne .L83
2011:FreeRTOS/Source/tasks.c **** 
 1315               	.LM139:
 1316               	/* #APP */
 1317               	 ;  2011 "FreeRTOS/Source/tasks.c" 1
 1318 053c F894      		cli
 1319               	 ;  0 "" 2
2021:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1321               	.LM140:
 1322               	/* #NOAPP */
 1323 053e 2FEF      		ldi r18,lo8(-1)
 1324 0540 3FEF      		ldi r19,lo8(-1)
 1325 0542 3093 0000 		sts xNextTaskUnblockTime+1,r19
 1326 0546 2093 0000 		sts xNextTaskUnblockTime,r18
2022:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 1328               	.LM141:
 1329 054a 8093 0000 		sts xSchedulerRunning,r24
2023:FreeRTOS/Source/tasks.c **** 
 1331               	.LM142:
 1332 054e 1092 0000 		sts xTickCount+1,__zero_reg__
 1333 0552 1092 0000 		sts xTickCount,__zero_reg__
 1334               	/* epilogue start */
2058:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1336               	.LM143:
 1337 0556 0F91      		pop r16
 1338 0558 FF90      		pop r15
 1339 055a EF90      		pop r14
2037:FreeRTOS/Source/tasks.c **** 		{
 1341               	.LM144:
 1342 055c 0C94 0000 		jmp xPortStartScheduler
 1343               	.L83:
 1344               	/* epilogue start */
2058:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1346               	.LM145:
 1347 0560 0F91      		pop r16
 1348 0562 FF90      		pop r15
 1349 0564 EF90      		pop r14
 1350 0566 0895      		ret
 1355               	.Lscope8:
 1357               		.stabd	78,0,0
 1359               	.global	vTaskEndScheduler
 1361               	vTaskEndScheduler:
 1362               		.stabd	46,0,0
2062:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
 1364               	.LM146:
 1365               	.LFBB9:
 1366               	/* prologue: function */
 1367               	/* frame size = 0 */
 1368               	/* stack size = 0 */
 1369               	.L__stack_usage = 0
2066:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1371               	.LM147:
 1372               	/* #APP */
 1373               	 ;  2066 "FreeRTOS/Source/tasks.c" 1
 1374 0568 F894      		cli
 1375               	 ;  0 "" 2
2067:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1377               	.LM148:
 1378               	/* #NOAPP */
 1379 056a 1092 0000 		sts xSchedulerRunning,__zero_reg__
2068:FreeRTOS/Source/tasks.c **** }
 1381               	.LM149:
 1382 056e 0C94 0000 		jmp vPortEndScheduler
 1384               	.Lscope9:
 1386               		.stabd	78,0,0
 1388               	.global	vTaskSuspendAll
 1390               	vTaskSuspendAll:
 1391               		.stabd	46,0,0
2073:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
 1393               	.LM150:
 1394               	.LFBB10:
 1395               	/* prologue: function */
 1396               	/* frame size = 0 */
 1397               	/* stack size = 0 */
 1398               	.L__stack_usage = 0
2078:FreeRTOS/Source/tasks.c **** }
 1400               	.LM151:
 1401 0572 8091 0000 		lds r24,uxSchedulerSuspended
 1402 0576 8F5F      		subi r24,lo8(-(1))
 1403 0578 8093 0000 		sts uxSchedulerSuspended,r24
 1404 057c 0895      		ret
 1406               	.Lscope10:
 1408               		.stabd	78,0,0
 1410               	.global	xTaskGetTickCount
 1412               	xTaskGetTickCount:
 1413               		.stabd	46,0,0
2256:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
 1415               	.LM152:
 1416               	.LFBB11:
 1417               	/* prologue: function */
 1418               	/* frame size = 0 */
 1419               	/* stack size = 0 */
 1420               	.L__stack_usage = 0
2260:FreeRTOS/Source/tasks.c **** 	{
 1422               	.LM153:
 1423               	/* #APP */
 1424               	 ;  2260 "FreeRTOS/Source/tasks.c" 1
 1425 057e 0FB6      		in		__tmp_reg__, __SREG__
 1426               	 ;  0 "" 2
 1427               	 ;  2260 "FreeRTOS/Source/tasks.c" 1
 1428 0580 F894      		cli
 1429               	 ;  0 "" 2
 1430               	 ;  2260 "FreeRTOS/Source/tasks.c" 1
 1431 0582 0F92      		push	__tmp_reg__
 1432               	 ;  0 "" 2
2262:FreeRTOS/Source/tasks.c **** 	}
 1434               	.LM154:
 1435               	/* #NOAPP */
 1436 0584 8091 0000 		lds r24,xTickCount
 1437 0588 9091 0000 		lds r25,xTickCount+1
2264:FreeRTOS/Source/tasks.c **** 
 1439               	.LM155:
 1440               	/* #APP */
 1441               	 ;  2264 "FreeRTOS/Source/tasks.c" 1
 1442 058c 0F90      		pop		__tmp_reg__
 1443               	 ;  0 "" 2
 1444               	 ;  2264 "FreeRTOS/Source/tasks.c" 1
 1445 058e 0FBE      		out		__SREG__, __tmp_reg__
 1446               	 ;  0 "" 2
2267:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1448               	.LM156:
 1449               	/* #NOAPP */
 1450 0590 0895      		ret
 1455               	.Lscope11:
 1457               		.stabd	78,0,0
 1459               	.global	xTaskGetTickCountFromISR
 1461               	xTaskGetTickCountFromISR:
 1462               		.stabd	46,0,0
2271:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
 1464               	.LM157:
 1465               	.LFBB12:
 1466               	/* prologue: function */
 1467               	/* frame size = 0 */
 1468               	/* stack size = 0 */
 1469               	.L__stack_usage = 0
2293:FreeRTOS/Source/tasks.c **** 	}
 1471               	.LM158:
 1472 0592 8091 0000 		lds r24,xTickCount
 1473 0596 9091 0000 		lds r25,xTickCount+1
2298:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1475               	.LM159:
 1476 059a 0895      		ret
 1481               	.Lscope12:
 1483               		.stabd	78,0,0
 1485               	.global	uxTaskGetNumberOfTasks
 1487               	uxTaskGetNumberOfTasks:
 1488               		.stabd	46,0,0
2302:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
 1490               	.LM160:
 1491               	.LFBB13:
 1492               	/* prologue: function */
 1493               	/* frame size = 0 */
 1494               	/* stack size = 0 */
 1495               	.L__stack_usage = 0
2305:FreeRTOS/Source/tasks.c **** }
 1497               	.LM161:
 1498 059c 8091 0000 		lds r24,uxCurrentNumberOfTasks
2306:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1500               	.LM162:
 1501 05a0 0895      		ret
 1503               	.Lscope13:
 1505               		.stabd	78,0,0
 1508               	.global	pcTaskGetName
 1510               	pcTaskGetName:
 1511               		.stabd	46,0,0
2310:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
 1513               	.LM163:
 1514               	.LFBB14:
 1515               	/* prologue: function */
 1516               	/* frame size = 0 */
 1517               	/* stack size = 0 */
 1518               	.L__stack_usage = 0
2315:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
 1520               	.LM164:
 1521 05a2 0097      		sbiw r24,0
 1522 05a4 01F4      		brne .L91
2315:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
 1524               	.LM165:
 1525 05a6 8091 0000 		lds r24,pxCurrentTCB
 1526 05aa 9091 0000 		lds r25,pxCurrentTCB+1
 1527               	.L91:
2318:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1529               	.LM166:
 1530 05ae 4996      		adiw r24,25
 1531 05b0 0895      		ret
 1533               	.Lscope14:
 1535               		.stabd	78,0,0
 1537               	.global	xTaskIncrementTick
 1539               	xTaskIncrementTick:
 1540               		.stabd	46,0,0
2637:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
 1542               	.LM167:
 1543               	.LFBB15:
 1544 05b2 CF92      		push r12
 1545 05b4 DF92      		push r13
 1546 05b6 EF92      		push r14
 1547 05b8 FF92      		push r15
 1548 05ba 0F93      		push r16
 1549 05bc 1F93      		push r17
 1550 05be CF93      		push r28
 1551 05c0 DF93      		push r29
 1552               	/* prologue: function */
 1553               	/* frame size = 0 */
 1554               	/* stack size = 8 */
 1555               	.L__stack_usage = 8
2646:FreeRTOS/Source/tasks.c **** 	{
 1557               	.LM168:
 1558 05c2 8091 0000 		lds r24,uxSchedulerSuspended
 1559 05c6 8111      		cpse r24,__zero_reg__
 1560 05c8 00C0      		rjmp .L93
 1561               	.LBB62:
2650:FreeRTOS/Source/tasks.c **** 
 1563               	.LM169:
 1564 05ca 0091 0000 		lds r16,xTickCount
 1565 05ce 1091 0000 		lds r17,xTickCount+1
 1566 05d2 0F5F      		subi r16,-1
 1567 05d4 1F4F      		sbci r17,-1
2654:FreeRTOS/Source/tasks.c **** 
 1569               	.LM170:
 1570 05d6 1093 0000 		sts xTickCount+1,r17
 1571 05da 0093 0000 		sts xTickCount,r16
2656:FreeRTOS/Source/tasks.c **** 		{
 1573               	.LM171:
 1574 05de 0115      		cp r16,__zero_reg__
 1575 05e0 1105      		cpc r17,__zero_reg__
 1576 05e2 01F4      		brne .L94
 1577               	.LBB63:
2658:FreeRTOS/Source/tasks.c **** 		}
 1579               	.LM172:
 1580 05e4 8091 0000 		lds r24,pxDelayedTaskList
 1581 05e8 9091 0000 		lds r25,pxDelayedTaskList+1
 1582 05ec 2091 0000 		lds r18,pxOverflowDelayedTaskList
 1583 05f0 3091 0000 		lds r19,pxOverflowDelayedTaskList+1
 1584 05f4 3093 0000 		sts pxDelayedTaskList+1,r19
 1585 05f8 2093 0000 		sts pxDelayedTaskList,r18
 1586 05fc 9093 0000 		sts pxOverflowDelayedTaskList+1,r25
 1587 0600 8093 0000 		sts pxOverflowDelayedTaskList,r24
 1588 0604 8091 0000 		lds r24,xNumOfOverflows
 1589 0608 8F5F      		subi r24,lo8(-(1))
 1590 060a 8093 0000 		sts xNumOfOverflows,r24
 1591 060e 0E94 0000 		call prvResetNextTaskUnblockTime
 1592               	.L94:
 1593               	.LBE63:
2669:FreeRTOS/Source/tasks.c **** 		{
 1595               	.LM173:
 1596 0612 8091 0000 		lds r24,xNextTaskUnblockTime
 1597 0616 9091 0000 		lds r25,xNextTaskUnblockTime+1
 1598 061a C0E0      		ldi r28,0
 1599 061c 0817      		cp r16,r24
 1600 061e 1907      		cpc r17,r25
 1601 0620 00F4      		brsh .+2
 1602 0622 00C0      		rjmp .L95
2723:FreeRTOS/Source/tasks.c **** 
 1604               	.LM174:
 1605 0624 D9E0      		ldi r29,lo8(9)
 1606               	.L96:
2673:FreeRTOS/Source/tasks.c **** 				{
 1608               	.LM175:
 1609 0626 E091 0000 		lds r30,pxDelayedTaskList
 1610 062a F091 0000 		lds r31,pxDelayedTaskList+1
 1611 062e 8081      		ld r24,Z
 1612 0630 8111      		cpse r24,__zero_reg__
 1613 0632 00C0      		rjmp .L97
2680:FreeRTOS/Source/tasks.c **** 					break;
 1615               	.LM176:
 1616 0634 8FEF      		ldi r24,lo8(-1)
 1617 0636 9FEF      		ldi r25,lo8(-1)
 1618 0638 00C0      		rjmp .L111
 1619               	.L97:
2689:FreeRTOS/Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 1621               	.LM177:
 1622 063a E091 0000 		lds r30,pxDelayedTaskList
 1623 063e F091 0000 		lds r31,pxDelayedTaskList+1
 1624 0642 0580      		ldd __tmp_reg__,Z+5
 1625 0644 F681      		ldd r31,Z+6
 1626 0646 E02D      		mov r30,__tmp_reg__
 1627 0648 E680      		ldd r14,Z+6
 1628 064a F780      		ldd r15,Z+7
2690:FreeRTOS/Source/tasks.c **** 
 1630               	.LM178:
 1631 064c D701      		movw r26,r14
 1632 064e 1296      		adiw r26,2
 1633 0650 8D91      		ld r24,X+
 1634 0652 9C91      		ld r25,X
 1635 0654 1397      		sbiw r26,2+1
2692:FreeRTOS/Source/tasks.c **** 					{
 1637               	.LM179:
 1638 0656 0817      		cp r16,r24
 1639 0658 1907      		cpc r17,r25
 1640 065a 00F4      		brsh .L98
 1641               	.L111:
2699:FreeRTOS/Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
 1643               	.LM180:
 1644 065c 9093 0000 		sts xNextTaskUnblockTime+1,r25
 1645 0660 8093 0000 		sts xNextTaskUnblockTime,r24
2700:FreeRTOS/Source/tasks.c **** 					}
 1647               	.LM181:
 1648 0664 00C0      		rjmp .L95
 1649               	.L98:
2708:FreeRTOS/Source/tasks.c **** 
 1651               	.LM182:
 1652 0666 6701      		movw r12,r14
 1653 0668 B2E0      		ldi r27,2
 1654 066a CB0E      		add r12,r27
 1655 066c D11C      		adc r13,__zero_reg__
 1656 066e C601      		movw r24,r12
 1657 0670 0E94 0000 		call uxListRemove
2712:FreeRTOS/Source/tasks.c **** 					{
 1659               	.LM183:
 1660 0674 F701      		movw r30,r14
 1661 0676 8489      		ldd r24,Z+20
 1662 0678 9589      		ldd r25,Z+21
 1663 067a 892B      		or r24,r25
 1664 067c 01F0      		breq .L99
2714:FreeRTOS/Source/tasks.c **** 					}
 1666               	.LM184:
 1667 067e C701      		movw r24,r14
 1668 0680 0C96      		adiw r24,12
 1669 0682 0E94 0000 		call uxListRemove
 1670               	.L99:
2723:FreeRTOS/Source/tasks.c **** 
 1672               	.LM185:
 1673 0686 D701      		movw r26,r14
 1674 0688 5696      		adiw r26,22
 1675 068a 8C91      		ld r24,X
 1676 068c 9091 0000 		lds r25,uxTopReadyPriority
 1677 0690 9817      		cp r25,r24
 1678 0692 00F4      		brsh .L100
2723:FreeRTOS/Source/tasks.c **** 
 1680               	.LM186:
 1681 0694 8093 0000 		sts uxTopReadyPriority,r24
 1682               	.L100:
2723:FreeRTOS/Source/tasks.c **** 
 1684               	.LM187:
 1685 0698 D89F      		mul r29,r24
 1686 069a C001      		movw r24,r0
 1687 069c 1124      		clr __zero_reg__
 1688 069e B601      		movw r22,r12
 1689 06a0 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1690 06a2 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1691 06a4 0E94 0000 		call vListInsertEnd
2733:FreeRTOS/Source/tasks.c **** 						{
 1693               	.LM188:
 1694 06a8 E091 0000 		lds r30,pxCurrentTCB
 1695 06ac F091 0000 		lds r31,pxCurrentTCB+1
 1696 06b0 D701      		movw r26,r14
 1697 06b2 5696      		adiw r26,22
 1698 06b4 9C91      		ld r25,X
 1699 06b6 8689      		ldd r24,Z+22
 1700 06b8 9817      		cp r25,r24
 1701 06ba 00F4      		brsh .+2
 1702 06bc 00C0      		rjmp .L96
2735:FreeRTOS/Source/tasks.c **** 						}
 1704               	.LM189:
 1705 06be C1E0      		ldi r28,lo8(1)
 1706 06c0 00C0      		rjmp .L96
 1707               	.L95:
2752:FreeRTOS/Source/tasks.c **** 			{
 1709               	.LM190:
 1710 06c2 E091 0000 		lds r30,pxCurrentTCB
 1711 06c6 F091 0000 		lds r31,pxCurrentTCB+1
 1712 06ca E689      		ldd r30,Z+22
 1713 06cc B9E0      		ldi r27,lo8(9)
 1714 06ce EB9F      		mul r30,r27
 1715 06d0 F001      		movw r30,r0
 1716 06d2 1124      		clr __zero_reg__
 1717 06d4 E050      		subi r30,lo8(-(pxReadyTasksLists))
 1718 06d6 F040      		sbci r31,hi8(-(pxReadyTasksLists))
 1719 06d8 8081      		ld r24,Z
 1720 06da 8230      		cpi r24,lo8(2)
 1721 06dc 00F0      		brlo .L102
2754:FreeRTOS/Source/tasks.c **** 			}
 1723               	.LM191:
 1724 06de C1E0      		ldi r28,lo8(1)
 1725 06e0 00C0      		rjmp .L102
 1726               	.L93:
 1727               	.LBE62:
2780:FreeRTOS/Source/tasks.c **** 
 1729               	.LM192:
 1730 06e2 8091 0000 		lds r24,uxPendedTicks
 1731 06e6 8F5F      		subi r24,lo8(-(1))
 1732 06e8 8093 0000 		sts uxPendedTicks,r24
2640:FreeRTOS/Source/tasks.c **** 
 1734               	.LM193:
 1735 06ec C0E0      		ldi r28,0
 1736               	.L102:
2793:FreeRTOS/Source/tasks.c **** 		{
 1738               	.LM194:
 1739 06ee 8091 0000 		lds r24,xYieldPending
 1740 06f2 8111      		cpse r24,__zero_reg__
2795:FreeRTOS/Source/tasks.c **** 		}
 1742               	.LM195:
 1743 06f4 C1E0      		ldi r28,lo8(1)
 1744               	.L103:
2805:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1746               	.LM196:
 1747 06f6 8C2F      		mov r24,r28
 1748               	/* epilogue start */
 1749 06f8 DF91      		pop r29
 1750 06fa CF91      		pop r28
 1751 06fc 1F91      		pop r17
 1752 06fe 0F91      		pop r16
 1753 0700 FF90      		pop r15
 1754 0702 EF90      		pop r14
 1755 0704 DF90      		pop r13
 1756 0706 CF90      		pop r12
 1757 0708 0895      		ret
 1770               	.Lscope15:
 1772               		.stabd	78,0,0
 1774               	.global	xTaskResumeAll
 1776               	xTaskResumeAll:
 1777               		.stabd	46,0,0
2146:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB = NULL;
 1779               	.LM197:
 1780               	.LFBB16:
 1781 070a EF92      		push r14
 1782 070c FF92      		push r15
 1783 070e 0F93      		push r16
 1784 0710 1F93      		push r17
 1785 0712 CF93      		push r28
 1786 0714 DF93      		push r29
 1787               	/* prologue: function */
 1788               	/* frame size = 0 */
 1789               	/* stack size = 6 */
 1790               	.L__stack_usage = 6
2159:FreeRTOS/Source/tasks.c **** 	{
 1792               	.LM198:
 1793               	/* #APP */
 1794               	 ;  2159 "FreeRTOS/Source/tasks.c" 1
 1795 0716 0FB6      		in		__tmp_reg__, __SREG__
 1796               	 ;  0 "" 2
 1797               	 ;  2159 "FreeRTOS/Source/tasks.c" 1
 1798 0718 F894      		cli
 1799               	 ;  0 "" 2
 1800               	 ;  2159 "FreeRTOS/Source/tasks.c" 1
 1801 071a 0F92      		push	__tmp_reg__
 1802               	 ;  0 "" 2
2161:FreeRTOS/Source/tasks.c **** 
 1804               	.LM199:
 1805               	/* #NOAPP */
 1806 071c 8091 0000 		lds r24,uxSchedulerSuspended
 1807 0720 8150      		subi r24,lo8(-(-1))
 1808 0722 8093 0000 		sts uxSchedulerSuspended,r24
2163:FreeRTOS/Source/tasks.c **** 		{
 1810               	.LM200:
 1811 0726 8091 0000 		lds r24,uxSchedulerSuspended
 1812 072a 8823      		tst r24
 1813 072c 01F0      		breq .L113
 1814               	.L115:
2148:FreeRTOS/Source/tasks.c **** 
 1816               	.LM201:
 1817 072e 80E0      		ldi r24,0
 1818 0730 00C0      		rjmp .L114
 1819               	.L113:
2165:FreeRTOS/Source/tasks.c **** 			{
 1821               	.LM202:
 1822 0732 8091 0000 		lds r24,uxCurrentNumberOfTasks
 1823 0736 8823      		tst r24
 1824 0738 01F0      		breq .L115
 1825 073a C0E0      		ldi r28,0
 1826 073c D0E0      		ldi r29,0
2174:FreeRTOS/Source/tasks.c **** 
 1828               	.LM203:
 1829 073e 89E0      		ldi r24,lo8(9)
 1830 0740 F82E      		mov r15,r24
2180:FreeRTOS/Source/tasks.c **** 					}
 1832               	.LM204:
 1833 0742 EE24      		clr r14
 1834 0744 E394      		inc r14
 1835               	.L116:
2169:FreeRTOS/Source/tasks.c **** 				{
 1837               	.LM205:
 1838 0746 8091 0000 		lds r24,xPendingReadyList
 1839 074a 8823      		tst r24
 1840 074c 01F0      		breq .L140
2171:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1842               	.LM206:
 1843 074e E091 0000 		lds r30,xPendingReadyList+5
 1844 0752 F091 0000 		lds r31,xPendingReadyList+5+1
 1845 0756 C681      		ldd r28,Z+6
 1846 0758 D781      		ldd r29,Z+7
2172:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1848               	.LM207:
 1849 075a CE01      		movw r24,r28
 1850 075c 0C96      		adiw r24,12
 1851 075e 0E94 0000 		call uxListRemove
2173:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1853               	.LM208:
 1854 0762 8E01      		movw r16,r28
 1855 0764 0E5F      		subi r16,-2
 1856 0766 1F4F      		sbci r17,-1
 1857 0768 C801      		movw r24,r16
 1858 076a 0E94 0000 		call uxListRemove
2174:FreeRTOS/Source/tasks.c **** 
 1860               	.LM209:
 1861 076e 8E89      		ldd r24,Y+22
 1862 0770 9091 0000 		lds r25,uxTopReadyPriority
 1863 0774 9817      		cp r25,r24
 1864 0776 00F4      		brsh .L117
2174:FreeRTOS/Source/tasks.c **** 
 1866               	.LM210:
 1867 0778 8093 0000 		sts uxTopReadyPriority,r24
 1868               	.L117:
2174:FreeRTOS/Source/tasks.c **** 
 1870               	.LM211:
 1871 077c F89E      		mul r15,r24
 1872 077e C001      		movw r24,r0
 1873 0780 1124      		clr __zero_reg__
 1874 0782 B801      		movw r22,r16
 1875 0784 8050      		subi r24,lo8(-(pxReadyTasksLists))
 1876 0786 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 1877 0788 0E94 0000 		call vListInsertEnd
2178:FreeRTOS/Source/tasks.c **** 					{
 1879               	.LM212:
 1880 078c E091 0000 		lds r30,pxCurrentTCB
 1881 0790 F091 0000 		lds r31,pxCurrentTCB+1
 1882 0794 9E89      		ldd r25,Y+22
 1883 0796 8689      		ldd r24,Z+22
 1884 0798 9817      		cp r25,r24
 1885 079a 00F0      		brlo .L116
2180:FreeRTOS/Source/tasks.c **** 					}
 1887               	.LM213:
 1888 079c E092 0000 		sts xYieldPending,r14
 1889 07a0 00C0      		rjmp .L116
 1890               	.L140:
2188:FreeRTOS/Source/tasks.c **** 				{
 1892               	.LM214:
 1893 07a2 CD2B      		or r28,r29
 1894 07a4 01F0      		breq .L120
2196:FreeRTOS/Source/tasks.c **** 				}
 1896               	.LM215:
 1897 07a6 0E94 0000 		call prvResetNextTaskUnblockTime
 1898               	.L120:
 1899               	.LBB64:
2204:FreeRTOS/Source/tasks.c **** 
 1901               	.LM216:
 1902 07aa C091 0000 		lds r28,uxPendedTicks
2206:FreeRTOS/Source/tasks.c **** 					{
 1904               	.LM217:
 1905 07ae CC23      		tst r28
 1906 07b0 01F0      		breq .L121
2212:FreeRTOS/Source/tasks.c **** 							}
 1908               	.LM218:
 1909 07b2 D1E0      		ldi r29,lo8(1)
 1910               	.L123:
2210:FreeRTOS/Source/tasks.c **** 							{
 1912               	.LM219:
 1913 07b4 0E94 0000 		call xTaskIncrementTick
 1914 07b8 8111      		cpse r24,__zero_reg__
2212:FreeRTOS/Source/tasks.c **** 							}
 1916               	.LM220:
 1917 07ba D093 0000 		sts xYieldPending,r29
 1918               	.L122:
2218:FreeRTOS/Source/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 1920               	.LM221:
 1921 07be C150      		subi r28,lo8(-(-1))
2219:FreeRTOS/Source/tasks.c **** 
 1923               	.LM222:
 1924 07c0 01F4      		brne .L123
2221:FreeRTOS/Source/tasks.c **** 					}
 1926               	.LM223:
 1927 07c2 1092 0000 		sts uxPendedTicks,__zero_reg__
 1928               	.L121:
 1929               	.LBE64:
2229:FreeRTOS/Source/tasks.c **** 				{
 1931               	.LM224:
 1932 07c6 8091 0000 		lds r24,xYieldPending
 1933 07ca 8823      		tst r24
 1934 07cc 01F4      		brne .+2
 1935 07ce 00C0      		rjmp .L115
2236:FreeRTOS/Source/tasks.c **** 				}
 1937               	.LM225:
 1938 07d0 0E94 0000 		call vPortYield
2233:FreeRTOS/Source/tasks.c **** 					}
 1940               	.LM226:
 1941 07d4 81E0      		ldi r24,lo8(1)
 1942               	.L114:
2249:FreeRTOS/Source/tasks.c **** 
 1944               	.LM227:
 1945               	/* #APP */
 1946               	 ;  2249 "FreeRTOS/Source/tasks.c" 1
 1947 07d6 0F90      		pop		__tmp_reg__
 1948               	 ;  0 "" 2
 1949               	 ;  2249 "FreeRTOS/Source/tasks.c" 1
 1950 07d8 0FBE      		out		__SREG__, __tmp_reg__
 1951               	 ;  0 "" 2
 1952               	/* epilogue start */
2252:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1954               	.LM228:
 1955               	/* #NOAPP */
 1956 07da DF91      		pop r29
 1957 07dc CF91      		pop r28
 1958 07de 1F91      		pop r17
 1959 07e0 0F91      		pop r16
 1960 07e2 FF90      		pop r15
 1961 07e4 EF90      		pop r14
 1962 07e6 0895      		ret
 1971               	.Lscope16:
 1973               		.stabd	78,0,0
 1977               	.global	vTaskDelayUntil
 1979               	vTaskDelayUntil:
 1980               		.stabd	46,0,0
1222:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 1982               	.LM229:
 1983               	.LFBB17:
 1984 07e8 0F93      		push r16
 1985 07ea 1F93      		push r17
 1986 07ec CF93      		push r28
 1987 07ee DF93      		push r29
 1988               	/* prologue: function */
 1989               	/* frame size = 0 */
 1990               	/* stack size = 4 */
 1991               	.L__stack_usage = 4
 1992 07f0 8C01      		movw r16,r24
 1993 07f2 EB01      		movw r28,r22
1230:FreeRTOS/Source/tasks.c **** 		{
 1995               	.LM230:
 1996 07f4 0E94 0000 		call vTaskSuspendAll
 1997               	.LBB65:
1234:FreeRTOS/Source/tasks.c **** 
 1999               	.LM231:
 2000 07f8 4091 0000 		lds r20,xTickCount
 2001 07fc 5091 0000 		lds r21,xTickCount+1
1237:FreeRTOS/Source/tasks.c **** 
 2003               	.LM232:
 2004 0800 F801      		movw r30,r16
 2005 0802 2081      		ld r18,Z
 2006 0804 3181      		ldd r19,Z+1
 2007 0806 C901      		movw r24,r18
 2008 0808 8C0F      		add r24,r28
 2009 080a 9D1F      		adc r25,r29
1239:FreeRTOS/Source/tasks.c **** 			{
 2011               	.LM233:
 2012 080c 4217      		cp r20,r18
 2013 080e 5307      		cpc r21,r19
 2014 0810 00F4      		brsh .L142
1246:FreeRTOS/Source/tasks.c **** 				{
 2016               	.LM234:
 2017 0812 8217      		cp r24,r18
 2018 0814 9307      		cpc r25,r19
 2019 0816 00F4      		brsh .L148
 2020 0818 00C0      		rjmp .L155
 2021               	.L142:
1260:FreeRTOS/Source/tasks.c **** 				{
 2023               	.LM235:
 2024 081a 8217      		cp r24,r18
 2025 081c 9307      		cpc r25,r19
 2026 081e 00F0      		brlo .L149
 2027               	.L155:
 2028               	.LBE65:
1224:FreeRTOS/Source/tasks.c **** 
 2030               	.LM236:
 2031 0820 21E0      		ldi r18,lo8(1)
 2032 0822 4817      		cp r20,r24
 2033 0824 5907      		cpc r21,r25
 2034 0826 00F0      		brlo .L143
 2035               	.L148:
1224:FreeRTOS/Source/tasks.c **** 
 2037               	.LM237:
 2038 0828 20E0      		ldi r18,0
 2039 082a 00C0      		rjmp .L143
 2040               	.L149:
 2041               	.LBB66:
1262:FreeRTOS/Source/tasks.c **** 				}
 2043               	.LM238:
 2044 082c 21E0      		ldi r18,lo8(1)
 2045               	.L143:
1271:FreeRTOS/Source/tasks.c **** 
 2047               	.LM239:
 2048 082e F801      		movw r30,r16
 2049 0830 9183      		std Z+1,r25
 2050 0832 8083      		st Z,r24
1273:FreeRTOS/Source/tasks.c **** 			{
 2052               	.LM240:
 2053 0834 2223      		tst r18
 2054 0836 01F0      		breq .L146
1279:FreeRTOS/Source/tasks.c **** 			}
 2056               	.LM241:
 2057 0838 60E0      		ldi r22,0
 2058 083a 841B      		sub r24,r20
 2059 083c 950B      		sbc r25,r21
 2060 083e 0E94 0000 		call prvAddCurrentTaskToDelayedList
 2061               	.L146:
 2062               	.LBE66:
1286:FreeRTOS/Source/tasks.c **** 
 2064               	.LM242:
 2065 0842 0E94 0000 		call xTaskResumeAll
1290:FreeRTOS/Source/tasks.c **** 		{
 2067               	.LM243:
 2068 0846 8111      		cpse r24,__zero_reg__
 2069 0848 00C0      		rjmp .L141
1292:FreeRTOS/Source/tasks.c **** 		}
 2071               	.LM244:
 2072 084a 0E94 0000 		call vPortYield
 2073               	.L141:
 2074               	/* epilogue start */
1298:FreeRTOS/Source/tasks.c **** 
 2076               	.LM245:
 2077 084e DF91      		pop r29
 2078 0850 CF91      		pop r28
 2079 0852 1F91      		pop r17
 2080 0854 0F91      		pop r16
 2081 0856 0895      		ret
 2093               	.Lscope17:
 2095               		.stabd	78,0,0
 2098               	.global	vTaskDelay
 2100               	vTaskDelay:
 2101               		.stabd	46,0,0
1306:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 2103               	.LM246:
 2104               	.LFBB18:
 2105 0858 CF93      		push r28
 2106 085a DF93      		push r29
 2107               	/* prologue: function */
 2108               	/* frame size = 0 */
 2109               	/* stack size = 2 */
 2110               	.L__stack_usage = 2
 2111 085c EC01      		movw r28,r24
1310:FreeRTOS/Source/tasks.c **** 		{
 2113               	.LM247:
 2114 085e 892B      		or r24,r25
 2115 0860 01F4      		brne .L157
 2116               	.L159:
1337:FreeRTOS/Source/tasks.c **** 		}
 2118               	.LM248:
 2119 0862 0E94 0000 		call vPortYield
 2120 0866 00C0      		rjmp .L156
 2121               	.L157:
1313:FreeRTOS/Source/tasks.c **** 			{
 2123               	.LM249:
 2124 0868 0E94 0000 		call vTaskSuspendAll
1324:FreeRTOS/Source/tasks.c **** 			}
 2126               	.LM250:
 2127 086c 60E0      		ldi r22,0
 2128 086e CE01      		movw r24,r28
 2129 0870 0E94 0000 		call prvAddCurrentTaskToDelayedList
1326:FreeRTOS/Source/tasks.c **** 		}
 2131               	.LM251:
 2132 0874 0E94 0000 		call xTaskResumeAll
1335:FreeRTOS/Source/tasks.c **** 		{
 2134               	.LM252:
 2135 0878 8823      		tst r24
 2136 087a 01F0      		breq .L159
 2137               	.L156:
 2138               	/* epilogue start */
1343:FreeRTOS/Source/tasks.c **** 
 2140               	.LM253:
 2141 087c DF91      		pop r29
 2142 087e CF91      		pop r28
 2143 0880 0895      		ret
 2145               	.Lscope18:
 2147               		.stabd	78,0,0
 2149               	.global	vTaskSwitchContext
 2151               	vTaskSwitchContext:
 2152               		.stabd	46,0,0
2901:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2154               	.LM254:
 2155               	.LFBB19:
 2156               	/* prologue: function */
 2157               	/* frame size = 0 */
 2158               	/* stack size = 0 */
 2159               	.L__stack_usage = 0
2902:FreeRTOS/Source/tasks.c **** 	{
 2161               	.LM255:
 2162 0882 8091 0000 		lds r24,uxSchedulerSuspended
 2163 0886 8823      		tst r24
 2164 0888 01F0      		breq .L164
2906:FreeRTOS/Source/tasks.c **** 	}
 2166               	.LM256:
 2167 088a 81E0      		ldi r24,lo8(1)
 2168 088c 8093 0000 		sts xYieldPending,r24
 2169 0890 0895      		ret
 2170               	.L164:
 2171               	.LBB71:
 2172               	.LBB72:
2910:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 2174               	.LM257:
 2175 0892 1092 0000 		sts xYieldPending,__zero_reg__
 2176               	.LBB73:
2952:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2178               	.LM258:
 2179 0896 8091 0000 		lds r24,uxTopReadyPriority
 2180 089a 69E0      		ldi r22,lo8(9)
 2181               	.L166:
 2182 089c 482F      		mov r20,r24
 2183 089e 50E0      		ldi r21,0
 2184 08a0 649F      		mul r22,r20
 2185 08a2 9001      		movw r18,r0
 2186 08a4 659F      		mul r22,r21
 2187 08a6 300D      		add r19,r0
 2188 08a8 1124      		clr __zero_reg__
 2189 08aa F901      		movw r30,r18
 2190 08ac E050      		subi r30,lo8(-(pxReadyTasksLists))
 2191 08ae F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2192 08b0 9081      		ld r25,Z
 2193 08b2 9111      		cpse r25,__zero_reg__
 2194 08b4 00C0      		rjmp .L169
 2195 08b6 8150      		subi r24,lo8(-(-1))
 2196 08b8 00C0      		rjmp .L166
 2197               	.L169:
 2198               	.LBB74:
 2199 08ba A181      		ldd r26,Z+1
 2200 08bc B281      		ldd r27,Z+2
 2201 08be 1296      		adiw r26,2
 2202 08c0 0D90      		ld __tmp_reg__,X+
 2203 08c2 BC91      		ld r27,X
 2204 08c4 A02D      		mov r26,__tmp_reg__
 2205 08c6 B283      		std Z+2,r27
 2206 08c8 A183      		std Z+1,r26
 2207 08ca 2050      		subi r18,lo8(-(pxReadyTasksLists+3))
 2208 08cc 3040      		sbci r19,hi8(-(pxReadyTasksLists+3))
 2209 08ce A217      		cp r26,r18
 2210 08d0 B307      		cpc r27,r19
 2211 08d2 01F4      		brne .L168
 2212 08d4 1296      		adiw r26,2
 2213 08d6 2D91      		ld r18,X+
 2214 08d8 3C91      		ld r19,X
 2215 08da 1397      		sbiw r26,2+1
 2216 08dc 3283      		std Z+2,r19
 2217 08de 2183      		std Z+1,r18
 2218               	.L168:
 2219 08e0 99E0      		ldi r25,lo8(9)
 2220 08e2 949F      		mul r25,r20
 2221 08e4 F001      		movw r30,r0
 2222 08e6 959F      		mul r25,r21
 2223 08e8 F00D      		add r31,r0
 2224 08ea 1124      		clr __zero_reg__
 2225 08ec E050      		subi r30,lo8(-(pxReadyTasksLists))
 2226 08ee F040      		sbci r31,hi8(-(pxReadyTasksLists))
 2227 08f0 0180      		ldd __tmp_reg__,Z+1
 2228 08f2 F281      		ldd r31,Z+2
 2229 08f4 E02D      		mov r30,__tmp_reg__
 2230 08f6 2681      		ldd r18,Z+6
 2231 08f8 3781      		ldd r19,Z+7
 2232 08fa 3093 0000 		sts pxCurrentTCB+1,r19
 2233 08fe 2093 0000 		sts pxCurrentTCB,r18
 2234               	.LBE74:
 2235 0902 8093 0000 		sts uxTopReadyPriority,r24
 2236 0906 0895      		ret
 2237               	.LBE73:
 2238               	.LBE72:
 2239               	.LBE71:
 2244               	.Lscope19:
 2246               		.stabd	78,0,0
 2249               	.global	vTaskSuspend
 2251               	vTaskSuspend:
 2252               		.stabd	46,0,0
1669:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 2254               	.LM259:
 2255               	.LFBB20:
 2256 0908 0F93      		push r16
 2257 090a 1F93      		push r17
 2258 090c CF93      		push r28
 2259 090e DF93      		push r29
 2260               	/* prologue: function */
 2261               	/* frame size = 0 */
 2262               	/* stack size = 4 */
 2263               	.L__stack_usage = 4
 2264 0910 EC01      		movw r28,r24
1672:FreeRTOS/Source/tasks.c **** 		{
 2266               	.LM260:
 2267               	/* #APP */
 2268               	 ;  1672 "FreeRTOS/Source/tasks.c" 1
 2269 0912 0FB6      		in		__tmp_reg__, __SREG__
 2270               	 ;  0 "" 2
 2271               	 ;  1672 "FreeRTOS/Source/tasks.c" 1
 2272 0914 F894      		cli
 2273               	 ;  0 "" 2
 2274               	 ;  1672 "FreeRTOS/Source/tasks.c" 1
 2275 0916 0F92      		push	__tmp_reg__
 2276               	 ;  0 "" 2
1676:FreeRTOS/Source/tasks.c **** 
 2278               	.LM261:
 2279               	/* #NOAPP */
 2280 0918 892B      		or r24,r25
 2281 091a 01F4      		brne .L171
1676:FreeRTOS/Source/tasks.c **** 
 2283               	.LM262:
 2284 091c C091 0000 		lds r28,pxCurrentTCB
 2285 0920 D091 0000 		lds r29,pxCurrentTCB+1
 2286               	.L171:
1682:FreeRTOS/Source/tasks.c **** 			{
 2288               	.LM263:
 2289 0924 8E01      		movw r16,r28
 2290 0926 0E5F      		subi r16,-2
 2291 0928 1F4F      		sbci r17,-1
 2292 092a C801      		movw r24,r16
 2293 092c 0E94 0000 		call uxListRemove
1692:FreeRTOS/Source/tasks.c **** 			{
 2295               	.LM264:
 2296 0930 8C89      		ldd r24,Y+20
 2297 0932 9D89      		ldd r25,Y+21
 2298 0934 892B      		or r24,r25
 2299 0936 01F0      		breq .L172
1694:FreeRTOS/Source/tasks.c **** 			}
 2301               	.LM265:
 2302 0938 CE01      		movw r24,r28
 2303 093a 0C96      		adiw r24,12
 2304 093c 0E94 0000 		call uxListRemove
 2305               	.L172:
1701:FreeRTOS/Source/tasks.c **** 
 2307               	.LM266:
 2308 0940 B801      		movw r22,r16
 2309 0942 80E0      		ldi r24,lo8(xSuspendedTaskList)
 2310 0944 90E0      		ldi r25,hi8(xSuspendedTaskList)
 2311 0946 0E94 0000 		call vListInsertEnd
1705:FreeRTOS/Source/tasks.c **** 				{
 2313               	.LM267:
 2314 094a 8DA1      		ldd r24,Y+37
 2315 094c 8130      		cpi r24,lo8(1)
 2316 094e 01F4      		brne .L173
1709:FreeRTOS/Source/tasks.c **** 				}
 2318               	.LM268:
 2319 0950 1DA2      		std Y+37,__zero_reg__
 2320               	.L173:
1714:FreeRTOS/Source/tasks.c **** 
 2322               	.LM269:
 2323               	/* #APP */
 2324               	 ;  1714 "FreeRTOS/Source/tasks.c" 1
 2325 0952 0F90      		pop		__tmp_reg__
 2326               	 ;  0 "" 2
 2327               	 ;  1714 "FreeRTOS/Source/tasks.c" 1
 2328 0954 0FBE      		out		__SREG__, __tmp_reg__
 2329               	 ;  0 "" 2
1716:FreeRTOS/Source/tasks.c **** 		{
 2331               	.LM270:
 2332               	/* #NOAPP */
 2333 0956 8091 0000 		lds r24,xSchedulerRunning
 2334 095a 8823      		tst r24
 2335 095c 01F0      		breq .L174
1720:FreeRTOS/Source/tasks.c **** 			{
 2337               	.LM271:
 2338               	/* #APP */
 2339               	 ;  1720 "FreeRTOS/Source/tasks.c" 1
 2340 095e 0FB6      		in		__tmp_reg__, __SREG__
 2341               	 ;  0 "" 2
 2342               	 ;  1720 "FreeRTOS/Source/tasks.c" 1
 2343 0960 F894      		cli
 2344               	 ;  0 "" 2
 2345               	 ;  1720 "FreeRTOS/Source/tasks.c" 1
 2346 0962 0F92      		push	__tmp_reg__
 2347               	 ;  0 "" 2
1722:FreeRTOS/Source/tasks.c **** 			}
 2349               	.LM272:
 2350               	/* #NOAPP */
 2351 0964 0E94 0000 		call prvResetNextTaskUnblockTime
1724:FreeRTOS/Source/tasks.c **** 		}
 2353               	.LM273:
 2354               	/* #APP */
 2355               	 ;  1724 "FreeRTOS/Source/tasks.c" 1
 2356 0968 0F90      		pop		__tmp_reg__
 2357               	 ;  0 "" 2
 2358               	 ;  1724 "FreeRTOS/Source/tasks.c" 1
 2359 096a 0FBE      		out		__SREG__, __tmp_reg__
 2360               	 ;  0 "" 2
 2361               	/* #NOAPP */
 2362               	.L174:
1731:FreeRTOS/Source/tasks.c **** 		{
 2364               	.LM274:
 2365 096c 8091 0000 		lds r24,pxCurrentTCB
 2366 0970 9091 0000 		lds r25,pxCurrentTCB+1
 2367 0974 C817      		cp r28,r24
 2368 0976 D907      		cpc r29,r25
 2369 0978 01F4      		brne .L170
1733:FreeRTOS/Source/tasks.c **** 			{
 2371               	.LM275:
 2372 097a 8091 0000 		lds r24,xSchedulerRunning
 2373 097e 8823      		tst r24
 2374 0980 01F0      		breq .L176
1737:FreeRTOS/Source/tasks.c **** 			}
 2376               	.LM276:
 2377 0982 0E94 0000 		call vPortYield
 2378 0986 00C0      		rjmp .L170
 2379               	.L176:
1744:FreeRTOS/Source/tasks.c **** 				{
 2381               	.LM277:
 2382 0988 9091 0000 		lds r25,xSuspendedTaskList
 2383 098c 8091 0000 		lds r24,uxCurrentNumberOfTasks
 2384 0990 9813      		cpse r25,r24
 2385 0992 00C0      		rjmp .L177
1750:FreeRTOS/Source/tasks.c **** 				}
 2387               	.LM278:
 2388 0994 1092 0000 		sts pxCurrentTCB+1,__zero_reg__
 2389 0998 1092 0000 		sts pxCurrentTCB,__zero_reg__
 2390 099c 00C0      		rjmp .L170
 2391               	.L177:
 2392               	/* epilogue start */
1762:FreeRTOS/Source/tasks.c **** 
 2394               	.LM279:
 2395 099e DF91      		pop r29
 2396 09a0 CF91      		pop r28
 2397 09a2 1F91      		pop r17
 2398 09a4 0F91      		pop r16
1754:FreeRTOS/Source/tasks.c **** 				}
 2400               	.LM280:
 2401 09a6 0C94 0000 		jmp vTaskSwitchContext
 2402               	.L170:
 2403               	/* epilogue start */
1762:FreeRTOS/Source/tasks.c **** 
 2405               	.LM281:
 2406 09aa DF91      		pop r29
 2407 09ac CF91      		pop r28
 2408 09ae 1F91      		pop r17
 2409 09b0 0F91      		pop r16
 2410 09b2 0895      		ret
 2412               	.Lscope20:
 2414               		.stabd	78,0,0
 2418               	.global	vTaskPlaceOnEventList
 2420               	vTaskPlaceOnEventList:
 2421               		.stabd	46,0,0
2974:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
 2423               	.LM282:
 2424               	.LFBB21:
 2425 09b4 CF93      		push r28
 2426 09b6 DF93      		push r29
 2427               	/* prologue: function */
 2428               	/* frame size = 0 */
 2429               	/* stack size = 2 */
 2430               	.L__stack_usage = 2
 2431 09b8 EB01      		movw r28,r22
2984:FreeRTOS/Source/tasks.c **** 
 2433               	.LM283:
 2434 09ba 6091 0000 		lds r22,pxCurrentTCB
 2435 09be 7091 0000 		lds r23,pxCurrentTCB+1
 2436 09c2 645F      		subi r22,-12
 2437 09c4 7F4F      		sbci r23,-1
 2438 09c6 0E94 0000 		call vListInsert
2986:FreeRTOS/Source/tasks.c **** }
 2440               	.LM284:
 2441 09ca 61E0      		ldi r22,lo8(1)
 2442 09cc CE01      		movw r24,r28
 2443               	/* epilogue start */
2987:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2445               	.LM285:
 2446 09ce DF91      		pop r29
 2447 09d0 CF91      		pop r28
2986:FreeRTOS/Source/tasks.c **** }
 2449               	.LM286:
 2450 09d2 0C94 0000 		jmp prvAddCurrentTaskToDelayedList
 2452               	.Lscope21:
 2454               		.stabd	78,0,0
 2459               	.global	vTaskPlaceOnUnorderedEventList
 2461               	vTaskPlaceOnUnorderedEventList:
 2462               		.stabd	46,0,0
2991:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
 2464               	.LM287:
 2465               	.LFBB22:
 2466 09d6 CF93      		push r28
 2467 09d8 DF93      		push r29
 2468               	/* prologue: function */
 2469               	/* frame size = 0 */
 2470               	/* stack size = 2 */
 2471               	.L__stack_usage = 2
 2472 09da EA01      		movw r28,r20
3001:FreeRTOS/Source/tasks.c **** 
 2474               	.LM288:
 2475 09dc E091 0000 		lds r30,pxCurrentTCB
 2476 09e0 F091 0000 		lds r31,pxCurrentTCB+1
 2477 09e4 7068      		ori r23,128
 2478 09e6 7587      		std Z+13,r23
 2479 09e8 6487      		std Z+12,r22
3008:FreeRTOS/Source/tasks.c **** 
 2481               	.LM289:
 2482 09ea 6091 0000 		lds r22,pxCurrentTCB
 2483 09ee 7091 0000 		lds r23,pxCurrentTCB+1
 2484 09f2 645F      		subi r22,-12
 2485 09f4 7F4F      		sbci r23,-1
 2486 09f6 0E94 0000 		call vListInsertEnd
3010:FreeRTOS/Source/tasks.c **** }
 2488               	.LM290:
 2489 09fa 61E0      		ldi r22,lo8(1)
 2490 09fc CE01      		movw r24,r28
 2491               	/* epilogue start */
3011:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2493               	.LM291:
 2494 09fe DF91      		pop r29
 2495 0a00 CF91      		pop r28
3010:FreeRTOS/Source/tasks.c **** }
 2497               	.LM292:
 2498 0a02 0C94 0000 		jmp prvAddCurrentTaskToDelayedList
 2500               	.Lscope22:
 2502               		.stabd	78,0,0
 2505               	.global	xTaskRemoveFromEventList
 2507               	xTaskRemoveFromEventList:
 2508               		.stabd	46,0,0
3048:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2510               	.LM293:
 2511               	.LFBB23:
 2512 0a06 0F93      		push r16
 2513 0a08 1F93      		push r17
 2514 0a0a CF93      		push r28
 2515 0a0c DF93      		push r29
 2516               	/* prologue: function */
 2517               	/* frame size = 0 */
 2518               	/* stack size = 4 */
 2519               	.L__stack_usage = 4
3065:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2521               	.LM294:
 2522 0a0e DC01      		movw r26,r24
 2523 0a10 1596      		adiw r26,5
 2524 0a12 ED91      		ld r30,X+
 2525 0a14 FC91      		ld r31,X
 2526 0a16 1697      		sbiw r26,5+1
 2527 0a18 C681      		ldd r28,Z+6
 2528 0a1a D781      		ldd r29,Z+7
3067:FreeRTOS/Source/tasks.c **** 
 2530               	.LM295:
 2531 0a1c 8E01      		movw r16,r28
 2532 0a1e 045F      		subi r16,-12
 2533 0a20 1F4F      		sbci r17,-1
 2534 0a22 C801      		movw r24,r16
 2535 0a24 0E94 0000 		call uxListRemove
3069:FreeRTOS/Source/tasks.c **** 	{
 2537               	.LM296:
 2538 0a28 8091 0000 		lds r24,uxSchedulerSuspended
 2539 0a2c 8111      		cpse r24,__zero_reg__
 2540 0a2e 00C0      		rjmp .L187
3071:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2542               	.LM297:
 2543 0a30 0A50      		subi r16,10
 2544 0a32 1109      		sbc r17,__zero_reg__
 2545 0a34 C801      		movw r24,r16
 2546 0a36 0E94 0000 		call uxListRemove
3072:FreeRTOS/Source/tasks.c **** 	}
 2548               	.LM298:
 2549 0a3a 8E89      		ldd r24,Y+22
 2550 0a3c 9091 0000 		lds r25,uxTopReadyPriority
 2551 0a40 9817      		cp r25,r24
 2552 0a42 00F4      		brsh .L188
3072:FreeRTOS/Source/tasks.c **** 	}
 2554               	.LM299:
 2555 0a44 8093 0000 		sts uxTopReadyPriority,r24
 2556               	.L188:
3072:FreeRTOS/Source/tasks.c **** 	}
 2558               	.LM300:
 2559 0a48 B9E0      		ldi r27,lo8(9)
 2560 0a4a 8B9F      		mul r24,r27
 2561 0a4c C001      		movw r24,r0
 2562 0a4e 1124      		clr __zero_reg__
 2563 0a50 B801      		movw r22,r16
 2564 0a52 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2565 0a54 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2566 0a56 00C0      		rjmp .L192
 2567               	.L187:
3078:FreeRTOS/Source/tasks.c **** 	}
 2569               	.LM301:
 2570 0a58 B801      		movw r22,r16
 2571 0a5a 80E0      		ldi r24,lo8(xPendingReadyList)
 2572 0a5c 90E0      		ldi r25,hi8(xPendingReadyList)
 2573               	.L192:
 2574 0a5e 0E94 0000 		call vListInsertEnd
3081:FreeRTOS/Source/tasks.c **** 	{
 2576               	.LM302:
 2577 0a62 E091 0000 		lds r30,pxCurrentTCB
 2578 0a66 F091 0000 		lds r31,pxCurrentTCB+1
 2579 0a6a 9E89      		ldd r25,Y+22
 2580 0a6c 8689      		ldd r24,Z+22
 2581 0a6e 8917      		cp r24,r25
 2582 0a70 00F4      		brsh .L191
3090:FreeRTOS/Source/tasks.c **** 	}
 2584               	.LM303:
 2585 0a72 81E0      		ldi r24,lo8(1)
 2586 0a74 8093 0000 		sts xYieldPending,r24
 2587 0a78 00C0      		rjmp .L190
 2588               	.L191:
3094:FreeRTOS/Source/tasks.c **** 	}
 2590               	.LM304:
 2591 0a7a 80E0      		ldi r24,0
 2592               	.L190:
 2593               	/* epilogue start */
3112:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2595               	.LM305:
 2596 0a7c DF91      		pop r29
 2597 0a7e CF91      		pop r28
 2598 0a80 1F91      		pop r17
 2599 0a82 0F91      		pop r16
 2600 0a84 0895      		ret
 2606               	.Lscope23:
 2608               		.stabd	78,0,0
 2612               	.global	vTaskRemoveFromUnorderedEventList
 2614               	vTaskRemoveFromUnorderedEventList:
 2615               		.stabd	46,0,0
3116:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2617               	.LM306:
 2618               	.LFBB24:
 2619 0a86 0F93      		push r16
 2620 0a88 1F93      		push r17
 2621 0a8a CF93      		push r28
 2622 0a8c DF93      		push r29
 2623               	/* prologue: function */
 2624               	/* frame size = 0 */
 2625               	/* stack size = 4 */
 2626               	.L__stack_usage = 4
3124:FreeRTOS/Source/tasks.c **** 
 2628               	.LM307:
 2629 0a8e 7068      		ori r23,128
 2630 0a90 FC01      		movw r30,r24
 2631 0a92 7183      		std Z+1,r23
 2632 0a94 6083      		st Z,r22
3128:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2634               	.LM308:
 2635 0a96 C681      		ldd r28,Z+6
 2636 0a98 D781      		ldd r29,Z+7
3130:FreeRTOS/Source/tasks.c **** 
 2638               	.LM309:
 2639 0a9a 0E94 0000 		call uxListRemove
3135:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2641               	.LM310:
 2642 0a9e 8E01      		movw r16,r28
 2643 0aa0 0E5F      		subi r16,-2
 2644 0aa2 1F4F      		sbci r17,-1
 2645 0aa4 C801      		movw r24,r16
 2646 0aa6 0E94 0000 		call uxListRemove
3136:FreeRTOS/Source/tasks.c **** 
 2648               	.LM311:
 2649 0aaa 8E89      		ldd r24,Y+22
 2650 0aac 9091 0000 		lds r25,uxTopReadyPriority
 2651 0ab0 9817      		cp r25,r24
 2652 0ab2 00F4      		brsh .L194
3136:FreeRTOS/Source/tasks.c **** 
 2654               	.LM312:
 2655 0ab4 8093 0000 		sts uxTopReadyPriority,r24
 2656               	.L194:
3136:FreeRTOS/Source/tasks.c **** 
 2658               	.LM313:
 2659 0ab8 F9E0      		ldi r31,lo8(9)
 2660 0aba 8F9F      		mul r24,r31
 2661 0abc C001      		movw r24,r0
 2662 0abe 1124      		clr __zero_reg__
 2663 0ac0 B801      		movw r22,r16
 2664 0ac2 8050      		subi r24,lo8(-(pxReadyTasksLists))
 2665 0ac4 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 2666 0ac6 0E94 0000 		call vListInsertEnd
3138:FreeRTOS/Source/tasks.c **** 	{
 2668               	.LM314:
 2669 0aca E091 0000 		lds r30,pxCurrentTCB
 2670 0ace F091 0000 		lds r31,pxCurrentTCB+1
 2671 0ad2 9E89      		ldd r25,Y+22
 2672 0ad4 8689      		ldd r24,Z+22
 2673 0ad6 8917      		cp r24,r25
 2674 0ad8 00F4      		brsh .L193
3144:FreeRTOS/Source/tasks.c **** 	}
 2676               	.LM315:
 2677 0ada 81E0      		ldi r24,lo8(1)
 2678 0adc 8093 0000 		sts xYieldPending,r24
 2679               	.L193:
 2680               	/* epilogue start */
3146:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2682               	.LM316:
 2683 0ae0 DF91      		pop r29
 2684 0ae2 CF91      		pop r28
 2685 0ae4 1F91      		pop r17
 2686 0ae6 0F91      		pop r16
 2687 0ae8 0895      		ret
 2692               	.Lscope24:
 2694               		.stabd	78,0,0
 2697               	.global	vTaskSetTimeOutState
 2699               	vTaskSetTimeOutState:
 2700               		.stabd	46,0,0
3150:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
 2702               	.LM317:
 2703               	.LFBB25:
 2704               	/* prologue: function */
 2705               	/* frame size = 0 */
 2706               	/* stack size = 0 */
 2707               	.L__stack_usage = 0
3152:FreeRTOS/Source/tasks.c **** 	{
 2709               	.LM318:
 2710               	/* #APP */
 2711               	 ;  3152 "FreeRTOS/Source/tasks.c" 1
 2712 0aea 0FB6      		in		__tmp_reg__, __SREG__
 2713               	 ;  0 "" 2
 2714               	 ;  3152 "FreeRTOS/Source/tasks.c" 1
 2715 0aec F894      		cli
 2716               	 ;  0 "" 2
 2717               	 ;  3152 "FreeRTOS/Source/tasks.c" 1
 2718 0aee 0F92      		push	__tmp_reg__
 2719               	 ;  0 "" 2
3154:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
 2721               	.LM319:
 2722               	/* #NOAPP */
 2723 0af0 2091 0000 		lds r18,xNumOfOverflows
 2724 0af4 FC01      		movw r30,r24
 2725 0af6 2083      		st Z,r18
3155:FreeRTOS/Source/tasks.c **** 	}
 2727               	.LM320:
 2728 0af8 2091 0000 		lds r18,xTickCount
 2729 0afc 3091 0000 		lds r19,xTickCount+1
 2730 0b00 3283      		std Z+2,r19
 2731 0b02 2183      		std Z+1,r18
3157:FreeRTOS/Source/tasks.c **** }
 2733               	.LM321:
 2734               	/* #APP */
 2735               	 ;  3157 "FreeRTOS/Source/tasks.c" 1
 2736 0b04 0F90      		pop		__tmp_reg__
 2737               	 ;  0 "" 2
 2738               	 ;  3157 "FreeRTOS/Source/tasks.c" 1
 2739 0b06 0FBE      		out		__SREG__, __tmp_reg__
 2740               	 ;  0 "" 2
 2741               	/* #NOAPP */
 2742 0b08 0895      		ret
 2744               	.Lscope25:
 2746               		.stabd	78,0,0
 2749               	.global	vTaskInternalSetTimeOutState
 2751               	vTaskInternalSetTimeOutState:
 2752               		.stabd	46,0,0
3162:FreeRTOS/Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
 2754               	.LM322:
 2755               	.LFBB26:
 2756               	/* prologue: function */
 2757               	/* frame size = 0 */
 2758               	/* stack size = 0 */
 2759               	.L__stack_usage = 0
3164:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2761               	.LM323:
 2762 0b0a 2091 0000 		lds r18,xNumOfOverflows
 2763 0b0e FC01      		movw r30,r24
 2764 0b10 2083      		st Z,r18
3165:FreeRTOS/Source/tasks.c **** }
 2766               	.LM324:
 2767 0b12 2091 0000 		lds r18,xTickCount
 2768 0b16 3091 0000 		lds r19,xTickCount+1
 2769 0b1a 3283      		std Z+2,r19
 2770 0b1c 2183      		std Z+1,r18
 2771 0b1e 0895      		ret
 2773               	.Lscope26:
 2775               		.stabd	78,0,0
 2779               	.global	xTaskCheckForTimeOut
 2781               	xTaskCheckForTimeOut:
 2782               		.stabd	46,0,0
3170:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 2784               	.LM325:
 2785               	.LFBB27:
 2786 0b20 CF93      		push r28
 2787 0b22 DF93      		push r29
 2788               	/* prologue: function */
 2789               	/* frame size = 0 */
 2790               	/* stack size = 2 */
 2791               	.L__stack_usage = 2
3176:FreeRTOS/Source/tasks.c **** 	{
 2793               	.LM326:
 2794               	/* #APP */
 2795               	 ;  3176 "FreeRTOS/Source/tasks.c" 1
 2796 0b24 0FB6      		in		__tmp_reg__, __SREG__
 2797               	 ;  0 "" 2
 2798               	 ;  3176 "FreeRTOS/Source/tasks.c" 1
 2799 0b26 F894      		cli
 2800               	 ;  0 "" 2
 2801               	 ;  3176 "FreeRTOS/Source/tasks.c" 1
 2802 0b28 0F92      		push	__tmp_reg__
 2803               	 ;  0 "" 2
 2804               	/* #NOAPP */
 2805               	.LBB75:
3179:FreeRTOS/Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 2807               	.LM327:
 2808 0b2a 4091 0000 		lds r20,xTickCount
 2809 0b2e 5091 0000 		lds r21,xTickCount+1
3194:FreeRTOS/Source/tasks.c **** 			{
 2811               	.LM328:
 2812 0b32 DB01      		movw r26,r22
 2813 0b34 2D91      		ld r18,X+
 2814 0b36 3C91      		ld r19,X
 2815 0b38 2F3F      		cpi r18,-1
 2816 0b3a BFEF      		ldi r27,-1
 2817 0b3c 3B07      		cpc r19,r27
 2818 0b3e 01F0      		breq .L202
3180:FreeRTOS/Source/tasks.c **** 
 2820               	.LM329:
 2821 0b40 EC01      		movw r28,r24
 2822 0b42 E981      		ldd r30,Y+1
 2823 0b44 FA81      		ldd r31,Y+2
3204:FreeRTOS/Source/tasks.c **** 		{
 2825               	.LM330:
 2826 0b46 A091 0000 		lds r26,xNumOfOverflows
 2827 0b4a B881      		ld r27,Y
 2828 0b4c BA17      		cp r27,r26
 2829 0b4e 01F0      		breq .L200
3204:FreeRTOS/Source/tasks.c **** 		{
 2831               	.LM331:
 2832 0b50 4E17      		cp r20,r30
 2833 0b52 5F07      		cpc r21,r31
 2834 0b54 00F4      		brsh .L203
 2835               	.L200:
3180:FreeRTOS/Source/tasks.c **** 
 2837               	.LM332:
 2838 0b56 4E1B      		sub r20,r30
 2839 0b58 5F0B      		sbc r21,r31
 2840 0b5a FB01      		movw r30,r22
3213:FreeRTOS/Source/tasks.c **** 		{
 2842               	.LM333:
 2843 0b5c 4217      		cp r20,r18
 2844 0b5e 5307      		cpc r21,r19
 2845 0b60 00F4      		brsh .L201
3216:FreeRTOS/Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
 2847               	.LM334:
 2848 0b62 241B      		sub r18,r20
 2849 0b64 350B      		sbc r19,r21
 2850 0b66 3183      		std Z+1,r19
 2851 0b68 2083      		st Z,r18
3217:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2853               	.LM335:
 2854 0b6a 0E94 0000 		call vTaskInternalSetTimeOutState
 2855 0b6e 00C0      		rjmp .L202
 2856               	.L201:
3222:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2858               	.LM336:
 2859 0b70 1182      		std Z+1,__zero_reg__
 2860 0b72 1082      		st Z,__zero_reg__
 2861 0b74 00C0      		rjmp .L203
 2862               	.L202:
3199:FreeRTOS/Source/tasks.c **** 			}
 2864               	.LM337:
 2865 0b76 80E0      		ldi r24,0
 2866 0b78 00C0      		rjmp .L199
 2867               	.L203:
3211:FreeRTOS/Source/tasks.c **** 		}
 2869               	.LM338:
 2870 0b7a 81E0      		ldi r24,lo8(1)
 2871               	.L199:
 2872               	.LBE75:
3226:FreeRTOS/Source/tasks.c **** 
 2874               	.LM339:
 2875               	/* #APP */
 2876               	 ;  3226 "FreeRTOS/Source/tasks.c" 1
 2877 0b7c 0F90      		pop		__tmp_reg__
 2878               	 ;  0 "" 2
 2879               	 ;  3226 "FreeRTOS/Source/tasks.c" 1
 2880 0b7e 0FBE      		out		__SREG__, __tmp_reg__
 2881               	 ;  0 "" 2
 2882               	/* epilogue start */
3229:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2884               	.LM340:
 2885               	/* #NOAPP */
 2886 0b80 DF91      		pop r29
 2887 0b82 CF91      		pop r28
 2888 0b84 0895      		ret
 2897               	.Lscope27:
 2899               		.stabd	78,0,0
 2901               	.global	vTaskMissedYield
 2903               	vTaskMissedYield:
 2904               		.stabd	46,0,0
3233:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
 2906               	.LM341:
 2907               	.LFBB28:
 2908               	/* prologue: function */
 2909               	/* frame size = 0 */
 2910               	/* stack size = 0 */
 2911               	.L__stack_usage = 0
3234:FreeRTOS/Source/tasks.c **** }
 2913               	.LM342:
 2914 0b86 81E0      		ldi r24,lo8(1)
 2915 0b88 8093 0000 		sts xYieldPending,r24
 2916 0b8c 0895      		ret
 2918               	.Lscope28:
 2920               		.stabd	78,0,0
 2922               	.global	xTaskGetCurrentTaskHandle
 2924               	xTaskGetCurrentTaskHandle:
 2925               		.stabd	46,0,0
3820:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
 2927               	.LM343:
 2928               	.LFBB29:
 2929               	/* prologue: function */
 2930               	/* frame size = 0 */
 2931               	/* stack size = 0 */
 2932               	.L__stack_usage = 0
3826:FreeRTOS/Source/tasks.c **** 
 2934               	.LM344:
 2935 0b8e 8091 0000 		lds r24,pxCurrentTCB
 2936 0b92 9091 0000 		lds r25,pxCurrentTCB+1
3829:FreeRTOS/Source/tasks.c **** 
 2938               	.LM345:
 2939 0b96 0895      		ret
 2944               	.Lscope29:
 2946               		.stabd	78,0,0
 2948               	.global	uxTaskResetEventItemValue
 2950               	uxTaskResetEventItemValue:
 2951               		.stabd	46,0,0
4447:FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
 2953               	.LM346:
 2954               	.LFBB30:
 2955               	/* prologue: function */
 2956               	/* frame size = 0 */
 2957               	/* stack size = 0 */
 2958               	.L__stack_usage = 0
4450:FreeRTOS/Source/tasks.c **** 
 2960               	.LM347:
 2961 0b98 E091 0000 		lds r30,pxCurrentTCB
 2962 0b9c F091 0000 		lds r31,pxCurrentTCB+1
 2963 0ba0 8485      		ldd r24,Z+12
 2964 0ba2 9585      		ldd r25,Z+13
4454:FreeRTOS/Source/tasks.c **** 
 2966               	.LM348:
 2967 0ba4 E091 0000 		lds r30,pxCurrentTCB
 2968 0ba8 F091 0000 		lds r31,pxCurrentTCB+1
 2969 0bac A091 0000 		lds r26,pxCurrentTCB
 2970 0bb0 B091 0000 		lds r27,pxCurrentTCB+1
 2971 0bb4 5696      		adiw r26,22
 2972 0bb6 4C91      		ld r20,X
 2973 0bb8 24E0      		ldi r18,lo8(4)
 2974 0bba 30E0      		ldi r19,0
 2975 0bbc 241B      		sub r18,r20
 2976 0bbe 3109      		sbc r19,__zero_reg__
 2977 0bc0 3587      		std Z+13,r19
 2978 0bc2 2487      		std Z+12,r18
4457:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2980               	.LM349:
 2981 0bc4 0895      		ret
 2986               	.Lscope30:
 2988               		.stabd	78,0,0
 2992               	.global	ulTaskNotifyTake
 2994               	ulTaskNotifyTake:
 2995               		.stabd	46,0,0
4480:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
 2997               	.LM350:
 2998               	.LFBB31:
 2999 0bc6 0F93      		push r16
 3000 0bc8 1F93      		push r17
 3001               	/* prologue: function */
 3002               	/* frame size = 0 */
 3003               	/* stack size = 2 */
 3004               	.L__stack_usage = 2
 3005 0bca 182F      		mov r17,r24
 3006 0bcc CB01      		movw r24,r22
4483:FreeRTOS/Source/tasks.c **** 		{
 3008               	.LM351:
 3009               	/* #APP */
 3010               	 ;  4483 "FreeRTOS/Source/tasks.c" 1
 3011 0bce 0FB6      		in		__tmp_reg__, __SREG__
 3012               	 ;  0 "" 2
 3013               	 ;  4483 "FreeRTOS/Source/tasks.c" 1
 3014 0bd0 F894      		cli
 3015               	 ;  0 "" 2
 3016               	 ;  4483 "FreeRTOS/Source/tasks.c" 1
 3017 0bd2 0F92      		push	__tmp_reg__
 3018               	 ;  0 "" 2
4486:FreeRTOS/Source/tasks.c **** 			{
 3020               	.LM352:
 3021               	/* #NOAPP */
 3022 0bd4 E091 0000 		lds r30,pxCurrentTCB
 3023 0bd8 F091 0000 		lds r31,pxCurrentTCB+1
 3024 0bdc 41A1      		ldd r20,Z+33
 3025 0bde 52A1      		ldd r21,Z+34
 3026 0be0 63A1      		ldd r22,Z+35
 3027 0be2 74A1      		ldd r23,Z+36
 3028 0be4 452B      		or r20,r21
 3029 0be6 462B      		or r20,r22
 3030 0be8 472B      		or r20,r23
 3031 0bea 01F4      		brne .L209
4489:FreeRTOS/Source/tasks.c **** 
 3033               	.LM353:
 3034 0bec E091 0000 		lds r30,pxCurrentTCB
 3035 0bf0 F091 0000 		lds r31,pxCurrentTCB+1
 3036 0bf4 21E0      		ldi r18,lo8(1)
 3037 0bf6 25A3      		std Z+37,r18
4491:FreeRTOS/Source/tasks.c **** 				{
 3039               	.LM354:
 3040 0bf8 0097      		sbiw r24,0
 3041 0bfa 01F0      		breq .L209
4493:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
 3043               	.LM355:
 3044 0bfc 61E0      		ldi r22,lo8(1)
 3045 0bfe 0E94 0000 		call prvAddCurrentTaskToDelayedList
4500:FreeRTOS/Source/tasks.c **** 				}
 3047               	.LM356:
 3048 0c02 0E94 0000 		call vPortYield
 3049               	.L209:
4512:FreeRTOS/Source/tasks.c **** 
 3051               	.LM357:
 3052               	/* #APP */
 3053               	 ;  4512 "FreeRTOS/Source/tasks.c" 1
 3054 0c06 0F90      		pop		__tmp_reg__
 3055               	 ;  0 "" 2
 3056               	 ;  4512 "FreeRTOS/Source/tasks.c" 1
 3057 0c08 0FBE      		out		__SREG__, __tmp_reg__
 3058               	 ;  0 "" 2
4514:FreeRTOS/Source/tasks.c **** 		{
 3060               	.LM358:
 3061               	 ;  4514 "FreeRTOS/Source/tasks.c" 1
 3062 0c0a 0FB6      		in		__tmp_reg__, __SREG__
 3063               	 ;  0 "" 2
 3064               	 ;  4514 "FreeRTOS/Source/tasks.c" 1
 3065 0c0c F894      		cli
 3066               	 ;  0 "" 2
 3067               	 ;  4514 "FreeRTOS/Source/tasks.c" 1
 3068 0c0e 0F92      		push	__tmp_reg__
 3069               	 ;  0 "" 2
4517:FreeRTOS/Source/tasks.c **** 
 3071               	.LM359:
 3072               	/* #NOAPP */
 3073 0c10 E091 0000 		lds r30,pxCurrentTCB
 3074 0c14 F091 0000 		lds r31,pxCurrentTCB+1
 3075 0c18 61A1      		ldd r22,Z+33
 3076 0c1a 72A1      		ldd r23,Z+34
 3077 0c1c 83A1      		ldd r24,Z+35
 3078 0c1e 94A1      		ldd r25,Z+36
4519:FreeRTOS/Source/tasks.c **** 			{
 3080               	.LM360:
 3081 0c20 6115      		cp r22,__zero_reg__
 3082 0c22 7105      		cpc r23,__zero_reg__
 3083 0c24 8105      		cpc r24,__zero_reg__
 3084 0c26 9105      		cpc r25,__zero_reg__
 3085 0c28 01F0      		breq .L211
4523:FreeRTOS/Source/tasks.c **** 				}
 3087               	.LM361:
 3088 0c2a E091 0000 		lds r30,pxCurrentTCB
 3089 0c2e F091 0000 		lds r31,pxCurrentTCB+1
4521:FreeRTOS/Source/tasks.c **** 				{
 3091               	.LM362:
 3092 0c32 1123      		tst r17
 3093 0c34 01F0      		breq .L212
4523:FreeRTOS/Source/tasks.c **** 				}
 3095               	.LM363:
 3096 0c36 11A2      		std Z+33,__zero_reg__
 3097 0c38 12A2      		std Z+34,__zero_reg__
 3098 0c3a 13A2      		std Z+35,__zero_reg__
 3099 0c3c 14A2      		std Z+36,__zero_reg__
 3100 0c3e 00C0      		rjmp .L211
 3101               	.L212:
4527:FreeRTOS/Source/tasks.c **** 				}
 3103               	.LM364:
 3104 0c40 8B01      		movw r16,r22
 3105 0c42 9C01      		movw r18,r24
 3106 0c44 0150      		subi r16,1
 3107 0c46 1109      		sbc r17,__zero_reg__
 3108 0c48 2109      		sbc r18,__zero_reg__
 3109 0c4a 3109      		sbc r19,__zero_reg__
 3110 0c4c 01A3      		std Z+33,r16
 3111 0c4e 12A3      		std Z+34,r17
 3112 0c50 23A3      		std Z+35,r18
 3113 0c52 34A3      		std Z+36,r19
 3114               	.L211:
4535:FreeRTOS/Source/tasks.c **** 		}
 3116               	.LM365:
 3117 0c54 E091 0000 		lds r30,pxCurrentTCB
 3118 0c58 F091 0000 		lds r31,pxCurrentTCB+1
 3119 0c5c 15A2      		std Z+37,__zero_reg__
4537:FreeRTOS/Source/tasks.c **** 
 3121               	.LM366:
 3122               	/* #APP */
 3123               	 ;  4537 "FreeRTOS/Source/tasks.c" 1
 3124 0c5e 0F90      		pop		__tmp_reg__
 3125               	 ;  0 "" 2
 3126               	 ;  4537 "FreeRTOS/Source/tasks.c" 1
 3127 0c60 0FBE      		out		__SREG__, __tmp_reg__
 3128               	 ;  0 "" 2
 3129               	/* epilogue start */
4540:FreeRTOS/Source/tasks.c **** 
 3131               	.LM367:
 3132               	/* #NOAPP */
 3133 0c62 1F91      		pop r17
 3134 0c64 0F91      		pop r16
 3135 0c66 0895      		ret
 3140               	.Lscope31:
 3142               		.stabd	78,0,0
 3148               	.global	xTaskNotifyWait
 3150               	xTaskNotifyWait:
 3151               		.stabd	46,0,0
4548:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
 3153               	.LM368:
 3154               	.LFBB32:
 3155 0c68 4F92      		push r4
 3156 0c6a 5F92      		push r5
 3157 0c6c 6F92      		push r6
 3158 0c6e 7F92      		push r7
 3159 0c70 8F92      		push r8
 3160 0c72 9F92      		push r9
 3161 0c74 AF92      		push r10
 3162 0c76 BF92      		push r11
 3163 0c78 EF92      		push r14
 3164 0c7a FF92      		push r15
 3165 0c7c 0F93      		push r16
 3166 0c7e 1F93      		push r17
 3167               	/* prologue: function */
 3168               	/* frame size = 0 */
 3169               	/* stack size = 12 */
 3170               	.L__stack_usage = 12
 3171 0c80 4901      		movw r8,r18
 3172 0c82 5A01      		movw r10,r20
4551:FreeRTOS/Source/tasks.c **** 		{
 3174               	.LM369:
 3175               	/* #APP */
 3176               	 ;  4551 "FreeRTOS/Source/tasks.c" 1
 3177 0c84 0FB6      		in		__tmp_reg__, __SREG__
 3178               	 ;  0 "" 2
 3179               	 ;  4551 "FreeRTOS/Source/tasks.c" 1
 3180 0c86 F894      		cli
 3181               	 ;  0 "" 2
 3182               	 ;  4551 "FreeRTOS/Source/tasks.c" 1
 3183 0c88 0F92      		push	__tmp_reg__
 3184               	 ;  0 "" 2
4554:FreeRTOS/Source/tasks.c **** 			{
 3186               	.LM370:
 3187               	/* #NOAPP */
 3188 0c8a E091 0000 		lds r30,pxCurrentTCB
 3189 0c8e F091 0000 		lds r31,pxCurrentTCB+1
 3190 0c92 25A1      		ldd r18,Z+37
 3191 0c94 2230      		cpi r18,lo8(2)
 3192 0c96 01F0      		breq .L221
4559:FreeRTOS/Source/tasks.c **** 
 3194               	.LM371:
 3195 0c98 E091 0000 		lds r30,pxCurrentTCB
 3196 0c9c F091 0000 		lds r31,pxCurrentTCB+1
 3197 0ca0 21A1      		ldd r18,Z+33
 3198 0ca2 32A1      		ldd r19,Z+34
 3199 0ca4 43A1      		ldd r20,Z+35
 3200 0ca6 54A1      		ldd r21,Z+36
 3201 0ca8 2B01      		movw r4,r22
 3202 0caa 3C01      		movw r6,r24
 3203 0cac 4094      		com r4
 3204 0cae 5094      		com r5
 3205 0cb0 6094      		com r6
 3206 0cb2 7094      		com r7
 3207 0cb4 D301      		movw r26,r6
 3208 0cb6 C201      		movw r24,r4
 3209 0cb8 8223      		and r24,r18
 3210 0cba 9323      		and r25,r19
 3211 0cbc A423      		and r26,r20
 3212 0cbe B523      		and r27,r21
 3213 0cc0 81A3      		std Z+33,r24
 3214 0cc2 92A3      		std Z+34,r25
 3215 0cc4 A3A3      		std Z+35,r26
 3216 0cc6 B4A3      		std Z+36,r27
4562:FreeRTOS/Source/tasks.c **** 
 3218               	.LM372:
 3219 0cc8 E091 0000 		lds r30,pxCurrentTCB
 3220 0ccc F091 0000 		lds r31,pxCurrentTCB+1
 3221 0cd0 81E0      		ldi r24,lo8(1)
 3222 0cd2 85A3      		std Z+37,r24
4564:FreeRTOS/Source/tasks.c **** 				{
 3224               	.LM373:
 3225 0cd4 E114      		cp r14,__zero_reg__
 3226 0cd6 F104      		cpc r15,__zero_reg__
 3227 0cd8 01F0      		breq .L221
4566:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
 3229               	.LM374:
 3230 0cda 61E0      		ldi r22,lo8(1)
 3231 0cdc C701      		movw r24,r14
 3232 0cde 0E94 0000 		call prvAddCurrentTaskToDelayedList
4573:FreeRTOS/Source/tasks.c **** 				}
 3234               	.LM375:
 3235 0ce2 0E94 0000 		call vPortYield
 3236               	.L221:
4585:FreeRTOS/Source/tasks.c **** 
 3238               	.LM376:
 3239               	/* #APP */
 3240               	 ;  4585 "FreeRTOS/Source/tasks.c" 1
 3241 0ce6 0F90      		pop		__tmp_reg__
 3242               	 ;  0 "" 2
 3243               	 ;  4585 "FreeRTOS/Source/tasks.c" 1
 3244 0ce8 0FBE      		out		__SREG__, __tmp_reg__
 3245               	 ;  0 "" 2
4587:FreeRTOS/Source/tasks.c **** 		{
 3247               	.LM377:
 3248               	 ;  4587 "FreeRTOS/Source/tasks.c" 1
 3249 0cea 0FB6      		in		__tmp_reg__, __SREG__
 3250               	 ;  0 "" 2
 3251               	 ;  4587 "FreeRTOS/Source/tasks.c" 1
 3252 0cec F894      		cli
 3253               	 ;  0 "" 2
 3254               	 ;  4587 "FreeRTOS/Source/tasks.c" 1
 3255 0cee 0F92      		push	__tmp_reg__
 3256               	 ;  0 "" 2
4591:FreeRTOS/Source/tasks.c **** 			{
 3258               	.LM378:
 3259               	/* #NOAPP */
 3260 0cf0 0115      		cp r16,__zero_reg__
 3261 0cf2 1105      		cpc r17,__zero_reg__
 3262 0cf4 01F0      		breq .L223
4595:FreeRTOS/Source/tasks.c **** 			}
 3264               	.LM379:
 3265 0cf6 E091 0000 		lds r30,pxCurrentTCB
 3266 0cfa F091 0000 		lds r31,pxCurrentTCB+1
 3267 0cfe 81A1      		ldd r24,Z+33
 3268 0d00 92A1      		ldd r25,Z+34
 3269 0d02 A3A1      		ldd r26,Z+35
 3270 0d04 B4A1      		ldd r27,Z+36
 3271 0d06 F801      		movw r30,r16
 3272 0d08 8083      		st Z,r24
 3273 0d0a 9183      		std Z+1,r25
 3274 0d0c A283      		std Z+2,r26
 3275 0d0e B383      		std Z+3,r27
 3276               	.L223:
4602:FreeRTOS/Source/tasks.c **** 			{
 3278               	.LM380:
 3279 0d10 E091 0000 		lds r30,pxCurrentTCB
 3280 0d14 F091 0000 		lds r31,pxCurrentTCB+1
 3281 0d18 85A1      		ldd r24,Z+37
 3282 0d1a 8230      		cpi r24,lo8(2)
 3283 0d1c 01F4      		brne .L225
4611:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
 3285               	.LM381:
 3286 0d1e E091 0000 		lds r30,pxCurrentTCB
 3287 0d22 F091 0000 		lds r31,pxCurrentTCB+1
 3288 0d26 41A1      		ldd r20,Z+33
 3289 0d28 52A1      		ldd r21,Z+34
 3290 0d2a 63A1      		ldd r22,Z+35
 3291 0d2c 74A1      		ldd r23,Z+36
 3292 0d2e D501      		movw r26,r10
 3293 0d30 C401      		movw r24,r8
 3294 0d32 8095      		com r24
 3295 0d34 9095      		com r25
 3296 0d36 A095      		com r26
 3297 0d38 B095      		com r27
 3298 0d3a 8423      		and r24,r20
 3299 0d3c 9523      		and r25,r21
 3300 0d3e A623      		and r26,r22
 3301 0d40 B723      		and r27,r23
 3302 0d42 81A3      		std Z+33,r24
 3303 0d44 92A3      		std Z+34,r25
 3304 0d46 A3A3      		std Z+35,r26
 3305 0d48 B4A3      		std Z+36,r27
4612:FreeRTOS/Source/tasks.c **** 			}
 3307               	.LM382:
 3308 0d4a 81E0      		ldi r24,lo8(1)
 3309 0d4c 00C0      		rjmp .L224
 3310               	.L225:
4605:FreeRTOS/Source/tasks.c **** 			}
 3312               	.LM383:
 3313 0d4e 80E0      		ldi r24,0
 3314               	.L224:
4615:FreeRTOS/Source/tasks.c **** 		}
 3316               	.LM384:
 3317 0d50 E091 0000 		lds r30,pxCurrentTCB
 3318 0d54 F091 0000 		lds r31,pxCurrentTCB+1
 3319 0d58 15A2      		std Z+37,__zero_reg__
4617:FreeRTOS/Source/tasks.c **** 
 3321               	.LM385:
 3322               	/* #APP */
 3323               	 ;  4617 "FreeRTOS/Source/tasks.c" 1
 3324 0d5a 0F90      		pop		__tmp_reg__
 3325               	 ;  0 "" 2
 3326               	 ;  4617 "FreeRTOS/Source/tasks.c" 1
 3327 0d5c 0FBE      		out		__SREG__, __tmp_reg__
 3328               	 ;  0 "" 2
 3329               	/* epilogue start */
4620:FreeRTOS/Source/tasks.c **** 
 3331               	.LM386:
 3332               	/* #NOAPP */
 3333 0d5e 1F91      		pop r17
 3334 0d60 0F91      		pop r16
 3335 0d62 FF90      		pop r15
 3336 0d64 EF90      		pop r14
 3337 0d66 BF90      		pop r11
 3338 0d68 AF90      		pop r10
 3339 0d6a 9F90      		pop r9
 3340 0d6c 8F90      		pop r8
 3341 0d6e 7F90      		pop r7
 3342 0d70 6F90      		pop r6
 3343 0d72 5F90      		pop r5
 3344 0d74 4F90      		pop r4
 3345 0d76 0895      		ret
 3350               	.Lscope32:
 3352               		.stabd	78,0,0
 3358               	.global	xTaskGenericNotify
 3360               	xTaskGenericNotify:
 3361               		.stabd	46,0,0
4628:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3363               	.LM387:
 3364               	.LFBB33:
 3365 0d78 0F93      		push r16
 3366 0d7a 1F93      		push r17
 3367 0d7c CF93      		push r28
 3368 0d7e DF93      		push r29
 3369               	/* prologue: function */
 3370               	/* frame size = 0 */
 3371               	/* stack size = 4 */
 3372               	.L__stack_usage = 4
 3373 0d80 FC01      		movw r30,r24
4636:FreeRTOS/Source/tasks.c **** 		{
 3375               	.LM388:
 3376               	/* #APP */
 3377               	 ;  4636 "FreeRTOS/Source/tasks.c" 1
 3378 0d82 0FB6      		in		__tmp_reg__, __SREG__
 3379               	 ;  0 "" 2
 3380               	 ;  4636 "FreeRTOS/Source/tasks.c" 1
 3381 0d84 F894      		cli
 3382               	 ;  0 "" 2
 3383               	 ;  4636 "FreeRTOS/Source/tasks.c" 1
 3384 0d86 0F92      		push	__tmp_reg__
 3385               	 ;  0 "" 2
4638:FreeRTOS/Source/tasks.c **** 			{
 3387               	.LM389:
 3388               	/* #NOAPP */
 3389 0d88 0115      		cp r16,__zero_reg__
 3390 0d8a 1105      		cpc r17,__zero_reg__
 3391 0d8c 01F0      		breq .L233
4640:FreeRTOS/Source/tasks.c **** 			}
 3393               	.LM390:
 3394 0d8e 81A1      		ldd r24,Z+33
 3395 0d90 92A1      		ldd r25,Z+34
 3396 0d92 A3A1      		ldd r26,Z+35
 3397 0d94 B4A1      		ldd r27,Z+36
 3398 0d96 E801      		movw r28,r16
 3399 0d98 8883      		st Y,r24
 3400 0d9a 9983      		std Y+1,r25
 3401 0d9c AA83      		std Y+2,r26
 3402 0d9e BB83      		std Y+3,r27
 3403               	.L233:
4643:FreeRTOS/Source/tasks.c **** 
 3405               	.LM391:
 3406 0da0 35A1      		ldd r19,Z+37
4645:FreeRTOS/Source/tasks.c **** 
 3408               	.LM392:
 3409 0da2 82E0      		ldi r24,lo8(2)
 3410 0da4 85A3      		std Z+37,r24
4647:FreeRTOS/Source/tasks.c **** 			{
 3412               	.LM393:
 3413 0da6 2230      		cpi r18,lo8(2)
 3414 0da8 01F0      		breq .L235
 3415 0daa 00F4      		brsh .L236
 3416 0dac 2130      		cpi r18,lo8(1)
 3417 0dae 01F4      		brne .L234
4650:FreeRTOS/Source/tasks.c **** 					break;
 3419               	.LM394:
 3420 0db0 81A1      		ldd r24,Z+33
 3421 0db2 92A1      		ldd r25,Z+34
 3422 0db4 A3A1      		ldd r26,Z+35
 3423 0db6 B4A1      		ldd r27,Z+36
 3424 0db8 482B      		or r20,r24
 3425 0dba 592B      		or r21,r25
 3426 0dbc 6A2B      		or r22,r26
 3427 0dbe 7B2B      		or r23,r27
 3428 0dc0 00C0      		rjmp .L248
 3429               	.L236:
4647:FreeRTOS/Source/tasks.c **** 			{
 3431               	.LM395:
 3432 0dc2 2330      		cpi r18,lo8(3)
 3433 0dc4 01F0      		breq .L248
 3434 0dc6 2430      		cpi r18,lo8(4)
 3435 0dc8 01F0      		breq .L239
 3436 0dca 00C0      		rjmp .L234
 3437               	.L235:
4654:FreeRTOS/Source/tasks.c **** 					break;
 3439               	.LM396:
 3440 0dcc 81A1      		ldd r24,Z+33
 3441 0dce 92A1      		ldd r25,Z+34
 3442 0dd0 A3A1      		ldd r26,Z+35
 3443 0dd2 B4A1      		ldd r27,Z+36
 3444 0dd4 0196      		adiw r24,1
 3445 0dd6 A11D      		adc r26,__zero_reg__
 3446 0dd8 B11D      		adc r27,__zero_reg__
 3447 0dda 81A3      		std Z+33,r24
 3448 0ddc 92A3      		std Z+34,r25
 3449 0dde A3A3      		std Z+35,r26
 3450 0de0 B4A3      		std Z+36,r27
4655:FreeRTOS/Source/tasks.c **** 
 3452               	.LM397:
 3453 0de2 00C0      		rjmp .L234
 3454               	.L239:
4662:FreeRTOS/Source/tasks.c **** 					{
 3456               	.LM398:
 3457 0de4 3230      		cpi r19,lo8(2)
 3458 0de6 01F0      		breq .L244
 3459               	.L248:
4664:FreeRTOS/Source/tasks.c **** 					}
 3461               	.LM399:
 3462 0de8 41A3      		std Z+33,r20
 3463 0dea 52A3      		std Z+34,r21
 3464 0dec 63A3      		std Z+35,r22
 3465 0dee 74A3      		std Z+36,r23
 3466               	.L234:
4691:FreeRTOS/Source/tasks.c **** 			{
 3468               	.LM400:
 3469 0df0 3130      		cpi r19,lo8(1)
 3470 0df2 01F4      		brne .L249
 3471 0df4 EF01      		movw r28,r30
4693:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 3473               	.LM401:
 3474 0df6 8F01      		movw r16,r30
 3475 0df8 0E5F      		subi r16,-2
 3476 0dfa 1F4F      		sbci r17,-1
 3477 0dfc C801      		movw r24,r16
 3478 0dfe 0E94 0000 		call uxListRemove
4694:FreeRTOS/Source/tasks.c **** 
 3480               	.LM402:
 3481 0e02 8E89      		ldd r24,Y+22
 3482 0e04 9091 0000 		lds r25,uxTopReadyPriority
 3483 0e08 9817      		cp r25,r24
 3484 0e0a 00F4      		brsh .L242
4694:FreeRTOS/Source/tasks.c **** 
 3486               	.LM403:
 3487 0e0c 8093 0000 		sts uxTopReadyPriority,r24
 3488               	.L242:
4694:FreeRTOS/Source/tasks.c **** 
 3490               	.LM404:
 3491 0e10 29E0      		ldi r18,lo8(9)
 3492 0e12 829F      		mul r24,r18
 3493 0e14 C001      		movw r24,r0
 3494 0e16 1124      		clr __zero_reg__
 3495 0e18 B801      		movw r22,r16
 3496 0e1a 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3497 0e1c 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3498 0e1e 0E94 0000 		call vListInsertEnd
4715:FreeRTOS/Source/tasks.c **** 				{
 3500               	.LM405:
 3501 0e22 E091 0000 		lds r30,pxCurrentTCB
 3502 0e26 F091 0000 		lds r31,pxCurrentTCB+1
 3503 0e2a 9E89      		ldd r25,Y+22
 3504 0e2c 8689      		ldd r24,Z+22
 3505 0e2e 8917      		cp r24,r25
 3506 0e30 00F4      		brsh .L249
4719:FreeRTOS/Source/tasks.c **** 				}
 3508               	.LM406:
 3509 0e32 0E94 0000 		call vPortYield
 3510               	.L249:
 3511 0e36 81E0      		ldi r24,lo8(1)
 3512 0e38 00C0      		rjmp .L240
 3513               	.L244:
4669:FreeRTOS/Source/tasks.c **** 					}
 3515               	.LM407:
 3516 0e3a 80E0      		ldi r24,0
 3517               	.L240:
4731:FreeRTOS/Source/tasks.c **** 
 3519               	.LM408:
 3520               	/* #APP */
 3521               	 ;  4731 "FreeRTOS/Source/tasks.c" 1
 3522 0e3c 0F90      		pop		__tmp_reg__
 3523               	 ;  0 "" 2
 3524               	 ;  4731 "FreeRTOS/Source/tasks.c" 1
 3525 0e3e 0FBE      		out		__SREG__, __tmp_reg__
 3526               	 ;  0 "" 2
 3527               	/* epilogue start */
4734:FreeRTOS/Source/tasks.c **** 
 3529               	.LM409:
 3530               	/* #NOAPP */
 3531 0e40 DF91      		pop r29
 3532 0e42 CF91      		pop r28
 3533 0e44 1F91      		pop r17
 3534 0e46 0F91      		pop r16
 3535 0e48 0895      		ret
 3541               	.Lscope33:
 3543               		.stabd	78,0,0
 3550               	.global	xTaskGenericNotifyFromISR
 3552               	xTaskGenericNotifyFromISR:
 3553               		.stabd	46,0,0
4742:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3555               	.LM410:
 3556               	.LFBB34:
 3557 0e4a EF92      		push r14
 3558 0e4c FF92      		push r15
 3559 0e4e 0F93      		push r16
 3560 0e50 1F93      		push r17
 3561 0e52 CF93      		push r28
 3562 0e54 DF93      		push r29
 3563               	/* prologue: function */
 3564               	/* frame size = 0 */
 3565               	/* stack size = 6 */
 3566               	.L__stack_usage = 6
 3567 0e56 FC01      		movw r30,r24
4772:FreeRTOS/Source/tasks.c **** 			{
 3569               	.LM411:
 3570 0e58 0115      		cp r16,__zero_reg__
 3571 0e5a 1105      		cpc r17,__zero_reg__
 3572 0e5c 01F0      		breq .L251
4774:FreeRTOS/Source/tasks.c **** 			}
 3574               	.LM412:
 3575 0e5e 81A1      		ldd r24,Z+33
 3576 0e60 92A1      		ldd r25,Z+34
 3577 0e62 A3A1      		ldd r26,Z+35
 3578 0e64 B4A1      		ldd r27,Z+36
 3579 0e66 E801      		movw r28,r16
 3580 0e68 8883      		st Y,r24
 3581 0e6a 9983      		std Y+1,r25
 3582 0e6c AA83      		std Y+2,r26
 3583 0e6e BB83      		std Y+3,r27
 3584               	.L251:
4777:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 3586               	.LM413:
 3587 0e70 35A1      		ldd r19,Z+37
4778:FreeRTOS/Source/tasks.c **** 
 3589               	.LM414:
 3590 0e72 82E0      		ldi r24,lo8(2)
 3591 0e74 85A3      		std Z+37,r24
4780:FreeRTOS/Source/tasks.c **** 			{
 3593               	.LM415:
 3594 0e76 2230      		cpi r18,lo8(2)
 3595 0e78 01F0      		breq .L253
 3596 0e7a 00F4      		brsh .L254
 3597 0e7c 2130      		cpi r18,lo8(1)
 3598 0e7e 01F4      		brne .L252
4783:FreeRTOS/Source/tasks.c **** 					break;
 3600               	.LM416:
 3601 0e80 81A1      		ldd r24,Z+33
 3602 0e82 92A1      		ldd r25,Z+34
 3603 0e84 A3A1      		ldd r26,Z+35
 3604 0e86 B4A1      		ldd r27,Z+36
 3605 0e88 482B      		or r20,r24
 3606 0e8a 592B      		or r21,r25
 3607 0e8c 6A2B      		or r22,r26
 3608 0e8e 7B2B      		or r23,r27
 3609 0e90 00C0      		rjmp .L272
 3610               	.L254:
4780:FreeRTOS/Source/tasks.c **** 			{
 3612               	.LM417:
 3613 0e92 2330      		cpi r18,lo8(3)
 3614 0e94 01F0      		breq .L272
 3615 0e96 2430      		cpi r18,lo8(4)
 3616 0e98 01F0      		breq .L257
 3617 0e9a 00C0      		rjmp .L252
 3618               	.L253:
4787:FreeRTOS/Source/tasks.c **** 					break;
 3620               	.LM418:
 3621 0e9c 81A1      		ldd r24,Z+33
 3622 0e9e 92A1      		ldd r25,Z+34
 3623 0ea0 A3A1      		ldd r26,Z+35
 3624 0ea2 B4A1      		ldd r27,Z+36
 3625 0ea4 0196      		adiw r24,1
 3626 0ea6 A11D      		adc r26,__zero_reg__
 3627 0ea8 B11D      		adc r27,__zero_reg__
 3628 0eaa 81A3      		std Z+33,r24
 3629 0eac 92A3      		std Z+34,r25
 3630 0eae A3A3      		std Z+35,r26
 3631 0eb0 B4A3      		std Z+36,r27
4788:FreeRTOS/Source/tasks.c **** 
 3633               	.LM419:
 3634 0eb2 00C0      		rjmp .L252
 3635               	.L257:
4795:FreeRTOS/Source/tasks.c **** 					{
 3637               	.LM420:
 3638 0eb4 3230      		cpi r19,lo8(2)
 3639 0eb6 01F0      		breq .L265
 3640               	.L272:
4797:FreeRTOS/Source/tasks.c **** 					}
 3642               	.LM421:
 3643 0eb8 41A3      		std Z+33,r20
 3644 0eba 52A3      		std Z+34,r21
 3645 0ebc 63A3      		std Z+35,r22
 3646 0ebe 74A3      		std Z+36,r23
 3647               	.L252:
4823:FreeRTOS/Source/tasks.c **** 			{
 3649               	.LM422:
 3650 0ec0 3130      		cpi r19,lo8(1)
 3651 0ec2 01F0      		breq .L259
 3652               	.L263:
4742:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3654               	.LM423:
 3655 0ec4 81E0      		ldi r24,lo8(1)
 3656 0ec6 00C0      		rjmp .L258
 3657               	.L259:
 3658 0ec8 EF01      		movw r28,r30
4828:FreeRTOS/Source/tasks.c **** 				{
 3660               	.LM424:
 3661 0eca 8091 0000 		lds r24,uxSchedulerSuspended
 3662 0ece 8111      		cpse r24,__zero_reg__
 3663 0ed0 00C0      		rjmp .L260
4830:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3665               	.LM425:
 3666 0ed2 8F01      		movw r16,r30
 3667 0ed4 0E5F      		subi r16,-2
 3668 0ed6 1F4F      		sbci r17,-1
 3669 0ed8 C801      		movw r24,r16
 3670 0eda 0E94 0000 		call uxListRemove
4831:FreeRTOS/Source/tasks.c **** 				}
 3672               	.LM426:
 3673 0ede 8E89      		ldd r24,Y+22
 3674 0ee0 9091 0000 		lds r25,uxTopReadyPriority
 3675 0ee4 9817      		cp r25,r24
 3676 0ee6 00F4      		brsh .L261
4831:FreeRTOS/Source/tasks.c **** 				}
 3678               	.LM427:
 3679 0ee8 8093 0000 		sts uxTopReadyPriority,r24
 3680               	.L261:
4831:FreeRTOS/Source/tasks.c **** 				}
 3682               	.LM428:
 3683 0eec E9E0      		ldi r30,lo8(9)
 3684 0eee 8E9F      		mul r24,r30
 3685 0ef0 C001      		movw r24,r0
 3686 0ef2 1124      		clr __zero_reg__
 3687 0ef4 B801      		movw r22,r16
 3688 0ef6 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3689 0ef8 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3690 0efa 00C0      		rjmp .L273
 3691               	.L260:
4837:FreeRTOS/Source/tasks.c **** 				}
 3693               	.LM429:
 3694 0efc BF01      		movw r22,r30
 3695 0efe 645F      		subi r22,-12
 3696 0f00 7F4F      		sbci r23,-1
 3697 0f02 80E0      		ldi r24,lo8(xPendingReadyList)
 3698 0f04 90E0      		ldi r25,hi8(xPendingReadyList)
 3699               	.L273:
 3700 0f06 0E94 0000 		call vListInsertEnd
4840:FreeRTOS/Source/tasks.c **** 				{
 3702               	.LM430:
 3703 0f0a E091 0000 		lds r30,pxCurrentTCB
 3704 0f0e F091 0000 		lds r31,pxCurrentTCB+1
 3705 0f12 9E89      		ldd r25,Y+22
 3706 0f14 8689      		ldd r24,Z+22
 3707 0f16 8917      		cp r24,r25
 3708 0f18 00F4      		brsh .L263
4844:FreeRTOS/Source/tasks.c **** 					{
 3710               	.LM431:
 3711 0f1a E114      		cp r14,__zero_reg__
 3712 0f1c F104      		cpc r15,__zero_reg__
 3713 0f1e 01F0      		breq .L264
4846:FreeRTOS/Source/tasks.c **** 					}
 3715               	.LM432:
 3716 0f20 81E0      		ldi r24,lo8(1)
 3717 0f22 E701      		movw r28,r14
 3718 0f24 8883      		st Y,r24
 3719               	.L264:
4852:FreeRTOS/Source/tasks.c **** 				}
 3721               	.LM433:
 3722 0f26 81E0      		ldi r24,lo8(1)
 3723 0f28 8093 0000 		sts xYieldPending,r24
 3724 0f2c 00C0      		rjmp .L258
 3725               	.L265:
4802:FreeRTOS/Source/tasks.c **** 					}
 3727               	.LM434:
 3728 0f2e 80E0      		ldi r24,0
 3729               	.L258:
 3730               	/* epilogue start */
4863:FreeRTOS/Source/tasks.c **** 
 3732               	.LM435:
 3733 0f30 DF91      		pop r29
 3734 0f32 CF91      		pop r28
 3735 0f34 1F91      		pop r17
 3736 0f36 0F91      		pop r16
 3737 0f38 FF90      		pop r15
 3738 0f3a EF90      		pop r14
 3739 0f3c 0895      		ret
 3745               	.Lscope34:
 3747               		.stabd	78,0,0
 3751               	.global	vTaskNotifyGiveFromISR
 3753               	vTaskNotifyGiveFromISR:
 3754               		.stabd	46,0,0
4871:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 3756               	.LM436:
 3757               	.LFBB35:
 3758 0f3e EF92      		push r14
 3759 0f40 FF92      		push r15
 3760 0f42 0F93      		push r16
 3761 0f44 1F93      		push r17
 3762 0f46 CF93      		push r28
 3763 0f48 DF93      		push r29
 3764               	/* prologue: function */
 3765               	/* frame size = 0 */
 3766               	/* stack size = 6 */
 3767               	.L__stack_usage = 6
 3768 0f4a FC01      		movw r30,r24
4900:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 3770               	.LM437:
 3771 0f4c 25A1      		ldd r18,Z+37
4901:FreeRTOS/Source/tasks.c **** 
 3773               	.LM438:
 3774 0f4e 82E0      		ldi r24,lo8(2)
 3775 0f50 85A3      		std Z+37,r24
4905:FreeRTOS/Source/tasks.c **** 
 3777               	.LM439:
 3778 0f52 81A1      		ldd r24,Z+33
 3779 0f54 92A1      		ldd r25,Z+34
 3780 0f56 A3A1      		ldd r26,Z+35
 3781 0f58 B4A1      		ldd r27,Z+36
 3782 0f5a 0196      		adiw r24,1
 3783 0f5c A11D      		adc r26,__zero_reg__
 3784 0f5e B11D      		adc r27,__zero_reg__
 3785 0f60 81A3      		std Z+33,r24
 3786 0f62 92A3      		std Z+34,r25
 3787 0f64 A3A3      		std Z+35,r26
 3788 0f66 B4A3      		std Z+36,r27
4911:FreeRTOS/Source/tasks.c **** 			{
 3790               	.LM440:
 3791 0f68 2130      		cpi r18,lo8(1)
 3792 0f6a 01F4      		brne .L274
 3793 0f6c 8B01      		movw r16,r22
 3794 0f6e EF01      		movw r28,r30
4916:FreeRTOS/Source/tasks.c **** 				{
 3796               	.LM441:
 3797 0f70 8091 0000 		lds r24,uxSchedulerSuspended
 3798 0f74 8111      		cpse r24,__zero_reg__
 3799 0f76 00C0      		rjmp .L277
4918:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3801               	.LM442:
 3802 0f78 7F01      		movw r14,r30
 3803 0f7a 22E0      		ldi r18,2
 3804 0f7c E20E      		add r14,r18
 3805 0f7e F11C      		adc r15,__zero_reg__
 3806 0f80 C701      		movw r24,r14
 3807 0f82 0E94 0000 		call uxListRemove
4919:FreeRTOS/Source/tasks.c **** 				}
 3809               	.LM443:
 3810 0f86 8E89      		ldd r24,Y+22
 3811 0f88 9091 0000 		lds r25,uxTopReadyPriority
 3812 0f8c 9817      		cp r25,r24
 3813 0f8e 00F4      		brsh .L278
4919:FreeRTOS/Source/tasks.c **** 				}
 3815               	.LM444:
 3816 0f90 8093 0000 		sts uxTopReadyPriority,r24
 3817               	.L278:
4919:FreeRTOS/Source/tasks.c **** 				}
 3819               	.LM445:
 3820 0f94 E9E0      		ldi r30,lo8(9)
 3821 0f96 8E9F      		mul r24,r30
 3822 0f98 C001      		movw r24,r0
 3823 0f9a 1124      		clr __zero_reg__
 3824 0f9c B701      		movw r22,r14
 3825 0f9e 8050      		subi r24,lo8(-(pxReadyTasksLists))
 3826 0fa0 9040      		sbci r25,hi8(-(pxReadyTasksLists))
 3827 0fa2 00C0      		rjmp .L285
 3828               	.L277:
4925:FreeRTOS/Source/tasks.c **** 				}
 3830               	.LM446:
 3831 0fa4 BF01      		movw r22,r30
 3832 0fa6 645F      		subi r22,-12
 3833 0fa8 7F4F      		sbci r23,-1
 3834 0faa 80E0      		ldi r24,lo8(xPendingReadyList)
 3835 0fac 90E0      		ldi r25,hi8(xPendingReadyList)
 3836               	.L285:
 3837 0fae 0E94 0000 		call vListInsertEnd
4928:FreeRTOS/Source/tasks.c **** 				{
 3839               	.LM447:
 3840 0fb2 E091 0000 		lds r30,pxCurrentTCB
 3841 0fb6 F091 0000 		lds r31,pxCurrentTCB+1
 3842 0fba 9E89      		ldd r25,Y+22
 3843 0fbc 8689      		ldd r24,Z+22
 3844 0fbe 8917      		cp r24,r25
 3845 0fc0 00F4      		brsh .L274
4932:FreeRTOS/Source/tasks.c **** 					{
 3847               	.LM448:
 3848 0fc2 0115      		cp r16,__zero_reg__
 3849 0fc4 1105      		cpc r17,__zero_reg__
 3850 0fc6 01F0      		breq .L281
4934:FreeRTOS/Source/tasks.c **** 					}
 3852               	.LM449:
 3853 0fc8 81E0      		ldi r24,lo8(1)
 3854 0fca F801      		movw r30,r16
 3855 0fcc 8083      		st Z,r24
 3856               	.L281:
4940:FreeRTOS/Source/tasks.c **** 				}
 3858               	.LM450:
 3859 0fce 81E0      		ldi r24,lo8(1)
 3860 0fd0 8093 0000 		sts xYieldPending,r24
 3861               	.L274:
 3862               	/* epilogue start */
4949:FreeRTOS/Source/tasks.c **** 
 3864               	.LM451:
 3865 0fd4 DF91      		pop r29
 3866 0fd6 CF91      		pop r28
 3867 0fd8 1F91      		pop r17
 3868 0fda 0F91      		pop r16
 3869 0fdc FF90      		pop r15
 3870 0fde EF90      		pop r14
 3871 0fe0 0895      		ret
 3876               	.Lscope35:
 3878               		.stabd	78,0,0
 3881               	.global	xTaskNotifyStateClear
 3883               	xTaskNotifyStateClear:
 3884               		.stabd	46,0,0
4958:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 3886               	.LM452:
 3887               	.LFBB36:
 3888               	/* prologue: function */
 3889               	/* frame size = 0 */
 3890               	/* stack size = 0 */
 3891               	.L__stack_usage = 0
4964:FreeRTOS/Source/tasks.c **** 
 3893               	.LM453:
 3894 0fe2 0097      		sbiw r24,0
 3895 0fe4 01F4      		brne .L287
4964:FreeRTOS/Source/tasks.c **** 
 3897               	.LM454:
 3898 0fe6 8091 0000 		lds r24,pxCurrentTCB
 3899 0fea 9091 0000 		lds r25,pxCurrentTCB+1
 3900               	.L287:
4966:FreeRTOS/Source/tasks.c **** 		{
 3902               	.LM455:
 3903               	/* #APP */
 3904               	 ;  4966 "FreeRTOS/Source/tasks.c" 1
 3905 0fee 0FB6      		in		__tmp_reg__, __SREG__
 3906               	 ;  0 "" 2
 3907               	 ;  4966 "FreeRTOS/Source/tasks.c" 1
 3908 0ff0 F894      		cli
 3909               	 ;  0 "" 2
 3910               	 ;  4966 "FreeRTOS/Source/tasks.c" 1
 3911 0ff2 0F92      		push	__tmp_reg__
 3912               	 ;  0 "" 2
4968:FreeRTOS/Source/tasks.c **** 			{
 3914               	.LM456:
 3915               	/* #NOAPP */
 3916 0ff4 FC01      		movw r30,r24
 3917 0ff6 25A1      		ldd r18,Z+37
 3918 0ff8 2230      		cpi r18,lo8(2)
 3919 0ffa 01F4      		brne .L289
4970:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
 3921               	.LM457:
 3922 0ffc 15A2      		std Z+37,__zero_reg__
4971:FreeRTOS/Source/tasks.c **** 			}
 3924               	.LM458:
 3925 0ffe 81E0      		ldi r24,lo8(1)
 3926 1000 00C0      		rjmp .L288
 3927               	.L289:
4975:FreeRTOS/Source/tasks.c **** 			}
 3929               	.LM459:
 3930 1002 80E0      		ldi r24,0
 3931               	.L288:
4978:FreeRTOS/Source/tasks.c **** 
 3933               	.LM460:
 3934               	/* #APP */
 3935               	 ;  4978 "FreeRTOS/Source/tasks.c" 1
 3936 1004 0F90      		pop		__tmp_reg__
 3937               	 ;  0 "" 2
 3938               	 ;  4978 "FreeRTOS/Source/tasks.c" 1
 3939 1006 0FBE      		out		__SREG__, __tmp_reg__
 3940               	 ;  0 "" 2
4981:FreeRTOS/Source/tasks.c **** 
 3942               	.LM461:
 3943               	/* #NOAPP */
 3944 1008 0895      		ret
 3949               	.Lscope36:
 3951               		.stabd	78,0,0
 3952               		.local	uxSchedulerSuspended
 3953               		.comm	uxSchedulerSuspended,1,1
 3954               		.local	xIdleTaskHandle
 3955               		.comm	xIdleTaskHandle,2,1
 3956               		.local	xNextTaskUnblockTime
 3957               		.comm	xNextTaskUnblockTime,2,1
 3958               		.local	uxTaskNumber
 3959               		.comm	uxTaskNumber,1,1
 3960               		.local	xNumOfOverflows
 3961               		.comm	xNumOfOverflows,1,1
 3962               		.local	xYieldPending
 3963               		.comm	xYieldPending,1,1
 3964               		.local	uxPendedTicks
 3965               		.comm	uxPendedTicks,1,1
 3966               		.local	xSchedulerRunning
 3967               		.comm	xSchedulerRunning,1,1
 3968               		.local	uxTopReadyPriority
 3969               		.comm	uxTopReadyPriority,1,1
 3970               		.local	xTickCount
 3971               		.comm	xTickCount,2,1
 3972               		.local	uxCurrentNumberOfTasks
 3973               		.comm	uxCurrentNumberOfTasks,1,1
 3974               		.local	xSuspendedTaskList
 3975               		.comm	xSuspendedTaskList,9,1
 3976               		.local	uxDeletedTasksWaitingCleanUp
 3977               		.comm	uxDeletedTasksWaitingCleanUp,1,1
 3978               		.local	xTasksWaitingTermination
 3979               		.comm	xTasksWaitingTermination,9,1
 3980               		.local	xPendingReadyList
 3981               		.comm	xPendingReadyList,9,1
 3982               		.local	pxOverflowDelayedTaskList
 3983               		.comm	pxOverflowDelayedTaskList,2,1
 3984               		.local	pxDelayedTaskList
 3985               		.comm	pxDelayedTaskList,2,1
 3986               		.local	xDelayedTaskList2
 3987               		.comm	xDelayedTaskList2,9,1
 3988               		.local	xDelayedTaskList1
 3989               		.comm	xDelayedTaskList1,9,1
 3990               		.local	pxReadyTasksLists
 3991               		.comm	pxReadyTasksLists,36,1
 3992               	.global	pxCurrentTCB
 3993               		.section .bss
 3996               	pxCurrentTCB:
 3997 0000 0000      		.zero	2
 4019               		.text
 4021               	.Letext0:
 4022               		.ident	"GCC: (GNU) 5.4.0"
 4023               	.global __do_copy_data
 4024               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/cctW9eug.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cctW9eug.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cctW9eug.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cctW9eug.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cctW9eug.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cctW9eug.s:183    .text:0000000000000000 prvResetNextTaskUnblockTime
     /tmp/cctW9eug.s:3983   .bss:000000000000002e pxDelayedTaskList
     /tmp/cctW9eug.s:3955   .bss:0000000000000005 xNextTaskUnblockTime
     /tmp/cctW9eug.s:235    .text:0000000000000036 prvAddCurrentTaskToDelayedList
     /tmp/cctW9eug.s:3969   .bss:000000000000000d xTickCount
     /tmp/cctW9eug.s:3996   .bss:0000000000000000 pxCurrentTCB
     /tmp/cctW9eug.s:3973   .bss:0000000000000010 xSuspendedTaskList
     /tmp/cctW9eug.s:3981   .bss:000000000000002c pxOverflowDelayedTaskList
     /tmp/cctW9eug.s:375    .text:00000000000000ee prvIdleTask
     /tmp/cctW9eug.s:3975   .bss:0000000000000019 uxDeletedTasksWaitingCleanUp
     /tmp/cctW9eug.s:3977   .bss:000000000000001a xTasksWaitingTermination
     /tmp/cctW9eug.s:3971   .bss:000000000000000f uxCurrentNumberOfTasks
     /tmp/cctW9eug.s:3989   .bss:0000000000000042 pxReadyTasksLists
     /tmp/cctW9eug.s:485    .text:000000000000014a xTaskCreate
     /tmp/cctW9eug.s:3987   .bss:0000000000000039 xDelayedTaskList1
     /tmp/cctW9eug.s:3985   .bss:0000000000000030 xDelayedTaskList2
     /tmp/cctW9eug.s:3979   .bss:0000000000000023 xPendingReadyList
     /tmp/cctW9eug.s:3965   .bss:000000000000000b xSchedulerRunning
     /tmp/cctW9eug.s:3957   .bss:0000000000000007 uxTaskNumber
     /tmp/cctW9eug.s:3967   .bss:000000000000000c uxTopReadyPriority
     /tmp/cctW9eug.s:876    .text:000000000000034c vTaskDelete
     /tmp/cctW9eug.s:1020   .text:00000000000003f6 vTaskResume
     /tmp/cctW9eug.s:1153   .text:0000000000000484 xTaskResumeFromISR
                             .bss:0000000000000002 uxSchedulerSuspended
     /tmp/cctW9eug.s:1282   .text:0000000000000514 vTaskStartScheduler
     /tmp/cctW9eug.s:3953   .bss:0000000000000003 xIdleTaskHandle
     /tmp/cctW9eug.s:1361   .text:0000000000000568 vTaskEndScheduler
     /tmp/cctW9eug.s:1390   .text:0000000000000572 vTaskSuspendAll
     /tmp/cctW9eug.s:1412   .text:000000000000057e xTaskGetTickCount
     /tmp/cctW9eug.s:1461   .text:0000000000000592 xTaskGetTickCountFromISR
     /tmp/cctW9eug.s:1487   .text:000000000000059c uxTaskGetNumberOfTasks
     /tmp/cctW9eug.s:1510   .text:00000000000005a2 pcTaskGetName
     /tmp/cctW9eug.s:1539   .text:00000000000005b2 xTaskIncrementTick
     /tmp/cctW9eug.s:3959   .bss:0000000000000008 xNumOfOverflows
     /tmp/cctW9eug.s:3963   .bss:000000000000000a uxPendedTicks
     /tmp/cctW9eug.s:3961   .bss:0000000000000009 xYieldPending
     /tmp/cctW9eug.s:1776   .text:000000000000070a xTaskResumeAll
     /tmp/cctW9eug.s:1979   .text:00000000000007e8 vTaskDelayUntil
     /tmp/cctW9eug.s:2100   .text:0000000000000858 vTaskDelay
     /tmp/cctW9eug.s:2151   .text:0000000000000882 vTaskSwitchContext
     /tmp/cctW9eug.s:2251   .text:0000000000000908 vTaskSuspend
     /tmp/cctW9eug.s:2420   .text:00000000000009b4 vTaskPlaceOnEventList
     /tmp/cctW9eug.s:2461   .text:00000000000009d6 vTaskPlaceOnUnorderedEventList
     /tmp/cctW9eug.s:2507   .text:0000000000000a06 xTaskRemoveFromEventList
     /tmp/cctW9eug.s:2614   .text:0000000000000a86 vTaskRemoveFromUnorderedEventList
     /tmp/cctW9eug.s:2699   .text:0000000000000aea vTaskSetTimeOutState
     /tmp/cctW9eug.s:2751   .text:0000000000000b0a vTaskInternalSetTimeOutState
     /tmp/cctW9eug.s:2781   .text:0000000000000b20 xTaskCheckForTimeOut
     /tmp/cctW9eug.s:2903   .text:0000000000000b86 vTaskMissedYield
     /tmp/cctW9eug.s:2924   .text:0000000000000b8e xTaskGetCurrentTaskHandle
     /tmp/cctW9eug.s:2950   .text:0000000000000b98 uxTaskResetEventItemValue
     /tmp/cctW9eug.s:2994   .text:0000000000000bc6 ulTaskNotifyTake
     /tmp/cctW9eug.s:3150   .text:0000000000000c68 xTaskNotifyWait
     /tmp/cctW9eug.s:3360   .text:0000000000000d78 xTaskGenericNotify
     /tmp/cctW9eug.s:3552   .text:0000000000000e4a xTaskGenericNotifyFromISR
     /tmp/cctW9eug.s:3753   .text:0000000000000f3e vTaskNotifyGiveFromISR
     /tmp/cctW9eug.s:3883   .text:0000000000000fe2 xTaskNotifyStateClear

UNDEFINED SYMBOLS
uxListRemove
vListInsertEnd
vListInsert
vPortFree
vPortYield
vApplicationIdleHook
pvPortMalloc
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
xPortStartScheduler
vPortEndScheduler
__do_copy_data
__do_clear_bss

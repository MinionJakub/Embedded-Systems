
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000078  00800100  000039a4  00003a38  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000039a4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000068b  00800178  00800178  00003ab0  2**0
                  ALLOC
  3 .stab         00008148  00000000  00000000  00003ab0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004ad7  00000000  00000000  0000bbf8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  000106cf  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000106e0  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  00010720  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  00010d14  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  000112b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  000112d0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b5 00 	jmp	0x16a	; 0x16a <__ctors_end>
       4:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
       8:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
       c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      10:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      14:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      18:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      1c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      20:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      24:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      28:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      2c:	0c 94 31 14 	jmp	0x2862	; 0x2862 <__vector_11>
      30:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      34:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      38:	0c 94 7b 01 	jmp	0x2f6	; 0x2f6 <__vector_14>
      3c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      40:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      44:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      48:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      4c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      50:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      54:	0c 94 90 01 	jmp	0x320	; 0x320 <__vector_21>
      58:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      5c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      60:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>
      64:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__bad_interrupt>

00000068 <__trampolines_end>:
      68:	6e 61       	ori	r22, 0x1E	; 30
      6a:	6e 00       	.word	0x006e	; ????

0000006c <__c.2332>:
      6c:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
      7c:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
      8c:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
      9c:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
      ac:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
      bc:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
      cc:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
      dc:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
      ec:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
      fc:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     10c:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     11c:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     12c:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     13c:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     14c:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     15c:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

0000016a <__ctors_end>:
     16a:	11 24       	eor	r1, r1
     16c:	1f be       	out	0x3f, r1	; 63
     16e:	cf ef       	ldi	r28, 0xFF	; 255
     170:	d8 e0       	ldi	r29, 0x08	; 8
     172:	de bf       	out	0x3e, r29	; 62
     174:	cd bf       	out	0x3d, r28	; 61

00000176 <__do_copy_data>:
     176:	11 e0       	ldi	r17, 0x01	; 1
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b1 e0       	ldi	r27, 0x01	; 1
     17c:	e4 ea       	ldi	r30, 0xA4	; 164
     17e:	f9 e3       	ldi	r31, 0x39	; 57
     180:	02 c0       	rjmp	.+4      	; 0x186 <__do_copy_data+0x10>
     182:	05 90       	lpm	r0, Z+
     184:	0d 92       	st	X+, r0
     186:	a8 37       	cpi	r26, 0x78	; 120
     188:	b1 07       	cpc	r27, r17
     18a:	d9 f7       	brne	.-10     	; 0x182 <__do_copy_data+0xc>

0000018c <__do_clear_bss>:
     18c:	28 e0       	ldi	r18, 0x08	; 8
     18e:	a8 e7       	ldi	r26, 0x78	; 120
     190:	b1 e0       	ldi	r27, 0x01	; 1
     192:	01 c0       	rjmp	.+2      	; 0x196 <.do_clear_bss_start>

00000194 <.do_clear_bss_loop>:
     194:	1d 92       	st	X+, r1

00000196 <.do_clear_bss_start>:
     196:	a3 30       	cpi	r26, 0x03	; 3
     198:	b2 07       	cpc	r27, r18
     19a:	e1 f7       	brne	.-8      	; 0x194 <.do_clear_bss_loop>
     19c:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <main>
     1a0:	0c 94 d0 1c 	jmp	0x39a0	; 0x39a0 <_exit>

000001a4 <__bad_interrupt>:
     1a4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001a8 <grzejnik_init>:
#define mainTRACE_TASK_PRIORITY 2
#define mainSHIFTING_TASK_PRIORITY 2

FILE uart_file = FDEV_SETUP_STREAM(uart_transmit, uart_receive, _FDEV_SETUP_RW);

void grzejnik_init(void) { GRZEJNIK_DDR = _BV(GRZEJNIK); }
     1a8:	80 e2       	ldi	r24, 0x20	; 32
     1aa:	84 b9       	out	0x04, r24	; 4
     1ac:	08 95       	ret

000001ae <timer_init>:

void timer_init() {
  // ctc mode tak zeby przerwanie było co 1/100 s
  TCCR0A = _BV(WGM01);            // CTC
     1ae:	82 e0       	ldi	r24, 0x02	; 2
     1b0:	84 bd       	out	0x24, r24	; 36
  TCCR0B = _BV(CS00) | _BV(CS02); // clk_io /1024
     1b2:	85 e0       	ldi	r24, 0x05	; 5
     1b4:	85 bd       	out	0x25, r24	; 37
  OCR0A = 30;                     // 100Hz
     1b6:	8e e1       	ldi	r24, 0x1E	; 30
     1b8:	87 bd       	out	0x27, r24	; 39
  TIMSK0 |= _BV(OCIE0A);
     1ba:	ee e6       	ldi	r30, 0x6E	; 110
     1bc:	f0 e0       	ldi	r31, 0x00	; 0
     1be:	80 81       	ld	r24, Z
     1c0:	82 60       	ori	r24, 0x02	; 2
     1c2:	80 83       	st	Z, r24
     1c4:	08 95       	ret

000001c6 <timer2_init>:
}

void timer2_init() {
  TCCR2A = _BV(WGM21) | _BV(COM2A0); // CTC
     1c6:	82 e4       	ldi	r24, 0x42	; 66
     1c8:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f80b0>
  TCCR2B = _BV(CS20);                // no prescaler
     1cc:	81 e0       	ldi	r24, 0x01	; 1
     1ce:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7f80b1>
  OCR2A = 30;
     1d2:	8e e1       	ldi	r24, 0x1E	; 30
     1d4:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
  DDRB |= _BV(PB3); // OC2A output
     1d8:	23 9a       	sbi	0x04, 3	; 4
     1da:	08 95       	ret

000001dc <adc_init>:
}

void adc_init() {
  ADMUX = _BV(REFS0) | _BV(REFS1); // referencja 1.1V, wejście ADC0
     1dc:	80 ec       	ldi	r24, 0xC0	; 192
     1de:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7f807c>
  DIDR0 = _BV(ADC0D);              // wyłącz wejście cyfrowe na ADC0
     1e2:	81 e0       	ldi	r24, 0x01	; 1
     1e4:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7f807e>
  // częstotliwość zegara ADC 125 kHz (16 MHz / 128)
  ADCSRA = _BV(ADPS0) | _BV(ADPS1) | _BV(ADPS2); // preskaler 128
     1e8:	ea e7       	ldi	r30, 0x7A	; 122
     1ea:	f0 e0       	ldi	r31, 0x00	; 0
     1ec:	87 e0       	ldi	r24, 0x07	; 7
     1ee:	80 83       	st	Z, r24
  ADCSRA |= _BV(ADEN) | _BV(ADIE);               // włącz ADC i interrupt
     1f0:	80 81       	ld	r24, Z
     1f2:	88 68       	ori	r24, 0x88	; 136
     1f4:	80 83       	st	Z, r24
     1f6:	08 95       	ret

000001f8 <pidControllerTask>:
}

void vApplicationIdleHook(void) {}
#define RISING 1
#define FALLING 0
static void pidControllerTask(void *pvParameters) {
     1f8:	cf 93       	push	r28
     1fa:	df 93       	push	r29
     1fc:	cd b7       	in	r28, 0x3d	; 61
     1fe:	de b7       	in	r29, 0x3e	; 62
     200:	62 97       	sbiw	r28, 0x12	; 18
     202:	0f b6       	in	r0, 0x3f	; 63
     204:	f8 94       	cli
     206:	de bf       	out	0x3e, r29	; 62
     208:	0f be       	out	0x3f, r0	; 63
     20a:	cd bf       	out	0x3d, r28	; 61
  timer2_init();
     20c:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <timer2_init>
  timer_init();
     210:	0e 94 d7 00 	call	0x1ae	; 0x1ae <timer_init>
  adc_init();
     214:	0e 94 ee 00 	call	0x1dc	; 0x1dc <adc_init>
  struct PID_DATA pid_data;
  //                 0.5                     0                   0
  pid_Init((2 * SCALING_FACTOR) >> 1, 0 * SCALING_FACTOR, 0 * SCALING_FACTOR,
     218:	9e 01       	movw	r18, r28
     21a:	2f 5f       	subi	r18, 0xFF	; 255
     21c:	3f 4f       	sbci	r19, 0xFF	; 255
     21e:	40 e0       	ldi	r20, 0x00	; 0
     220:	50 e0       	ldi	r21, 0x00	; 0
     222:	60 e0       	ldi	r22, 0x00	; 0
     224:	70 e0       	ldi	r23, 0x00	; 0
     226:	80 e8       	ldi	r24, 0x80	; 128
     228:	90 e0       	ldi	r25, 0x00	; 0
     22a:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <pid_Init>
           &pid_data);
  sei();
     22e:	78 94       	sei
  int16_t input, ocr2a = OCR2A;
     230:	00 91 b3 00 	lds	r16, 0x00B3	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
     234:	10 e0       	ldi	r17, 0x00	; 0
  while (1) {
    if (adc_bool) {

      // Jeśli settemp E (0,35) to takie cos zmapuje go na (0,255)
      // adc E (0,1023) więc adc/4 bedzie tez w (0,255)
      input = pid_Controller((settemp * 255) / 35, adc / 4, &pid_data);
     236:	55 24       	eor	r5, r5
     238:	5a 94       	dec	r5
     23a:	93 e2       	ldi	r25, 0x23	; 35
     23c:	69 2e       	mov	r6, r25
     23e:	71 2c       	mov	r7, r1
      //input = -input;
      if (cnt % 300 == 0) {
     240:	2c e2       	ldi	r18, 0x2C	; 44
     242:	82 2e       	mov	r8, r18
     244:	99 24       	eor	r9, r9
     246:	93 94       	inc	r9
        printf("Pid controller value: %d, OCR2A %d\r\n", input, ocr2a);
     248:	30 e1       	ldi	r19, 0x10	; 16
     24a:	a3 2e       	mov	r10, r19
     24c:	31 e0       	ldi	r19, 0x01	; 1
     24e:	b3 2e       	mov	r11, r19
           &pid_data);
  sei();
  int16_t input, ocr2a = OCR2A;
  uint16_t cnt, mapped_temp;
  while (1) {
    if (adc_bool) {
     250:	80 91 78 01 	lds	r24, 0x0178	; 0x800178 <__data_end>
     254:	88 23       	and	r24, r24
     256:	e1 f3       	breq	.-8      	; 0x250 <pidControllerTask+0x58>

      // Jeśli settemp E (0,35) to takie cos zmapuje go na (0,255)
      // adc E (0,1023) więc adc/4 bedzie tez w (0,255)
      input = pid_Controller((settemp * 255) / 35, adc / 4, &pid_data);
     258:	20 91 fb 07 	lds	r18, 0x07FB	; 0x8007fb <adc>
     25c:	30 91 fc 07 	lds	r19, 0x07FC	; 0x8007fc <adc+0x1>
     260:	40 91 00 01 	lds	r20, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
     264:	50 91 01 01 	lds	r21, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
     268:	36 95       	lsr	r19
     26a:	27 95       	ror	r18
     26c:	36 95       	lsr	r19
     26e:	27 95       	ror	r18
     270:	54 9e       	mul	r5, r20
     272:	c0 01       	movw	r24, r0
     274:	55 9e       	mul	r5, r21
     276:	90 0d       	add	r25, r0
     278:	11 24       	eor	r1, r1
     27a:	b3 01       	movw	r22, r6
     27c:	0e 94 ef 17 	call	0x2fde	; 0x2fde <__udivmodhi4>
     280:	cb 01       	movw	r24, r22
     282:	ae 01       	movw	r20, r28
     284:	4f 5f       	subi	r20, 0xFF	; 255
     286:	5f 4f       	sbci	r21, 0xFF	; 255
     288:	b9 01       	movw	r22, r18
     28a:	0e 94 97 02 	call	0x52e	; 0x52e <pid_Controller>
     28e:	7c 01       	movw	r14, r24
      //input = -input;
      if (cnt % 300 == 0) {
     290:	c6 01       	movw	r24, r12
     292:	b4 01       	movw	r22, r8
     294:	0e 94 ef 17 	call	0x2fde	; 0x2fde <__udivmodhi4>
     298:	89 2b       	or	r24, r25
     29a:	81 f4       	brne	.+32     	; 0x2bc <pidControllerTask+0xc4>
        printf("Pid controller value: %d, OCR2A %d\r\n", input, ocr2a);
     29c:	1f 93       	push	r17
     29e:	0f 93       	push	r16
     2a0:	ff 92       	push	r15
     2a2:	ef 92       	push	r14
     2a4:	bf 92       	push	r11
     2a6:	af 92       	push	r10
     2a8:	0e 94 5c 1c 	call	0x38b8	; 0x38b8 <printf>
     2ac:	0f 90       	pop	r0
     2ae:	0f 90       	pop	r0
     2b0:	0f 90       	pop	r0
     2b2:	0f 90       	pop	r0
     2b4:	0f 90       	pop	r0
     2b6:	0f 90       	pop	r0
        cnt = 0;
     2b8:	c1 2c       	mov	r12, r1
     2ba:	d1 2c       	mov	r13, r1
      }
      cnt++;
     2bc:	8f ef       	ldi	r24, 0xFF	; 255
     2be:	c8 1a       	sub	r12, r24
     2c0:	d8 0a       	sbc	r13, r24
      ocr2a = OCR2A;
     2c2:	80 91 b3 00 	lds	r24, 0x00B3	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
     2c6:	08 2f       	mov	r16, r24
     2c8:	10 e0       	ldi	r17, 0x00	; 0
      if (ocr2a + input <= 0)
     2ca:	97 01       	movw	r18, r14
     2cc:	20 0f       	add	r18, r16
     2ce:	31 1f       	adc	r19, r17
     2d0:	12 16       	cp	r1, r18
     2d2:	13 06       	cpc	r1, r19
     2d4:	1c f0       	brlt	.+6      	; 0x2dc <pidControllerTask+0xe4>
        OCR2A = 0;
     2d6:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
     2da:	0a c0       	rjmp	.+20     	; 0x2f0 <pidControllerTask+0xf8>
      else if (ocr2a + input > 255)
     2dc:	2f 3f       	cpi	r18, 0xFF	; 255
     2de:	31 05       	cpc	r19, r1
     2e0:	21 f0       	breq	.+8      	; 0x2ea <pidControllerTask+0xf2>
     2e2:	1c f0       	brlt	.+6      	; 0x2ea <pidControllerTask+0xf2>
        OCR2A = 255;
     2e4:	50 92 b3 00 	sts	0x00B3, r5	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
     2e8:	03 c0       	rjmp	.+6      	; 0x2f0 <pidControllerTask+0xf8>
      else
        OCR2A = ocr2a + input;
     2ea:	e8 0e       	add	r14, r24
     2ec:	e0 92 b3 00 	sts	0x00B3, r14	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
      adc_bool = 0;
     2f0:	10 92 78 01 	sts	0x0178, r1	; 0x800178 <__data_end>
     2f4:	ad cf       	rjmp	.-166    	; 0x250 <pidControllerTask+0x58>

000002f6 <__vector_14>:
  ADCSRA = _BV(ADPS0) | _BV(ADPS1) | _BV(ADPS2); // preskaler 128
  ADCSRA |= _BV(ADEN) | _BV(ADIE);               // włącz ADC i interrupt
  // ADCSRB = _BV(ADTS0) | _BV(ADTS1);
}

ISR(TIMER0_COMPA_vect) { ADCSRA |= _BV(ADSC); }
     2f6:	1f 92       	push	r1
     2f8:	0f 92       	push	r0
     2fa:	0f b6       	in	r0, 0x3f	; 63
     2fc:	0f 92       	push	r0
     2fe:	11 24       	eor	r1, r1
     300:	8f 93       	push	r24
     302:	ef 93       	push	r30
     304:	ff 93       	push	r31
     306:	ea e7       	ldi	r30, 0x7A	; 122
     308:	f0 e0       	ldi	r31, 0x00	; 0
     30a:	80 81       	ld	r24, Z
     30c:	80 64       	ori	r24, 0x40	; 64
     30e:	80 83       	st	Z, r24
     310:	ff 91       	pop	r31
     312:	ef 91       	pop	r30
     314:	8f 91       	pop	r24
     316:	0f 90       	pop	r0
     318:	0f be       	out	0x3f, r0	; 63
     31a:	0f 90       	pop	r0
     31c:	1f 90       	pop	r1
     31e:	18 95       	reti

00000320 <__vector_21>:

volatile uint16_t settemp = 20;
volatile uint16_t adc;
volatile uint8_t adc_bool = 0;
ISR(ADC_vect) {
     320:	1f 92       	push	r1
     322:	0f 92       	push	r0
     324:	0f b6       	in	r0, 0x3f	; 63
     326:	0f 92       	push	r0
     328:	11 24       	eor	r1, r1
     32a:	8f 93       	push	r24
     32c:	9f 93       	push	r25
  adc = ADC;
     32e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7f8078>
     332:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7f8079>
     336:	90 93 fc 07 	sts	0x07FC, r25	; 0x8007fc <adc+0x1>
     33a:	80 93 fb 07 	sts	0x07FB, r24	; 0x8007fb <adc>
  // temp = (adc + (adc / 10)) / 1024;
  // temp = (temp - V_SUB) / MCP9700_SCALE;
  // temp = (int16_t)(((adc + (adc / 10)) / 20) - 21);
  adc_bool = 1;
     33e:	81 e0       	ldi	r24, 0x01	; 1
     340:	80 93 78 01 	sts	0x0178, r24	; 0x800178 <__data_end>
}
     344:	9f 91       	pop	r25
     346:	8f 91       	pop	r24
     348:	0f 90       	pop	r0
     34a:	0f be       	out	0x3f, r0	; 63
     34c:	0f 90       	pop	r0
     34e:	1f 90       	pop	r1
     350:	18 95       	reti

00000352 <readline>:

uint8_t readline(char *line) {
     352:	ef 92       	push	r14
     354:	ff 92       	push	r15
     356:	0f 93       	push	r16
     358:	1f 93       	push	r17
     35a:	cf 93       	push	r28
     35c:	8c 01       	movw	r16, r24
     35e:	7c 01       	movw	r14, r24
  uint8_t c = 0;
     360:	c0 e0       	ldi	r28, 0x00	; 0
  while (c < BUFF) {
    line[c] = getchar();
     362:	80 91 fd 07 	lds	r24, 0x07FD	; 0x8007fd <__iob>
     366:	90 91 fe 07 	lds	r25, 0x07FE	; 0x8007fe <__iob+0x1>
     36a:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <fgetc>
     36e:	f7 01       	movw	r30, r14
     370:	81 93       	st	Z+, r24
     372:	7f 01       	movw	r14, r30
    if (line[c++] == 0x0d)
     374:	cf 5f       	subi	r28, 0xFF	; 255
     376:	8d 30       	cpi	r24, 0x0D	; 13
     378:	11 f0       	breq	.+4      	; 0x37e <readline+0x2c>
  adc_bool = 1;
}

uint8_t readline(char *line) {
  uint8_t c = 0;
  while (c < BUFF) {
     37a:	c4 31       	cpi	r28, 0x14	; 20
     37c:	91 f7       	brne	.-28     	; 0x362 <readline+0x10>
    line[c] = getchar();
    if (line[c++] == 0x0d)
      break;
  }
  line[c] = '\0';
     37e:	f8 01       	movw	r30, r16
     380:	ec 0f       	add	r30, r28
     382:	f1 1d       	adc	r31, r1
     384:	10 82       	st	Z, r1
  return c;
}
     386:	8c 2f       	mov	r24, r28
     388:	cf 91       	pop	r28
     38a:	1f 91       	pop	r17
     38c:	0f 91       	pop	r16
     38e:	ff 90       	pop	r15
     390:	ef 90       	pop	r14
     392:	08 95       	ret

00000394 <uartControllerTask>:
      adc_bool = 0;
    }
  }
}

static void uartControllerTask(void *pvParameters) {
     394:	cf 93       	push	r28
     396:	df 93       	push	r29
     398:	cd b7       	in	r28, 0x3d	; 61
     39a:	de b7       	in	r29, 0x3e	; 62
     39c:	64 97       	sbiw	r28, 0x14	; 20
     39e:	0f b6       	in	r0, 0x3f	; 63
     3a0:	f8 94       	cli
     3a2:	de bf       	out	0x3e, r29	; 62
     3a4:	0f be       	out	0x3f, r0	; 63
     3a6:	cd bf       	out	0x3d, r28	; 61
      printf("Current temp: %.2f\r\n", temp);
    } else if (!strncmp(strpart, "change", 6)) {
      strpart = strtok(NULL, " ");
      tmpsettemp = atoi(strpart);
      settemp = tmpsettemp;
      printf("Set temp: %d\r\n", tmpsettemp);
     3a8:	08 e5       	ldi	r16, 0x58	; 88
     3aa:	11 e0       	ldi	r17, 0x01	; 1
    readline(cmd);
    strpart = strtok(cmd, " ");
    if (!strncmp(strpart, "temp", 4)) {
      temp = (adc * 1.1) / 1024.0;
      temp = (temp - V_SUB) / MCP9700_SCALE;
      printf("Current temp: %.2f\r\n", temp);
     3ac:	8c e3       	ldi	r24, 0x3C	; 60
     3ae:	e8 2e       	mov	r14, r24
     3b0:	81 e0       	ldi	r24, 0x01	; 1
     3b2:	f8 2e       	mov	r15, r24
  char cmd[BUFF];
  int16_t tmpsettemp;
  char *strpart;
  float temp;
  while (1) {
    readline(cmd);
     3b4:	ce 01       	movw	r24, r28
     3b6:	01 96       	adiw	r24, 0x01	; 1
     3b8:	0e 94 a9 01 	call	0x352	; 0x352 <readline>
    strpart = strtok(cmd, " ");
     3bc:	65 e3       	ldi	r22, 0x35	; 53
     3be:	71 e0       	ldi	r23, 0x01	; 1
     3c0:	ce 01       	movw	r24, r28
     3c2:	01 96       	adiw	r24, 0x01	; 1
     3c4:	0e 94 8c 1b 	call	0x3718	; 0x3718 <strtok>
     3c8:	6c 01       	movw	r12, r24
    if (!strncmp(strpart, "temp", 4)) {
     3ca:	44 e0       	ldi	r20, 0x04	; 4
     3cc:	50 e0       	ldi	r21, 0x00	; 0
     3ce:	67 e3       	ldi	r22, 0x37	; 55
     3d0:	71 e0       	ldi	r23, 0x01	; 1
     3d2:	0e 94 9a 1b 	call	0x3734	; 0x3734 <strncmp>
     3d6:	89 2b       	or	r24, r25
     3d8:	79 f5       	brne	.+94     	; 0x438 <__EEPROM_REGION_LENGTH__+0x38>
      temp = (adc * 1.1) / 1024.0;
     3da:	60 91 fb 07 	lds	r22, 0x07FB	; 0x8007fb <adc>
     3de:	70 91 fc 07 	lds	r23, 0x07FC	; 0x8007fc <adc+0x1>
      temp = (temp - V_SUB) / MCP9700_SCALE;
     3e2:	80 e0       	ldi	r24, 0x00	; 0
     3e4:	90 e0       	ldi	r25, 0x00	; 0
     3e6:	0e 94 90 19 	call	0x3320	; 0x3320 <__floatunsisf>
     3ea:	2d ec       	ldi	r18, 0xCD	; 205
     3ec:	3c ec       	ldi	r19, 0xCC	; 204
     3ee:	4c e8       	ldi	r20, 0x8C	; 140
     3f0:	5f e3       	ldi	r21, 0x3F	; 63
     3f2:	0e 94 1e 1a 	call	0x343c	; 0x343c <__mulsf3>
     3f6:	20 e0       	ldi	r18, 0x00	; 0
     3f8:	30 e0       	ldi	r19, 0x00	; 0
     3fa:	40 e8       	ldi	r20, 0x80	; 128
     3fc:	5a e3       	ldi	r21, 0x3A	; 58
     3fe:	0e 94 1e 1a 	call	0x343c	; 0x343c <__mulsf3>
     402:	2d ec       	ldi	r18, 0xCD	; 205
     404:	3c ec       	ldi	r19, 0xCC	; 204
     406:	4c ec       	ldi	r20, 0xCC	; 204
     408:	5e e3       	ldi	r21, 0x3E	; 62
     40a:	0e 94 b1 18 	call	0x3162	; 0x3162 <__subsf3>
      printf("Current temp: %.2f\r\n", temp);
     40e:	27 e7       	ldi	r18, 0x77	; 119
     410:	3e eb       	ldi	r19, 0xBE	; 190
     412:	4f e9       	ldi	r20, 0x9F	; 159
     414:	5c e3       	ldi	r21, 0x3C	; 60
     416:	0e 94 1e 19 	call	0x323c	; 0x323c <__divsf3>
     41a:	9f 93       	push	r25
     41c:	8f 93       	push	r24
     41e:	7f 93       	push	r23
     420:	6f 93       	push	r22
     422:	ff 92       	push	r15
     424:	ef 92       	push	r14
     426:	0e 94 5c 1c 	call	0x38b8	; 0x38b8 <printf>
     42a:	0f 90       	pop	r0
     42c:	0f 90       	pop	r0
     42e:	0f 90       	pop	r0
     430:	0f 90       	pop	r0
     432:	0f 90       	pop	r0
     434:	0f 90       	pop	r0
     436:	be cf       	rjmp	.-132    	; 0x3b4 <uartControllerTask+0x20>
    } else if (!strncmp(strpart, "change", 6)) {
     438:	46 e0       	ldi	r20, 0x06	; 6
     43a:	50 e0       	ldi	r21, 0x00	; 0
     43c:	61 e5       	ldi	r22, 0x51	; 81
     43e:	71 e0       	ldi	r23, 0x01	; 1
     440:	c6 01       	movw	r24, r12
     442:	0e 94 9a 1b 	call	0x3734	; 0x3734 <strncmp>
     446:	89 2b       	or	r24, r25
     448:	09 f0       	breq	.+2      	; 0x44c <__EEPROM_REGION_LENGTH__+0x4c>
     44a:	b4 cf       	rjmp	.-152    	; 0x3b4 <uartControllerTask+0x20>
      strpart = strtok(NULL, " ");
     44c:	65 e3       	ldi	r22, 0x35	; 53
     44e:	71 e0       	ldi	r23, 0x01	; 1
     450:	80 e0       	ldi	r24, 0x00	; 0
     452:	90 e0       	ldi	r25, 0x00	; 0
     454:	0e 94 8c 1b 	call	0x3718	; 0x3718 <strtok>
      tmpsettemp = atoi(strpart);
     458:	0e 94 8b 1a 	call	0x3516	; 0x3516 <atoi>
      settemp = tmpsettemp;
     45c:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
     460:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
      printf("Set temp: %d\r\n", tmpsettemp);
     464:	9f 93       	push	r25
     466:	8f 93       	push	r24
     468:	1f 93       	push	r17
     46a:	0f 93       	push	r16
     46c:	0e 94 5c 1c 	call	0x38b8	; 0x38b8 <printf>
     470:	0f 90       	pop	r0
     472:	0f 90       	pop	r0
     474:	0f 90       	pop	r0
     476:	0f 90       	pop	r0
     478:	9d cf       	rjmp	.-198    	; 0x3b4 <uartControllerTask+0x20>

0000047a <sum_pid>:
  vTaskStartScheduler();

  return 0;
}

int16_t sum_pid(struct PID_DATA *pid_data) {
     47a:	fc 01       	movw	r30, r24
  return pid_data->P_Factor + pid_data->D_Factor + pid_data->I_Factor;
     47c:	86 81       	ldd	r24, Z+6	; 0x06
     47e:	97 81       	ldd	r25, Z+7	; 0x07
     480:	22 85       	ldd	r18, Z+10	; 0x0a
     482:	33 85       	ldd	r19, Z+11	; 0x0b
     484:	28 0f       	add	r18, r24
     486:	39 1f       	adc	r19, r25
     488:	80 85       	ldd	r24, Z+8	; 0x08
     48a:	91 85       	ldd	r25, Z+9	; 0x09
}
     48c:	82 0f       	add	r24, r18
     48e:	93 1f       	adc	r25, r19
     490:	08 95       	ret

00000492 <vApplicationIdleHook>:

void vApplicationIdleHook(void) {}
     492:	08 95       	ret

00000494 <uart_init>:
#include "uart.h"

// inicjalizacja UART
void uart_init() {
  // ustaw baudrate
  UBRR0 = UBRR_VALUE;
     494:	87 e6       	ldi	r24, 0x67	; 103
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
     49c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
  // wyczyść rejestr UCSR0A
  UCSR0A = 0;
     4a0:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  // włącz odbiornik i nadajnik
  UCSR0B = _BV(RXEN0) | _BV(TXEN0);
     4a4:	88 e1       	ldi	r24, 0x18	; 24
     4a6:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
  // ustaw format 8n1
  UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
     4aa:	86 e0       	ldi	r24, 0x06	; 6
     4ac:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
     4b0:	08 95       	ret

000004b2 <uart_transmit>:
}

// transmisja jednego znaku
int uart_transmit(char data, FILE *stream) {
  // czekaj aż transmiter gotowy
  while (!(UCSR0A & _BV(UDRE0)))
     4b2:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
     4b6:	95 ff       	sbrs	r25, 5
     4b8:	fc cf       	rjmp	.-8      	; 0x4b2 <uart_transmit>
    ;
  UDR0 = data;
     4ba:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
  return 0;
}
     4be:	80 e0       	ldi	r24, 0x00	; 0
     4c0:	90 e0       	ldi	r25, 0x00	; 0
     4c2:	08 95       	ret

000004c4 <uart_receive>:

// odczyt jednego znaku
int uart_receive(FILE *stream) {
  // czekaj aż znak dostępny
  while (!(UCSR0A & _BV(RXC0)))
     4c4:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
     4c8:	87 ff       	sbrs	r24, 7
     4ca:	fc cf       	rjmp	.-8      	; 0x4c4 <uart_receive>
    ;
  return UDR0;
     4cc:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
}
     4d0:	90 e0       	ldi	r25, 0x00	; 0
     4d2:	08 95       	ret

000004d4 <pid_Init>:
 *  \param d_factor  Derivate term.
 *  \param pid  Struct with PID status.
 */
void pid_Init(int16_t p_factor, int16_t i_factor, int16_t d_factor, struct PID_DATA *pid)
// Set up PID controller parameters
{
     4d4:	cf 93       	push	r28
     4d6:	df 93       	push	r29
     4d8:	fb 01       	movw	r30, r22
     4da:	e9 01       	movw	r28, r18
  // Start values for PID controller
  pid->sumError = 0;
     4dc:	1a 82       	std	Y+2, r1	; 0x02
     4de:	1b 82       	std	Y+3, r1	; 0x03
     4e0:	1c 82       	std	Y+4, r1	; 0x04
     4e2:	1d 82       	std	Y+5, r1	; 0x05
  pid->lastProcessValue = 0;
     4e4:	19 82       	std	Y+1, r1	; 0x01
     4e6:	18 82       	st	Y, r1
  // Tuning constants for PID loop
  pid->P_Factor = p_factor;
     4e8:	9f 83       	std	Y+7, r25	; 0x07
     4ea:	8e 83       	std	Y+6, r24	; 0x06
  pid->I_Factor = i_factor;
     4ec:	79 87       	std	Y+9, r23	; 0x09
     4ee:	68 87       	std	Y+8, r22	; 0x08
  pid->D_Factor = d_factor;
     4f0:	5b 87       	std	Y+11, r21	; 0x0b
     4f2:	4a 87       	std	Y+10, r20	; 0x0a
  // Limits to avoid overflow
  pid->maxError = MAX_INT / (pid->P_Factor + 1);
     4f4:	bc 01       	movw	r22, r24
     4f6:	6f 5f       	subi	r22, 0xFF	; 255
     4f8:	7f 4f       	sbci	r23, 0xFF	; 255
     4fa:	8f ef       	ldi	r24, 0xFF	; 255
     4fc:	9f e7       	ldi	r25, 0x7F	; 127
     4fe:	0e 94 03 18 	call	0x3006	; 0x3006 <__divmodhi4>
     502:	7d 87       	std	Y+13, r23	; 0x0d
     504:	6c 87       	std	Y+12, r22	; 0x0c
  pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1);
     506:	9f 01       	movw	r18, r30
     508:	2f 5f       	subi	r18, 0xFF	; 255
     50a:	3f 4f       	sbci	r19, 0xFF	; 255
     50c:	03 2e       	mov	r0, r19
     50e:	00 0c       	add	r0, r0
     510:	44 0b       	sbc	r20, r20
     512:	55 0b       	sbc	r21, r21
     514:	6f ef       	ldi	r22, 0xFF	; 255
     516:	7f ef       	ldi	r23, 0xFF	; 255
     518:	8f ef       	ldi	r24, 0xFF	; 255
     51a:	9f e3       	ldi	r25, 0x3F	; 63
     51c:	0e 94 17 18 	call	0x302e	; 0x302e <__divmodsi4>
     520:	2e 87       	std	Y+14, r18	; 0x0e
     522:	3f 87       	std	Y+15, r19	; 0x0f
     524:	48 8b       	std	Y+16, r20	; 0x10
     526:	59 8b       	std	Y+17, r21	; 0x11
}
     528:	df 91       	pop	r29
     52a:	cf 91       	pop	r28
     52c:	08 95       	ret

0000052e <pid_Controller>:
 *  \param setPoint  Desired value.
 *  \param processValue  Measured value.
 *  \param pid_st  PID status struct.
 */
int16_t pid_Controller(int16_t setPoint, int16_t processValue, struct PID_DATA *pid_st)
{
     52e:	ef 92       	push	r14
     530:	ff 92       	push	r15
     532:	0f 93       	push	r16
     534:	1f 93       	push	r17
     536:	cf 93       	push	r28
     538:	df 93       	push	r29
     53a:	8b 01       	movw	r16, r22
     53c:	fa 01       	movw	r30, r20
  int16_t error, p_term, d_term;
  int32_t i_term, ret, temp;

  error = setPoint - processValue;
     53e:	9c 01       	movw	r18, r24
     540:	26 1b       	sub	r18, r22
     542:	37 0b       	sbc	r19, r23

  // Calculate Pterm and limit error overflow
  if (error > pid_st->maxError){
     544:	84 85       	ldd	r24, Z+12	; 0x0c
     546:	95 85       	ldd	r25, Z+13	; 0x0d
     548:	82 17       	cp	r24, r18
     54a:	93 07       	cpc	r25, r19
     54c:	84 f0       	brlt	.+32     	; 0x56e <pid_Controller+0x40>
    p_term = MAX_INT;
  }
  else if (error < -pid_st->maxError){
     54e:	91 95       	neg	r25
     550:	81 95       	neg	r24
     552:	91 09       	sbc	r25, r1
     554:	28 17       	cp	r18, r24
     556:	39 07       	cpc	r19, r25
     558:	6c f0       	brlt	.+26     	; 0x574 <pid_Controller+0x46>
    p_term = -MAX_INT;
  }
  else{
    p_term = pid_st->P_Factor * error;
     55a:	86 81       	ldd	r24, Z+6	; 0x06
     55c:	97 81       	ldd	r25, Z+7	; 0x07
     55e:	28 9f       	mul	r18, r24
     560:	e0 01       	movw	r28, r0
     562:	29 9f       	mul	r18, r25
     564:	d0 0d       	add	r29, r0
     566:	38 9f       	mul	r19, r24
     568:	d0 0d       	add	r29, r0
     56a:	11 24       	eor	r1, r1
     56c:	05 c0       	rjmp	.+10     	; 0x578 <pid_Controller+0x4a>

  error = setPoint - processValue;

  // Calculate Pterm and limit error overflow
  if (error > pid_st->maxError){
    p_term = MAX_INT;
     56e:	cf ef       	ldi	r28, 0xFF	; 255
     570:	df e7       	ldi	r29, 0x7F	; 127
     572:	02 c0       	rjmp	.+4      	; 0x578 <pid_Controller+0x4a>
  }
  else if (error < -pid_st->maxError){
    p_term = -MAX_INT;
     574:	c1 e0       	ldi	r28, 0x01	; 1
     576:	d0 e8       	ldi	r29, 0x80	; 128
  else{
    p_term = pid_st->P_Factor * error;
  }

  // Calculate Iterm and limit integral runaway
  temp = pid_st->sumError + error;
     578:	c9 01       	movw	r24, r18
     57a:	33 0f       	add	r19, r19
     57c:	aa 0b       	sbc	r26, r26
     57e:	bb 0b       	sbc	r27, r27
     580:	42 81       	ldd	r20, Z+2	; 0x02
     582:	53 81       	ldd	r21, Z+3	; 0x03
     584:	64 81       	ldd	r22, Z+4	; 0x04
     586:	75 81       	ldd	r23, Z+5	; 0x05
     588:	9a 01       	movw	r18, r20
     58a:	ab 01       	movw	r20, r22
     58c:	28 0f       	add	r18, r24
     58e:	39 1f       	adc	r19, r25
     590:	4a 1f       	adc	r20, r26
     592:	5b 1f       	adc	r21, r27
  if(temp > pid_st->maxSumError){
     594:	86 85       	ldd	r24, Z+14	; 0x0e
     596:	97 85       	ldd	r25, Z+15	; 0x0f
     598:	a0 89       	ldd	r26, Z+16	; 0x10
     59a:	b1 89       	ldd	r27, Z+17	; 0x11
     59c:	82 17       	cp	r24, r18
     59e:	93 07       	cpc	r25, r19
     5a0:	a4 07       	cpc	r26, r20
     5a2:	b5 07       	cpc	r27, r21
     5a4:	4c f4       	brge	.+18     	; 0x5b8 <pid_Controller+0x8a>
    i_term = MAX_I_TERM;
    pid_st->sumError = pid_st->maxSumError;
     5a6:	82 83       	std	Z+2, r24	; 0x02
     5a8:	93 83       	std	Z+3, r25	; 0x03
     5aa:	a4 83       	std	Z+4, r26	; 0x04
     5ac:	b5 83       	std	Z+5, r27	; 0x05
  }

  // Calculate Iterm and limit integral runaway
  temp = pid_st->sumError + error;
  if(temp > pid_st->maxSumError){
    i_term = MAX_I_TERM;
     5ae:	6f ef       	ldi	r22, 0xFF	; 255
     5b0:	7f ef       	ldi	r23, 0xFF	; 255
     5b2:	8f ef       	ldi	r24, 0xFF	; 255
     5b4:	9f e3       	ldi	r25, 0x3F	; 63
     5b6:	1d c0       	rjmp	.+58     	; 0x5f2 <pid_Controller+0xc4>
    pid_st->sumError = pid_st->maxSumError;
  }
  else if(temp < -pid_st->maxSumError){
     5b8:	b0 95       	com	r27
     5ba:	a0 95       	com	r26
     5bc:	90 95       	com	r25
     5be:	81 95       	neg	r24
     5c0:	9f 4f       	sbci	r25, 0xFF	; 255
     5c2:	af 4f       	sbci	r26, 0xFF	; 255
     5c4:	bf 4f       	sbci	r27, 0xFF	; 255
     5c6:	28 17       	cp	r18, r24
     5c8:	39 07       	cpc	r19, r25
     5ca:	4a 07       	cpc	r20, r26
     5cc:	5b 07       	cpc	r21, r27
     5ce:	4c f4       	brge	.+18     	; 0x5e2 <pid_Controller+0xb4>
    i_term = -MAX_I_TERM;
    pid_st->sumError = -pid_st->maxSumError;
     5d0:	82 83       	std	Z+2, r24	; 0x02
     5d2:	93 83       	std	Z+3, r25	; 0x03
     5d4:	a4 83       	std	Z+4, r26	; 0x04
     5d6:	b5 83       	std	Z+5, r27	; 0x05
  if(temp > pid_st->maxSumError){
    i_term = MAX_I_TERM;
    pid_st->sumError = pid_st->maxSumError;
  }
  else if(temp < -pid_st->maxSumError){
    i_term = -MAX_I_TERM;
     5d8:	61 e0       	ldi	r22, 0x01	; 1
     5da:	70 e0       	ldi	r23, 0x00	; 0
     5dc:	80 e0       	ldi	r24, 0x00	; 0
     5de:	90 ec       	ldi	r25, 0xC0	; 192
     5e0:	08 c0       	rjmp	.+16     	; 0x5f2 <pid_Controller+0xc4>
    pid_st->sumError = -pid_st->maxSumError;
  }
  else{
    pid_st->sumError = temp;
     5e2:	22 83       	std	Z+2, r18	; 0x02
     5e4:	33 83       	std	Z+3, r19	; 0x03
     5e6:	44 83       	std	Z+4, r20	; 0x04
     5e8:	55 83       	std	Z+5, r21	; 0x05
    i_term = pid_st->I_Factor * pid_st->sumError;
     5ea:	a0 85       	ldd	r26, Z+8	; 0x08
     5ec:	b1 85       	ldd	r27, Z+9	; 0x09
     5ee:	0e 94 36 18 	call	0x306c	; 0x306c <__mulshisi3>
  }

  // Calculate Dterm
  d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue);
     5f2:	20 81       	ld	r18, Z
     5f4:	31 81       	ldd	r19, Z+1	; 0x01
     5f6:	20 1b       	sub	r18, r16
     5f8:	31 0b       	sbc	r19, r17
     5fa:	a2 85       	ldd	r26, Z+10	; 0x0a
     5fc:	b3 85       	ldd	r27, Z+11	; 0x0b
     5fe:	2a 9f       	mul	r18, r26
     600:	70 01       	movw	r14, r0
     602:	2b 9f       	mul	r18, r27
     604:	f0 0c       	add	r15, r0
     606:	3a 9f       	mul	r19, r26
     608:	f0 0c       	add	r15, r0
     60a:	11 24       	eor	r1, r1

  pid_st->lastProcessValue = processValue;
     60c:	11 83       	std	Z+1, r17	; 0x01
     60e:	00 83       	st	Z, r16

  ret = (p_term + i_term + d_term) / SCALING_FACTOR;
     610:	8e 01       	movw	r16, r28
     612:	dd 0f       	add	r29, r29
     614:	22 0b       	sbc	r18, r18
     616:	33 0b       	sbc	r19, r19
     618:	ab 01       	movw	r20, r22
     61a:	bc 01       	movw	r22, r24
     61c:	40 0f       	add	r20, r16
     61e:	51 1f       	adc	r21, r17
     620:	62 1f       	adc	r22, r18
     622:	73 1f       	adc	r23, r19
     624:	c7 01       	movw	r24, r14
     626:	ff 0c       	add	r15, r15
     628:	aa 0b       	sbc	r26, r26
     62a:	bb 0b       	sbc	r27, r27
     62c:	8a 01       	movw	r16, r20
     62e:	9b 01       	movw	r18, r22
     630:	08 0f       	add	r16, r24
     632:	19 1f       	adc	r17, r25
     634:	2a 1f       	adc	r18, r26
     636:	3b 1f       	adc	r19, r27
     638:	c9 01       	movw	r24, r18
     63a:	b8 01       	movw	r22, r16
     63c:	20 e8       	ldi	r18, 0x80	; 128
     63e:	30 e0       	ldi	r19, 0x00	; 0
     640:	40 e0       	ldi	r20, 0x00	; 0
     642:	50 e0       	ldi	r21, 0x00	; 0
     644:	0e 94 17 18 	call	0x302e	; 0x302e <__divmodsi4>
     648:	21 30       	cpi	r18, 0x01	; 1
     64a:	10 e8       	ldi	r17, 0x80	; 128
     64c:	31 07       	cpc	r19, r17
     64e:	1f ef       	ldi	r17, 0xFF	; 255
     650:	41 07       	cpc	r20, r17
     652:	51 07       	cpc	r21, r17
     654:	24 f4       	brge	.+8      	; 0x65e <pid_Controller+0x130>
     656:	21 e0       	ldi	r18, 0x01	; 1
     658:	30 e8       	ldi	r19, 0x80	; 128
     65a:	4f ef       	ldi	r20, 0xFF	; 255
     65c:	5f ef       	ldi	r21, 0xFF	; 255
  }
  else if(ret < -MAX_INT){
    ret = -MAX_INT;
  }

  return((int16_t)ret);
     65e:	da 01       	movw	r26, r20
     660:	c9 01       	movw	r24, r18
     662:	81 15       	cp	r24, r1
     664:	20 e8       	ldi	r18, 0x80	; 128
     666:	92 07       	cpc	r25, r18
     668:	a1 05       	cpc	r26, r1
     66a:	b1 05       	cpc	r27, r1
     66c:	24 f0       	brlt	.+8      	; 0x676 <pid_Controller+0x148>
     66e:	8f ef       	ldi	r24, 0xFF	; 255
     670:	9f e7       	ldi	r25, 0x7F	; 127
     672:	a0 e0       	ldi	r26, 0x00	; 0
     674:	b0 e0       	ldi	r27, 0x00	; 0
}
     676:	df 91       	pop	r29
     678:	cf 91       	pop	r28
     67a:	1f 91       	pop	r17
     67c:	0f 91       	pop	r16
     67e:	ff 90       	pop	r15
     680:	ef 90       	pop	r14
     682:	08 95       	ret

00000684 <pid_Reset_Integrator>:
 *
 *  Calling this function will reset the integrator in the PID regulator.
 */
void pid_Reset_Integrator(pidData_t *pid_st)
{
  pid_st->sumError = 0;
     684:	fc 01       	movw	r30, r24
     686:	12 82       	std	Z+2, r1	; 0x02
     688:	13 82       	std	Z+3, r1	; 0x03
     68a:	14 82       	std	Z+4, r1	; 0x04
     68c:	15 82       	std	Z+5, r1	; 0x05
     68e:	08 95       	ret

00000690 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     690:	e0 91 a7 01 	lds	r30, 0x01A7	; 0x8001a7 <pxDelayedTaskList>
     694:	f0 91 a8 01 	lds	r31, 0x01A8	; 0x8001a8 <pxDelayedTaskList+0x1>
     698:	80 81       	ld	r24, Z
     69a:	81 11       	cpse	r24, r1
     69c:	03 c0       	rjmp	.+6      	; 0x6a4 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     69e:	8f ef       	ldi	r24, 0xFF	; 255
     6a0:	9f ef       	ldi	r25, 0xFF	; 255
     6a2:	0c c0       	rjmp	.+24     	; 0x6bc <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     6a4:	e0 91 a7 01 	lds	r30, 0x01A7	; 0x8001a7 <pxDelayedTaskList>
     6a8:	f0 91 a8 01 	lds	r31, 0x01A8	; 0x8001a8 <pxDelayedTaskList+0x1>
     6ac:	05 80       	ldd	r0, Z+5	; 0x05
     6ae:	f6 81       	ldd	r31, Z+6	; 0x06
     6b0:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     6b2:	06 80       	ldd	r0, Z+6	; 0x06
     6b4:	f7 81       	ldd	r31, Z+7	; 0x07
     6b6:	e0 2d       	mov	r30, r0
     6b8:	82 81       	ldd	r24, Z+2	; 0x02
     6ba:	93 81       	ldd	r25, Z+3	; 0x03
     6bc:	90 93 7f 01 	sts	0x017F, r25	; 0x80017f <xNextTaskUnblockTime+0x1>
     6c0:	80 93 7e 01 	sts	0x017E, r24	; 0x80017e <xNextTaskUnblockTime>
     6c4:	08 95       	ret

000006c6 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     6c6:	ff 92       	push	r15
     6c8:	0f 93       	push	r16
     6ca:	1f 93       	push	r17
     6cc:	cf 93       	push	r28
     6ce:	df 93       	push	r29
     6d0:	ec 01       	movw	r28, r24
     6d2:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     6d4:	00 91 86 01 	lds	r16, 0x0186	; 0x800186 <xTickCount>
     6d8:	10 91 87 01 	lds	r17, 0x0187	; 0x800187 <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     6dc:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <pxCurrentTCB>
     6e0:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
     6e4:	02 96       	adiw	r24, 0x02	; 2
     6e6:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     6ea:	cf 3f       	cpi	r28, 0xFF	; 255
     6ec:	8f ef       	ldi	r24, 0xFF	; 255
     6ee:	d8 07       	cpc	r29, r24
     6f0:	89 f4       	brne	.+34     	; 0x714 <prvAddCurrentTaskToDelayedList+0x4e>
     6f2:	ff 20       	and	r15, r15
     6f4:	79 f0       	breq	.+30     	; 0x714 <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     6f6:	60 91 79 01 	lds	r22, 0x0179	; 0x800179 <pxCurrentTCB>
     6fa:	70 91 7a 01 	lds	r23, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
     6fe:	6e 5f       	subi	r22, 0xFE	; 254
     700:	7f 4f       	sbci	r23, 0xFF	; 255
     702:	89 e8       	ldi	r24, 0x89	; 137
     704:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	1f 91       	pop	r17
     70c:	0f 91       	pop	r16
     70e:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     710:	0c 94 4b 10 	jmp	0x2096	; 0x2096 <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     714:	c0 0f       	add	r28, r16
     716:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     718:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
     71c:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
     720:	d3 83       	std	Z+3, r29	; 0x03
     722:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     724:	60 91 79 01 	lds	r22, 0x0179	; 0x800179 <pxCurrentTCB>
     728:	70 91 7a 01 	lds	r23, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     72c:	c0 17       	cp	r28, r16
     72e:	d1 07       	cpc	r29, r17
     730:	68 f4       	brcc	.+26     	; 0x74c <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     732:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <pxOverflowDelayedTaskList>
     736:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <pxOverflowDelayedTaskList+0x1>
     73a:	6e 5f       	subi	r22, 0xFE	; 254
     73c:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     73e:	df 91       	pop	r29
     740:	cf 91       	pop	r28
     742:	1f 91       	pop	r17
     744:	0f 91       	pop	r16
     746:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     748:	0c 94 6c 10 	jmp	0x20d8	; 0x20d8 <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     74c:	80 91 a7 01 	lds	r24, 0x01A7	; 0x8001a7 <pxDelayedTaskList>
     750:	90 91 a8 01 	lds	r25, 0x01A8	; 0x8001a8 <pxDelayedTaskList+0x1>
     754:	6e 5f       	subi	r22, 0xFE	; 254
     756:	7f 4f       	sbci	r23, 0xFF	; 255
     758:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     75c:	80 91 7e 01 	lds	r24, 0x017E	; 0x80017e <xNextTaskUnblockTime>
     760:	90 91 7f 01 	lds	r25, 0x017F	; 0x80017f <xNextTaskUnblockTime+0x1>
     764:	c8 17       	cp	r28, r24
     766:	d9 07       	cpc	r29, r25
     768:	20 f4       	brcc	.+8      	; 0x772 <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     76a:	d0 93 7f 01 	sts	0x017F, r29	; 0x80017f <xNextTaskUnblockTime+0x1>
     76e:	c0 93 7e 01 	sts	0x017E, r28	; 0x80017e <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     772:	df 91       	pop	r29
     774:	cf 91       	pop	r28
     776:	1f 91       	pop	r17
     778:	0f 91       	pop	r16
     77a:	ff 90       	pop	r15
     77c:	08 95       	ret

0000077e <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     77e:	80 91 92 01 	lds	r24, 0x0192	; 0x800192 <uxDeletedTasksWaitingCleanUp>
     782:	88 23       	and	r24, r24
     784:	09 f1       	breq	.+66     	; 0x7c8 <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     786:	0f b6       	in	r0, 0x3f	; 63
     788:	f8 94       	cli
     78a:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     78c:	e0 91 98 01 	lds	r30, 0x0198	; 0x800198 <xTasksWaitingTermination+0x5>
     790:	f0 91 99 01 	lds	r31, 0x0199	; 0x800199 <xTasksWaitingTermination+0x6>
     794:	c6 81       	ldd	r28, Z+6	; 0x06
     796:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     798:	ce 01       	movw	r24, r28
     79a:	02 96       	adiw	r24, 0x02	; 2
     79c:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
				--uxCurrentNumberOfTasks;
     7a0:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <uxCurrentNumberOfTasks>
     7a4:	81 50       	subi	r24, 0x01	; 1
     7a6:	80 93 88 01 	sts	0x0188, r24	; 0x800188 <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     7aa:	80 91 92 01 	lds	r24, 0x0192	; 0x800192 <uxDeletedTasksWaitingCleanUp>
     7ae:	81 50       	subi	r24, 0x01	; 1
     7b0:	80 93 92 01 	sts	0x0192, r24	; 0x800192 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     7b4:	0f 90       	pop	r0
     7b6:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     7b8:	8f 89       	ldd	r24, Y+23	; 0x17
     7ba:	98 8d       	ldd	r25, Y+24	; 0x18
     7bc:	0e 94 c0 12 	call	0x2580	; 0x2580 <vPortFree>
			vPortFree( pxTCB );
     7c0:	ce 01       	movw	r24, r28
     7c2:	0e 94 c0 12 	call	0x2580	; 0x2580 <vPortFree>
     7c6:	db cf       	rjmp	.-74     	; 0x77e <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     7c8:	80 91 bb 01 	lds	r24, 0x01BB	; 0x8001bb <pxReadyTasksLists>
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	10 f0       	brcs	.+4      	; 0x7d4 <prvIdleTask+0x56>
			{
				taskYIELD();
     7d0:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     7d4:	0e 94 49 02 	call	0x492	; 0x492 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     7d8:	d2 cf       	rjmp	.-92     	; 0x77e <prvIdleTask>

000007da <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     7da:	3f 92       	push	r3
     7dc:	4f 92       	push	r4
     7de:	5f 92       	push	r5
     7e0:	6f 92       	push	r6
     7e2:	7f 92       	push	r7
     7e4:	8f 92       	push	r8
     7e6:	9f 92       	push	r9
     7e8:	af 92       	push	r10
     7ea:	bf 92       	push	r11
     7ec:	cf 92       	push	r12
     7ee:	df 92       	push	r13
     7f0:	ef 92       	push	r14
     7f2:	ff 92       	push	r15
     7f4:	0f 93       	push	r16
     7f6:	1f 93       	push	r17
     7f8:	cf 93       	push	r28
     7fa:	df 93       	push	r29
     7fc:	4c 01       	movw	r8, r24
     7fe:	16 2f       	mov	r17, r22
     800:	37 2e       	mov	r3, r23
     802:	6a 01       	movw	r12, r20
     804:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     806:	ca 01       	movw	r24, r20
     808:	0e 94 8e 12 	call	0x251c	; 0x251c <pvPortMalloc>
     80c:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     80e:	89 2b       	or	r24, r25
     810:	09 f4       	brne	.+2      	; 0x814 <__DATA_REGION_LENGTH__+0x14>
     812:	d1 c0       	rjmp	.+418    	; 0x9b6 <__stack+0xb7>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     814:	86 e2       	ldi	r24, 0x26	; 38
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	0e 94 8e 12 	call	0x251c	; 0x251c <pvPortMalloc>
     81c:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     81e:	89 2b       	or	r24, r25
     820:	79 f0       	breq	.+30     	; 0x840 <__DATA_REGION_LENGTH__+0x40>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     822:	58 8e       	std	Y+24, r5	; 0x18
     824:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     826:	c6 01       	movw	r24, r12
     828:	01 97       	sbiw	r24, 0x01	; 1
     82a:	32 01       	movw	r6, r4
     82c:	68 0e       	add	r6, r24
     82e:	79 1e       	adc	r7, r25
     830:	be 01       	movw	r22, r28
     832:	67 5e       	subi	r22, 0xE7	; 231
     834:	7f 4f       	sbci	r23, 0xFF	; 255
     836:	e1 2f       	mov	r30, r17
     838:	f3 2d       	mov	r31, r3
     83a:	cf 01       	movw	r24, r30
     83c:	08 96       	adiw	r24, 0x08	; 8
     83e:	07 c0       	rjmp	.+14     	; 0x84e <__DATA_REGION_LENGTH__+0x4e>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     840:	c2 01       	movw	r24, r4
     842:	0e 94 c0 12 	call	0x2580	; 0x2580 <vPortFree>
     846:	b7 c0       	rjmp	.+366    	; 0x9b6 <__stack+0xb7>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     848:	e8 17       	cp	r30, r24
     84a:	f9 07       	cpc	r31, r25
     84c:	49 f0       	breq	.+18     	; 0x860 <__DATA_REGION_LENGTH__+0x60>
     84e:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     850:	41 91       	ld	r20, Z+
     852:	db 01       	movw	r26, r22
     854:	4d 93       	st	X+, r20
     856:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     858:	d9 01       	movw	r26, r18
     85a:	2c 91       	ld	r18, X
     85c:	21 11       	cpse	r18, r1
     85e:	f4 cf       	rjmp	.-24     	; 0x848 <__DATA_REGION_LENGTH__+0x48>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     860:	18 a2       	std	Y+32, r1	; 0x20
     862:	04 30       	cpi	r16, 0x04	; 4
     864:	08 f0       	brcs	.+2      	; 0x868 <__DATA_REGION_LENGTH__+0x68>
     866:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     868:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     86a:	6e 01       	movw	r12, r28
     86c:	b2 e0       	ldi	r27, 0x02	; 2
     86e:	cb 0e       	add	r12, r27
     870:	d1 1c       	adc	r13, r1
     872:	c6 01       	movw	r24, r12
     874:	0e 94 47 10 	call	0x208e	; 0x208e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     878:	ce 01       	movw	r24, r28
     87a:	0c 96       	adiw	r24, 0x0c	; 12
     87c:	0e 94 47 10 	call	0x208e	; 0x208e <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     880:	d9 87       	std	Y+9, r29	; 0x09
     882:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     884:	84 e0       	ldi	r24, 0x04	; 4
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	80 1b       	sub	r24, r16
     88a:	91 09       	sbc	r25, r1
     88c:	9d 87       	std	Y+13, r25	; 0x0d
     88e:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     890:	db 8b       	std	Y+19, r29	; 0x13
     892:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     894:	19 a2       	std	Y+33, r1	; 0x21
     896:	1a a2       	std	Y+34, r1	; 0x22
     898:	1b a2       	std	Y+35, r1	; 0x23
     89a:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     89c:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     89e:	a5 01       	movw	r20, r10
     8a0:	b4 01       	movw	r22, r8
     8a2:	c3 01       	movw	r24, r6
     8a4:	0e 94 cf 12 	call	0x259e	; 0x259e <pxPortInitialiseStack>
     8a8:	99 83       	std	Y+1, r25	; 0x01
     8aa:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     8ac:	e1 14       	cp	r14, r1
     8ae:	f1 04       	cpc	r15, r1
     8b0:	19 f0       	breq	.+6      	; 0x8b8 <__DATA_REGION_LENGTH__+0xb8>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     8b2:	f7 01       	movw	r30, r14
     8b4:	d1 83       	std	Z+1, r29	; 0x01
     8b6:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     8b8:	0f b6       	in	r0, 0x3f	; 63
     8ba:	f8 94       	cli
     8bc:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     8be:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <uxCurrentNumberOfTasks>
     8c2:	8f 5f       	subi	r24, 0xFF	; 255
     8c4:	80 93 88 01 	sts	0x0188, r24	; 0x800188 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     8c8:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <pxCurrentTCB>
     8cc:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
     8d0:	89 2b       	or	r24, r25
     8d2:	d1 f5       	brne	.+116    	; 0x948 <__stack+0x49>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     8d4:	d0 93 7a 01 	sts	0x017A, r29	; 0x80017a <pxCurrentTCB+0x1>
     8d8:	c0 93 79 01 	sts	0x0179, r28	; 0x800179 <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     8dc:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <uxCurrentNumberOfTasks>
     8e0:	81 30       	cpi	r24, 0x01	; 1
     8e2:	09 f0       	breq	.+2      	; 0x8e6 <__DATA_REGION_LENGTH__+0xe6>
     8e4:	41 c0       	rjmp	.+130    	; 0x968 <__stack+0x69>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     8e6:	8b eb       	ldi	r24, 0xBB	; 187
     8e8:	91 e0       	ldi	r25, 0x01	; 1
     8ea:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
     8ee:	84 ec       	ldi	r24, 0xC4	; 196
     8f0:	91 e0       	ldi	r25, 0x01	; 1
     8f2:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
     8f6:	8d ec       	ldi	r24, 0xCD	; 205
     8f8:	91 e0       	ldi	r25, 0x01	; 1
     8fa:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
     8fe:	86 ed       	ldi	r24, 0xD6	; 214
     900:	91 e0       	ldi	r25, 0x01	; 1
     902:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     906:	82 eb       	ldi	r24, 0xB2	; 178
     908:	91 e0       	ldi	r25, 0x01	; 1
     90a:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     90e:	89 ea       	ldi	r24, 0xA9	; 169
     910:	91 e0       	ldi	r25, 0x01	; 1
     912:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     916:	8c e9       	ldi	r24, 0x9C	; 156
     918:	91 e0       	ldi	r25, 0x01	; 1
     91a:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     91e:	83 e9       	ldi	r24, 0x93	; 147
     920:	91 e0       	ldi	r25, 0x01	; 1
     922:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     926:	89 e8       	ldi	r24, 0x89	; 137
     928:	91 e0       	ldi	r25, 0x01	; 1
     92a:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     92e:	82 eb       	ldi	r24, 0xB2	; 178
     930:	91 e0       	ldi	r25, 0x01	; 1
     932:	90 93 a8 01 	sts	0x01A8, r25	; 0x8001a8 <pxDelayedTaskList+0x1>
     936:	80 93 a7 01 	sts	0x01A7, r24	; 0x8001a7 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     93a:	89 ea       	ldi	r24, 0xA9	; 169
     93c:	91 e0       	ldi	r25, 0x01	; 1
     93e:	90 93 a6 01 	sts	0x01A6, r25	; 0x8001a6 <pxOverflowDelayedTaskList+0x1>
     942:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <pxOverflowDelayedTaskList>
     946:	10 c0       	rjmp	.+32     	; 0x968 <__stack+0x69>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     948:	80 91 84 01 	lds	r24, 0x0184	; 0x800184 <xSchedulerRunning>
     94c:	81 11       	cpse	r24, r1
     94e:	0c c0       	rjmp	.+24     	; 0x968 <__stack+0x69>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     950:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
     954:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
     958:	96 89       	ldd	r25, Z+22	; 0x16
     95a:	8e 89       	ldd	r24, Y+22	; 0x16
     95c:	89 17       	cp	r24, r25
     95e:	20 f0       	brcs	.+8      	; 0x968 <__stack+0x69>
				{
					pxCurrentTCB = pxNewTCB;
     960:	d0 93 7a 01 	sts	0x017A, r29	; 0x80017a <pxCurrentTCB+0x1>
     964:	c0 93 79 01 	sts	0x0179, r28	; 0x800179 <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     968:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <uxTaskNumber>
     96c:	8f 5f       	subi	r24, 0xFF	; 255
     96e:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     972:	8e 89       	ldd	r24, Y+22	; 0x16
     974:	90 91 85 01 	lds	r25, 0x0185	; 0x800185 <uxTopReadyPriority>
     978:	98 17       	cp	r25, r24
     97a:	10 f4       	brcc	.+4      	; 0x980 <__stack+0x81>
     97c:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <uxTopReadyPriority>
     980:	f9 e0       	ldi	r31, 0x09	; 9
     982:	8f 9f       	mul	r24, r31
     984:	c0 01       	movw	r24, r0
     986:	11 24       	eor	r1, r1
     988:	b6 01       	movw	r22, r12
     98a:	85 54       	subi	r24, 0x45	; 69
     98c:	9e 4f       	sbci	r25, 0xFE	; 254
     98e:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     992:	0f 90       	pop	r0
     994:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     996:	80 91 84 01 	lds	r24, 0x0184	; 0x800184 <xSchedulerRunning>
     99a:	88 23       	and	r24, r24
     99c:	51 f0       	breq	.+20     	; 0x9b2 <__stack+0xb3>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     99e:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
     9a2:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
     9a6:	96 89       	ldd	r25, Z+22	; 0x16
     9a8:	8e 89       	ldd	r24, Y+22	; 0x16
     9aa:	98 17       	cp	r25, r24
     9ac:	10 f4       	brcc	.+4      	; 0x9b2 <__stack+0xb3>
		{
			taskYIELD_IF_USING_PREEMPTION();
     9ae:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     9b2:	81 e0       	ldi	r24, 0x01	; 1
     9b4:	01 c0       	rjmp	.+2      	; 0x9b8 <__stack+0xb9>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     9b6:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     9b8:	df 91       	pop	r29
     9ba:	cf 91       	pop	r28
     9bc:	1f 91       	pop	r17
     9be:	0f 91       	pop	r16
     9c0:	ff 90       	pop	r15
     9c2:	ef 90       	pop	r14
     9c4:	df 90       	pop	r13
     9c6:	cf 90       	pop	r12
     9c8:	bf 90       	pop	r11
     9ca:	af 90       	pop	r10
     9cc:	9f 90       	pop	r9
     9ce:	8f 90       	pop	r8
     9d0:	7f 90       	pop	r7
     9d2:	6f 90       	pop	r6
     9d4:	5f 90       	pop	r5
     9d6:	4f 90       	pop	r4
     9d8:	3f 90       	pop	r3
     9da:	08 95       	ret

000009dc <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     9dc:	0f 93       	push	r16
     9de:	1f 93       	push	r17
     9e0:	cf 93       	push	r28
     9e2:	df 93       	push	r29
     9e4:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     9e6:	0f b6       	in	r0, 0x3f	; 63
     9e8:	f8 94       	cli
     9ea:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     9ec:	89 2b       	or	r24, r25
     9ee:	21 f4       	brne	.+8      	; 0x9f8 <vTaskDelete+0x1c>
     9f0:	c0 91 79 01 	lds	r28, 0x0179	; 0x800179 <pxCurrentTCB>
     9f4:	d0 91 7a 01 	lds	r29, 0x017A	; 0x80017a <pxCurrentTCB+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     9f8:	8e 01       	movw	r16, r28
     9fa:	0e 5f       	subi	r16, 0xFE	; 254
     9fc:	1f 4f       	sbci	r17, 0xFF	; 255
     9fe:	c8 01       	movw	r24, r16
     a00:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     a04:	8c 89       	ldd	r24, Y+20	; 0x14
     a06:	9d 89       	ldd	r25, Y+21	; 0x15
     a08:	89 2b       	or	r24, r25
     a0a:	21 f0       	breq	.+8      	; 0xa14 <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     a0c:	ce 01       	movw	r24, r28
     a0e:	0c 96       	adiw	r24, 0x0c	; 12
     a10:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     a14:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <uxTaskNumber>
     a18:	8f 5f       	subi	r24, 0xFF	; 255
     a1a:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     a1e:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <pxCurrentTCB>
     a22:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
     a26:	c8 17       	cp	r28, r24
     a28:	d9 07       	cpc	r29, r25
     a2a:	59 f4       	brne	.+22     	; 0xa42 <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     a2c:	b8 01       	movw	r22, r16
     a2e:	83 e9       	ldi	r24, 0x93	; 147
     a30:	91 e0       	ldi	r25, 0x01	; 1
     a32:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     a36:	80 91 92 01 	lds	r24, 0x0192	; 0x800192 <uxDeletedTasksWaitingCleanUp>
     a3a:	8f 5f       	subi	r24, 0xFF	; 255
     a3c:	80 93 92 01 	sts	0x0192, r24	; 0x800192 <uxDeletedTasksWaitingCleanUp>
     a40:	0e c0       	rjmp	.+28     	; 0xa5e <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     a42:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <uxCurrentNumberOfTasks>
     a46:	81 50       	subi	r24, 0x01	; 1
     a48:	80 93 88 01 	sts	0x0188, r24	; 0x800188 <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     a4c:	8f 89       	ldd	r24, Y+23	; 0x17
     a4e:	98 8d       	ldd	r25, Y+24	; 0x18
     a50:	0e 94 c0 12 	call	0x2580	; 0x2580 <vPortFree>
			vPortFree( pxTCB );
     a54:	ce 01       	movw	r24, r28
     a56:	0e 94 c0 12 	call	0x2580	; 0x2580 <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     a5a:	0e 94 48 03 	call	0x690	; 0x690 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     a5e:	0f 90       	pop	r0
     a60:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     a62:	80 91 84 01 	lds	r24, 0x0184	; 0x800184 <xSchedulerRunning>
     a66:	88 23       	and	r24, r24
     a68:	49 f0       	breq	.+18     	; 0xa7c <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     a6a:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <pxCurrentTCB>
     a6e:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
     a72:	c8 17       	cp	r28, r24
     a74:	d9 07       	cpc	r29, r25
     a76:	11 f4       	brne	.+4      	; 0xa7c <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     a78:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     a7c:	df 91       	pop	r29
     a7e:	cf 91       	pop	r28
     a80:	1f 91       	pop	r17
     a82:	0f 91       	pop	r16
     a84:	08 95       	ret

00000a86 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     a86:	0f 93       	push	r16
     a88:	1f 93       	push	r17
     a8a:	cf 93       	push	r28
     a8c:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     a8e:	20 91 79 01 	lds	r18, 0x0179	; 0x800179 <pxCurrentTCB>
     a92:	30 91 7a 01 	lds	r19, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
     a96:	82 17       	cp	r24, r18
     a98:	93 07       	cpc	r25, r19
     a9a:	b9 f1       	breq	.+110    	; 0xb0a <vTaskResume+0x84>
     a9c:	00 97       	sbiw	r24, 0x00	; 0
     a9e:	a9 f1       	breq	.+106    	; 0xb0a <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     aa0:	0f b6       	in	r0, 0x3f	; 63
     aa2:	f8 94       	cli
     aa4:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     aa6:	fc 01       	movw	r30, r24
     aa8:	22 85       	ldd	r18, Z+10	; 0x0a
     aaa:	33 85       	ldd	r19, Z+11	; 0x0b
     aac:	29 58       	subi	r18, 0x89	; 137
     aae:	31 40       	sbci	r19, 0x01	; 1
     ab0:	51 f5       	brne	.+84     	; 0xb06 <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     ab2:	fc 01       	movw	r30, r24
     ab4:	24 89       	ldd	r18, Z+20	; 0x14
     ab6:	35 89       	ldd	r19, Z+21	; 0x15
     ab8:	f1 e0       	ldi	r31, 0x01	; 1
     aba:	2c 39       	cpi	r18, 0x9C	; 156
     abc:	3f 07       	cpc	r19, r31
     abe:	19 f1       	breq	.+70     	; 0xb06 <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     ac0:	23 2b       	or	r18, r19
     ac2:	09 f5       	brne	.+66     	; 0xb06 <vTaskResume+0x80>
     ac4:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     ac6:	8c 01       	movw	r16, r24
     ac8:	0e 5f       	subi	r16, 0xFE	; 254
     aca:	1f 4f       	sbci	r17, 0xFF	; 255
     acc:	c8 01       	movw	r24, r16
     ace:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     ad2:	8e 89       	ldd	r24, Y+22	; 0x16
     ad4:	90 91 85 01 	lds	r25, 0x0185	; 0x800185 <uxTopReadyPriority>
     ad8:	98 17       	cp	r25, r24
     ada:	10 f4       	brcc	.+4      	; 0xae0 <vTaskResume+0x5a>
     adc:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <uxTopReadyPriority>
     ae0:	29 e0       	ldi	r18, 0x09	; 9
     ae2:	82 9f       	mul	r24, r18
     ae4:	c0 01       	movw	r24, r0
     ae6:	11 24       	eor	r1, r1
     ae8:	b8 01       	movw	r22, r16
     aea:	85 54       	subi	r24, 0x45	; 69
     aec:	9e 4f       	sbci	r25, 0xFE	; 254
     aee:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     af2:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
     af6:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
     afa:	9e 89       	ldd	r25, Y+22	; 0x16
     afc:	86 89       	ldd	r24, Z+22	; 0x16
     afe:	98 17       	cp	r25, r24
     b00:	10 f0       	brcs	.+4      	; 0xb06 <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     b02:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     b06:	0f 90       	pop	r0
     b08:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b0a:	df 91       	pop	r29
     b0c:	cf 91       	pop	r28
     b0e:	1f 91       	pop	r17
     b10:	0f 91       	pop	r16
     b12:	08 95       	ret

00000b14 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     b14:	ef 92       	push	r14
     b16:	ff 92       	push	r15
     b18:	1f 93       	push	r17
     b1a:	cf 93       	push	r28
     b1c:	df 93       	push	r29
     b1e:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     b20:	8a 85       	ldd	r24, Y+10	; 0x0a
     b22:	9b 85       	ldd	r25, Y+11	; 0x0b
     b24:	89 58       	subi	r24, 0x89	; 137
     b26:	91 40       	sbci	r25, 0x01	; 1
     b28:	99 f4       	brne	.+38     	; 0xb50 <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     b2a:	8c 89       	ldd	r24, Y+20	; 0x14
     b2c:	9d 89       	ldd	r25, Y+21	; 0x15
     b2e:	21 e0       	ldi	r18, 0x01	; 1
     b30:	8c 39       	cpi	r24, 0x9C	; 156
     b32:	92 07       	cpc	r25, r18
     b34:	69 f0       	breq	.+26     	; 0xb50 <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     b36:	89 2b       	or	r24, r25
     b38:	59 f4       	brne	.+22     	; 0xb50 <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     b3a:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <uxSchedulerSuspended>
     b3e:	88 23       	and	r24, r24
     b40:	49 f0       	breq	.+18     	; 0xb54 <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     b42:	be 01       	movw	r22, r28
     b44:	64 5f       	subi	r22, 0xF4	; 244
     b46:	7f 4f       	sbci	r23, 0xFF	; 255
     b48:	8c e9       	ldi	r24, 0x9C	; 156
     b4a:	91 e0       	ldi	r25, 0x01	; 1
     b4c:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     b50:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     b52:	21 c0       	rjmp	.+66     	; 0xb96 <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     b54:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
     b58:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     b5c:	11 e0       	ldi	r17, 0x01	; 1
     b5e:	9e 89       	ldd	r25, Y+22	; 0x16
     b60:	86 89       	ldd	r24, Z+22	; 0x16
     b62:	98 17       	cp	r25, r24
     b64:	08 f4       	brcc	.+2      	; 0xb68 <xTaskResumeFromISR+0x54>
     b66:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     b68:	7e 01       	movw	r14, r28
     b6a:	82 e0       	ldi	r24, 0x02	; 2
     b6c:	e8 0e       	add	r14, r24
     b6e:	f1 1c       	adc	r15, r1
     b70:	c7 01       	movw	r24, r14
     b72:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     b76:	8e 89       	ldd	r24, Y+22	; 0x16
     b78:	90 91 85 01 	lds	r25, 0x0185	; 0x800185 <uxTopReadyPriority>
     b7c:	98 17       	cp	r25, r24
     b7e:	10 f4       	brcc	.+4      	; 0xb84 <xTaskResumeFromISR+0x70>
     b80:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <uxTopReadyPriority>
     b84:	29 e0       	ldi	r18, 0x09	; 9
     b86:	82 9f       	mul	r24, r18
     b88:	c0 01       	movw	r24, r0
     b8a:	11 24       	eor	r1, r1
     b8c:	b7 01       	movw	r22, r14
     b8e:	85 54       	subi	r24, 0x45	; 69
     b90:	9e 4f       	sbci	r25, 0xFE	; 254
     b92:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     b96:	81 2f       	mov	r24, r17
     b98:	df 91       	pop	r29
     b9a:	cf 91       	pop	r28
     b9c:	1f 91       	pop	r17
     b9e:	ff 90       	pop	r15
     ba0:	ef 90       	pop	r14
     ba2:	08 95       	ret

00000ba4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     ba4:	ef 92       	push	r14
     ba6:	ff 92       	push	r15
     ba8:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     baa:	8c e7       	ldi	r24, 0x7C	; 124
     bac:	e8 2e       	mov	r14, r24
     bae:	81 e0       	ldi	r24, 0x01	; 1
     bb0:	f8 2e       	mov	r15, r24
     bb2:	00 e0       	ldi	r16, 0x00	; 0
     bb4:	20 e0       	ldi	r18, 0x00	; 0
     bb6:	30 e0       	ldi	r19, 0x00	; 0
     bb8:	45 e5       	ldi	r20, 0x55	; 85
     bba:	50 e0       	ldi	r21, 0x00	; 0
     bbc:	63 e7       	ldi	r22, 0x73	; 115
     bbe:	71 e0       	ldi	r23, 0x01	; 1
     bc0:	8f eb       	ldi	r24, 0xBF	; 191
     bc2:	93 e0       	ldi	r25, 0x03	; 3
     bc4:	0e 94 ed 03 	call	0x7da	; 0x7da <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     bc8:	81 30       	cpi	r24, 0x01	; 1
     bca:	91 f4       	brne	.+36     	; 0xbf0 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     bcc:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     bce:	2f ef       	ldi	r18, 0xFF	; 255
     bd0:	3f ef       	ldi	r19, 0xFF	; 255
     bd2:	30 93 7f 01 	sts	0x017F, r19	; 0x80017f <xNextTaskUnblockTime+0x1>
     bd6:	20 93 7e 01 	sts	0x017E, r18	; 0x80017e <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     bda:	80 93 84 01 	sts	0x0184, r24	; 0x800184 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     bde:	10 92 87 01 	sts	0x0187, r1	; 0x800187 <xTickCount+0x1>
     be2:	10 92 86 01 	sts	0x0186, r1	; 0x800186 <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     be6:	0f 91       	pop	r16
     be8:	ff 90       	pop	r15
     bea:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     bec:	0c 94 3b 13 	jmp	0x2676	; 0x2676 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     bf0:	0f 91       	pop	r16
     bf2:	ff 90       	pop	r15
     bf4:	ef 90       	pop	r14
     bf6:	08 95       	ret

00000bf8 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     bf8:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     bfa:	10 92 84 01 	sts	0x0184, r1	; 0x800184 <xSchedulerRunning>
	vPortEndScheduler();
     bfe:	0c 94 7b 13 	jmp	0x26f6	; 0x26f6 <vPortEndScheduler>

00000c02 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     c02:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <uxSchedulerSuspended>
     c06:	8f 5f       	subi	r24, 0xFF	; 255
     c08:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <uxSchedulerSuspended>
     c0c:	08 95       	ret

00000c0e <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     c0e:	0f b6       	in	r0, 0x3f	; 63
     c10:	f8 94       	cli
     c12:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     c14:	80 91 86 01 	lds	r24, 0x0186	; 0x800186 <xTickCount>
     c18:	90 91 87 01 	lds	r25, 0x0187	; 0x800187 <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     c1c:	0f 90       	pop	r0
     c1e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     c20:	08 95       	ret

00000c22 <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     c22:	80 91 86 01 	lds	r24, 0x0186	; 0x800186 <xTickCount>
     c26:	90 91 87 01 	lds	r25, 0x0187	; 0x800187 <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     c2a:	08 95       	ret

00000c2c <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     c2c:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <uxCurrentNumberOfTasks>
}
     c30:	08 95       	ret

00000c32 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     c32:	00 97       	sbiw	r24, 0x00	; 0
     c34:	21 f4       	brne	.+8      	; 0xc3e <pcTaskGetName+0xc>
     c36:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <pxCurrentTCB>
     c3a:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     c3e:	49 96       	adiw	r24, 0x19	; 25
     c40:	08 95       	ret

00000c42 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     c42:	cf 92       	push	r12
     c44:	df 92       	push	r13
     c46:	ef 92       	push	r14
     c48:	ff 92       	push	r15
     c4a:	0f 93       	push	r16
     c4c:	1f 93       	push	r17
     c4e:	cf 93       	push	r28
     c50:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c52:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <uxSchedulerSuspended>
     c56:	81 11       	cpse	r24, r1
     c58:	8c c0       	rjmp	.+280    	; 0xd72 <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     c5a:	00 91 86 01 	lds	r16, 0x0186	; 0x800186 <xTickCount>
     c5e:	10 91 87 01 	lds	r17, 0x0187	; 0x800187 <xTickCount+0x1>
     c62:	0f 5f       	subi	r16, 0xFF	; 255
     c64:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     c66:	10 93 87 01 	sts	0x0187, r17	; 0x800187 <xTickCount+0x1>
     c6a:	00 93 86 01 	sts	0x0186, r16	; 0x800186 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     c6e:	01 15       	cp	r16, r1
     c70:	11 05       	cpc	r17, r1
     c72:	b9 f4       	brne	.+46     	; 0xca2 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     c74:	80 91 a7 01 	lds	r24, 0x01A7	; 0x8001a7 <pxDelayedTaskList>
     c78:	90 91 a8 01 	lds	r25, 0x01A8	; 0x8001a8 <pxDelayedTaskList+0x1>
     c7c:	20 91 a5 01 	lds	r18, 0x01A5	; 0x8001a5 <pxOverflowDelayedTaskList>
     c80:	30 91 a6 01 	lds	r19, 0x01A6	; 0x8001a6 <pxOverflowDelayedTaskList+0x1>
     c84:	30 93 a8 01 	sts	0x01A8, r19	; 0x8001a8 <pxDelayedTaskList+0x1>
     c88:	20 93 a7 01 	sts	0x01A7, r18	; 0x8001a7 <pxDelayedTaskList>
     c8c:	90 93 a6 01 	sts	0x01A6, r25	; 0x8001a6 <pxOverflowDelayedTaskList+0x1>
     c90:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <pxOverflowDelayedTaskList>
     c94:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <xNumOfOverflows>
     c98:	8f 5f       	subi	r24, 0xFF	; 255
     c9a:	80 93 81 01 	sts	0x0181, r24	; 0x800181 <xNumOfOverflows>
     c9e:	0e 94 48 03 	call	0x690	; 0x690 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     ca2:	80 91 7e 01 	lds	r24, 0x017E	; 0x80017e <xNextTaskUnblockTime>
     ca6:	90 91 7f 01 	lds	r25, 0x017F	; 0x80017f <xNextTaskUnblockTime+0x1>
     caa:	c0 e0       	ldi	r28, 0x00	; 0
     cac:	08 17       	cp	r16, r24
     cae:	19 07       	cpc	r17, r25
     cb0:	08 f4       	brcc	.+2      	; 0xcb4 <xTaskIncrementTick+0x72>
     cb2:	4f c0       	rjmp	.+158    	; 0xd52 <xTaskIncrementTick+0x110>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     cb4:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     cb6:	e0 91 a7 01 	lds	r30, 0x01A7	; 0x8001a7 <pxDelayedTaskList>
     cba:	f0 91 a8 01 	lds	r31, 0x01A8	; 0x8001a8 <pxDelayedTaskList+0x1>
     cbe:	80 81       	ld	r24, Z
     cc0:	81 11       	cpse	r24, r1
     cc2:	03 c0       	rjmp	.+6      	; 0xcca <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     cc4:	8f ef       	ldi	r24, 0xFF	; 255
     cc6:	9f ef       	ldi	r25, 0xFF	; 255
     cc8:	11 c0       	rjmp	.+34     	; 0xcec <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     cca:	e0 91 a7 01 	lds	r30, 0x01A7	; 0x8001a7 <pxDelayedTaskList>
     cce:	f0 91 a8 01 	lds	r31, 0x01A8	; 0x8001a8 <pxDelayedTaskList+0x1>
     cd2:	05 80       	ldd	r0, Z+5	; 0x05
     cd4:	f6 81       	ldd	r31, Z+6	; 0x06
     cd6:	e0 2d       	mov	r30, r0
     cd8:	e6 80       	ldd	r14, Z+6	; 0x06
     cda:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     cdc:	d7 01       	movw	r26, r14
     cde:	12 96       	adiw	r26, 0x02	; 2
     ce0:	8d 91       	ld	r24, X+
     ce2:	9c 91       	ld	r25, X
     ce4:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     ce6:	08 17       	cp	r16, r24
     ce8:	19 07       	cpc	r17, r25
     cea:	28 f4       	brcc	.+10     	; 0xcf6 <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     cec:	90 93 7f 01 	sts	0x017F, r25	; 0x80017f <xNextTaskUnblockTime+0x1>
     cf0:	80 93 7e 01 	sts	0x017E, r24	; 0x80017e <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     cf4:	2e c0       	rjmp	.+92     	; 0xd52 <xTaskIncrementTick+0x110>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     cf6:	67 01       	movw	r12, r14
     cf8:	b2 e0       	ldi	r27, 0x02	; 2
     cfa:	cb 0e       	add	r12, r27
     cfc:	d1 1c       	adc	r13, r1
     cfe:	c6 01       	movw	r24, r12
     d00:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     d04:	f7 01       	movw	r30, r14
     d06:	84 89       	ldd	r24, Z+20	; 0x14
     d08:	95 89       	ldd	r25, Z+21	; 0x15
     d0a:	89 2b       	or	r24, r25
     d0c:	21 f0       	breq	.+8      	; 0xd16 <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     d0e:	c7 01       	movw	r24, r14
     d10:	0c 96       	adiw	r24, 0x0c	; 12
     d12:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     d16:	d7 01       	movw	r26, r14
     d18:	56 96       	adiw	r26, 0x16	; 22
     d1a:	8c 91       	ld	r24, X
     d1c:	90 91 85 01 	lds	r25, 0x0185	; 0x800185 <uxTopReadyPriority>
     d20:	98 17       	cp	r25, r24
     d22:	10 f4       	brcc	.+4      	; 0xd28 <xTaskIncrementTick+0xe6>
     d24:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <uxTopReadyPriority>
     d28:	d8 9f       	mul	r29, r24
     d2a:	c0 01       	movw	r24, r0
     d2c:	11 24       	eor	r1, r1
     d2e:	b6 01       	movw	r22, r12
     d30:	85 54       	subi	r24, 0x45	; 69
     d32:	9e 4f       	sbci	r25, 0xFE	; 254
     d34:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     d38:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
     d3c:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
     d40:	d7 01       	movw	r26, r14
     d42:	56 96       	adiw	r26, 0x16	; 22
     d44:	9c 91       	ld	r25, X
     d46:	86 89       	ldd	r24, Z+22	; 0x16
     d48:	98 17       	cp	r25, r24
     d4a:	08 f4       	brcc	.+2      	; 0xd4e <xTaskIncrementTick+0x10c>
     d4c:	b4 cf       	rjmp	.-152    	; 0xcb6 <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     d4e:	c1 e0       	ldi	r28, 0x01	; 1
     d50:	b2 cf       	rjmp	.-156    	; 0xcb6 <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     d52:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
     d56:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
     d5a:	e6 89       	ldd	r30, Z+22	; 0x16
     d5c:	b9 e0       	ldi	r27, 0x09	; 9
     d5e:	eb 9f       	mul	r30, r27
     d60:	f0 01       	movw	r30, r0
     d62:	11 24       	eor	r1, r1
     d64:	e5 54       	subi	r30, 0x45	; 69
     d66:	fe 4f       	sbci	r31, 0xFE	; 254
     d68:	80 81       	ld	r24, Z
     d6a:	82 30       	cpi	r24, 0x02	; 2
     d6c:	40 f0       	brcs	.+16     	; 0xd7e <xTaskIncrementTick+0x13c>
			{
				xSwitchRequired = pdTRUE;
     d6e:	c1 e0       	ldi	r28, 0x01	; 1
     d70:	06 c0       	rjmp	.+12     	; 0xd7e <xTaskIncrementTick+0x13c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     d72:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <uxPendedTicks>
     d76:	8f 5f       	subi	r24, 0xFF	; 255
     d78:	80 93 83 01 	sts	0x0183, r24	; 0x800183 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     d7c:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     d7e:	80 91 82 01 	lds	r24, 0x0182	; 0x800182 <xYieldPending>
     d82:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     d84:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     d86:	8c 2f       	mov	r24, r28
     d88:	df 91       	pop	r29
     d8a:	cf 91       	pop	r28
     d8c:	1f 91       	pop	r17
     d8e:	0f 91       	pop	r16
     d90:	ff 90       	pop	r15
     d92:	ef 90       	pop	r14
     d94:	df 90       	pop	r13
     d96:	cf 90       	pop	r12
     d98:	08 95       	ret

00000d9a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     d9a:	ef 92       	push	r14
     d9c:	ff 92       	push	r15
     d9e:	0f 93       	push	r16
     da0:	1f 93       	push	r17
     da2:	cf 93       	push	r28
     da4:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     da6:	0f b6       	in	r0, 0x3f	; 63
     da8:	f8 94       	cli
     daa:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     dac:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <uxSchedulerSuspended>
     db0:	81 50       	subi	r24, 0x01	; 1
     db2:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     db6:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <uxSchedulerSuspended>
     dba:	88 23       	and	r24, r24
     dbc:	11 f0       	breq	.+4      	; 0xdc2 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     dbe:	80 e0       	ldi	r24, 0x00	; 0
     dc0:	52 c0       	rjmp	.+164    	; 0xe66 <xTaskResumeAll+0xcc>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     dc2:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <uxCurrentNumberOfTasks>
     dc6:	88 23       	and	r24, r24
     dc8:	d1 f3       	breq	.-12     	; 0xdbe <xTaskResumeAll+0x24>
     dca:	c0 e0       	ldi	r28, 0x00	; 0
     dcc:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     dce:	89 e0       	ldi	r24, 0x09	; 9
     dd0:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     dd2:	ee 24       	eor	r14, r14
     dd4:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     dd6:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <xPendingReadyList>
     dda:	88 23       	and	r24, r24
     ddc:	51 f1       	breq	.+84     	; 0xe32 <xTaskResumeAll+0x98>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     dde:	e0 91 a1 01 	lds	r30, 0x01A1	; 0x8001a1 <xPendingReadyList+0x5>
     de2:	f0 91 a2 01 	lds	r31, 0x01A2	; 0x8001a2 <xPendingReadyList+0x6>
     de6:	c6 81       	ldd	r28, Z+6	; 0x06
     de8:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     dea:	ce 01       	movw	r24, r28
     dec:	0c 96       	adiw	r24, 0x0c	; 12
     dee:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     df2:	8e 01       	movw	r16, r28
     df4:	0e 5f       	subi	r16, 0xFE	; 254
     df6:	1f 4f       	sbci	r17, 0xFF	; 255
     df8:	c8 01       	movw	r24, r16
     dfa:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     dfe:	8e 89       	ldd	r24, Y+22	; 0x16
     e00:	90 91 85 01 	lds	r25, 0x0185	; 0x800185 <uxTopReadyPriority>
     e04:	98 17       	cp	r25, r24
     e06:	10 f4       	brcc	.+4      	; 0xe0c <xTaskResumeAll+0x72>
     e08:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <uxTopReadyPriority>
     e0c:	f8 9e       	mul	r15, r24
     e0e:	c0 01       	movw	r24, r0
     e10:	11 24       	eor	r1, r1
     e12:	b8 01       	movw	r22, r16
     e14:	85 54       	subi	r24, 0x45	; 69
     e16:	9e 4f       	sbci	r25, 0xFE	; 254
     e18:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     e1c:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
     e20:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
     e24:	9e 89       	ldd	r25, Y+22	; 0x16
     e26:	86 89       	ldd	r24, Z+22	; 0x16
     e28:	98 17       	cp	r25, r24
     e2a:	a8 f2       	brcs	.-86     	; 0xdd6 <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     e2c:	e0 92 82 01 	sts	0x0182, r14	; 0x800182 <xYieldPending>
     e30:	d2 cf       	rjmp	.-92     	; 0xdd6 <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     e32:	cd 2b       	or	r28, r29
     e34:	11 f0       	breq	.+4      	; 0xe3a <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     e36:	0e 94 48 03 	call	0x690	; 0x690 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     e3a:	c0 91 83 01 	lds	r28, 0x0183	; 0x800183 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     e3e:	cc 23       	and	r28, r28
     e40:	51 f0       	breq	.+20     	; 0xe56 <xTaskResumeAll+0xbc>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     e42:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     e44:	0e 94 21 06 	call	0xc42	; 0xc42 <xTaskIncrementTick>
     e48:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     e4a:	d0 93 82 01 	sts	0x0182, r29	; 0x800182 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     e4e:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     e50:	c9 f7       	brne	.-14     	; 0xe44 <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     e52:	10 92 83 01 	sts	0x0183, r1	; 0x800183 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     e56:	80 91 82 01 	lds	r24, 0x0182	; 0x800182 <xYieldPending>
     e5a:	88 23       	and	r24, r24
     e5c:	09 f4       	brne	.+2      	; 0xe60 <xTaskResumeAll+0xc6>
     e5e:	af cf       	rjmp	.-162    	; 0xdbe <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     e60:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     e64:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     e66:	0f 90       	pop	r0
     e68:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     e6a:	df 91       	pop	r29
     e6c:	cf 91       	pop	r28
     e6e:	1f 91       	pop	r17
     e70:	0f 91       	pop	r16
     e72:	ff 90       	pop	r15
     e74:	ef 90       	pop	r14
     e76:	08 95       	ret

00000e78 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     e78:	0f 93       	push	r16
     e7a:	1f 93       	push	r17
     e7c:	cf 93       	push	r28
     e7e:	df 93       	push	r29
     e80:	8c 01       	movw	r16, r24
     e82:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     e84:	0e 94 01 06 	call	0xc02	; 0xc02 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     e88:	40 91 86 01 	lds	r20, 0x0186	; 0x800186 <xTickCount>
     e8c:	50 91 87 01 	lds	r21, 0x0187	; 0x800187 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     e90:	f8 01       	movw	r30, r16
     e92:	20 81       	ld	r18, Z
     e94:	31 81       	ldd	r19, Z+1	; 0x01
     e96:	c9 01       	movw	r24, r18
     e98:	8c 0f       	add	r24, r28
     e9a:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     e9c:	42 17       	cp	r20, r18
     e9e:	53 07       	cpc	r21, r19
     ea0:	20 f4       	brcc	.+8      	; 0xeaa <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     ea2:	82 17       	cp	r24, r18
     ea4:	93 07       	cpc	r25, r19
     ea6:	40 f4       	brcc	.+16     	; 0xeb8 <vTaskDelayUntil+0x40>
     ea8:	03 c0       	rjmp	.+6      	; 0xeb0 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     eaa:	82 17       	cp	r24, r18
     eac:	93 07       	cpc	r25, r19
     eae:	30 f0       	brcs	.+12     	; 0xebc <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     eb0:	21 e0       	ldi	r18, 0x01	; 1
     eb2:	48 17       	cp	r20, r24
     eb4:	59 07       	cpc	r21, r25
     eb6:	18 f0       	brcs	.+6      	; 0xebe <vTaskDelayUntil+0x46>
     eb8:	20 e0       	ldi	r18, 0x00	; 0
     eba:	01 c0       	rjmp	.+2      	; 0xebe <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     ebc:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     ebe:	f8 01       	movw	r30, r16
     ec0:	91 83       	std	Z+1, r25	; 0x01
     ec2:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     ec4:	22 23       	and	r18, r18
     ec6:	29 f0       	breq	.+10     	; 0xed2 <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     ec8:	60 e0       	ldi	r22, 0x00	; 0
     eca:	84 1b       	sub	r24, r20
     ecc:	95 0b       	sbc	r25, r21
     ece:	0e 94 63 03 	call	0x6c6	; 0x6c6 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     ed2:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     ed6:	81 11       	cpse	r24, r1
     ed8:	02 c0       	rjmp	.+4      	; 0xede <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     eda:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     ede:	df 91       	pop	r29
     ee0:	cf 91       	pop	r28
     ee2:	1f 91       	pop	r17
     ee4:	0f 91       	pop	r16
     ee6:	08 95       	ret

00000ee8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     ee8:	cf 93       	push	r28
     eea:	df 93       	push	r29
     eec:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     eee:	89 2b       	or	r24, r25
     ef0:	19 f4       	brne	.+6      	; 0xef8 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     ef2:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
     ef6:	0a c0       	rjmp	.+20     	; 0xf0c <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     ef8:	0e 94 01 06 	call	0xc02	; 0xc02 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     efc:	60 e0       	ldi	r22, 0x00	; 0
     efe:	ce 01       	movw	r24, r28
     f00:	0e 94 63 03 	call	0x6c6	; 0x6c6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     f04:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     f08:	88 23       	and	r24, r24
     f0a:	99 f3       	breq	.-26     	; 0xef2 <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     f0c:	df 91       	pop	r29
     f0e:	cf 91       	pop	r28
     f10:	08 95       	ret

00000f12 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     f12:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <uxSchedulerSuspended>
     f16:	88 23       	and	r24, r24
     f18:	21 f0       	breq	.+8      	; 0xf22 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     f1a:	81 e0       	ldi	r24, 0x01	; 1
     f1c:	80 93 82 01 	sts	0x0182, r24	; 0x800182 <xYieldPending>
     f20:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     f22:	10 92 82 01 	sts	0x0182, r1	; 0x800182 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     f26:	80 91 85 01 	lds	r24, 0x0185	; 0x800185 <uxTopReadyPriority>
     f2a:	69 e0       	ldi	r22, 0x09	; 9
     f2c:	48 2f       	mov	r20, r24
     f2e:	50 e0       	ldi	r21, 0x00	; 0
     f30:	64 9f       	mul	r22, r20
     f32:	90 01       	movw	r18, r0
     f34:	65 9f       	mul	r22, r21
     f36:	30 0d       	add	r19, r0
     f38:	11 24       	eor	r1, r1
     f3a:	f9 01       	movw	r30, r18
     f3c:	e5 54       	subi	r30, 0x45	; 69
     f3e:	fe 4f       	sbci	r31, 0xFE	; 254
     f40:	90 81       	ld	r25, Z
     f42:	91 11       	cpse	r25, r1
     f44:	02 c0       	rjmp	.+4      	; 0xf4a <vTaskSwitchContext+0x38>
     f46:	81 50       	subi	r24, 0x01	; 1
     f48:	f1 cf       	rjmp	.-30     	; 0xf2c <vTaskSwitchContext+0x1a>
     f4a:	a1 81       	ldd	r26, Z+1	; 0x01
     f4c:	b2 81       	ldd	r27, Z+2	; 0x02
     f4e:	12 96       	adiw	r26, 0x02	; 2
     f50:	0d 90       	ld	r0, X+
     f52:	bc 91       	ld	r27, X
     f54:	a0 2d       	mov	r26, r0
     f56:	b2 83       	std	Z+2, r27	; 0x02
     f58:	a1 83       	std	Z+1, r26	; 0x01
     f5a:	22 54       	subi	r18, 0x42	; 66
     f5c:	3e 4f       	sbci	r19, 0xFE	; 254
     f5e:	a2 17       	cp	r26, r18
     f60:	b3 07       	cpc	r27, r19
     f62:	31 f4       	brne	.+12     	; 0xf70 <vTaskSwitchContext+0x5e>
     f64:	12 96       	adiw	r26, 0x02	; 2
     f66:	2d 91       	ld	r18, X+
     f68:	3c 91       	ld	r19, X
     f6a:	13 97       	sbiw	r26, 0x03	; 3
     f6c:	32 83       	std	Z+2, r19	; 0x02
     f6e:	21 83       	std	Z+1, r18	; 0x01
     f70:	99 e0       	ldi	r25, 0x09	; 9
     f72:	94 9f       	mul	r25, r20
     f74:	f0 01       	movw	r30, r0
     f76:	95 9f       	mul	r25, r21
     f78:	f0 0d       	add	r31, r0
     f7a:	11 24       	eor	r1, r1
     f7c:	e5 54       	subi	r30, 0x45	; 69
     f7e:	fe 4f       	sbci	r31, 0xFE	; 254
     f80:	01 80       	ldd	r0, Z+1	; 0x01
     f82:	f2 81       	ldd	r31, Z+2	; 0x02
     f84:	e0 2d       	mov	r30, r0
     f86:	26 81       	ldd	r18, Z+6	; 0x06
     f88:	37 81       	ldd	r19, Z+7	; 0x07
     f8a:	30 93 7a 01 	sts	0x017A, r19	; 0x80017a <pxCurrentTCB+0x1>
     f8e:	20 93 79 01 	sts	0x0179, r18	; 0x800179 <pxCurrentTCB>
     f92:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <uxTopReadyPriority>
     f96:	08 95       	ret

00000f98 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     f98:	0f 93       	push	r16
     f9a:	1f 93       	push	r17
     f9c:	cf 93       	push	r28
     f9e:	df 93       	push	r29
     fa0:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     fa2:	0f b6       	in	r0, 0x3f	; 63
     fa4:	f8 94       	cli
     fa6:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     fa8:	89 2b       	or	r24, r25
     faa:	21 f4       	brne	.+8      	; 0xfb4 <vTaskSuspend+0x1c>
     fac:	c0 91 79 01 	lds	r28, 0x0179	; 0x800179 <pxCurrentTCB>
     fb0:	d0 91 7a 01 	lds	r29, 0x017A	; 0x80017a <pxCurrentTCB+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     fb4:	8e 01       	movw	r16, r28
     fb6:	0e 5f       	subi	r16, 0xFE	; 254
     fb8:	1f 4f       	sbci	r17, 0xFF	; 255
     fba:	c8 01       	movw	r24, r16
     fbc:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     fc0:	8c 89       	ldd	r24, Y+20	; 0x14
     fc2:	9d 89       	ldd	r25, Y+21	; 0x15
     fc4:	89 2b       	or	r24, r25
     fc6:	21 f0       	breq	.+8      	; 0xfd0 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     fc8:	ce 01       	movw	r24, r28
     fca:	0c 96       	adiw	r24, 0x0c	; 12
     fcc:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     fd0:	b8 01       	movw	r22, r16
     fd2:	89 e8       	ldi	r24, 0x89	; 137
     fd4:	91 e0       	ldi	r25, 0x01	; 1
     fd6:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     fda:	8d a1       	ldd	r24, Y+37	; 0x25
     fdc:	81 30       	cpi	r24, 0x01	; 1
     fde:	09 f4       	brne	.+2      	; 0xfe2 <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     fe0:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     fe2:	0f 90       	pop	r0
     fe4:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     fe6:	80 91 84 01 	lds	r24, 0x0184	; 0x800184 <xSchedulerRunning>
     fea:	88 23       	and	r24, r24
     fec:	39 f0       	breq	.+14     	; 0xffc <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     fee:	0f b6       	in	r0, 0x3f	; 63
     ff0:	f8 94       	cli
     ff2:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     ff4:	0e 94 48 03 	call	0x690	; 0x690 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     ff8:	0f 90       	pop	r0
     ffa:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     ffc:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <pxCurrentTCB>
    1000:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    1004:	c8 17       	cp	r28, r24
    1006:	d9 07       	cpc	r29, r25
    1008:	c1 f4       	brne	.+48     	; 0x103a <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
    100a:	80 91 84 01 	lds	r24, 0x0184	; 0x800184 <xSchedulerRunning>
    100e:	88 23       	and	r24, r24
    1010:	19 f0       	breq	.+6      	; 0x1018 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    1012:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
    1016:	11 c0       	rjmp	.+34     	; 0x103a <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    1018:	90 91 89 01 	lds	r25, 0x0189	; 0x800189 <xSuspendedTaskList>
    101c:	80 91 88 01 	lds	r24, 0x0188	; 0x800188 <uxCurrentNumberOfTasks>
    1020:	98 13       	cpse	r25, r24
    1022:	05 c0       	rjmp	.+10     	; 0x102e <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    1024:	10 92 7a 01 	sts	0x017A, r1	; 0x80017a <pxCurrentTCB+0x1>
    1028:	10 92 79 01 	sts	0x0179, r1	; 0x800179 <pxCurrentTCB>
    102c:	06 c0       	rjmp	.+12     	; 0x103a <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    102e:	df 91       	pop	r29
    1030:	cf 91       	pop	r28
    1032:	1f 91       	pop	r17
    1034:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
    1036:	0c 94 89 07 	jmp	0xf12	; 0xf12 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    103a:	df 91       	pop	r29
    103c:	cf 91       	pop	r28
    103e:	1f 91       	pop	r17
    1040:	0f 91       	pop	r16
    1042:	08 95       	ret

00001044 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1044:	cf 93       	push	r28
    1046:	df 93       	push	r29
    1048:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    104a:	60 91 79 01 	lds	r22, 0x0179	; 0x800179 <pxCurrentTCB>
    104e:	70 91 7a 01 	lds	r23, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    1052:	64 5f       	subi	r22, 0xF4	; 244
    1054:	7f 4f       	sbci	r23, 0xFF	; 255
    1056:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    105a:	61 e0       	ldi	r22, 0x01	; 1
    105c:	ce 01       	movw	r24, r28
}
    105e:	df 91       	pop	r29
    1060:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1062:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <prvAddCurrentTaskToDelayedList>

00001066 <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    1066:	cf 93       	push	r28
    1068:	df 93       	push	r29
    106a:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    106c:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    1070:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    1074:	70 68       	ori	r23, 0x80	; 128
    1076:	75 87       	std	Z+13, r23	; 0x0d
    1078:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    107a:	60 91 79 01 	lds	r22, 0x0179	; 0x800179 <pxCurrentTCB>
    107e:	70 91 7a 01 	lds	r23, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    1082:	64 5f       	subi	r22, 0xF4	; 244
    1084:	7f 4f       	sbci	r23, 0xFF	; 255
    1086:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    108a:	61 e0       	ldi	r22, 0x01	; 1
    108c:	ce 01       	movw	r24, r28
}
    108e:	df 91       	pop	r29
    1090:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1092:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <prvAddCurrentTaskToDelayedList>

00001096 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1096:	0f 93       	push	r16
    1098:	1f 93       	push	r17
    109a:	cf 93       	push	r28
    109c:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    109e:	dc 01       	movw	r26, r24
    10a0:	15 96       	adiw	r26, 0x05	; 5
    10a2:	ed 91       	ld	r30, X+
    10a4:	fc 91       	ld	r31, X
    10a6:	16 97       	sbiw	r26, 0x06	; 6
    10a8:	c6 81       	ldd	r28, Z+6	; 0x06
    10aa:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    10ac:	8e 01       	movw	r16, r28
    10ae:	04 5f       	subi	r16, 0xF4	; 244
    10b0:	1f 4f       	sbci	r17, 0xFF	; 255
    10b2:	c8 01       	movw	r24, r16
    10b4:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    10b8:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <uxSchedulerSuspended>
    10bc:	81 11       	cpse	r24, r1
    10be:	14 c0       	rjmp	.+40     	; 0x10e8 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    10c0:	0a 50       	subi	r16, 0x0A	; 10
    10c2:	11 09       	sbc	r17, r1
    10c4:	c8 01       	movw	r24, r16
    10c6:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    10ca:	8e 89       	ldd	r24, Y+22	; 0x16
    10cc:	90 91 85 01 	lds	r25, 0x0185	; 0x800185 <uxTopReadyPriority>
    10d0:	98 17       	cp	r25, r24
    10d2:	10 f4       	brcc	.+4      	; 0x10d8 <xTaskRemoveFromEventList+0x42>
    10d4:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <uxTopReadyPriority>
    10d8:	b9 e0       	ldi	r27, 0x09	; 9
    10da:	8b 9f       	mul	r24, r27
    10dc:	c0 01       	movw	r24, r0
    10de:	11 24       	eor	r1, r1
    10e0:	b8 01       	movw	r22, r16
    10e2:	85 54       	subi	r24, 0x45	; 69
    10e4:	9e 4f       	sbci	r25, 0xFE	; 254
    10e6:	03 c0       	rjmp	.+6      	; 0x10ee <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    10e8:	b8 01       	movw	r22, r16
    10ea:	8c e9       	ldi	r24, 0x9C	; 156
    10ec:	91 e0       	ldi	r25, 0x01	; 1
    10ee:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    10f2:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    10f6:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    10fa:	9e 89       	ldd	r25, Y+22	; 0x16
    10fc:	86 89       	ldd	r24, Z+22	; 0x16
    10fe:	89 17       	cp	r24, r25
    1100:	20 f4       	brcc	.+8      	; 0x110a <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1102:	81 e0       	ldi	r24, 0x01	; 1
    1104:	80 93 82 01 	sts	0x0182, r24	; 0x800182 <xYieldPending>
    1108:	01 c0       	rjmp	.+2      	; 0x110c <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
    110a:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    110c:	df 91       	pop	r29
    110e:	cf 91       	pop	r28
    1110:	1f 91       	pop	r17
    1112:	0f 91       	pop	r16
    1114:	08 95       	ret

00001116 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    1116:	0f 93       	push	r16
    1118:	1f 93       	push	r17
    111a:	cf 93       	push	r28
    111c:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    111e:	70 68       	ori	r23, 0x80	; 128
    1120:	fc 01       	movw	r30, r24
    1122:	71 83       	std	Z+1, r23	; 0x01
    1124:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1126:	c6 81       	ldd	r28, Z+6	; 0x06
    1128:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    112a:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    112e:	8e 01       	movw	r16, r28
    1130:	0e 5f       	subi	r16, 0xFE	; 254
    1132:	1f 4f       	sbci	r17, 0xFF	; 255
    1134:	c8 01       	movw	r24, r16
    1136:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    113a:	8e 89       	ldd	r24, Y+22	; 0x16
    113c:	90 91 85 01 	lds	r25, 0x0185	; 0x800185 <uxTopReadyPriority>
    1140:	98 17       	cp	r25, r24
    1142:	10 f4       	brcc	.+4      	; 0x1148 <vTaskRemoveFromUnorderedEventList+0x32>
    1144:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <uxTopReadyPriority>
    1148:	f9 e0       	ldi	r31, 0x09	; 9
    114a:	8f 9f       	mul	r24, r31
    114c:	c0 01       	movw	r24, r0
    114e:	11 24       	eor	r1, r1
    1150:	b8 01       	movw	r22, r16
    1152:	85 54       	subi	r24, 0x45	; 69
    1154:	9e 4f       	sbci	r25, 0xFE	; 254
    1156:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    115a:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    115e:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    1162:	9e 89       	ldd	r25, Y+22	; 0x16
    1164:	86 89       	ldd	r24, Z+22	; 0x16
    1166:	89 17       	cp	r24, r25
    1168:	18 f4       	brcc	.+6      	; 0x1170 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    116a:	81 e0       	ldi	r24, 0x01	; 1
    116c:	80 93 82 01 	sts	0x0182, r24	; 0x800182 <xYieldPending>
	}
}
    1170:	df 91       	pop	r29
    1172:	cf 91       	pop	r28
    1174:	1f 91       	pop	r17
    1176:	0f 91       	pop	r16
    1178:	08 95       	ret

0000117a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    117a:	0f b6       	in	r0, 0x3f	; 63
    117c:	f8 94       	cli
    117e:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    1180:	20 91 81 01 	lds	r18, 0x0181	; 0x800181 <xNumOfOverflows>
    1184:	fc 01       	movw	r30, r24
    1186:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
    1188:	20 91 86 01 	lds	r18, 0x0186	; 0x800186 <xTickCount>
    118c:	30 91 87 01 	lds	r19, 0x0187	; 0x800187 <xTickCount+0x1>
    1190:	32 83       	std	Z+2, r19	; 0x02
    1192:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
    1194:	0f 90       	pop	r0
    1196:	0f be       	out	0x3f, r0	; 63
    1198:	08 95       	ret

0000119a <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    119a:	20 91 81 01 	lds	r18, 0x0181	; 0x800181 <xNumOfOverflows>
    119e:	fc 01       	movw	r30, r24
    11a0:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    11a2:	20 91 86 01 	lds	r18, 0x0186	; 0x800186 <xTickCount>
    11a6:	30 91 87 01 	lds	r19, 0x0187	; 0x800187 <xTickCount+0x1>
    11aa:	32 83       	std	Z+2, r19	; 0x02
    11ac:	21 83       	std	Z+1, r18	; 0x01
    11ae:	08 95       	ret

000011b0 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    11b0:	cf 93       	push	r28
    11b2:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    11b4:	0f b6       	in	r0, 0x3f	; 63
    11b6:	f8 94       	cli
    11b8:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    11ba:	40 91 86 01 	lds	r20, 0x0186	; 0x800186 <xTickCount>
    11be:	50 91 87 01 	lds	r21, 0x0187	; 0x800187 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    11c2:	db 01       	movw	r26, r22
    11c4:	2d 91       	ld	r18, X+
    11c6:	3c 91       	ld	r19, X
    11c8:	2f 3f       	cpi	r18, 0xFF	; 255
    11ca:	bf ef       	ldi	r27, 0xFF	; 255
    11cc:	3b 07       	cpc	r19, r27
    11ce:	d9 f0       	breq	.+54     	; 0x1206 <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    11d0:	ec 01       	movw	r28, r24
    11d2:	e9 81       	ldd	r30, Y+1	; 0x01
    11d4:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    11d6:	a0 91 81 01 	lds	r26, 0x0181	; 0x800181 <xNumOfOverflows>
    11da:	b8 81       	ld	r27, Y
    11dc:	ba 17       	cp	r27, r26
    11de:	19 f0       	breq	.+6      	; 0x11e6 <xTaskCheckForTimeOut+0x36>
    11e0:	4e 17       	cp	r20, r30
    11e2:	5f 07       	cpc	r21, r31
    11e4:	90 f4       	brcc	.+36     	; 0x120a <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    11e6:	4e 1b       	sub	r20, r30
    11e8:	5f 0b       	sbc	r21, r31
    11ea:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    11ec:	42 17       	cp	r20, r18
    11ee:	53 07       	cpc	r21, r19
    11f0:	38 f4       	brcc	.+14     	; 0x1200 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    11f2:	24 1b       	sub	r18, r20
    11f4:	35 0b       	sbc	r19, r21
    11f6:	31 83       	std	Z+1, r19	; 0x01
    11f8:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
    11fa:	0e 94 cd 08 	call	0x119a	; 0x119a <vTaskInternalSetTimeOutState>
    11fe:	03 c0       	rjmp	.+6      	; 0x1206 <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
    1200:	11 82       	std	Z+1, r1	; 0x01
    1202:	10 82       	st	Z, r1
    1204:	02 c0       	rjmp	.+4      	; 0x120a <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    1206:	80 e0       	ldi	r24, 0x00	; 0
    1208:	01 c0       	rjmp	.+2      	; 0x120c <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    120a:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    120c:	0f 90       	pop	r0
    120e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1210:	df 91       	pop	r29
    1212:	cf 91       	pop	r28
    1214:	08 95       	ret

00001216 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1216:	81 e0       	ldi	r24, 0x01	; 1
    1218:	80 93 82 01 	sts	0x0182, r24	; 0x800182 <xYieldPending>
    121c:	08 95       	ret

0000121e <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    121e:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <pxCurrentTCB>
    1222:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <pxCurrentTCB+0x1>

		return xReturn;
	}
    1226:	08 95       	ret

00001228 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1228:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    122c:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    1230:	84 85       	ldd	r24, Z+12	; 0x0c
    1232:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1234:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    1238:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    123c:	a0 91 79 01 	lds	r26, 0x0179	; 0x800179 <pxCurrentTCB>
    1240:	b0 91 7a 01 	lds	r27, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    1244:	56 96       	adiw	r26, 0x16	; 22
    1246:	4c 91       	ld	r20, X
    1248:	24 e0       	ldi	r18, 0x04	; 4
    124a:	30 e0       	ldi	r19, 0x00	; 0
    124c:	24 1b       	sub	r18, r20
    124e:	31 09       	sbc	r19, r1
    1250:	35 87       	std	Z+13, r19	; 0x0d
    1252:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    1254:	08 95       	ret

00001256 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    1256:	0f 93       	push	r16
    1258:	1f 93       	push	r17
    125a:	18 2f       	mov	r17, r24
    125c:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    125e:	0f b6       	in	r0, 0x3f	; 63
    1260:	f8 94       	cli
    1262:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    1264:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    1268:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    126c:	41 a1       	ldd	r20, Z+33	; 0x21
    126e:	52 a1       	ldd	r21, Z+34	; 0x22
    1270:	63 a1       	ldd	r22, Z+35	; 0x23
    1272:	74 a1       	ldd	r23, Z+36	; 0x24
    1274:	45 2b       	or	r20, r21
    1276:	46 2b       	or	r20, r22
    1278:	47 2b       	or	r20, r23
    127a:	69 f4       	brne	.+26     	; 0x1296 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    127c:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    1280:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    1284:	21 e0       	ldi	r18, 0x01	; 1
    1286:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1288:	00 97       	sbiw	r24, 0x00	; 0
    128a:	29 f0       	breq	.+10     	; 0x1296 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    128c:	61 e0       	ldi	r22, 0x01	; 1
    128e:	0e 94 63 03 	call	0x6c6	; 0x6c6 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1292:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1296:	0f 90       	pop	r0
    1298:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    129a:	0f b6       	in	r0, 0x3f	; 63
    129c:	f8 94       	cli
    129e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    12a0:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    12a4:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    12a8:	61 a1       	ldd	r22, Z+33	; 0x21
    12aa:	72 a1       	ldd	r23, Z+34	; 0x22
    12ac:	83 a1       	ldd	r24, Z+35	; 0x23
    12ae:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
    12b0:	61 15       	cp	r22, r1
    12b2:	71 05       	cpc	r23, r1
    12b4:	81 05       	cpc	r24, r1
    12b6:	91 05       	cpc	r25, r1
    12b8:	a9 f0       	breq	.+42     	; 0x12e4 <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    12ba:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    12be:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
    12c2:	11 23       	and	r17, r17
    12c4:	29 f0       	breq	.+10     	; 0x12d0 <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    12c6:	11 a2       	std	Z+33, r1	; 0x21
    12c8:	12 a2       	std	Z+34, r1	; 0x22
    12ca:	13 a2       	std	Z+35, r1	; 0x23
    12cc:	14 a2       	std	Z+36, r1	; 0x24
    12ce:	0a c0       	rjmp	.+20     	; 0x12e4 <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    12d0:	8b 01       	movw	r16, r22
    12d2:	9c 01       	movw	r18, r24
    12d4:	01 50       	subi	r16, 0x01	; 1
    12d6:	11 09       	sbc	r17, r1
    12d8:	21 09       	sbc	r18, r1
    12da:	31 09       	sbc	r19, r1
    12dc:	01 a3       	std	Z+33, r16	; 0x21
    12de:	12 a3       	std	Z+34, r17	; 0x22
    12e0:	23 a3       	std	Z+35, r18	; 0x23
    12e2:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    12e4:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    12e8:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    12ec:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    12ee:	0f 90       	pop	r0
    12f0:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    12f2:	1f 91       	pop	r17
    12f4:	0f 91       	pop	r16
    12f6:	08 95       	ret

000012f8 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    12f8:	4f 92       	push	r4
    12fa:	5f 92       	push	r5
    12fc:	6f 92       	push	r6
    12fe:	7f 92       	push	r7
    1300:	8f 92       	push	r8
    1302:	9f 92       	push	r9
    1304:	af 92       	push	r10
    1306:	bf 92       	push	r11
    1308:	ef 92       	push	r14
    130a:	ff 92       	push	r15
    130c:	0f 93       	push	r16
    130e:	1f 93       	push	r17
    1310:	49 01       	movw	r8, r18
    1312:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    1314:	0f b6       	in	r0, 0x3f	; 63
    1316:	f8 94       	cli
    1318:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    131a:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    131e:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    1322:	25 a1       	ldd	r18, Z+37	; 0x25
    1324:	22 30       	cpi	r18, 0x02	; 2
    1326:	39 f1       	breq	.+78     	; 0x1376 <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    1328:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    132c:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    1330:	21 a1       	ldd	r18, Z+33	; 0x21
    1332:	32 a1       	ldd	r19, Z+34	; 0x22
    1334:	43 a1       	ldd	r20, Z+35	; 0x23
    1336:	54 a1       	ldd	r21, Z+36	; 0x24
    1338:	2b 01       	movw	r4, r22
    133a:	3c 01       	movw	r6, r24
    133c:	40 94       	com	r4
    133e:	50 94       	com	r5
    1340:	60 94       	com	r6
    1342:	70 94       	com	r7
    1344:	d3 01       	movw	r26, r6
    1346:	c2 01       	movw	r24, r4
    1348:	82 23       	and	r24, r18
    134a:	93 23       	and	r25, r19
    134c:	a4 23       	and	r26, r20
    134e:	b5 23       	and	r27, r21
    1350:	81 a3       	std	Z+33, r24	; 0x21
    1352:	92 a3       	std	Z+34, r25	; 0x22
    1354:	a3 a3       	std	Z+35, r26	; 0x23
    1356:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1358:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    135c:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    1360:	81 e0       	ldi	r24, 0x01	; 1
    1362:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1364:	e1 14       	cp	r14, r1
    1366:	f1 04       	cpc	r15, r1
    1368:	31 f0       	breq	.+12     	; 0x1376 <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    136a:	61 e0       	ldi	r22, 0x01	; 1
    136c:	c7 01       	movw	r24, r14
    136e:	0e 94 63 03 	call	0x6c6	; 0x6c6 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1372:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1376:	0f 90       	pop	r0
    1378:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    137a:	0f b6       	in	r0, 0x3f	; 63
    137c:	f8 94       	cli
    137e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    1380:	01 15       	cp	r16, r1
    1382:	11 05       	cpc	r17, r1
    1384:	69 f0       	breq	.+26     	; 0x13a0 <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    1386:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    138a:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    138e:	81 a1       	ldd	r24, Z+33	; 0x21
    1390:	92 a1       	ldd	r25, Z+34	; 0x22
    1392:	a3 a1       	ldd	r26, Z+35	; 0x23
    1394:	b4 a1       	ldd	r27, Z+36	; 0x24
    1396:	f8 01       	movw	r30, r16
    1398:	80 83       	st	Z, r24
    139a:	91 83       	std	Z+1, r25	; 0x01
    139c:	a2 83       	std	Z+2, r26	; 0x02
    139e:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    13a0:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    13a4:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    13a8:	85 a1       	ldd	r24, Z+37	; 0x25
    13aa:	82 30       	cpi	r24, 0x02	; 2
    13ac:	c1 f4       	brne	.+48     	; 0x13de <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    13ae:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    13b2:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    13b6:	41 a1       	ldd	r20, Z+33	; 0x21
    13b8:	52 a1       	ldd	r21, Z+34	; 0x22
    13ba:	63 a1       	ldd	r22, Z+35	; 0x23
    13bc:	74 a1       	ldd	r23, Z+36	; 0x24
    13be:	d5 01       	movw	r26, r10
    13c0:	c4 01       	movw	r24, r8
    13c2:	80 95       	com	r24
    13c4:	90 95       	com	r25
    13c6:	a0 95       	com	r26
    13c8:	b0 95       	com	r27
    13ca:	84 23       	and	r24, r20
    13cc:	95 23       	and	r25, r21
    13ce:	a6 23       	and	r26, r22
    13d0:	b7 23       	and	r27, r23
    13d2:	81 a3       	std	Z+33, r24	; 0x21
    13d4:	92 a3       	std	Z+34, r25	; 0x22
    13d6:	a3 a3       	std	Z+35, r26	; 0x23
    13d8:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    13da:	81 e0       	ldi	r24, 0x01	; 1
    13dc:	01 c0       	rjmp	.+2      	; 0x13e0 <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    13de:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    13e0:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    13e4:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    13e8:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    13ea:	0f 90       	pop	r0
    13ec:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    13ee:	1f 91       	pop	r17
    13f0:	0f 91       	pop	r16
    13f2:	ff 90       	pop	r15
    13f4:	ef 90       	pop	r14
    13f6:	bf 90       	pop	r11
    13f8:	af 90       	pop	r10
    13fa:	9f 90       	pop	r9
    13fc:	8f 90       	pop	r8
    13fe:	7f 90       	pop	r7
    1400:	6f 90       	pop	r6
    1402:	5f 90       	pop	r5
    1404:	4f 90       	pop	r4
    1406:	08 95       	ret

00001408 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    1408:	0f 93       	push	r16
    140a:	1f 93       	push	r17
    140c:	cf 93       	push	r28
    140e:	df 93       	push	r29
    1410:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
    1412:	0f b6       	in	r0, 0x3f	; 63
    1414:	f8 94       	cli
    1416:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    1418:	01 15       	cp	r16, r1
    141a:	11 05       	cpc	r17, r1
    141c:	49 f0       	breq	.+18     	; 0x1430 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    141e:	81 a1       	ldd	r24, Z+33	; 0x21
    1420:	92 a1       	ldd	r25, Z+34	; 0x22
    1422:	a3 a1       	ldd	r26, Z+35	; 0x23
    1424:	b4 a1       	ldd	r27, Z+36	; 0x24
    1426:	e8 01       	movw	r28, r16
    1428:	88 83       	st	Y, r24
    142a:	99 83       	std	Y+1, r25	; 0x01
    142c:	aa 83       	std	Y+2, r26	; 0x02
    142e:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1430:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1432:	82 e0       	ldi	r24, 0x02	; 2
    1434:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1436:	22 30       	cpi	r18, 0x02	; 2
    1438:	89 f0       	breq	.+34     	; 0x145c <xTaskGenericNotify+0x54>
    143a:	58 f4       	brcc	.+22     	; 0x1452 <xTaskGenericNotify+0x4a>
    143c:	21 30       	cpi	r18, 0x01	; 1
    143e:	01 f5       	brne	.+64     	; 0x1480 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1440:	81 a1       	ldd	r24, Z+33	; 0x21
    1442:	92 a1       	ldd	r25, Z+34	; 0x22
    1444:	a3 a1       	ldd	r26, Z+35	; 0x23
    1446:	b4 a1       	ldd	r27, Z+36	; 0x24
    1448:	48 2b       	or	r20, r24
    144a:	59 2b       	or	r21, r25
    144c:	6a 2b       	or	r22, r26
    144e:	7b 2b       	or	r23, r27
    1450:	13 c0       	rjmp	.+38     	; 0x1478 <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1452:	23 30       	cpi	r18, 0x03	; 3
    1454:	89 f0       	breq	.+34     	; 0x1478 <xTaskGenericNotify+0x70>
    1456:	24 30       	cpi	r18, 0x04	; 4
    1458:	69 f0       	breq	.+26     	; 0x1474 <xTaskGenericNotify+0x6c>
    145a:	12 c0       	rjmp	.+36     	; 0x1480 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    145c:	81 a1       	ldd	r24, Z+33	; 0x21
    145e:	92 a1       	ldd	r25, Z+34	; 0x22
    1460:	a3 a1       	ldd	r26, Z+35	; 0x23
    1462:	b4 a1       	ldd	r27, Z+36	; 0x24
    1464:	01 96       	adiw	r24, 0x01	; 1
    1466:	a1 1d       	adc	r26, r1
    1468:	b1 1d       	adc	r27, r1
    146a:	81 a3       	std	Z+33, r24	; 0x21
    146c:	92 a3       	std	Z+34, r25	; 0x22
    146e:	a3 a3       	std	Z+35, r26	; 0x23
    1470:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1472:	06 c0       	rjmp	.+12     	; 0x1480 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1474:	32 30       	cpi	r19, 0x02	; 2
    1476:	49 f1       	breq	.+82     	; 0x14ca <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1478:	41 a3       	std	Z+33, r20	; 0x21
    147a:	52 a3       	std	Z+34, r21	; 0x22
    147c:	63 a3       	std	Z+35, r22	; 0x23
    147e:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1480:	31 30       	cpi	r19, 0x01	; 1
    1482:	09 f5       	brne	.+66     	; 0x14c6 <xTaskGenericNotify+0xbe>
    1484:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1486:	8f 01       	movw	r16, r30
    1488:	0e 5f       	subi	r16, 0xFE	; 254
    148a:	1f 4f       	sbci	r17, 0xFF	; 255
    148c:	c8 01       	movw	r24, r16
    148e:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    1492:	8e 89       	ldd	r24, Y+22	; 0x16
    1494:	90 91 85 01 	lds	r25, 0x0185	; 0x800185 <uxTopReadyPriority>
    1498:	98 17       	cp	r25, r24
    149a:	10 f4       	brcc	.+4      	; 0x14a0 <xTaskGenericNotify+0x98>
    149c:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <uxTopReadyPriority>
    14a0:	29 e0       	ldi	r18, 0x09	; 9
    14a2:	82 9f       	mul	r24, r18
    14a4:	c0 01       	movw	r24, r0
    14a6:	11 24       	eor	r1, r1
    14a8:	b8 01       	movw	r22, r16
    14aa:	85 54       	subi	r24, 0x45	; 69
    14ac:	9e 4f       	sbci	r25, 0xFE	; 254
    14ae:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    14b2:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    14b6:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    14ba:	9e 89       	ldd	r25, Y+22	; 0x16
    14bc:	86 89       	ldd	r24, Z+22	; 0x16
    14be:	89 17       	cp	r24, r25
    14c0:	10 f4       	brcc	.+4      	; 0x14c6 <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    14c2:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
    14c6:	81 e0       	ldi	r24, 0x01	; 1
    14c8:	01 c0       	rjmp	.+2      	; 0x14cc <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    14ca:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    14cc:	0f 90       	pop	r0
    14ce:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    14d0:	df 91       	pop	r29
    14d2:	cf 91       	pop	r28
    14d4:	1f 91       	pop	r17
    14d6:	0f 91       	pop	r16
    14d8:	08 95       	ret

000014da <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    14da:	ef 92       	push	r14
    14dc:	ff 92       	push	r15
    14de:	0f 93       	push	r16
    14e0:	1f 93       	push	r17
    14e2:	cf 93       	push	r28
    14e4:	df 93       	push	r29
    14e6:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    14e8:	01 15       	cp	r16, r1
    14ea:	11 05       	cpc	r17, r1
    14ec:	49 f0       	breq	.+18     	; 0x1500 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    14ee:	81 a1       	ldd	r24, Z+33	; 0x21
    14f0:	92 a1       	ldd	r25, Z+34	; 0x22
    14f2:	a3 a1       	ldd	r26, Z+35	; 0x23
    14f4:	b4 a1       	ldd	r27, Z+36	; 0x24
    14f6:	e8 01       	movw	r28, r16
    14f8:	88 83       	st	Y, r24
    14fa:	99 83       	std	Y+1, r25	; 0x01
    14fc:	aa 83       	std	Y+2, r26	; 0x02
    14fe:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1500:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1502:	82 e0       	ldi	r24, 0x02	; 2
    1504:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1506:	22 30       	cpi	r18, 0x02	; 2
    1508:	89 f0       	breq	.+34     	; 0x152c <xTaskGenericNotifyFromISR+0x52>
    150a:	58 f4       	brcc	.+22     	; 0x1522 <xTaskGenericNotifyFromISR+0x48>
    150c:	21 30       	cpi	r18, 0x01	; 1
    150e:	01 f5       	brne	.+64     	; 0x1550 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1510:	81 a1       	ldd	r24, Z+33	; 0x21
    1512:	92 a1       	ldd	r25, Z+34	; 0x22
    1514:	a3 a1       	ldd	r26, Z+35	; 0x23
    1516:	b4 a1       	ldd	r27, Z+36	; 0x24
    1518:	48 2b       	or	r20, r24
    151a:	59 2b       	or	r21, r25
    151c:	6a 2b       	or	r22, r26
    151e:	7b 2b       	or	r23, r27
    1520:	13 c0       	rjmp	.+38     	; 0x1548 <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1522:	23 30       	cpi	r18, 0x03	; 3
    1524:	89 f0       	breq	.+34     	; 0x1548 <xTaskGenericNotifyFromISR+0x6e>
    1526:	24 30       	cpi	r18, 0x04	; 4
    1528:	69 f0       	breq	.+26     	; 0x1544 <xTaskGenericNotifyFromISR+0x6a>
    152a:	12 c0       	rjmp	.+36     	; 0x1550 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    152c:	81 a1       	ldd	r24, Z+33	; 0x21
    152e:	92 a1       	ldd	r25, Z+34	; 0x22
    1530:	a3 a1       	ldd	r26, Z+35	; 0x23
    1532:	b4 a1       	ldd	r27, Z+36	; 0x24
    1534:	01 96       	adiw	r24, 0x01	; 1
    1536:	a1 1d       	adc	r26, r1
    1538:	b1 1d       	adc	r27, r1
    153a:	81 a3       	std	Z+33, r24	; 0x21
    153c:	92 a3       	std	Z+34, r25	; 0x22
    153e:	a3 a3       	std	Z+35, r26	; 0x23
    1540:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1542:	06 c0       	rjmp	.+12     	; 0x1550 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1544:	32 30       	cpi	r19, 0x02	; 2
    1546:	d9 f1       	breq	.+118    	; 0x15be <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1548:	41 a3       	std	Z+33, r20	; 0x21
    154a:	52 a3       	std	Z+34, r21	; 0x22
    154c:	63 a3       	std	Z+35, r22	; 0x23
    154e:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1550:	31 30       	cpi	r19, 0x01	; 1
    1552:	11 f0       	breq	.+4      	; 0x1558 <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1554:	81 e0       	ldi	r24, 0x01	; 1
    1556:	34 c0       	rjmp	.+104    	; 0x15c0 <xTaskGenericNotifyFromISR+0xe6>
    1558:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    155a:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <uxSchedulerSuspended>
    155e:	81 11       	cpse	r24, r1
    1560:	15 c0       	rjmp	.+42     	; 0x158c <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1562:	8f 01       	movw	r16, r30
    1564:	0e 5f       	subi	r16, 0xFE	; 254
    1566:	1f 4f       	sbci	r17, 0xFF	; 255
    1568:	c8 01       	movw	r24, r16
    156a:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    156e:	8e 89       	ldd	r24, Y+22	; 0x16
    1570:	90 91 85 01 	lds	r25, 0x0185	; 0x800185 <uxTopReadyPriority>
    1574:	98 17       	cp	r25, r24
    1576:	10 f4       	brcc	.+4      	; 0x157c <xTaskGenericNotifyFromISR+0xa2>
    1578:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <uxTopReadyPriority>
    157c:	e9 e0       	ldi	r30, 0x09	; 9
    157e:	8e 9f       	mul	r24, r30
    1580:	c0 01       	movw	r24, r0
    1582:	11 24       	eor	r1, r1
    1584:	b8 01       	movw	r22, r16
    1586:	85 54       	subi	r24, 0x45	; 69
    1588:	9e 4f       	sbci	r25, 0xFE	; 254
    158a:	05 c0       	rjmp	.+10     	; 0x1596 <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    158c:	bf 01       	movw	r22, r30
    158e:	64 5f       	subi	r22, 0xF4	; 244
    1590:	7f 4f       	sbci	r23, 0xFF	; 255
    1592:	8c e9       	ldi	r24, 0x9C	; 156
    1594:	91 e0       	ldi	r25, 0x01	; 1
    1596:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    159a:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    159e:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    15a2:	9e 89       	ldd	r25, Y+22	; 0x16
    15a4:	86 89       	ldd	r24, Z+22	; 0x16
    15a6:	89 17       	cp	r24, r25
    15a8:	a8 f6       	brcc	.-86     	; 0x1554 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    15aa:	e1 14       	cp	r14, r1
    15ac:	f1 04       	cpc	r15, r1
    15ae:	19 f0       	breq	.+6      	; 0x15b6 <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    15b0:	81 e0       	ldi	r24, 0x01	; 1
    15b2:	e7 01       	movw	r28, r14
    15b4:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    15b6:	81 e0       	ldi	r24, 0x01	; 1
    15b8:	80 93 82 01 	sts	0x0182, r24	; 0x800182 <xYieldPending>
    15bc:	01 c0       	rjmp	.+2      	; 0x15c0 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    15be:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	1f 91       	pop	r17
    15c6:	0f 91       	pop	r16
    15c8:	ff 90       	pop	r15
    15ca:	ef 90       	pop	r14
    15cc:	08 95       	ret

000015ce <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    15ce:	ef 92       	push	r14
    15d0:	ff 92       	push	r15
    15d2:	0f 93       	push	r16
    15d4:	1f 93       	push	r17
    15d6:	cf 93       	push	r28
    15d8:	df 93       	push	r29
    15da:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    15dc:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    15de:	82 e0       	ldi	r24, 0x02	; 2
    15e0:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    15e2:	81 a1       	ldd	r24, Z+33	; 0x21
    15e4:	92 a1       	ldd	r25, Z+34	; 0x22
    15e6:	a3 a1       	ldd	r26, Z+35	; 0x23
    15e8:	b4 a1       	ldd	r27, Z+36	; 0x24
    15ea:	01 96       	adiw	r24, 0x01	; 1
    15ec:	a1 1d       	adc	r26, r1
    15ee:	b1 1d       	adc	r27, r1
    15f0:	81 a3       	std	Z+33, r24	; 0x21
    15f2:	92 a3       	std	Z+34, r25	; 0x22
    15f4:	a3 a3       	std	Z+35, r26	; 0x23
    15f6:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    15f8:	21 30       	cpi	r18, 0x01	; 1
    15fa:	a1 f5       	brne	.+104    	; 0x1664 <vTaskNotifyGiveFromISR+0x96>
    15fc:	8b 01       	movw	r16, r22
    15fe:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1600:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <uxSchedulerSuspended>
    1604:	81 11       	cpse	r24, r1
    1606:	16 c0       	rjmp	.+44     	; 0x1634 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1608:	7f 01       	movw	r14, r30
    160a:	22 e0       	ldi	r18, 0x02	; 2
    160c:	e2 0e       	add	r14, r18
    160e:	f1 1c       	adc	r15, r1
    1610:	c7 01       	movw	r24, r14
    1612:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1616:	8e 89       	ldd	r24, Y+22	; 0x16
    1618:	90 91 85 01 	lds	r25, 0x0185	; 0x800185 <uxTopReadyPriority>
    161c:	98 17       	cp	r25, r24
    161e:	10 f4       	brcc	.+4      	; 0x1624 <vTaskNotifyGiveFromISR+0x56>
    1620:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <uxTopReadyPriority>
    1624:	e9 e0       	ldi	r30, 0x09	; 9
    1626:	8e 9f       	mul	r24, r30
    1628:	c0 01       	movw	r24, r0
    162a:	11 24       	eor	r1, r1
    162c:	b7 01       	movw	r22, r14
    162e:	85 54       	subi	r24, 0x45	; 69
    1630:	9e 4f       	sbci	r25, 0xFE	; 254
    1632:	05 c0       	rjmp	.+10     	; 0x163e <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1634:	bf 01       	movw	r22, r30
    1636:	64 5f       	subi	r22, 0xF4	; 244
    1638:	7f 4f       	sbci	r23, 0xFF	; 255
    163a:	8c e9       	ldi	r24, 0x9C	; 156
    163c:	91 e0       	ldi	r25, 0x01	; 1
    163e:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1642:	e0 91 79 01 	lds	r30, 0x0179	; 0x800179 <pxCurrentTCB>
    1646:	f0 91 7a 01 	lds	r31, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    164a:	9e 89       	ldd	r25, Y+22	; 0x16
    164c:	86 89       	ldd	r24, Z+22	; 0x16
    164e:	89 17       	cp	r24, r25
    1650:	48 f4       	brcc	.+18     	; 0x1664 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1652:	01 15       	cp	r16, r1
    1654:	11 05       	cpc	r17, r1
    1656:	19 f0       	breq	.+6      	; 0x165e <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1658:	81 e0       	ldi	r24, 0x01	; 1
    165a:	f8 01       	movw	r30, r16
    165c:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    165e:	81 e0       	ldi	r24, 0x01	; 1
    1660:	80 93 82 01 	sts	0x0182, r24	; 0x800182 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    1664:	df 91       	pop	r29
    1666:	cf 91       	pop	r28
    1668:	1f 91       	pop	r17
    166a:	0f 91       	pop	r16
    166c:	ff 90       	pop	r15
    166e:	ef 90       	pop	r14
    1670:	08 95       	ret

00001672 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    1672:	00 97       	sbiw	r24, 0x00	; 0
    1674:	21 f4       	brne	.+8      	; 0x167e <xTaskNotifyStateClear+0xc>
    1676:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <pxCurrentTCB>
    167a:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    167e:	0f b6       	in	r0, 0x3f	; 63
    1680:	f8 94       	cli
    1682:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    1684:	fc 01       	movw	r30, r24
    1686:	25 a1       	ldd	r18, Z+37	; 0x25
    1688:	22 30       	cpi	r18, 0x02	; 2
    168a:	19 f4       	brne	.+6      	; 0x1692 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    168c:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    168e:	81 e0       	ldi	r24, 0x01	; 1
    1690:	01 c0       	rjmp	.+2      	; 0x1694 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    1692:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    1694:	0f 90       	pop	r0
    1696:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1698:	08 95       	ret

0000169a <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    169a:	0f b6       	in	r0, 0x3f	; 63
    169c:	f8 94       	cli
    169e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    16a0:	fc 01       	movw	r30, r24
    16a2:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    16a4:	0f 90       	pop	r0
    16a6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    16a8:	81 e0       	ldi	r24, 0x01	; 1
    16aa:	91 11       	cpse	r25, r1
    16ac:	80 e0       	ldi	r24, 0x00	; 0
}
    16ae:	08 95       	ret

000016b0 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    16b0:	0f 93       	push	r16
    16b2:	1f 93       	push	r17
    16b4:	cf 93       	push	r28
    16b6:	df 93       	push	r29
    16b8:	ec 01       	movw	r28, r24
    16ba:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    16bc:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    16be:	4c 8d       	ldd	r20, Y+28	; 0x1c
    16c0:	44 23       	and	r20, r20
    16c2:	b1 f1       	breq	.+108    	; 0x1730 <prvCopyDataToQueue+0x80>
    16c4:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    16c6:	01 11       	cpse	r16, r1
    16c8:	15 c0       	rjmp	.+42     	; 0x16f4 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    16ca:	8a 81       	ldd	r24, Y+2	; 0x02
    16cc:	9b 81       	ldd	r25, Y+3	; 0x03
    16ce:	0e 94 91 1b 	call	0x3722	; 0x3722 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    16d2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16d4:	8a 81       	ldd	r24, Y+2	; 0x02
    16d6:	9b 81       	ldd	r25, Y+3	; 0x03
    16d8:	82 0f       	add	r24, r18
    16da:	91 1d       	adc	r25, r1
    16dc:	9b 83       	std	Y+3, r25	; 0x03
    16de:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    16e0:	2c 81       	ldd	r18, Y+4	; 0x04
    16e2:	3d 81       	ldd	r19, Y+5	; 0x05
    16e4:	82 17       	cp	r24, r18
    16e6:	93 07       	cpc	r25, r19
    16e8:	18 f1       	brcs	.+70     	; 0x1730 <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    16ea:	88 81       	ld	r24, Y
    16ec:	99 81       	ldd	r25, Y+1	; 0x01
    16ee:	9b 83       	std	Y+3, r25	; 0x03
    16f0:	8a 83       	std	Y+2, r24	; 0x02
    16f2:	1e c0       	rjmp	.+60     	; 0x1730 <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    16f4:	8e 81       	ldd	r24, Y+6	; 0x06
    16f6:	9f 81       	ldd	r25, Y+7	; 0x07
    16f8:	0e 94 91 1b 	call	0x3722	; 0x3722 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    16fc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    16fe:	90 e0       	ldi	r25, 0x00	; 0
    1700:	91 95       	neg	r25
    1702:	81 95       	neg	r24
    1704:	91 09       	sbc	r25, r1
    1706:	2e 81       	ldd	r18, Y+6	; 0x06
    1708:	3f 81       	ldd	r19, Y+7	; 0x07
    170a:	28 0f       	add	r18, r24
    170c:	39 1f       	adc	r19, r25
    170e:	3f 83       	std	Y+7, r19	; 0x07
    1710:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1712:	48 81       	ld	r20, Y
    1714:	59 81       	ldd	r21, Y+1	; 0x01
    1716:	24 17       	cp	r18, r20
    1718:	35 07       	cpc	r19, r21
    171a:	30 f4       	brcc	.+12     	; 0x1728 <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    171c:	2c 81       	ldd	r18, Y+4	; 0x04
    171e:	3d 81       	ldd	r19, Y+5	; 0x05
    1720:	82 0f       	add	r24, r18
    1722:	93 1f       	adc	r25, r19
    1724:	9f 83       	std	Y+7, r25	; 0x07
    1726:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1728:	02 30       	cpi	r16, 0x02	; 2
    172a:	11 f4       	brne	.+4      	; 0x1730 <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    172c:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    172e:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1730:	1f 5f       	subi	r17, 0xFF	; 255
    1732:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    1734:	80 e0       	ldi	r24, 0x00	; 0
    1736:	df 91       	pop	r29
    1738:	cf 91       	pop	r28
    173a:	1f 91       	pop	r17
    173c:	0f 91       	pop	r16
    173e:	08 95       	ret

00001740 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1740:	fc 01       	movw	r30, r24
    1742:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1744:	44 8d       	ldd	r20, Z+28	; 0x1c
    1746:	44 23       	and	r20, r20
    1748:	a1 f0       	breq	.+40     	; 0x1772 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    174a:	50 e0       	ldi	r21, 0x00	; 0
    174c:	26 81       	ldd	r18, Z+6	; 0x06
    174e:	37 81       	ldd	r19, Z+7	; 0x07
    1750:	24 0f       	add	r18, r20
    1752:	35 1f       	adc	r19, r21
    1754:	37 83       	std	Z+7, r19	; 0x07
    1756:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1758:	64 81       	ldd	r22, Z+4	; 0x04
    175a:	75 81       	ldd	r23, Z+5	; 0x05
    175c:	26 17       	cp	r18, r22
    175e:	37 07       	cpc	r19, r23
    1760:	20 f0       	brcs	.+8      	; 0x176a <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1762:	20 81       	ld	r18, Z
    1764:	31 81       	ldd	r19, Z+1	; 0x01
    1766:	37 83       	std	Z+7, r19	; 0x07
    1768:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    176a:	66 81       	ldd	r22, Z+6	; 0x06
    176c:	77 81       	ldd	r23, Z+7	; 0x07
    176e:	0c 94 91 1b 	jmp	0x3722	; 0x3722 <memcpy>
    1772:	08 95       	ret

00001774 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1774:	ef 92       	push	r14
    1776:	ff 92       	push	r15
    1778:	1f 93       	push	r17
    177a:	cf 93       	push	r28
    177c:	df 93       	push	r29
    177e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1780:	0f b6       	in	r0, 0x3f	; 63
    1782:	f8 94       	cli
    1784:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1786:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1788:	7c 01       	movw	r14, r24
    178a:	81 e1       	ldi	r24, 0x11	; 17
    178c:	e8 0e       	add	r14, r24
    178e:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1790:	11 16       	cp	r1, r17
    1792:	5c f4       	brge	.+22     	; 0x17aa <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1794:	89 89       	ldd	r24, Y+17	; 0x11
    1796:	88 23       	and	r24, r24
    1798:	41 f0       	breq	.+16     	; 0x17aa <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    179a:	c7 01       	movw	r24, r14
    179c:	0e 94 4b 08 	call	0x1096	; 0x1096 <xTaskRemoveFromEventList>
    17a0:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    17a2:	0e 94 0b 09 	call	0x1216	; 0x1216 <vTaskMissedYield>
    17a6:	11 50       	subi	r17, 0x01	; 1
    17a8:	f3 cf       	rjmp	.-26     	; 0x1790 <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    17aa:	8f ef       	ldi	r24, 0xFF	; 255
    17ac:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    17ae:	0f 90       	pop	r0
    17b0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    17b2:	0f b6       	in	r0, 0x3f	; 63
    17b4:	f8 94       	cli
    17b6:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    17b8:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17ba:	7e 01       	movw	r14, r28
    17bc:	88 e0       	ldi	r24, 0x08	; 8
    17be:	e8 0e       	add	r14, r24
    17c0:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    17c2:	11 16       	cp	r1, r17
    17c4:	5c f4       	brge	.+22     	; 0x17dc <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17c6:	88 85       	ldd	r24, Y+8	; 0x08
    17c8:	88 23       	and	r24, r24
    17ca:	41 f0       	breq	.+16     	; 0x17dc <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17cc:	c7 01       	movw	r24, r14
    17ce:	0e 94 4b 08 	call	0x1096	; 0x1096 <xTaskRemoveFromEventList>
    17d2:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    17d4:	0e 94 0b 09 	call	0x1216	; 0x1216 <vTaskMissedYield>
    17d8:	11 50       	subi	r17, 0x01	; 1
    17da:	f3 cf       	rjmp	.-26     	; 0x17c2 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    17dc:	8f ef       	ldi	r24, 0xFF	; 255
    17de:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    17e0:	0f 90       	pop	r0
    17e2:	0f be       	out	0x3f, r0	; 63
}
    17e4:	df 91       	pop	r29
    17e6:	cf 91       	pop	r28
    17e8:	1f 91       	pop	r17
    17ea:	ff 90       	pop	r15
    17ec:	ef 90       	pop	r14
    17ee:	08 95       	ret

000017f0 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    17f0:	cf 93       	push	r28
    17f2:	df 93       	push	r29
    17f4:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    17f6:	0f b6       	in	r0, 0x3f	; 63
    17f8:	f8 94       	cli
    17fa:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    17fc:	48 81       	ld	r20, Y
    17fe:	59 81       	ldd	r21, Y+1	; 0x01
    1800:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1802:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1804:	9a 01       	movw	r18, r20
    1806:	87 9f       	mul	r24, r23
    1808:	20 0d       	add	r18, r0
    180a:	31 1d       	adc	r19, r1
    180c:	11 24       	eor	r1, r1
    180e:	3d 83       	std	Y+5, r19	; 0x05
    1810:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1812:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1814:	5b 83       	std	Y+3, r21	; 0x03
    1816:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1818:	90 e0       	ldi	r25, 0x00	; 0
    181a:	01 97       	sbiw	r24, 0x01	; 1
    181c:	78 9f       	mul	r23, r24
    181e:	90 01       	movw	r18, r0
    1820:	79 9f       	mul	r23, r25
    1822:	30 0d       	add	r19, r0
    1824:	11 24       	eor	r1, r1
    1826:	ca 01       	movw	r24, r20
    1828:	82 0f       	add	r24, r18
    182a:	93 1f       	adc	r25, r19
    182c:	9f 83       	std	Y+7, r25	; 0x07
    182e:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1830:	8f ef       	ldi	r24, 0xFF	; 255
    1832:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1834:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1836:	61 11       	cpse	r22, r1
    1838:	0c c0       	rjmp	.+24     	; 0x1852 <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    183a:	88 85       	ldd	r24, Y+8	; 0x08
    183c:	88 23       	and	r24, r24
    183e:	89 f0       	breq	.+34     	; 0x1862 <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1840:	ce 01       	movw	r24, r28
    1842:	08 96       	adiw	r24, 0x08	; 8
    1844:	0e 94 4b 08 	call	0x1096	; 0x1096 <xTaskRemoveFromEventList>
    1848:	88 23       	and	r24, r24
    184a:	59 f0       	breq	.+22     	; 0x1862 <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    184c:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
    1850:	08 c0       	rjmp	.+16     	; 0x1862 <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1852:	ce 01       	movw	r24, r28
    1854:	08 96       	adiw	r24, 0x08	; 8
    1856:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    185a:	ce 01       	movw	r24, r28
    185c:	41 96       	adiw	r24, 0x11	; 17
    185e:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1862:	0f 90       	pop	r0
    1864:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1866:	81 e0       	ldi	r24, 0x01	; 1
    1868:	df 91       	pop	r29
    186a:	cf 91       	pop	r28
    186c:	08 95       	ret

0000186e <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    186e:	0f 93       	push	r16
    1870:	1f 93       	push	r17
    1872:	cf 93       	push	r28
    1874:	df 93       	push	r29
    1876:	08 2f       	mov	r16, r24
    1878:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    187a:	66 23       	and	r22, r22
    187c:	21 f0       	breq	.+8      	; 0x1886 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    187e:	86 9f       	mul	r24, r22
    1880:	c0 01       	movw	r24, r0
    1882:	11 24       	eor	r1, r1
    1884:	02 c0       	rjmp	.+4      	; 0x188a <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1886:	80 e0       	ldi	r24, 0x00	; 0
    1888:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    188a:	4f 96       	adiw	r24, 0x1f	; 31
    188c:	0e 94 8e 12 	call	0x251c	; 0x251c <pvPortMalloc>
    1890:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    1892:	00 97       	sbiw	r24, 0x00	; 0
    1894:	71 f0       	breq	.+28     	; 0x18b2 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1896:	11 11       	cpse	r17, r1
    1898:	03 c0       	rjmp	.+6      	; 0x18a0 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    189a:	99 83       	std	Y+1, r25	; 0x01
    189c:	88 83       	st	Y, r24
    189e:	03 c0       	rjmp	.+6      	; 0x18a6 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    18a0:	4f 96       	adiw	r24, 0x1f	; 31
    18a2:	99 83       	std	Y+1, r25	; 0x01
    18a4:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    18a6:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    18a8:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    18aa:	61 e0       	ldi	r22, 0x01	; 1
    18ac:	ce 01       	movw	r24, r28
    18ae:	0e 94 f8 0b 	call	0x17f0	; 0x17f0 <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    18b2:	ce 01       	movw	r24, r28
    18b4:	df 91       	pop	r29
    18b6:	cf 91       	pop	r28
    18b8:	1f 91       	pop	r17
    18ba:	0f 91       	pop	r16
    18bc:	08 95       	ret

000018be <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    18be:	af 92       	push	r10
    18c0:	bf 92       	push	r11
    18c2:	cf 92       	push	r12
    18c4:	df 92       	push	r13
    18c6:	ff 92       	push	r15
    18c8:	0f 93       	push	r16
    18ca:	1f 93       	push	r17
    18cc:	cf 93       	push	r28
    18ce:	df 93       	push	r29
    18d0:	00 d0       	rcall	.+0      	; 0x18d2 <xQueueGenericSend+0x14>
    18d2:	00 d0       	rcall	.+0      	; 0x18d4 <xQueueGenericSend+0x16>
    18d4:	1f 92       	push	r1
    18d6:	cd b7       	in	r28, 0x3d	; 61
    18d8:	de b7       	in	r29, 0x3e	; 62
    18da:	8c 01       	movw	r16, r24
    18dc:	6b 01       	movw	r12, r22
    18de:	5d 83       	std	Y+5, r21	; 0x05
    18e0:	4c 83       	std	Y+4, r20	; 0x04
    18e2:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    18e4:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    18e6:	58 01       	movw	r10, r16
    18e8:	98 e0       	ldi	r25, 0x08	; 8
    18ea:	a9 0e       	add	r10, r25
    18ec:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    18ee:	0f b6       	in	r0, 0x3f	; 63
    18f0:	f8 94       	cli
    18f2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    18f4:	f8 01       	movw	r30, r16
    18f6:	22 8d       	ldd	r18, Z+26	; 0x1a
    18f8:	93 8d       	ldd	r25, Z+27	; 0x1b
    18fa:	29 17       	cp	r18, r25
    18fc:	18 f0       	brcs	.+6      	; 0x1904 <xQueueGenericSend+0x46>
    18fe:	f2 e0       	ldi	r31, 0x02	; 2
    1900:	ff 12       	cpse	r15, r31
    1902:	14 c0       	rjmp	.+40     	; 0x192c <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1904:	4f 2d       	mov	r20, r15
    1906:	b6 01       	movw	r22, r12
    1908:	c8 01       	movw	r24, r16
    190a:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    190e:	f8 01       	movw	r30, r16
    1910:	91 89       	ldd	r25, Z+17	; 0x11
    1912:	99 23       	and	r25, r25
    1914:	21 f0       	breq	.+8      	; 0x191e <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1916:	c8 01       	movw	r24, r16
    1918:	41 96       	adiw	r24, 0x11	; 17
    191a:	0e 94 4b 08 	call	0x1096	; 0x1096 <xTaskRemoveFromEventList>
    191e:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1920:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1924:	0f 90       	pop	r0
    1926:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1928:	81 e0       	ldi	r24, 0x01	; 1
    192a:	50 c0       	rjmp	.+160    	; 0x19cc <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    192c:	2c 81       	ldd	r18, Y+4	; 0x04
    192e:	3d 81       	ldd	r19, Y+5	; 0x05
    1930:	23 2b       	or	r18, r19
    1932:	19 f4       	brne	.+6      	; 0x193a <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1934:	0f 90       	pop	r0
    1936:	0f be       	out	0x3f, r0	; 63
    1938:	48 c0       	rjmp	.+144    	; 0x19ca <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    193a:	81 11       	cpse	r24, r1
    193c:	04 c0       	rjmp	.+8      	; 0x1946 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    193e:	ce 01       	movw	r24, r28
    1940:	01 96       	adiw	r24, 0x01	; 1
    1942:	0e 94 cd 08 	call	0x119a	; 0x119a <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1946:	0f 90       	pop	r0
    1948:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    194a:	0e 94 01 06 	call	0xc02	; 0xc02 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    194e:	0f b6       	in	r0, 0x3f	; 63
    1950:	f8 94       	cli
    1952:	0f 92       	push	r0
    1954:	f8 01       	movw	r30, r16
    1956:	85 8d       	ldd	r24, Z+29	; 0x1d
    1958:	8f 3f       	cpi	r24, 0xFF	; 255
    195a:	09 f4       	brne	.+2      	; 0x195e <xQueueGenericSend+0xa0>
    195c:	15 8e       	std	Z+29, r1	; 0x1d
    195e:	f8 01       	movw	r30, r16
    1960:	86 8d       	ldd	r24, Z+30	; 0x1e
    1962:	8f 3f       	cpi	r24, 0xFF	; 255
    1964:	09 f4       	brne	.+2      	; 0x1968 <xQueueGenericSend+0xaa>
    1966:	16 8e       	std	Z+30, r1	; 0x1e
    1968:	0f 90       	pop	r0
    196a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    196c:	be 01       	movw	r22, r28
    196e:	6c 5f       	subi	r22, 0xFC	; 252
    1970:	7f 4f       	sbci	r23, 0xFF	; 255
    1972:	ce 01       	movw	r24, r28
    1974:	01 96       	adiw	r24, 0x01	; 1
    1976:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <xTaskCheckForTimeOut>
    197a:	81 11       	cpse	r24, r1
    197c:	21 c0       	rjmp	.+66     	; 0x19c0 <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    197e:	0f b6       	in	r0, 0x3f	; 63
    1980:	f8 94       	cli
    1982:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1984:	f8 01       	movw	r30, r16
    1986:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1988:	0f 90       	pop	r0
    198a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    198c:	83 8d       	ldd	r24, Z+27	; 0x1b
    198e:	98 13       	cpse	r25, r24
    1990:	11 c0       	rjmp	.+34     	; 0x19b4 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1992:	6c 81       	ldd	r22, Y+4	; 0x04
    1994:	7d 81       	ldd	r23, Y+5	; 0x05
    1996:	c5 01       	movw	r24, r10
    1998:	0e 94 22 08 	call	0x1044	; 0x1044 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    199c:	c8 01       	movw	r24, r16
    199e:	0e 94 ba 0b 	call	0x1774	; 0x1774 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    19a2:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>
    19a6:	88 23       	and	r24, r24
    19a8:	11 f0       	breq	.+4      	; 0x19ae <xQueueGenericSend+0xf0>
    19aa:	81 e0       	ldi	r24, 0x01	; 1
    19ac:	a0 cf       	rjmp	.-192    	; 0x18ee <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    19ae:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
    19b2:	fb cf       	rjmp	.-10     	; 0x19aa <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    19b4:	c8 01       	movw	r24, r16
    19b6:	0e 94 ba 0b 	call	0x1774	; 0x1774 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19ba:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>
    19be:	f5 cf       	rjmp	.-22     	; 0x19aa <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    19c0:	c8 01       	movw	r24, r16
    19c2:	0e 94 ba 0b 	call	0x1774	; 0x1774 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19c6:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    19ca:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    19cc:	0f 90       	pop	r0
    19ce:	0f 90       	pop	r0
    19d0:	0f 90       	pop	r0
    19d2:	0f 90       	pop	r0
    19d4:	0f 90       	pop	r0
    19d6:	df 91       	pop	r29
    19d8:	cf 91       	pop	r28
    19da:	1f 91       	pop	r17
    19dc:	0f 91       	pop	r16
    19de:	ff 90       	pop	r15
    19e0:	df 90       	pop	r13
    19e2:	cf 90       	pop	r12
    19e4:	bf 90       	pop	r11
    19e6:	af 90       	pop	r10
    19e8:	08 95       	ret

000019ea <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    19ea:	ef 92       	push	r14
    19ec:	ff 92       	push	r15
    19ee:	1f 93       	push	r17
    19f0:	cf 93       	push	r28
    19f2:	df 93       	push	r29
    19f4:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    19f6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    19f8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    19fa:	98 17       	cp	r25, r24
    19fc:	10 f0       	brcs	.+4      	; 0x1a02 <xQueueGenericSendFromISR+0x18>
    19fe:	22 30       	cpi	r18, 0x02	; 2
    1a00:	e1 f4       	brne	.+56     	; 0x1a3a <xQueueGenericSendFromISR+0x50>
    1a02:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1a04:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1a06:	42 2f       	mov	r20, r18
    1a08:	ce 01       	movw	r24, r28
    1a0a:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1a0e:	1f 3f       	cpi	r17, 0xFF	; 255
    1a10:	81 f4       	brne	.+32     	; 0x1a32 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a12:	89 89       	ldd	r24, Y+17	; 0x11
    1a14:	88 23       	and	r24, r24
    1a16:	79 f0       	breq	.+30     	; 0x1a36 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a18:	ce 01       	movw	r24, r28
    1a1a:	41 96       	adiw	r24, 0x11	; 17
    1a1c:	0e 94 4b 08 	call	0x1096	; 0x1096 <xTaskRemoveFromEventList>
    1a20:	88 23       	and	r24, r24
    1a22:	49 f0       	breq	.+18     	; 0x1a36 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1a24:	e1 14       	cp	r14, r1
    1a26:	f1 04       	cpc	r15, r1
    1a28:	31 f0       	breq	.+12     	; 0x1a36 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1a2a:	81 e0       	ldi	r24, 0x01	; 1
    1a2c:	f7 01       	movw	r30, r14
    1a2e:	80 83       	st	Z, r24
    1a30:	05 c0       	rjmp	.+10     	; 0x1a3c <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1a32:	1f 5f       	subi	r17, 0xFF	; 255
    1a34:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    1a36:	81 e0       	ldi	r24, 0x01	; 1
    1a38:	01 c0       	rjmp	.+2      	; 0x1a3c <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1a3a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a3c:	df 91       	pop	r29
    1a3e:	cf 91       	pop	r28
    1a40:	1f 91       	pop	r17
    1a42:	ff 90       	pop	r15
    1a44:	ef 90       	pop	r14
    1a46:	08 95       	ret

00001a48 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1a48:	cf 93       	push	r28
    1a4a:	df 93       	push	r29
    1a4c:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a4e:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1a50:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a52:	98 17       	cp	r25, r24
    1a54:	c0 f4       	brcc	.+48     	; 0x1a86 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1a56:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1a58:	9f 5f       	subi	r25, 0xFF	; 255
    1a5a:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1a5c:	8f 3f       	cpi	r24, 0xFF	; 255
    1a5e:	79 f4       	brne	.+30     	; 0x1a7e <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a60:	81 89       	ldd	r24, Z+17	; 0x11
    1a62:	88 23       	and	r24, r24
    1a64:	71 f0       	breq	.+28     	; 0x1a82 <xQueueGiveFromISR+0x3a>
    1a66:	eb 01       	movw	r28, r22
    1a68:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a6a:	41 96       	adiw	r24, 0x11	; 17
    1a6c:	0e 94 4b 08 	call	0x1096	; 0x1096 <xTaskRemoveFromEventList>
    1a70:	88 23       	and	r24, r24
    1a72:	39 f0       	breq	.+14     	; 0x1a82 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1a74:	20 97       	sbiw	r28, 0x00	; 0
    1a76:	29 f0       	breq	.+10     	; 0x1a82 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	88 83       	st	Y, r24
    1a7c:	05 c0       	rjmp	.+10     	; 0x1a88 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1a7e:	8f 5f       	subi	r24, 0xFF	; 255
    1a80:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1a82:	81 e0       	ldi	r24, 0x01	; 1
    1a84:	01 c0       	rjmp	.+2      	; 0x1a88 <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1a86:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a88:	df 91       	pop	r29
    1a8a:	cf 91       	pop	r28
    1a8c:	08 95       	ret

00001a8e <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1a8e:	af 92       	push	r10
    1a90:	bf 92       	push	r11
    1a92:	cf 92       	push	r12
    1a94:	df 92       	push	r13
    1a96:	ff 92       	push	r15
    1a98:	0f 93       	push	r16
    1a9a:	1f 93       	push	r17
    1a9c:	cf 93       	push	r28
    1a9e:	df 93       	push	r29
    1aa0:	00 d0       	rcall	.+0      	; 0x1aa2 <xQueueReceive+0x14>
    1aa2:	00 d0       	rcall	.+0      	; 0x1aa4 <xQueueReceive+0x16>
    1aa4:	1f 92       	push	r1
    1aa6:	cd b7       	in	r28, 0x3d	; 61
    1aa8:	de b7       	in	r29, 0x3e	; 62
    1aaa:	8c 01       	movw	r16, r24
    1aac:	6b 01       	movw	r12, r22
    1aae:	5d 83       	std	Y+5, r21	; 0x05
    1ab0:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1ab2:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ab4:	58 01       	movw	r10, r16
    1ab6:	91 e1       	ldi	r25, 0x11	; 17
    1ab8:	a9 0e       	add	r10, r25
    1aba:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1abc:	0f b6       	in	r0, 0x3f	; 63
    1abe:	f8 94       	cli
    1ac0:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1ac2:	f8 01       	movw	r30, r16
    1ac4:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ac6:	ff 20       	and	r15, r15
    1ac8:	a9 f0       	breq	.+42     	; 0x1af4 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1aca:	b6 01       	movw	r22, r12
    1acc:	c8 01       	movw	r24, r16
    1ace:	0e 94 a0 0b 	call	0x1740	; 0x1740 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1ad2:	fa 94       	dec	r15
    1ad4:	f8 01       	movw	r30, r16
    1ad6:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ad8:	80 85       	ldd	r24, Z+8	; 0x08
    1ada:	88 23       	and	r24, r24
    1adc:	39 f0       	breq	.+14     	; 0x1aec <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ade:	c8 01       	movw	r24, r16
    1ae0:	08 96       	adiw	r24, 0x08	; 8
    1ae2:	0e 94 4b 08 	call	0x1096	; 0x1096 <xTaskRemoveFromEventList>
    1ae6:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1ae8:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1aec:	0f 90       	pop	r0
    1aee:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1af0:	81 e0       	ldi	r24, 0x01	; 1
    1af2:	50 c0       	rjmp	.+160    	; 0x1b94 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1af4:	2c 81       	ldd	r18, Y+4	; 0x04
    1af6:	3d 81       	ldd	r19, Y+5	; 0x05
    1af8:	23 2b       	or	r18, r19
    1afa:	19 f4       	brne	.+6      	; 0x1b02 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1afc:	0f 90       	pop	r0
    1afe:	0f be       	out	0x3f, r0	; 63
    1b00:	48 c0       	rjmp	.+144    	; 0x1b92 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1b02:	81 11       	cpse	r24, r1
    1b04:	04 c0       	rjmp	.+8      	; 0x1b0e <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1b06:	ce 01       	movw	r24, r28
    1b08:	01 96       	adiw	r24, 0x01	; 1
    1b0a:	0e 94 cd 08 	call	0x119a	; 0x119a <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1b0e:	0f 90       	pop	r0
    1b10:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b12:	0e 94 01 06 	call	0xc02	; 0xc02 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b16:	0f b6       	in	r0, 0x3f	; 63
    1b18:	f8 94       	cli
    1b1a:	0f 92       	push	r0
    1b1c:	f8 01       	movw	r30, r16
    1b1e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b20:	8f 3f       	cpi	r24, 0xFF	; 255
    1b22:	09 f4       	brne	.+2      	; 0x1b26 <xQueueReceive+0x98>
    1b24:	15 8e       	std	Z+29, r1	; 0x1d
    1b26:	f8 01       	movw	r30, r16
    1b28:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b2a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b2c:	09 f4       	brne	.+2      	; 0x1b30 <xQueueReceive+0xa2>
    1b2e:	16 8e       	std	Z+30, r1	; 0x1e
    1b30:	0f 90       	pop	r0
    1b32:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b34:	be 01       	movw	r22, r28
    1b36:	6c 5f       	subi	r22, 0xFC	; 252
    1b38:	7f 4f       	sbci	r23, 0xFF	; 255
    1b3a:	ce 01       	movw	r24, r28
    1b3c:	01 96       	adiw	r24, 0x01	; 1
    1b3e:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <xTaskCheckForTimeOut>
    1b42:	81 11       	cpse	r24, r1
    1b44:	1c c0       	rjmp	.+56     	; 0x1b7e <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b46:	c8 01       	movw	r24, r16
    1b48:	0e 94 4d 0b 	call	0x169a	; 0x169a <prvIsQueueEmpty>
    1b4c:	88 23       	and	r24, r24
    1b4e:	89 f0       	breq	.+34     	; 0x1b72 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b50:	6c 81       	ldd	r22, Y+4	; 0x04
    1b52:	7d 81       	ldd	r23, Y+5	; 0x05
    1b54:	c5 01       	movw	r24, r10
    1b56:	0e 94 22 08 	call	0x1044	; 0x1044 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b5a:	c8 01       	movw	r24, r16
    1b5c:	0e 94 ba 0b 	call	0x1774	; 0x1774 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1b60:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>
    1b64:	88 23       	and	r24, r24
    1b66:	11 f0       	breq	.+4      	; 0x1b6c <xQueueReceive+0xde>
    1b68:	81 e0       	ldi	r24, 0x01	; 1
    1b6a:	a8 cf       	rjmp	.-176    	; 0x1abc <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    1b6c:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
    1b70:	fb cf       	rjmp	.-10     	; 0x1b68 <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1b72:	c8 01       	movw	r24, r16
    1b74:	0e 94 ba 0b 	call	0x1774	; 0x1774 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b78:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>
    1b7c:	f5 cf       	rjmp	.-22     	; 0x1b68 <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1b7e:	c8 01       	movw	r24, r16
    1b80:	0e 94 ba 0b 	call	0x1774	; 0x1774 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b84:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b88:	c8 01       	movw	r24, r16
    1b8a:	0e 94 4d 0b 	call	0x169a	; 0x169a <prvIsQueueEmpty>
    1b8e:	88 23       	and	r24, r24
    1b90:	59 f3       	breq	.-42     	; 0x1b68 <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1b92:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1b94:	0f 90       	pop	r0
    1b96:	0f 90       	pop	r0
    1b98:	0f 90       	pop	r0
    1b9a:	0f 90       	pop	r0
    1b9c:	0f 90       	pop	r0
    1b9e:	df 91       	pop	r29
    1ba0:	cf 91       	pop	r28
    1ba2:	1f 91       	pop	r17
    1ba4:	0f 91       	pop	r16
    1ba6:	ff 90       	pop	r15
    1ba8:	df 90       	pop	r13
    1baa:	cf 90       	pop	r12
    1bac:	bf 90       	pop	r11
    1bae:	af 90       	pop	r10
    1bb0:	08 95       	ret

00001bb2 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    1bb2:	ef 92       	push	r14
    1bb4:	ff 92       	push	r15
    1bb6:	0f 93       	push	r16
    1bb8:	1f 93       	push	r17
    1bba:	cf 93       	push	r28
    1bbc:	df 93       	push	r29
    1bbe:	00 d0       	rcall	.+0      	; 0x1bc0 <xQueueSemaphoreTake+0xe>
    1bc0:	00 d0       	rcall	.+0      	; 0x1bc2 <xQueueSemaphoreTake+0x10>
    1bc2:	1f 92       	push	r1
    1bc4:	cd b7       	in	r28, 0x3d	; 61
    1bc6:	de b7       	in	r29, 0x3e	; 62
    1bc8:	8c 01       	movw	r16, r24
    1bca:	7d 83       	std	Y+5, r23	; 0x05
    1bcc:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1bce:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1bd0:	78 01       	movw	r14, r16
    1bd2:	81 e1       	ldi	r24, 0x11	; 17
    1bd4:	e8 0e       	add	r14, r24
    1bd6:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1bd8:	0f b6       	in	r0, 0x3f	; 63
    1bda:	f8 94       	cli
    1bdc:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1bde:	f8 01       	movw	r30, r16
    1be0:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1be2:	88 23       	and	r24, r24
    1be4:	81 f0       	breq	.+32     	; 0x1c06 <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1be6:	81 50       	subi	r24, 0x01	; 1
    1be8:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1bea:	80 85       	ldd	r24, Z+8	; 0x08
    1bec:	88 23       	and	r24, r24
    1bee:	39 f0       	breq	.+14     	; 0x1bfe <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bf0:	c8 01       	movw	r24, r16
    1bf2:	08 96       	adiw	r24, 0x08	; 8
    1bf4:	0e 94 4b 08 	call	0x1096	; 0x1096 <xTaskRemoveFromEventList>
    1bf8:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1bfa:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1bfe:	0f 90       	pop	r0
    1c00:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1c02:	81 e0       	ldi	r24, 0x01	; 1
    1c04:	50 c0       	rjmp	.+160    	; 0x1ca6 <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1c06:	2c 81       	ldd	r18, Y+4	; 0x04
    1c08:	3d 81       	ldd	r19, Y+5	; 0x05
    1c0a:	23 2b       	or	r18, r19
    1c0c:	19 f4       	brne	.+6      	; 0x1c14 <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1c0e:	0f 90       	pop	r0
    1c10:	0f be       	out	0x3f, r0	; 63
    1c12:	48 c0       	rjmp	.+144    	; 0x1ca4 <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1c14:	91 11       	cpse	r25, r1
    1c16:	04 c0       	rjmp	.+8      	; 0x1c20 <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1c18:	ce 01       	movw	r24, r28
    1c1a:	01 96       	adiw	r24, 0x01	; 1
    1c1c:	0e 94 cd 08 	call	0x119a	; 0x119a <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1c20:	0f 90       	pop	r0
    1c22:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c24:	0e 94 01 06 	call	0xc02	; 0xc02 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c28:	0f b6       	in	r0, 0x3f	; 63
    1c2a:	f8 94       	cli
    1c2c:	0f 92       	push	r0
    1c2e:	f8 01       	movw	r30, r16
    1c30:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c32:	8f 3f       	cpi	r24, 0xFF	; 255
    1c34:	09 f4       	brne	.+2      	; 0x1c38 <xQueueSemaphoreTake+0x86>
    1c36:	15 8e       	std	Z+29, r1	; 0x1d
    1c38:	f8 01       	movw	r30, r16
    1c3a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c3c:	8f 3f       	cpi	r24, 0xFF	; 255
    1c3e:	09 f4       	brne	.+2      	; 0x1c42 <xQueueSemaphoreTake+0x90>
    1c40:	16 8e       	std	Z+30, r1	; 0x1e
    1c42:	0f 90       	pop	r0
    1c44:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c46:	be 01       	movw	r22, r28
    1c48:	6c 5f       	subi	r22, 0xFC	; 252
    1c4a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c4c:	ce 01       	movw	r24, r28
    1c4e:	01 96       	adiw	r24, 0x01	; 1
    1c50:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <xTaskCheckForTimeOut>
    1c54:	81 11       	cpse	r24, r1
    1c56:	1c c0       	rjmp	.+56     	; 0x1c90 <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c58:	c8 01       	movw	r24, r16
    1c5a:	0e 94 4d 0b 	call	0x169a	; 0x169a <prvIsQueueEmpty>
    1c5e:	88 23       	and	r24, r24
    1c60:	89 f0       	breq	.+34     	; 0x1c84 <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c62:	6c 81       	ldd	r22, Y+4	; 0x04
    1c64:	7d 81       	ldd	r23, Y+5	; 0x05
    1c66:	c7 01       	movw	r24, r14
    1c68:	0e 94 22 08 	call	0x1044	; 0x1044 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1c6c:	c8 01       	movw	r24, r16
    1c6e:	0e 94 ba 0b 	call	0x1774	; 0x1774 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1c72:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>
    1c76:	88 23       	and	r24, r24
    1c78:	11 f0       	breq	.+4      	; 0x1c7e <xQueueSemaphoreTake+0xcc>
    1c7a:	91 e0       	ldi	r25, 0x01	; 1
    1c7c:	ad cf       	rjmp	.-166    	; 0x1bd8 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1c7e:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
    1c82:	fb cf       	rjmp	.-10     	; 0x1c7a <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1c84:	c8 01       	movw	r24, r16
    1c86:	0e 94 ba 0b 	call	0x1774	; 0x1774 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c8a:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>
    1c8e:	f5 cf       	rjmp	.-22     	; 0x1c7a <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1c90:	c8 01       	movw	r24, r16
    1c92:	0e 94 ba 0b 	call	0x1774	; 0x1774 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c96:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c9a:	c8 01       	movw	r24, r16
    1c9c:	0e 94 4d 0b 	call	0x169a	; 0x169a <prvIsQueueEmpty>
    1ca0:	88 23       	and	r24, r24
    1ca2:	59 f3       	breq	.-42     	; 0x1c7a <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1ca4:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1ca6:	0f 90       	pop	r0
    1ca8:	0f 90       	pop	r0
    1caa:	0f 90       	pop	r0
    1cac:	0f 90       	pop	r0
    1cae:	0f 90       	pop	r0
    1cb0:	df 91       	pop	r29
    1cb2:	cf 91       	pop	r28
    1cb4:	1f 91       	pop	r17
    1cb6:	0f 91       	pop	r16
    1cb8:	ff 90       	pop	r15
    1cba:	ef 90       	pop	r14
    1cbc:	08 95       	ret

00001cbe <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1cbe:	cf 92       	push	r12
    1cc0:	df 92       	push	r13
    1cc2:	ef 92       	push	r14
    1cc4:	ff 92       	push	r15
    1cc6:	0f 93       	push	r16
    1cc8:	1f 93       	push	r17
    1cca:	cf 93       	push	r28
    1ccc:	df 93       	push	r29
    1cce:	00 d0       	rcall	.+0      	; 0x1cd0 <xQueuePeek+0x12>
    1cd0:	00 d0       	rcall	.+0      	; 0x1cd2 <xQueuePeek+0x14>
    1cd2:	1f 92       	push	r1
    1cd4:	cd b7       	in	r28, 0x3d	; 61
    1cd6:	de b7       	in	r29, 0x3e	; 62
    1cd8:	8c 01       	movw	r16, r24
    1cda:	7b 01       	movw	r14, r22
    1cdc:	5d 83       	std	Y+5, r21	; 0x05
    1cde:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1ce0:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ce2:	68 01       	movw	r12, r16
    1ce4:	91 e1       	ldi	r25, 0x11	; 17
    1ce6:	c9 0e       	add	r12, r25
    1ce8:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1cea:	0f b6       	in	r0, 0x3f	; 63
    1cec:	f8 94       	cli
    1cee:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1cf0:	f8 01       	movw	r30, r16
    1cf2:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1cf4:	99 23       	and	r25, r25
    1cf6:	b9 f0       	breq	.+46     	; 0x1d26 <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1cf8:	c6 80       	ldd	r12, Z+6	; 0x06
    1cfa:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1cfc:	b7 01       	movw	r22, r14
    1cfe:	c8 01       	movw	r24, r16
    1d00:	0e 94 a0 0b 	call	0x1740	; 0x1740 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1d04:	f8 01       	movw	r30, r16
    1d06:	d7 82       	std	Z+7, r13	; 0x07
    1d08:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d0a:	81 89       	ldd	r24, Z+17	; 0x11
    1d0c:	88 23       	and	r24, r24
    1d0e:	39 f0       	breq	.+14     	; 0x1d1e <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d10:	c8 01       	movw	r24, r16
    1d12:	41 96       	adiw	r24, 0x11	; 17
    1d14:	0e 94 4b 08 	call	0x1096	; 0x1096 <xTaskRemoveFromEventList>
    1d18:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1d1a:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1d1e:	0f 90       	pop	r0
    1d20:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1d22:	81 e0       	ldi	r24, 0x01	; 1
    1d24:	50 c0       	rjmp	.+160    	; 0x1dc6 <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1d26:	2c 81       	ldd	r18, Y+4	; 0x04
    1d28:	3d 81       	ldd	r19, Y+5	; 0x05
    1d2a:	23 2b       	or	r18, r19
    1d2c:	19 f4       	brne	.+6      	; 0x1d34 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1d2e:	0f 90       	pop	r0
    1d30:	0f be       	out	0x3f, r0	; 63
    1d32:	48 c0       	rjmp	.+144    	; 0x1dc4 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1d34:	81 11       	cpse	r24, r1
    1d36:	04 c0       	rjmp	.+8      	; 0x1d40 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1d38:	ce 01       	movw	r24, r28
    1d3a:	01 96       	adiw	r24, 0x01	; 1
    1d3c:	0e 94 cd 08 	call	0x119a	; 0x119a <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1d40:	0f 90       	pop	r0
    1d42:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1d44:	0e 94 01 06 	call	0xc02	; 0xc02 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1d48:	0f b6       	in	r0, 0x3f	; 63
    1d4a:	f8 94       	cli
    1d4c:	0f 92       	push	r0
    1d4e:	f8 01       	movw	r30, r16
    1d50:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d52:	8f 3f       	cpi	r24, 0xFF	; 255
    1d54:	09 f4       	brne	.+2      	; 0x1d58 <xQueuePeek+0x9a>
    1d56:	15 8e       	std	Z+29, r1	; 0x1d
    1d58:	f8 01       	movw	r30, r16
    1d5a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d5c:	8f 3f       	cpi	r24, 0xFF	; 255
    1d5e:	09 f4       	brne	.+2      	; 0x1d62 <xQueuePeek+0xa4>
    1d60:	16 8e       	std	Z+30, r1	; 0x1e
    1d62:	0f 90       	pop	r0
    1d64:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d66:	be 01       	movw	r22, r28
    1d68:	6c 5f       	subi	r22, 0xFC	; 252
    1d6a:	7f 4f       	sbci	r23, 0xFF	; 255
    1d6c:	ce 01       	movw	r24, r28
    1d6e:	01 96       	adiw	r24, 0x01	; 1
    1d70:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <xTaskCheckForTimeOut>
    1d74:	81 11       	cpse	r24, r1
    1d76:	1c c0       	rjmp	.+56     	; 0x1db0 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d78:	c8 01       	movw	r24, r16
    1d7a:	0e 94 4d 0b 	call	0x169a	; 0x169a <prvIsQueueEmpty>
    1d7e:	88 23       	and	r24, r24
    1d80:	89 f0       	breq	.+34     	; 0x1da4 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d82:	6c 81       	ldd	r22, Y+4	; 0x04
    1d84:	7d 81       	ldd	r23, Y+5	; 0x05
    1d86:	c6 01       	movw	r24, r12
    1d88:	0e 94 22 08 	call	0x1044	; 0x1044 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1d8c:	c8 01       	movw	r24, r16
    1d8e:	0e 94 ba 0b 	call	0x1774	; 0x1774 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1d92:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>
    1d96:	88 23       	and	r24, r24
    1d98:	11 f0       	breq	.+4      	; 0x1d9e <xQueuePeek+0xe0>
    1d9a:	81 e0       	ldi	r24, 0x01	; 1
    1d9c:	a6 cf       	rjmp	.-180    	; 0x1cea <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    1d9e:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <vPortYield>
    1da2:	fb cf       	rjmp	.-10     	; 0x1d9a <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1da4:	c8 01       	movw	r24, r16
    1da6:	0e 94 ba 0b 	call	0x1774	; 0x1774 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1daa:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>
    1dae:	f5 cf       	rjmp	.-22     	; 0x1d9a <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1db0:	c8 01       	movw	r24, r16
    1db2:	0e 94 ba 0b 	call	0x1774	; 0x1774 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1db6:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1dba:	c8 01       	movw	r24, r16
    1dbc:	0e 94 4d 0b 	call	0x169a	; 0x169a <prvIsQueueEmpty>
    1dc0:	88 23       	and	r24, r24
    1dc2:	59 f3       	breq	.-42     	; 0x1d9a <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1dc4:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1dc6:	0f 90       	pop	r0
    1dc8:	0f 90       	pop	r0
    1dca:	0f 90       	pop	r0
    1dcc:	0f 90       	pop	r0
    1dce:	0f 90       	pop	r0
    1dd0:	df 91       	pop	r29
    1dd2:	cf 91       	pop	r28
    1dd4:	1f 91       	pop	r17
    1dd6:	0f 91       	pop	r16
    1dd8:	ff 90       	pop	r15
    1dda:	ef 90       	pop	r14
    1ddc:	df 90       	pop	r13
    1dde:	cf 90       	pop	r12
    1de0:	08 95       	ret

00001de2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1de2:	ef 92       	push	r14
    1de4:	ff 92       	push	r15
    1de6:	0f 93       	push	r16
    1de8:	1f 93       	push	r17
    1dea:	cf 93       	push	r28
    1dec:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1dee:	fc 01       	movw	r30, r24
    1df0:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1df2:	00 23       	and	r16, r16
    1df4:	e9 f0       	breq	.+58     	; 0x1e30 <xQueueReceiveFromISR+0x4e>
    1df6:	7a 01       	movw	r14, r20
    1df8:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1dfa:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1dfc:	0e 94 a0 0b 	call	0x1740	; 0x1740 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1e00:	01 50       	subi	r16, 0x01	; 1
    1e02:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1e04:	1f 3f       	cpi	r17, 0xFF	; 255
    1e06:	81 f4       	brne	.+32     	; 0x1e28 <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e08:	88 85       	ldd	r24, Y+8	; 0x08
    1e0a:	88 23       	and	r24, r24
    1e0c:	79 f0       	breq	.+30     	; 0x1e2c <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e0e:	ce 01       	movw	r24, r28
    1e10:	08 96       	adiw	r24, 0x08	; 8
    1e12:	0e 94 4b 08 	call	0x1096	; 0x1096 <xTaskRemoveFromEventList>
    1e16:	88 23       	and	r24, r24
    1e18:	49 f0       	breq	.+18     	; 0x1e2c <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1e1a:	e1 14       	cp	r14, r1
    1e1c:	f1 04       	cpc	r15, r1
    1e1e:	31 f0       	breq	.+12     	; 0x1e2c <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1e20:	81 e0       	ldi	r24, 0x01	; 1
    1e22:	f7 01       	movw	r30, r14
    1e24:	80 83       	st	Z, r24
    1e26:	05 c0       	rjmp	.+10     	; 0x1e32 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1e28:	1f 5f       	subi	r17, 0xFF	; 255
    1e2a:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1e2c:	81 e0       	ldi	r24, 0x01	; 1
    1e2e:	01 c0       	rjmp	.+2      	; 0x1e32 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1e30:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1e32:	df 91       	pop	r29
    1e34:	cf 91       	pop	r28
    1e36:	1f 91       	pop	r17
    1e38:	0f 91       	pop	r16
    1e3a:	ff 90       	pop	r15
    1e3c:	ef 90       	pop	r14
    1e3e:	08 95       	ret

00001e40 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1e40:	0f 93       	push	r16
    1e42:	1f 93       	push	r17
    1e44:	cf 93       	push	r28
    1e46:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e48:	fc 01       	movw	r30, r24
    1e4a:	22 8d       	ldd	r18, Z+26	; 0x1a
    1e4c:	22 23       	and	r18, r18
    1e4e:	49 f0       	breq	.+18     	; 0x1e62 <xQueuePeekFromISR+0x22>
    1e50:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1e52:	06 81       	ldd	r16, Z+6	; 0x06
    1e54:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1e56:	0e 94 a0 0b 	call	0x1740	; 0x1740 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1e5a:	1f 83       	std	Y+7, r17	; 0x07
    1e5c:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1e5e:	81 e0       	ldi	r24, 0x01	; 1
    1e60:	01 c0       	rjmp	.+2      	; 0x1e64 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1e62:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1e64:	df 91       	pop	r29
    1e66:	cf 91       	pop	r28
    1e68:	1f 91       	pop	r17
    1e6a:	0f 91       	pop	r16
    1e6c:	08 95       	ret

00001e6e <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1e6e:	0f b6       	in	r0, 0x3f	; 63
    1e70:	f8 94       	cli
    1e72:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1e74:	fc 01       	movw	r30, r24
    1e76:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1e78:	0f 90       	pop	r0
    1e7a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1e7c:	08 95       	ret

00001e7e <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1e7e:	0f b6       	in	r0, 0x3f	; 63
    1e80:	f8 94       	cli
    1e82:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1e84:	fc 01       	movw	r30, r24
    1e86:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1e88:	0f 90       	pop	r0
    1e8a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1e8c:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1e8e:	82 1b       	sub	r24, r18
    1e90:	08 95       	ret

00001e92 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1e92:	fc 01       	movw	r30, r24
    1e94:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1e96:	08 95       	ret

00001e98 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1e98:	0c 94 c0 12 	jmp	0x2580	; 0x2580 <vPortFree>

00001e9c <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1e9c:	fc 01       	movw	r30, r24
    1e9e:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1ea0:	81 e0       	ldi	r24, 0x01	; 1
    1ea2:	91 11       	cpse	r25, r1
    1ea4:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1ea6:	08 95       	ret

00001ea8 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1ea8:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1eaa:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	23 8d       	ldd	r18, Z+27	; 0x1b
    1eb0:	29 13       	cpse	r18, r25
    1eb2:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1eb4:	08 95       	ret

00001eb6 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1eb6:	cf 93       	push	r28
    1eb8:	df 93       	push	r29
    1eba:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1ebc:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1ebe:	0f b6       	in	r0, 0x3f	; 63
    1ec0:	f8 94       	cli
    1ec2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1ec4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ec6:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1ec8:	0f 90       	pop	r0
    1eca:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1ecc:	89 13       	cpse	r24, r25
    1ece:	0f c0       	rjmp	.+30     	; 0x1eee <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1ed0:	41 15       	cp	r20, r1
    1ed2:	51 05       	cpc	r21, r1
    1ed4:	49 f0       	breq	.+18     	; 0x1ee8 <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1ed6:	be 01       	movw	r22, r28
    1ed8:	68 5f       	subi	r22, 0xF8	; 248
    1eda:	7f 4f       	sbci	r23, 0xFF	; 255
    1edc:	ca 01       	movw	r24, r20
    1ede:	0e 94 3a 11 	call	0x2274	; 0x2274 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1ee2:	78 94       	sei
					return errQUEUE_BLOCKED;
    1ee4:	8c ef       	ldi	r24, 0xFC	; 252
    1ee6:	1b c0       	rjmp	.+54     	; 0x1f1e <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1ee8:	78 94       	sei
					return errQUEUE_FULL;
    1eea:	80 e0       	ldi	r24, 0x00	; 0
    1eec:	18 c0       	rjmp	.+48     	; 0x1f1e <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1eee:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1ef0:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1ef2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ef4:	89 17       	cp	r24, r25
    1ef6:	88 f4       	brcc	.+34     	; 0x1f1a <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1ef8:	40 e0       	ldi	r20, 0x00	; 0
    1efa:	ce 01       	movw	r24, r28
    1efc:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f00:	89 89       	ldd	r24, Y+17	; 0x11
    1f02:	81 11       	cpse	r24, r1
    1f04:	02 c0       	rjmp	.+4      	; 0x1f0a <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1f06:	81 e0       	ldi	r24, 0x01	; 1
    1f08:	09 c0       	rjmp	.+18     	; 0x1f1c <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f0a:	ce 01       	movw	r24, r28
    1f0c:	41 96       	adiw	r24, 0x11	; 17
    1f0e:	0e 94 69 12 	call	0x24d2	; 0x24d2 <xCoRoutineRemoveFromEventList>
    1f12:	88 23       	and	r24, r24
    1f14:	c1 f3       	breq	.-16     	; 0x1f06 <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1f16:	8b ef       	ldi	r24, 0xFB	; 251
    1f18:	01 c0       	rjmp	.+2      	; 0x1f1c <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1f1a:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1f1c:	78 94       	sei

		return xReturn;
	}
    1f1e:	df 91       	pop	r29
    1f20:	cf 91       	pop	r28
    1f22:	08 95       	ret

00001f24 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1f24:	cf 93       	push	r28
    1f26:	df 93       	push	r29
    1f28:	ec 01       	movw	r28, r24
    1f2a:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1f2c:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1f2e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f30:	81 11       	cpse	r24, r1
    1f32:	0f c0       	rjmp	.+30     	; 0x1f52 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1f34:	41 15       	cp	r20, r1
    1f36:	51 05       	cpc	r21, r1
    1f38:	49 f0       	breq	.+18     	; 0x1f4c <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1f3a:	be 01       	movw	r22, r28
    1f3c:	6f 5e       	subi	r22, 0xEF	; 239
    1f3e:	7f 4f       	sbci	r23, 0xFF	; 255
    1f40:	ca 01       	movw	r24, r20
    1f42:	0e 94 3a 11 	call	0x2274	; 0x2274 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1f46:	78 94       	sei
					return errQUEUE_BLOCKED;
    1f48:	8c ef       	ldi	r24, 0xFC	; 252
    1f4a:	30 c0       	rjmp	.+96     	; 0x1fac <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1f4c:	78 94       	sei
					return errQUEUE_FULL;
    1f4e:	80 e0       	ldi	r24, 0x00	; 0
    1f50:	2d c0       	rjmp	.+90     	; 0x1fac <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1f52:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1f54:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f56:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f58:	88 23       	and	r24, r24
    1f5a:	31 f1       	breq	.+76     	; 0x1fa8 <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1f5c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1f5e:	50 e0       	ldi	r21, 0x00	; 0
    1f60:	2e 81       	ldd	r18, Y+6	; 0x06
    1f62:	3f 81       	ldd	r19, Y+7	; 0x07
    1f64:	24 0f       	add	r18, r20
    1f66:	35 1f       	adc	r19, r21
    1f68:	3f 83       	std	Y+7, r19	; 0x07
    1f6a:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1f6c:	8c 81       	ldd	r24, Y+4	; 0x04
    1f6e:	9d 81       	ldd	r25, Y+5	; 0x05
    1f70:	28 17       	cp	r18, r24
    1f72:	39 07       	cpc	r19, r25
    1f74:	20 f0       	brcs	.+8      	; 0x1f7e <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1f76:	88 81       	ld	r24, Y
    1f78:	99 81       	ldd	r25, Y+1	; 0x01
    1f7a:	9f 83       	std	Y+7, r25	; 0x07
    1f7c:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1f7e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1f80:	91 50       	subi	r25, 0x01	; 1
    1f82:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1f84:	6e 81       	ldd	r22, Y+6	; 0x06
    1f86:	7f 81       	ldd	r23, Y+7	; 0x07
    1f88:	cf 01       	movw	r24, r30
    1f8a:	0e 94 91 1b 	call	0x3722	; 0x3722 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f8e:	88 85       	ldd	r24, Y+8	; 0x08
    1f90:	81 11       	cpse	r24, r1
    1f92:	02 c0       	rjmp	.+4      	; 0x1f98 <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1f94:	81 e0       	ldi	r24, 0x01	; 1
    1f96:	09 c0       	rjmp	.+18     	; 0x1faa <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f98:	ce 01       	movw	r24, r28
    1f9a:	08 96       	adiw	r24, 0x08	; 8
    1f9c:	0e 94 69 12 	call	0x24d2	; 0x24d2 <xCoRoutineRemoveFromEventList>
    1fa0:	88 23       	and	r24, r24
    1fa2:	c1 f3       	breq	.-16     	; 0x1f94 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1fa4:	8b ef       	ldi	r24, 0xFB	; 251
    1fa6:	01 c0       	rjmp	.+2      	; 0x1faa <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1fa8:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1faa:	78 94       	sei

		return xReturn;
	}
    1fac:	df 91       	pop	r29
    1fae:	cf 91       	pop	r28
    1fb0:	08 95       	ret

00001fb2 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1fb2:	0f 93       	push	r16
    1fb4:	1f 93       	push	r17
    1fb6:	cf 93       	push	r28
    1fb8:	8c 01       	movw	r16, r24
    1fba:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1fbc:	fc 01       	movw	r30, r24
    1fbe:	92 8d       	ldd	r25, Z+26	; 0x1a
    1fc0:	83 8d       	ldd	r24, Z+27	; 0x1b
    1fc2:	98 17       	cp	r25, r24
    1fc4:	10 f0       	brcs	.+4      	; 0x1fca <xQueueCRSendFromISR+0x18>
    1fc6:	4c 2f       	mov	r20, r28
    1fc8:	12 c0       	rjmp	.+36     	; 0x1fee <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1fca:	40 e0       	ldi	r20, 0x00	; 0
    1fcc:	c8 01       	movw	r24, r16
    1fce:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1fd2:	c1 11       	cpse	r28, r1
    1fd4:	f8 cf       	rjmp	.-16     	; 0x1fc6 <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1fd6:	f8 01       	movw	r30, r16
    1fd8:	81 89       	ldd	r24, Z+17	; 0x11
    1fda:	88 23       	and	r24, r24
    1fdc:	39 f0       	breq	.+14     	; 0x1fec <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1fde:	c8 01       	movw	r24, r16
    1fe0:	41 96       	adiw	r24, 0x11	; 17
    1fe2:	0e 94 69 12 	call	0x24d2	; 0x24d2 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1fe6:	41 e0       	ldi	r20, 0x01	; 1
    1fe8:	81 11       	cpse	r24, r1
    1fea:	01 c0       	rjmp	.+2      	; 0x1fee <xQueueCRSendFromISR+0x3c>
    1fec:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1fee:	84 2f       	mov	r24, r20
    1ff0:	cf 91       	pop	r28
    1ff2:	1f 91       	pop	r17
    1ff4:	0f 91       	pop	r16
    1ff6:	08 95       	ret

00001ff8 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1ff8:	0f 93       	push	r16
    1ffa:	1f 93       	push	r17
    1ffc:	cf 93       	push	r28
    1ffe:	df 93       	push	r29
    2000:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2002:	82 8d       	ldd	r24, Z+26	; 0x1a
    2004:	88 23       	and	r24, r24
    2006:	79 f1       	breq	.+94     	; 0x2066 <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2008:	24 8d       	ldd	r18, Z+28	; 0x1c
    200a:	30 e0       	ldi	r19, 0x00	; 0
    200c:	a6 81       	ldd	r26, Z+6	; 0x06
    200e:	b7 81       	ldd	r27, Z+7	; 0x07
    2010:	a2 0f       	add	r26, r18
    2012:	b3 1f       	adc	r27, r19
    2014:	b7 83       	std	Z+7, r27	; 0x07
    2016:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2018:	84 81       	ldd	r24, Z+4	; 0x04
    201a:	95 81       	ldd	r25, Z+5	; 0x05
    201c:	a8 17       	cp	r26, r24
    201e:	b9 07       	cpc	r27, r25
    2020:	20 f0       	brcs	.+8      	; 0x202a <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2022:	80 81       	ld	r24, Z
    2024:	91 81       	ldd	r25, Z+1	; 0x01
    2026:	97 83       	std	Z+7, r25	; 0x07
    2028:	86 83       	std	Z+6, r24	; 0x06
    202a:	8a 01       	movw	r16, r20
    202c:	cb 01       	movw	r24, r22
    202e:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    2030:	42 8d       	ldd	r20, Z+26	; 0x1a
    2032:	41 50       	subi	r20, 0x01	; 1
    2034:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2036:	66 81       	ldd	r22, Z+6	; 0x06
    2038:	77 81       	ldd	r23, Z+7	; 0x07
    203a:	a9 01       	movw	r20, r18
    203c:	0e 94 91 1b 	call	0x3722	; 0x3722 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    2040:	f8 01       	movw	r30, r16
    2042:	80 81       	ld	r24, Z
    2044:	88 23       	and	r24, r24
    2046:	11 f0       	breq	.+4      	; 0x204c <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    2048:	81 e0       	ldi	r24, 0x01	; 1
    204a:	0e c0       	rjmp	.+28     	; 0x2068 <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    204c:	88 85       	ldd	r24, Y+8	; 0x08
    204e:	88 23       	and	r24, r24
    2050:	d9 f3       	breq	.-10     	; 0x2048 <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2052:	ce 01       	movw	r24, r28
    2054:	08 96       	adiw	r24, 0x08	; 8
    2056:	0e 94 69 12 	call	0x24d2	; 0x24d2 <xCoRoutineRemoveFromEventList>
    205a:	88 23       	and	r24, r24
    205c:	a9 f3       	breq	.-22     	; 0x2048 <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    205e:	81 e0       	ldi	r24, 0x01	; 1
    2060:	f8 01       	movw	r30, r16
    2062:	80 83       	st	Z, r24
    2064:	01 c0       	rjmp	.+2      	; 0x2068 <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    2066:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    2068:	df 91       	pop	r29
    206a:	cf 91       	pop	r28
    206c:	1f 91       	pop	r17
    206e:	0f 91       	pop	r16
    2070:	08 95       	ret

00002072 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2072:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2074:	03 96       	adiw	r24, 0x03	; 3
    2076:	92 83       	std	Z+2, r25	; 0x02
    2078:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    207a:	2f ef       	ldi	r18, 0xFF	; 255
    207c:	3f ef       	ldi	r19, 0xFF	; 255
    207e:	34 83       	std	Z+4, r19	; 0x04
    2080:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2082:	96 83       	std	Z+6, r25	; 0x06
    2084:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2086:	90 87       	std	Z+8, r25	; 0x08
    2088:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    208a:	10 82       	st	Z, r1
    208c:	08 95       	ret

0000208e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    208e:	fc 01       	movw	r30, r24
    2090:	11 86       	std	Z+9, r1	; 0x09
    2092:	10 86       	std	Z+8, r1	; 0x08
    2094:	08 95       	ret

00002096 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2096:	cf 93       	push	r28
    2098:	df 93       	push	r29
    209a:	9c 01       	movw	r18, r24
    209c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    209e:	dc 01       	movw	r26, r24
    20a0:	11 96       	adiw	r26, 0x01	; 1
    20a2:	cd 91       	ld	r28, X+
    20a4:	dc 91       	ld	r29, X
    20a6:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    20a8:	d3 83       	std	Z+3, r29	; 0x03
    20aa:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    20ac:	8c 81       	ldd	r24, Y+4	; 0x04
    20ae:	9d 81       	ldd	r25, Y+5	; 0x05
    20b0:	95 83       	std	Z+5, r25	; 0x05
    20b2:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    20b4:	8c 81       	ldd	r24, Y+4	; 0x04
    20b6:	9d 81       	ldd	r25, Y+5	; 0x05
    20b8:	dc 01       	movw	r26, r24
    20ba:	13 96       	adiw	r26, 0x03	; 3
    20bc:	7c 93       	st	X, r23
    20be:	6e 93       	st	-X, r22
    20c0:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    20c2:	7d 83       	std	Y+5, r23	; 0x05
    20c4:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    20c6:	31 87       	std	Z+9, r19	; 0x09
    20c8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    20ca:	f9 01       	movw	r30, r18
    20cc:	80 81       	ld	r24, Z
    20ce:	8f 5f       	subi	r24, 0xFF	; 255
    20d0:	80 83       	st	Z, r24
}
    20d2:	df 91       	pop	r29
    20d4:	cf 91       	pop	r28
    20d6:	08 95       	ret

000020d8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    20d8:	0f 93       	push	r16
    20da:	1f 93       	push	r17
    20dc:	cf 93       	push	r28
    20de:	df 93       	push	r29
    20e0:	8c 01       	movw	r16, r24
    20e2:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    20e4:	80 81       	ld	r24, Z
    20e6:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    20e8:	8f 3f       	cpi	r24, 0xFF	; 255
    20ea:	2f ef       	ldi	r18, 0xFF	; 255
    20ec:	92 07       	cpc	r25, r18
    20ee:	21 f4       	brne	.+8      	; 0x20f8 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    20f0:	e8 01       	movw	r28, r16
    20f2:	af 81       	ldd	r26, Y+7	; 0x07
    20f4:	b8 85       	ldd	r27, Y+8	; 0x08
    20f6:	0e c0       	rjmp	.+28     	; 0x2114 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    20f8:	d8 01       	movw	r26, r16
    20fa:	13 96       	adiw	r26, 0x03	; 3
    20fc:	12 96       	adiw	r26, 0x02	; 2
    20fe:	2d 91       	ld	r18, X+
    2100:	3c 91       	ld	r19, X
    2102:	13 97       	sbiw	r26, 0x03	; 3
    2104:	e9 01       	movw	r28, r18
    2106:	48 81       	ld	r20, Y
    2108:	59 81       	ldd	r21, Y+1	; 0x01
    210a:	84 17       	cp	r24, r20
    210c:	95 07       	cpc	r25, r21
    210e:	10 f0       	brcs	.+4      	; 0x2114 <vListInsert+0x3c>
    2110:	d9 01       	movw	r26, r18
    2112:	f4 cf       	rjmp	.-24     	; 0x20fc <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2114:	12 96       	adiw	r26, 0x02	; 2
    2116:	8d 91       	ld	r24, X+
    2118:	9c 91       	ld	r25, X
    211a:	13 97       	sbiw	r26, 0x03	; 3
    211c:	93 83       	std	Z+3, r25	; 0x03
    211e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2120:	ec 01       	movw	r28, r24
    2122:	fd 83       	std	Y+5, r31	; 0x05
    2124:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2126:	b5 83       	std	Z+5, r27	; 0x05
    2128:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    212a:	13 96       	adiw	r26, 0x03	; 3
    212c:	fc 93       	st	X, r31
    212e:	ee 93       	st	-X, r30
    2130:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    2132:	11 87       	std	Z+9, r17	; 0x09
    2134:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    2136:	f8 01       	movw	r30, r16
    2138:	80 81       	ld	r24, Z
    213a:	8f 5f       	subi	r24, 0xFF	; 255
    213c:	80 83       	st	Z, r24
}
    213e:	df 91       	pop	r29
    2140:	cf 91       	pop	r28
    2142:	1f 91       	pop	r17
    2144:	0f 91       	pop	r16
    2146:	08 95       	ret

00002148 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2148:	cf 93       	push	r28
    214a:	df 93       	push	r29
    214c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    214e:	a0 85       	ldd	r26, Z+8	; 0x08
    2150:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2152:	82 81       	ldd	r24, Z+2	; 0x02
    2154:	93 81       	ldd	r25, Z+3	; 0x03
    2156:	24 81       	ldd	r18, Z+4	; 0x04
    2158:	35 81       	ldd	r19, Z+5	; 0x05
    215a:	ec 01       	movw	r28, r24
    215c:	3d 83       	std	Y+5, r19	; 0x05
    215e:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2160:	c4 81       	ldd	r28, Z+4	; 0x04
    2162:	d5 81       	ldd	r29, Z+5	; 0x05
    2164:	9b 83       	std	Y+3, r25	; 0x03
    2166:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2168:	11 96       	adiw	r26, 0x01	; 1
    216a:	8d 91       	ld	r24, X+
    216c:	9c 91       	ld	r25, X
    216e:	12 97       	sbiw	r26, 0x02	; 2
    2170:	e8 17       	cp	r30, r24
    2172:	f9 07       	cpc	r31, r25
    2174:	21 f4       	brne	.+8      	; 0x217e <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2176:	12 96       	adiw	r26, 0x02	; 2
    2178:	dc 93       	st	X, r29
    217a:	ce 93       	st	-X, r28
    217c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    217e:	11 86       	std	Z+9, r1	; 0x09
    2180:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2182:	8c 91       	ld	r24, X
    2184:	81 50       	subi	r24, 0x01	; 1
    2186:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    2188:	8c 91       	ld	r24, X
}
    218a:	df 91       	pop	r29
    218c:	cf 91       	pop	r28
    218e:	08 95       	ret

00002190 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    2190:	cf 92       	push	r12
    2192:	df 92       	push	r13
    2194:	ef 92       	push	r14
    2196:	ff 92       	push	r15
    2198:	1f 93       	push	r17
    219a:	cf 93       	push	r28
    219c:	df 93       	push	r29
    219e:	6c 01       	movw	r12, r24
    21a0:	16 2f       	mov	r17, r22
    21a2:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    21a4:	8a e1       	ldi	r24, 0x1A	; 26
    21a6:	90 e0       	ldi	r25, 0x00	; 0
    21a8:	0e 94 8e 12 	call	0x251c	; 0x251c <pvPortMalloc>
    21ac:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    21ae:	89 2b       	or	r24, r25
    21b0:	09 f4       	brne	.+2      	; 0x21b4 <xCoRoutineCreate+0x24>
    21b2:	57 c0       	rjmp	.+174    	; 0x2262 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    21b4:	80 91 df 01 	lds	r24, 0x01DF	; 0x8001df <pxCurrentCoRoutine>
    21b8:	90 91 e0 01 	lds	r25, 0x01E0	; 0x8001e0 <pxCurrentCoRoutine+0x1>
    21bc:	89 2b       	or	r24, r25
    21be:	21 f5       	brne	.+72     	; 0x2208 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    21c0:	d0 93 e0 01 	sts	0x01E0, r29	; 0x8001e0 <pxCurrentCoRoutine+0x1>
    21c4:	c0 93 df 01 	sts	0x01DF, r28	; 0x8001df <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    21c8:	87 e0       	ldi	r24, 0x07	; 7
    21ca:	92 e0       	ldi	r25, 0x02	; 2
    21cc:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
    21d0:	80 e1       	ldi	r24, 0x10	; 16
    21d2:	92 e0       	ldi	r25, 0x02	; 2
    21d4:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    21d8:	8e ef       	ldi	r24, 0xFE	; 254
    21da:	91 e0       	ldi	r25, 0x01	; 1
    21dc:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    21e0:	85 ef       	ldi	r24, 0xF5	; 245
    21e2:	91 e0       	ldi	r25, 0x01	; 1
    21e4:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    21e8:	88 ee       	ldi	r24, 0xE8	; 232
    21ea:	91 e0       	ldi	r25, 0x01	; 1
    21ec:	0e 94 39 10 	call	0x2072	; 0x2072 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    21f0:	8e ef       	ldi	r24, 0xFE	; 254
    21f2:	91 e0       	ldi	r25, 0x01	; 1
    21f4:	90 93 f4 01 	sts	0x01F4, r25	; 0x8001f4 <pxDelayedCoRoutineList+0x1>
    21f8:	80 93 f3 01 	sts	0x01F3, r24	; 0x8001f3 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    21fc:	85 ef       	ldi	r24, 0xF5	; 245
    21fe:	91 e0       	ldi	r25, 0x01	; 1
    2200:	90 93 f2 01 	sts	0x01F2, r25	; 0x8001f2 <pxOverflowDelayedCoRoutineList+0x1>
    2204:	80 93 f1 01 	sts	0x01F1, r24	; 0x8001f1 <pxOverflowDelayedCoRoutineList>
    2208:	11 11       	cpse	r17, r1
    220a:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    220c:	19 8e       	std	Y+25, r1	; 0x19
    220e:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2210:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2212:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2214:	fe 01       	movw	r30, r28
    2216:	c1 92       	st	Z+, r12
    2218:	d1 92       	st	Z+, r13
    221a:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    221c:	cf 01       	movw	r24, r30
    221e:	0e 94 47 10 	call	0x208e	; 0x208e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2222:	ce 01       	movw	r24, r28
    2224:	0c 96       	adiw	r24, 0x0c	; 12
    2226:	0e 94 47 10 	call	0x208e	; 0x208e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    222a:	d9 87       	std	Y+9, r29	; 0x09
    222c:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    222e:	db 8b       	std	Y+19, r29	; 0x13
    2230:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    2232:	82 e0       	ldi	r24, 0x02	; 2
    2234:	90 e0       	ldi	r25, 0x00	; 0
    2236:	81 1b       	sub	r24, r17
    2238:	91 09       	sbc	r25, r1
    223a:	9d 87       	std	Y+13, r25	; 0x0d
    223c:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    223e:	8e 89       	ldd	r24, Y+22	; 0x16
    2240:	90 91 e7 01 	lds	r25, 0x01E7	; 0x8001e7 <uxTopCoRoutineReadyPriority>
    2244:	98 17       	cp	r25, r24
    2246:	10 f4       	brcc	.+4      	; 0x224c <xCoRoutineCreate+0xbc>
    2248:	80 93 e7 01 	sts	0x01E7, r24	; 0x8001e7 <uxTopCoRoutineReadyPriority>
    224c:	f9 e0       	ldi	r31, 0x09	; 9
    224e:	8f 9f       	mul	r24, r31
    2250:	c0 01       	movw	r24, r0
    2252:	11 24       	eor	r1, r1
    2254:	b7 01       	movw	r22, r14
    2256:	89 5f       	subi	r24, 0xF9	; 249
    2258:	9d 4f       	sbci	r25, 0xFD	; 253
    225a:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>

		xReturn = pdPASS;
    225e:	81 e0       	ldi	r24, 0x01	; 1
    2260:	01 c0       	rjmp	.+2      	; 0x2264 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2262:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    2264:	df 91       	pop	r29
    2266:	cf 91       	pop	r28
    2268:	1f 91       	pop	r17
    226a:	ff 90       	pop	r15
    226c:	ef 90       	pop	r14
    226e:	df 90       	pop	r13
    2270:	cf 90       	pop	r12
    2272:	08 95       	ret

00002274 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    2274:	0f 93       	push	r16
    2276:	1f 93       	push	r17
    2278:	cf 93       	push	r28
    227a:	df 93       	push	r29
    227c:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    227e:	c0 91 e5 01 	lds	r28, 0x01E5	; 0x8001e5 <xCoRoutineTickCount>
    2282:	d0 91 e6 01 	lds	r29, 0x01E6	; 0x8001e6 <xCoRoutineTickCount+0x1>
    2286:	c8 0f       	add	r28, r24
    2288:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    228a:	80 91 df 01 	lds	r24, 0x01DF	; 0x8001df <pxCurrentCoRoutine>
    228e:	90 91 e0 01 	lds	r25, 0x01E0	; 0x8001e0 <pxCurrentCoRoutine+0x1>
    2292:	02 96       	adiw	r24, 0x02	; 2
    2294:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2298:	e0 91 df 01 	lds	r30, 0x01DF	; 0x8001df <pxCurrentCoRoutine>
    229c:	f0 91 e0 01 	lds	r31, 0x01E0	; 0x8001e0 <pxCurrentCoRoutine+0x1>
    22a0:	d3 83       	std	Z+3, r29	; 0x03
    22a2:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    22a4:	80 91 e5 01 	lds	r24, 0x01E5	; 0x8001e5 <xCoRoutineTickCount>
    22a8:	90 91 e6 01 	lds	r25, 0x01E6	; 0x8001e6 <xCoRoutineTickCount+0x1>
    22ac:	bf 01       	movw	r22, r30
    22ae:	6e 5f       	subi	r22, 0xFE	; 254
    22b0:	7f 4f       	sbci	r23, 0xFF	; 255
    22b2:	c8 17       	cp	r28, r24
    22b4:	d9 07       	cpc	r29, r25
    22b6:	28 f4       	brcc	.+10     	; 0x22c2 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    22b8:	80 91 f1 01 	lds	r24, 0x01F1	; 0x8001f1 <pxOverflowDelayedCoRoutineList>
    22bc:	90 91 f2 01 	lds	r25, 0x01F2	; 0x8001f2 <pxOverflowDelayedCoRoutineList+0x1>
    22c0:	04 c0       	rjmp	.+8      	; 0x22ca <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    22c2:	80 91 f3 01 	lds	r24, 0x01F3	; 0x8001f3 <pxDelayedCoRoutineList>
    22c6:	90 91 f4 01 	lds	r25, 0x01F4	; 0x8001f4 <pxDelayedCoRoutineList+0x1>
    22ca:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <vListInsert>
	}

	if( pxEventList )
    22ce:	01 15       	cp	r16, r1
    22d0:	11 05       	cpc	r17, r1
    22d2:	69 f0       	breq	.+26     	; 0x22ee <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    22d4:	60 91 df 01 	lds	r22, 0x01DF	; 0x8001df <pxCurrentCoRoutine>
    22d8:	70 91 e0 01 	lds	r23, 0x01E0	; 0x8001e0 <pxCurrentCoRoutine+0x1>
    22dc:	64 5f       	subi	r22, 0xF4	; 244
    22de:	7f 4f       	sbci	r23, 0xFF	; 255
    22e0:	c8 01       	movw	r24, r16
	}
}
    22e2:	df 91       	pop	r29
    22e4:	cf 91       	pop	r28
    22e6:	1f 91       	pop	r17
    22e8:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    22ea:	0c 94 6c 10 	jmp	0x20d8	; 0x20d8 <vListInsert>
	}
}
    22ee:	df 91       	pop	r29
    22f0:	cf 91       	pop	r28
    22f2:	1f 91       	pop	r17
    22f4:	0f 91       	pop	r16
    22f6:	08 95       	ret

000022f8 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    22f8:	ff 92       	push	r15
    22fa:	0f 93       	push	r16
    22fc:	1f 93       	push	r17
    22fe:	cf 93       	push	r28
    2300:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2302:	99 e0       	ldi	r25, 0x09	; 9
    2304:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2306:	80 91 e8 01 	lds	r24, 0x01E8	; 0x8001e8 <xPendingReadyCoRoutineList>
    230a:	88 23       	and	r24, r24
    230c:	11 f1       	breq	.+68     	; 0x2352 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    230e:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    2310:	e0 91 ed 01 	lds	r30, 0x01ED	; 0x8001ed <xPendingReadyCoRoutineList+0x5>
    2314:	f0 91 ee 01 	lds	r31, 0x01EE	; 0x8001ee <xPendingReadyCoRoutineList+0x6>
    2318:	c6 81       	ldd	r28, Z+6	; 0x06
    231a:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    231c:	ce 01       	movw	r24, r28
    231e:	0c 96       	adiw	r24, 0x0c	; 12
    2320:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    2324:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2326:	8e 01       	movw	r16, r28
    2328:	0e 5f       	subi	r16, 0xFE	; 254
    232a:	1f 4f       	sbci	r17, 0xFF	; 255
    232c:	c8 01       	movw	r24, r16
    232e:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2332:	8e 89       	ldd	r24, Y+22	; 0x16
    2334:	90 91 e7 01 	lds	r25, 0x01E7	; 0x8001e7 <uxTopCoRoutineReadyPriority>
    2338:	98 17       	cp	r25, r24
    233a:	10 f4       	brcc	.+4      	; 0x2340 <vCoRoutineSchedule+0x48>
    233c:	80 93 e7 01 	sts	0x01E7, r24	; 0x8001e7 <uxTopCoRoutineReadyPriority>
    2340:	f8 9e       	mul	r15, r24
    2342:	c0 01       	movw	r24, r0
    2344:	11 24       	eor	r1, r1
    2346:	b8 01       	movw	r22, r16
    2348:	89 5f       	subi	r24, 0xF9	; 249
    234a:	9d 4f       	sbci	r25, 0xFD	; 253
    234c:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>
    2350:	da cf       	rjmp	.-76     	; 0x2306 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2352:	0e 94 07 06 	call	0xc0e	; 0xc0e <xTaskGetTickCount>
    2356:	20 91 e3 01 	lds	r18, 0x01E3	; 0x8001e3 <xLastTickCount>
    235a:	30 91 e4 01 	lds	r19, 0x01E4	; 0x8001e4 <xLastTickCount+0x1>
    235e:	82 1b       	sub	r24, r18
    2360:	93 0b       	sbc	r25, r19
    2362:	90 93 e2 01 	sts	0x01E2, r25	; 0x8001e2 <xPassedTicks+0x1>
    2366:	80 93 e1 01 	sts	0x01E1, r24	; 0x8001e1 <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    236a:	89 e0       	ldi	r24, 0x09	; 9
    236c:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    236e:	20 91 e1 01 	lds	r18, 0x01E1	; 0x8001e1 <xPassedTicks>
    2372:	30 91 e2 01 	lds	r19, 0x01E2	; 0x8001e2 <xPassedTicks+0x1>
    2376:	80 91 e5 01 	lds	r24, 0x01E5	; 0x8001e5 <xCoRoutineTickCount>
    237a:	90 91 e6 01 	lds	r25, 0x01E6	; 0x8001e6 <xCoRoutineTickCount+0x1>
    237e:	21 15       	cp	r18, r1
    2380:	31 05       	cpc	r19, r1
    2382:	09 f4       	brne	.+2      	; 0x2386 <vCoRoutineSchedule+0x8e>
    2384:	54 c0       	rjmp	.+168    	; 0x242e <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    2386:	01 96       	adiw	r24, 0x01	; 1
    2388:	90 93 e6 01 	sts	0x01E6, r25	; 0x8001e6 <xCoRoutineTickCount+0x1>
    238c:	80 93 e5 01 	sts	0x01E5, r24	; 0x8001e5 <xCoRoutineTickCount>
		xPassedTicks--;
    2390:	21 50       	subi	r18, 0x01	; 1
    2392:	31 09       	sbc	r19, r1
    2394:	30 93 e2 01 	sts	0x01E2, r19	; 0x8001e2 <xPassedTicks+0x1>
    2398:	20 93 e1 01 	sts	0x01E1, r18	; 0x8001e1 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    239c:	89 2b       	or	r24, r25
    239e:	09 f0       	breq	.+2      	; 0x23a2 <vCoRoutineSchedule+0xaa>
    23a0:	3e c0       	rjmp	.+124    	; 0x241e <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    23a2:	80 91 f3 01 	lds	r24, 0x01F3	; 0x8001f3 <pxDelayedCoRoutineList>
    23a6:	90 91 f4 01 	lds	r25, 0x01F4	; 0x8001f4 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    23aa:	20 91 f1 01 	lds	r18, 0x01F1	; 0x8001f1 <pxOverflowDelayedCoRoutineList>
    23ae:	30 91 f2 01 	lds	r19, 0x01F2	; 0x8001f2 <pxOverflowDelayedCoRoutineList+0x1>
    23b2:	30 93 f4 01 	sts	0x01F4, r19	; 0x8001f4 <pxDelayedCoRoutineList+0x1>
    23b6:	20 93 f3 01 	sts	0x01F3, r18	; 0x8001f3 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    23ba:	90 93 f2 01 	sts	0x01F2, r25	; 0x8001f2 <pxOverflowDelayedCoRoutineList+0x1>
    23be:	80 93 f1 01 	sts	0x01F1, r24	; 0x8001f1 <pxOverflowDelayedCoRoutineList>
    23c2:	2d c0       	rjmp	.+90     	; 0x241e <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    23c4:	05 80       	ldd	r0, Z+5	; 0x05
    23c6:	f6 81       	ldd	r31, Z+6	; 0x06
    23c8:	e0 2d       	mov	r30, r0
    23ca:	c6 81       	ldd	r28, Z+6	; 0x06
    23cc:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    23ce:	2a 81       	ldd	r18, Y+2	; 0x02
    23d0:	3b 81       	ldd	r19, Y+3	; 0x03
    23d2:	80 91 e5 01 	lds	r24, 0x01E5	; 0x8001e5 <xCoRoutineTickCount>
    23d6:	90 91 e6 01 	lds	r25, 0x01E6	; 0x8001e6 <xCoRoutineTickCount+0x1>
    23da:	82 17       	cp	r24, r18
    23dc:	93 07       	cpc	r25, r19
    23de:	38 f2       	brcs	.-114    	; 0x236e <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    23e0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    23e2:	8e 01       	movw	r16, r28
    23e4:	0e 5f       	subi	r16, 0xFE	; 254
    23e6:	1f 4f       	sbci	r17, 0xFF	; 255
    23e8:	c8 01       	movw	r24, r16
    23ea:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    23ee:	8c 89       	ldd	r24, Y+20	; 0x14
    23f0:	9d 89       	ldd	r25, Y+21	; 0x15
    23f2:	89 2b       	or	r24, r25
    23f4:	21 f0       	breq	.+8      	; 0x23fe <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    23f6:	ce 01       	movw	r24, r28
    23f8:	0c 96       	adiw	r24, 0x0c	; 12
    23fa:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    23fe:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2400:	8e 89       	ldd	r24, Y+22	; 0x16
    2402:	90 91 e7 01 	lds	r25, 0x01E7	; 0x8001e7 <uxTopCoRoutineReadyPriority>
    2406:	98 17       	cp	r25, r24
    2408:	10 f4       	brcc	.+4      	; 0x240e <vCoRoutineSchedule+0x116>
    240a:	80 93 e7 01 	sts	0x01E7, r24	; 0x8001e7 <uxTopCoRoutineReadyPriority>
    240e:	f8 9e       	mul	r15, r24
    2410:	c0 01       	movw	r24, r0
    2412:	11 24       	eor	r1, r1
    2414:	b8 01       	movw	r22, r16
    2416:	89 5f       	subi	r24, 0xF9	; 249
    2418:	9d 4f       	sbci	r25, 0xFD	; 253
    241a:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    241e:	e0 91 f3 01 	lds	r30, 0x01F3	; 0x8001f3 <pxDelayedCoRoutineList>
    2422:	f0 91 f4 01 	lds	r31, 0x01F4	; 0x8001f4 <pxDelayedCoRoutineList+0x1>
    2426:	80 81       	ld	r24, Z
    2428:	81 11       	cpse	r24, r1
    242a:	cc cf       	rjmp	.-104    	; 0x23c4 <vCoRoutineSchedule+0xcc>
    242c:	a0 cf       	rjmp	.-192    	; 0x236e <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    242e:	90 93 e4 01 	sts	0x01E4, r25	; 0x8001e4 <xLastTickCount+0x1>
    2432:	80 93 e3 01 	sts	0x01E3, r24	; 0x8001e3 <xLastTickCount>
    2436:	80 91 e7 01 	lds	r24, 0x01E7	; 0x8001e7 <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    243a:	69 e0       	ldi	r22, 0x09	; 9
    243c:	48 2f       	mov	r20, r24
    243e:	50 e0       	ldi	r21, 0x00	; 0
    2440:	64 9f       	mul	r22, r20
    2442:	90 01       	movw	r18, r0
    2444:	65 9f       	mul	r22, r21
    2446:	30 0d       	add	r19, r0
    2448:	11 24       	eor	r1, r1
    244a:	f9 01       	movw	r30, r18
    244c:	e9 5f       	subi	r30, 0xF9	; 249
    244e:	fd 4f       	sbci	r31, 0xFD	; 253
    2450:	90 81       	ld	r25, Z
    2452:	91 11       	cpse	r25, r1
    2454:	0c c0       	rjmp	.+24     	; 0x246e <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2456:	81 11       	cpse	r24, r1
    2458:	08 c0       	rjmp	.+16     	; 0x246a <vCoRoutineSchedule+0x172>
    245a:	10 92 e7 01 	sts	0x01E7, r1	; 0x8001e7 <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    245e:	df 91       	pop	r29
    2460:	cf 91       	pop	r28
    2462:	1f 91       	pop	r17
    2464:	0f 91       	pop	r16
    2466:	ff 90       	pop	r15
    2468:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    246a:	81 50       	subi	r24, 0x01	; 1
    246c:	e7 cf       	rjmp	.-50     	; 0x243c <vCoRoutineSchedule+0x144>
    246e:	80 93 e7 01 	sts	0x01E7, r24	; 0x8001e7 <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2472:	a1 81       	ldd	r26, Z+1	; 0x01
    2474:	b2 81       	ldd	r27, Z+2	; 0x02
    2476:	12 96       	adiw	r26, 0x02	; 2
    2478:	0d 90       	ld	r0, X+
    247a:	bc 91       	ld	r27, X
    247c:	a0 2d       	mov	r26, r0
    247e:	b2 83       	std	Z+2, r27	; 0x02
    2480:	a1 83       	std	Z+1, r26	; 0x01
    2482:	26 5f       	subi	r18, 0xF6	; 246
    2484:	3d 4f       	sbci	r19, 0xFD	; 253
    2486:	a2 17       	cp	r26, r18
    2488:	b3 07       	cpc	r27, r19
    248a:	31 f4       	brne	.+12     	; 0x2498 <vCoRoutineSchedule+0x1a0>
    248c:	12 96       	adiw	r26, 0x02	; 2
    248e:	8d 91       	ld	r24, X+
    2490:	9c 91       	ld	r25, X
    2492:	13 97       	sbiw	r26, 0x03	; 3
    2494:	92 83       	std	Z+2, r25	; 0x02
    2496:	81 83       	std	Z+1, r24	; 0x01
    2498:	89 e0       	ldi	r24, 0x09	; 9
    249a:	84 9f       	mul	r24, r20
    249c:	f0 01       	movw	r30, r0
    249e:	85 9f       	mul	r24, r21
    24a0:	f0 0d       	add	r31, r0
    24a2:	11 24       	eor	r1, r1
    24a4:	e9 5f       	subi	r30, 0xF9	; 249
    24a6:	fd 4f       	sbci	r31, 0xFD	; 253
    24a8:	01 80       	ldd	r0, Z+1	; 0x01
    24aa:	f2 81       	ldd	r31, Z+2	; 0x02
    24ac:	e0 2d       	mov	r30, r0
    24ae:	86 81       	ldd	r24, Z+6	; 0x06
    24b0:	97 81       	ldd	r25, Z+7	; 0x07
    24b2:	90 93 e0 01 	sts	0x01E0, r25	; 0x8001e0 <pxCurrentCoRoutine+0x1>
    24b6:	80 93 df 01 	sts	0x01DF, r24	; 0x8001df <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    24ba:	dc 01       	movw	r26, r24
    24bc:	ed 91       	ld	r30, X+
    24be:	fc 91       	ld	r31, X
    24c0:	11 97       	sbiw	r26, 0x01	; 1
    24c2:	57 96       	adiw	r26, 0x17	; 23
    24c4:	6c 91       	ld	r22, X

	return;
}
    24c6:	df 91       	pop	r29
    24c8:	cf 91       	pop	r28
    24ca:	1f 91       	pop	r17
    24cc:	0f 91       	pop	r16
    24ce:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    24d0:	09 94       	ijmp

000024d2 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    24d2:	0f 93       	push	r16
    24d4:	1f 93       	push	r17
    24d6:	cf 93       	push	r28
    24d8:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    24da:	dc 01       	movw	r26, r24
    24dc:	15 96       	adiw	r26, 0x05	; 5
    24de:	ed 91       	ld	r30, X+
    24e0:	fc 91       	ld	r31, X
    24e2:	16 97       	sbiw	r26, 0x06	; 6
    24e4:	c6 81       	ldd	r28, Z+6	; 0x06
    24e6:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    24e8:	8e 01       	movw	r16, r28
    24ea:	04 5f       	subi	r16, 0xF4	; 244
    24ec:	1f 4f       	sbci	r17, 0xFF	; 255
    24ee:	c8 01       	movw	r24, r16
    24f0:	0e 94 a4 10 	call	0x2148	; 0x2148 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    24f4:	b8 01       	movw	r22, r16
    24f6:	88 ee       	ldi	r24, 0xE8	; 232
    24f8:	91 e0       	ldi	r25, 0x01	; 1
    24fa:	0e 94 4b 10 	call	0x2096	; 0x2096 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    24fe:	e0 91 df 01 	lds	r30, 0x01DF	; 0x8001df <pxCurrentCoRoutine>
    2502:	f0 91 e0 01 	lds	r31, 0x01E0	; 0x8001e0 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2506:	81 e0       	ldi	r24, 0x01	; 1
    2508:	2e 89       	ldd	r18, Y+22	; 0x16
    250a:	96 89       	ldd	r25, Z+22	; 0x16
    250c:	29 17       	cp	r18, r25
    250e:	08 f4       	brcc	.+2      	; 0x2512 <xCoRoutineRemoveFromEventList+0x40>
    2510:	80 e0       	ldi	r24, 0x00	; 0
}
    2512:	df 91       	pop	r29
    2514:	cf 91       	pop	r28
    2516:	1f 91       	pop	r17
    2518:	0f 91       	pop	r16
    251a:	08 95       	ret

0000251c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    251c:	cf 93       	push	r28
    251e:	df 93       	push	r29
    2520:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2522:	0e 94 01 06 	call	0xc02	; 0xc02 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2526:	80 91 19 02 	lds	r24, 0x0219	; 0x800219 <pucAlignedHeap.2079>
    252a:	90 91 1a 02 	lds	r25, 0x021A	; 0x80021a <pucAlignedHeap.2079+0x1>
    252e:	89 2b       	or	r24, r25
    2530:	31 f4       	brne	.+12     	; 0x253e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2532:	8e e1       	ldi	r24, 0x1E	; 30
    2534:	92 e0       	ldi	r25, 0x02	; 2
    2536:	90 93 1a 02 	sts	0x021A, r25	; 0x80021a <pucAlignedHeap.2079+0x1>
    253a:	80 93 19 02 	sts	0x0219, r24	; 0x800219 <pucAlignedHeap.2079>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    253e:	20 91 1b 02 	lds	r18, 0x021B	; 0x80021b <xNextFreeByte>
    2542:	30 91 1c 02 	lds	r19, 0x021C	; 0x80021c <xNextFreeByte+0x1>
    2546:	c9 01       	movw	r24, r18
    2548:	8c 0f       	add	r24, r28
    254a:	9d 1f       	adc	r25, r29
    254c:	8b 3d       	cpi	r24, 0xDB	; 219
    254e:	45 e0       	ldi	r20, 0x05	; 5
    2550:	94 07       	cpc	r25, r20
    2552:	70 f4       	brcc	.+28     	; 0x2570 <pvPortMalloc+0x54>
    2554:	28 17       	cp	r18, r24
    2556:	39 07       	cpc	r19, r25
    2558:	58 f4       	brcc	.+22     	; 0x2570 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    255a:	c0 91 19 02 	lds	r28, 0x0219	; 0x800219 <pucAlignedHeap.2079>
    255e:	d0 91 1a 02 	lds	r29, 0x021A	; 0x80021a <pucAlignedHeap.2079+0x1>
    2562:	c2 0f       	add	r28, r18
    2564:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2566:	90 93 1c 02 	sts	0x021C, r25	; 0x80021c <xNextFreeByte+0x1>
    256a:	80 93 1b 02 	sts	0x021B, r24	; 0x80021b <xNextFreeByte>
    256e:	02 c0       	rjmp	.+4      	; 0x2574 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    2570:	c0 e0       	ldi	r28, 0x00	; 0
    2572:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2574:	0e 94 cd 06 	call	0xd9a	; 0xd9a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2578:	ce 01       	movw	r24, r28
    257a:	df 91       	pop	r29
    257c:	cf 91       	pop	r28
    257e:	08 95       	ret

00002580 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2580:	08 95       	ret

00002582 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2582:	10 92 1c 02 	sts	0x021C, r1	; 0x80021c <xNextFreeByte+0x1>
    2586:	10 92 1b 02 	sts	0x021B, r1	; 0x80021b <xNextFreeByte>
    258a:	08 95       	ret

0000258c <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    258c:	20 91 1b 02 	lds	r18, 0x021B	; 0x80021b <xNextFreeByte>
    2590:	30 91 1c 02 	lds	r19, 0x021C	; 0x80021c <xNextFreeByte+0x1>
}
    2594:	8b ed       	ldi	r24, 0xDB	; 219
    2596:	95 e0       	ldi	r25, 0x05	; 5
    2598:	82 1b       	sub	r24, r18
    259a:	93 0b       	sbc	r25, r19
    259c:	08 95       	ret

0000259e <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    259e:	31 e1       	ldi	r19, 0x11	; 17
    25a0:	fc 01       	movw	r30, r24
    25a2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    25a4:	31 97       	sbiw	r30, 0x01	; 1
    25a6:	22 e2       	ldi	r18, 0x22	; 34
    25a8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    25aa:	31 97       	sbiw	r30, 0x01	; 1
    25ac:	a3 e3       	ldi	r26, 0x33	; 51
    25ae:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    25b0:	31 97       	sbiw	r30, 0x01	; 1
    25b2:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    25b4:	31 97       	sbiw	r30, 0x01	; 1
    25b6:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    25b8:	31 97       	sbiw	r30, 0x01	; 1
    25ba:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    25bc:	31 97       	sbiw	r30, 0x01	; 1
    25be:	60 e8       	ldi	r22, 0x80	; 128
    25c0:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    25c2:	31 97       	sbiw	r30, 0x01	; 1
    25c4:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    25c6:	31 97       	sbiw	r30, 0x01	; 1
    25c8:	62 e0       	ldi	r22, 0x02	; 2
    25ca:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    25cc:	31 97       	sbiw	r30, 0x01	; 1
    25ce:	63 e0       	ldi	r22, 0x03	; 3
    25d0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    25d2:	31 97       	sbiw	r30, 0x01	; 1
    25d4:	64 e0       	ldi	r22, 0x04	; 4
    25d6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    25d8:	31 97       	sbiw	r30, 0x01	; 1
    25da:	65 e0       	ldi	r22, 0x05	; 5
    25dc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    25de:	31 97       	sbiw	r30, 0x01	; 1
    25e0:	66 e0       	ldi	r22, 0x06	; 6
    25e2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    25e4:	31 97       	sbiw	r30, 0x01	; 1
    25e6:	67 e0       	ldi	r22, 0x07	; 7
    25e8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    25ea:	31 97       	sbiw	r30, 0x01	; 1
    25ec:	68 e0       	ldi	r22, 0x08	; 8
    25ee:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    25f0:	31 97       	sbiw	r30, 0x01	; 1
    25f2:	69 e0       	ldi	r22, 0x09	; 9
    25f4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    25f6:	31 97       	sbiw	r30, 0x01	; 1
    25f8:	60 e1       	ldi	r22, 0x10	; 16
    25fa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    25fc:	31 97       	sbiw	r30, 0x01	; 1
    25fe:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2600:	31 97       	sbiw	r30, 0x01	; 1
    2602:	32 e1       	ldi	r19, 0x12	; 18
    2604:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2606:	31 97       	sbiw	r30, 0x01	; 1
    2608:	33 e1       	ldi	r19, 0x13	; 19
    260a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    260c:	31 97       	sbiw	r30, 0x01	; 1
    260e:	34 e1       	ldi	r19, 0x14	; 20
    2610:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2612:	31 97       	sbiw	r30, 0x01	; 1
    2614:	35 e1       	ldi	r19, 0x15	; 21
    2616:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2618:	31 97       	sbiw	r30, 0x01	; 1
    261a:	36 e1       	ldi	r19, 0x16	; 22
    261c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    261e:	31 97       	sbiw	r30, 0x01	; 1
    2620:	37 e1       	ldi	r19, 0x17	; 23
    2622:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2624:	31 97       	sbiw	r30, 0x01	; 1
    2626:	38 e1       	ldi	r19, 0x18	; 24
    2628:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    262a:	31 97       	sbiw	r30, 0x01	; 1
    262c:	39 e1       	ldi	r19, 0x19	; 25
    262e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2630:	31 97       	sbiw	r30, 0x01	; 1
    2632:	30 e2       	ldi	r19, 0x20	; 32
    2634:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2636:	31 97       	sbiw	r30, 0x01	; 1
    2638:	31 e2       	ldi	r19, 0x21	; 33
    263a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    263c:	31 97       	sbiw	r30, 0x01	; 1
    263e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2640:	31 97       	sbiw	r30, 0x01	; 1
    2642:	23 e2       	ldi	r18, 0x23	; 35
    2644:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2646:	31 97       	sbiw	r30, 0x01	; 1
    2648:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    264a:	31 97       	sbiw	r30, 0x01	; 1
    264c:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    264e:	31 97       	sbiw	r30, 0x01	; 1
    2650:	26 e2       	ldi	r18, 0x26	; 38
    2652:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2654:	31 97       	sbiw	r30, 0x01	; 1
    2656:	27 e2       	ldi	r18, 0x27	; 39
    2658:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    265a:	31 97       	sbiw	r30, 0x01	; 1
    265c:	28 e2       	ldi	r18, 0x28	; 40
    265e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2660:	31 97       	sbiw	r30, 0x01	; 1
    2662:	29 e2       	ldi	r18, 0x29	; 41
    2664:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2666:	31 97       	sbiw	r30, 0x01	; 1
    2668:	20 e3       	ldi	r18, 0x30	; 48
    266a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    266c:	31 97       	sbiw	r30, 0x01	; 1
    266e:	21 e3       	ldi	r18, 0x31	; 49
    2670:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2672:	86 97       	sbiw	r24, 0x26	; 38
    2674:	08 95       	ret

00002676 <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    2676:	89 ef       	ldi	r24, 0xF9	; 249
    2678:	90 e0       	ldi	r25, 0x00	; 0
    267a:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
    267e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    2682:	e0 e8       	ldi	r30, 0x80	; 128
    2684:	f0 e0       	ldi	r31, 0x00	; 0
    2686:	80 81       	ld	r24, Z
    2688:	8c 7f       	andi	r24, 0xFC	; 252
    268a:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    268c:	8b e0       	ldi	r24, 0x0B	; 11
    268e:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2692:	ef e6       	ldi	r30, 0x6F	; 111
    2694:	f0 e0       	ldi	r31, 0x00	; 0
    2696:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2698:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    269a:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    269c:	a0 91 79 01 	lds	r26, 0x0179	; 0x800179 <pxCurrentTCB>
    26a0:	b0 91 7a 01 	lds	r27, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    26a4:	cd 91       	ld	r28, X+
    26a6:	cd bf       	out	0x3d, r28	; 61
    26a8:	dd 91       	ld	r29, X+
    26aa:	de bf       	out	0x3e, r29	; 62
    26ac:	ff 91       	pop	r31
    26ae:	ef 91       	pop	r30
    26b0:	df 91       	pop	r29
    26b2:	cf 91       	pop	r28
    26b4:	bf 91       	pop	r27
    26b6:	af 91       	pop	r26
    26b8:	9f 91       	pop	r25
    26ba:	8f 91       	pop	r24
    26bc:	7f 91       	pop	r23
    26be:	6f 91       	pop	r22
    26c0:	5f 91       	pop	r21
    26c2:	4f 91       	pop	r20
    26c4:	3f 91       	pop	r19
    26c6:	2f 91       	pop	r18
    26c8:	1f 91       	pop	r17
    26ca:	0f 91       	pop	r16
    26cc:	ff 90       	pop	r15
    26ce:	ef 90       	pop	r14
    26d0:	df 90       	pop	r13
    26d2:	cf 90       	pop	r12
    26d4:	bf 90       	pop	r11
    26d6:	af 90       	pop	r10
    26d8:	9f 90       	pop	r9
    26da:	8f 90       	pop	r8
    26dc:	7f 90       	pop	r7
    26de:	6f 90       	pop	r6
    26e0:	5f 90       	pop	r5
    26e2:	4f 90       	pop	r4
    26e4:	3f 90       	pop	r3
    26e6:	2f 90       	pop	r2
    26e8:	1f 90       	pop	r1
    26ea:	0f 90       	pop	r0
    26ec:	0f be       	out	0x3f, r0	; 63
    26ee:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    26f0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    26f2:	81 e0       	ldi	r24, 0x01	; 1
    26f4:	08 95       	ret

000026f6 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    26f6:	08 95       	ret

000026f8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    26f8:	0f 92       	push	r0
    26fa:	0f b6       	in	r0, 0x3f	; 63
    26fc:	f8 94       	cli
    26fe:	0f 92       	push	r0
    2700:	1f 92       	push	r1
    2702:	11 24       	eor	r1, r1
    2704:	2f 92       	push	r2
    2706:	3f 92       	push	r3
    2708:	4f 92       	push	r4
    270a:	5f 92       	push	r5
    270c:	6f 92       	push	r6
    270e:	7f 92       	push	r7
    2710:	8f 92       	push	r8
    2712:	9f 92       	push	r9
    2714:	af 92       	push	r10
    2716:	bf 92       	push	r11
    2718:	cf 92       	push	r12
    271a:	df 92       	push	r13
    271c:	ef 92       	push	r14
    271e:	ff 92       	push	r15
    2720:	0f 93       	push	r16
    2722:	1f 93       	push	r17
    2724:	2f 93       	push	r18
    2726:	3f 93       	push	r19
    2728:	4f 93       	push	r20
    272a:	5f 93       	push	r21
    272c:	6f 93       	push	r22
    272e:	7f 93       	push	r23
    2730:	8f 93       	push	r24
    2732:	9f 93       	push	r25
    2734:	af 93       	push	r26
    2736:	bf 93       	push	r27
    2738:	cf 93       	push	r28
    273a:	df 93       	push	r29
    273c:	ef 93       	push	r30
    273e:	ff 93       	push	r31
    2740:	a0 91 79 01 	lds	r26, 0x0179	; 0x800179 <pxCurrentTCB>
    2744:	b0 91 7a 01 	lds	r27, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    2748:	0d b6       	in	r0, 0x3d	; 61
    274a:	0d 92       	st	X+, r0
    274c:	0e b6       	in	r0, 0x3e	; 62
    274e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2750:	0e 94 89 07 	call	0xf12	; 0xf12 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2754:	a0 91 79 01 	lds	r26, 0x0179	; 0x800179 <pxCurrentTCB>
    2758:	b0 91 7a 01 	lds	r27, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    275c:	cd 91       	ld	r28, X+
    275e:	cd bf       	out	0x3d, r28	; 61
    2760:	dd 91       	ld	r29, X+
    2762:	de bf       	out	0x3e, r29	; 62
    2764:	ff 91       	pop	r31
    2766:	ef 91       	pop	r30
    2768:	df 91       	pop	r29
    276a:	cf 91       	pop	r28
    276c:	bf 91       	pop	r27
    276e:	af 91       	pop	r26
    2770:	9f 91       	pop	r25
    2772:	8f 91       	pop	r24
    2774:	7f 91       	pop	r23
    2776:	6f 91       	pop	r22
    2778:	5f 91       	pop	r21
    277a:	4f 91       	pop	r20
    277c:	3f 91       	pop	r19
    277e:	2f 91       	pop	r18
    2780:	1f 91       	pop	r17
    2782:	0f 91       	pop	r16
    2784:	ff 90       	pop	r15
    2786:	ef 90       	pop	r14
    2788:	df 90       	pop	r13
    278a:	cf 90       	pop	r12
    278c:	bf 90       	pop	r11
    278e:	af 90       	pop	r10
    2790:	9f 90       	pop	r9
    2792:	8f 90       	pop	r8
    2794:	7f 90       	pop	r7
    2796:	6f 90       	pop	r6
    2798:	5f 90       	pop	r5
    279a:	4f 90       	pop	r4
    279c:	3f 90       	pop	r3
    279e:	2f 90       	pop	r2
    27a0:	1f 90       	pop	r1
    27a2:	0f 90       	pop	r0
    27a4:	0f be       	out	0x3f, r0	; 63
    27a6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    27a8:	08 95       	ret

000027aa <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    27aa:	0f 92       	push	r0
    27ac:	0f b6       	in	r0, 0x3f	; 63
    27ae:	f8 94       	cli
    27b0:	0f 92       	push	r0
    27b2:	1f 92       	push	r1
    27b4:	11 24       	eor	r1, r1
    27b6:	2f 92       	push	r2
    27b8:	3f 92       	push	r3
    27ba:	4f 92       	push	r4
    27bc:	5f 92       	push	r5
    27be:	6f 92       	push	r6
    27c0:	7f 92       	push	r7
    27c2:	8f 92       	push	r8
    27c4:	9f 92       	push	r9
    27c6:	af 92       	push	r10
    27c8:	bf 92       	push	r11
    27ca:	cf 92       	push	r12
    27cc:	df 92       	push	r13
    27ce:	ef 92       	push	r14
    27d0:	ff 92       	push	r15
    27d2:	0f 93       	push	r16
    27d4:	1f 93       	push	r17
    27d6:	2f 93       	push	r18
    27d8:	3f 93       	push	r19
    27da:	4f 93       	push	r20
    27dc:	5f 93       	push	r21
    27de:	6f 93       	push	r22
    27e0:	7f 93       	push	r23
    27e2:	8f 93       	push	r24
    27e4:	9f 93       	push	r25
    27e6:	af 93       	push	r26
    27e8:	bf 93       	push	r27
    27ea:	cf 93       	push	r28
    27ec:	df 93       	push	r29
    27ee:	ef 93       	push	r30
    27f0:	ff 93       	push	r31
    27f2:	a0 91 79 01 	lds	r26, 0x0179	; 0x800179 <pxCurrentTCB>
    27f6:	b0 91 7a 01 	lds	r27, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    27fa:	0d b6       	in	r0, 0x3d	; 61
    27fc:	0d 92       	st	X+, r0
    27fe:	0e b6       	in	r0, 0x3e	; 62
    2800:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2802:	0e 94 21 06 	call	0xc42	; 0xc42 <xTaskIncrementTick>
    2806:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2808:	0e 94 89 07 	call	0xf12	; 0xf12 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    280c:	a0 91 79 01 	lds	r26, 0x0179	; 0x800179 <pxCurrentTCB>
    2810:	b0 91 7a 01 	lds	r27, 0x017A	; 0x80017a <pxCurrentTCB+0x1>
    2814:	cd 91       	ld	r28, X+
    2816:	cd bf       	out	0x3d, r28	; 61
    2818:	dd 91       	ld	r29, X+
    281a:	de bf       	out	0x3e, r29	; 62
    281c:	ff 91       	pop	r31
    281e:	ef 91       	pop	r30
    2820:	df 91       	pop	r29
    2822:	cf 91       	pop	r28
    2824:	bf 91       	pop	r27
    2826:	af 91       	pop	r26
    2828:	9f 91       	pop	r25
    282a:	8f 91       	pop	r24
    282c:	7f 91       	pop	r23
    282e:	6f 91       	pop	r22
    2830:	5f 91       	pop	r21
    2832:	4f 91       	pop	r20
    2834:	3f 91       	pop	r19
    2836:	2f 91       	pop	r18
    2838:	1f 91       	pop	r17
    283a:	0f 91       	pop	r16
    283c:	ff 90       	pop	r15
    283e:	ef 90       	pop	r14
    2840:	df 90       	pop	r13
    2842:	cf 90       	pop	r12
    2844:	bf 90       	pop	r11
    2846:	af 90       	pop	r10
    2848:	9f 90       	pop	r9
    284a:	8f 90       	pop	r8
    284c:	7f 90       	pop	r7
    284e:	6f 90       	pop	r6
    2850:	5f 90       	pop	r5
    2852:	4f 90       	pop	r4
    2854:	3f 90       	pop	r3
    2856:	2f 90       	pop	r2
    2858:	1f 90       	pop	r1
    285a:	0f 90       	pop	r0
    285c:	0f be       	out	0x3f, r0	; 63
    285e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2860:	08 95       	ret

00002862 <__vector_11>:
    2862:	0e 94 d5 13 	call	0x27aa	; 0x27aa <vPortYieldFromTick>
    2866:	18 95       	reti

00002868 <vfprintf>:
    2868:	a0 e1       	ldi	r26, 0x10	; 16
    286a:	b0 e0       	ldi	r27, 0x00	; 0
    286c:	ea e3       	ldi	r30, 0x3A	; 58
    286e:	f4 e1       	ldi	r31, 0x14	; 20
    2870:	0c 94 3e 18 	jmp	0x307c	; 0x307c <__prologue_saves__>
    2874:	7c 01       	movw	r14, r24
    2876:	1b 01       	movw	r2, r22
    2878:	6a 01       	movw	r12, r20
    287a:	fc 01       	movw	r30, r24
    287c:	17 82       	std	Z+7, r1	; 0x07
    287e:	16 82       	std	Z+6, r1	; 0x06
    2880:	83 81       	ldd	r24, Z+3	; 0x03
    2882:	81 ff       	sbrs	r24, 1
    2884:	44 c3       	rjmp	.+1672   	; 0x2f0e <vfprintf+0x6a6>
    2886:	9e 01       	movw	r18, r28
    2888:	2f 5f       	subi	r18, 0xFF	; 255
    288a:	3f 4f       	sbci	r19, 0xFF	; 255
    288c:	39 01       	movw	r6, r18
    288e:	f7 01       	movw	r30, r14
    2890:	93 81       	ldd	r25, Z+3	; 0x03
    2892:	f1 01       	movw	r30, r2
    2894:	93 fd       	sbrc	r25, 3
    2896:	85 91       	lpm	r24, Z+
    2898:	93 ff       	sbrs	r25, 3
    289a:	81 91       	ld	r24, Z+
    289c:	1f 01       	movw	r2, r30
    289e:	88 23       	and	r24, r24
    28a0:	09 f4       	brne	.+2      	; 0x28a4 <vfprintf+0x3c>
    28a2:	31 c3       	rjmp	.+1634   	; 0x2f06 <vfprintf+0x69e>
    28a4:	85 32       	cpi	r24, 0x25	; 37
    28a6:	39 f4       	brne	.+14     	; 0x28b6 <vfprintf+0x4e>
    28a8:	93 fd       	sbrc	r25, 3
    28aa:	85 91       	lpm	r24, Z+
    28ac:	93 ff       	sbrs	r25, 3
    28ae:	81 91       	ld	r24, Z+
    28b0:	1f 01       	movw	r2, r30
    28b2:	85 32       	cpi	r24, 0x25	; 37
    28b4:	39 f4       	brne	.+14     	; 0x28c4 <vfprintf+0x5c>
    28b6:	b7 01       	movw	r22, r14
    28b8:	90 e0       	ldi	r25, 0x00	; 0
    28ba:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    28be:	56 01       	movw	r10, r12
    28c0:	65 01       	movw	r12, r10
    28c2:	e5 cf       	rjmp	.-54     	; 0x288e <vfprintf+0x26>
    28c4:	10 e0       	ldi	r17, 0x00	; 0
    28c6:	51 2c       	mov	r5, r1
    28c8:	91 2c       	mov	r9, r1
    28ca:	ff e1       	ldi	r31, 0x1F	; 31
    28cc:	f9 15       	cp	r31, r9
    28ce:	d8 f0       	brcs	.+54     	; 0x2906 <vfprintf+0x9e>
    28d0:	8b 32       	cpi	r24, 0x2B	; 43
    28d2:	79 f0       	breq	.+30     	; 0x28f2 <vfprintf+0x8a>
    28d4:	38 f4       	brcc	.+14     	; 0x28e4 <vfprintf+0x7c>
    28d6:	80 32       	cpi	r24, 0x20	; 32
    28d8:	79 f0       	breq	.+30     	; 0x28f8 <vfprintf+0x90>
    28da:	83 32       	cpi	r24, 0x23	; 35
    28dc:	a1 f4       	brne	.+40     	; 0x2906 <vfprintf+0x9e>
    28de:	f9 2d       	mov	r31, r9
    28e0:	f0 61       	ori	r31, 0x10	; 16
    28e2:	2e c0       	rjmp	.+92     	; 0x2940 <vfprintf+0xd8>
    28e4:	8d 32       	cpi	r24, 0x2D	; 45
    28e6:	61 f0       	breq	.+24     	; 0x2900 <vfprintf+0x98>
    28e8:	80 33       	cpi	r24, 0x30	; 48
    28ea:	69 f4       	brne	.+26     	; 0x2906 <vfprintf+0x9e>
    28ec:	29 2d       	mov	r18, r9
    28ee:	21 60       	ori	r18, 0x01	; 1
    28f0:	2d c0       	rjmp	.+90     	; 0x294c <vfprintf+0xe4>
    28f2:	39 2d       	mov	r19, r9
    28f4:	32 60       	ori	r19, 0x02	; 2
    28f6:	93 2e       	mov	r9, r19
    28f8:	89 2d       	mov	r24, r9
    28fa:	84 60       	ori	r24, 0x04	; 4
    28fc:	98 2e       	mov	r9, r24
    28fe:	2a c0       	rjmp	.+84     	; 0x2954 <vfprintf+0xec>
    2900:	e9 2d       	mov	r30, r9
    2902:	e8 60       	ori	r30, 0x08	; 8
    2904:	15 c0       	rjmp	.+42     	; 0x2930 <vfprintf+0xc8>
    2906:	97 fc       	sbrc	r9, 7
    2908:	2d c0       	rjmp	.+90     	; 0x2964 <vfprintf+0xfc>
    290a:	20 ed       	ldi	r18, 0xD0	; 208
    290c:	28 0f       	add	r18, r24
    290e:	2a 30       	cpi	r18, 0x0A	; 10
    2910:	88 f4       	brcc	.+34     	; 0x2934 <vfprintf+0xcc>
    2912:	96 fe       	sbrs	r9, 6
    2914:	06 c0       	rjmp	.+12     	; 0x2922 <vfprintf+0xba>
    2916:	3a e0       	ldi	r19, 0x0A	; 10
    2918:	13 9f       	mul	r17, r19
    291a:	20 0d       	add	r18, r0
    291c:	11 24       	eor	r1, r1
    291e:	12 2f       	mov	r17, r18
    2920:	19 c0       	rjmp	.+50     	; 0x2954 <vfprintf+0xec>
    2922:	8a e0       	ldi	r24, 0x0A	; 10
    2924:	58 9e       	mul	r5, r24
    2926:	20 0d       	add	r18, r0
    2928:	11 24       	eor	r1, r1
    292a:	52 2e       	mov	r5, r18
    292c:	e9 2d       	mov	r30, r9
    292e:	e0 62       	ori	r30, 0x20	; 32
    2930:	9e 2e       	mov	r9, r30
    2932:	10 c0       	rjmp	.+32     	; 0x2954 <vfprintf+0xec>
    2934:	8e 32       	cpi	r24, 0x2E	; 46
    2936:	31 f4       	brne	.+12     	; 0x2944 <vfprintf+0xdc>
    2938:	96 fc       	sbrc	r9, 6
    293a:	e5 c2       	rjmp	.+1482   	; 0x2f06 <vfprintf+0x69e>
    293c:	f9 2d       	mov	r31, r9
    293e:	f0 64       	ori	r31, 0x40	; 64
    2940:	9f 2e       	mov	r9, r31
    2942:	08 c0       	rjmp	.+16     	; 0x2954 <vfprintf+0xec>
    2944:	8c 36       	cpi	r24, 0x6C	; 108
    2946:	21 f4       	brne	.+8      	; 0x2950 <vfprintf+0xe8>
    2948:	29 2d       	mov	r18, r9
    294a:	20 68       	ori	r18, 0x80	; 128
    294c:	92 2e       	mov	r9, r18
    294e:	02 c0       	rjmp	.+4      	; 0x2954 <vfprintf+0xec>
    2950:	88 36       	cpi	r24, 0x68	; 104
    2952:	41 f4       	brne	.+16     	; 0x2964 <vfprintf+0xfc>
    2954:	f1 01       	movw	r30, r2
    2956:	93 fd       	sbrc	r25, 3
    2958:	85 91       	lpm	r24, Z+
    295a:	93 ff       	sbrs	r25, 3
    295c:	81 91       	ld	r24, Z+
    295e:	1f 01       	movw	r2, r30
    2960:	81 11       	cpse	r24, r1
    2962:	b3 cf       	rjmp	.-154    	; 0x28ca <vfprintf+0x62>
    2964:	9b eb       	ldi	r25, 0xBB	; 187
    2966:	98 0f       	add	r25, r24
    2968:	93 30       	cpi	r25, 0x03	; 3
    296a:	20 f4       	brcc	.+8      	; 0x2974 <vfprintf+0x10c>
    296c:	99 2d       	mov	r25, r9
    296e:	90 61       	ori	r25, 0x10	; 16
    2970:	80 5e       	subi	r24, 0xE0	; 224
    2972:	07 c0       	rjmp	.+14     	; 0x2982 <vfprintf+0x11a>
    2974:	9b e9       	ldi	r25, 0x9B	; 155
    2976:	98 0f       	add	r25, r24
    2978:	93 30       	cpi	r25, 0x03	; 3
    297a:	08 f0       	brcs	.+2      	; 0x297e <vfprintf+0x116>
    297c:	66 c1       	rjmp	.+716    	; 0x2c4a <vfprintf+0x3e2>
    297e:	99 2d       	mov	r25, r9
    2980:	9f 7e       	andi	r25, 0xEF	; 239
    2982:	96 ff       	sbrs	r25, 6
    2984:	16 e0       	ldi	r17, 0x06	; 6
    2986:	9f 73       	andi	r25, 0x3F	; 63
    2988:	99 2e       	mov	r9, r25
    298a:	85 36       	cpi	r24, 0x65	; 101
    298c:	19 f4       	brne	.+6      	; 0x2994 <vfprintf+0x12c>
    298e:	90 64       	ori	r25, 0x40	; 64
    2990:	99 2e       	mov	r9, r25
    2992:	08 c0       	rjmp	.+16     	; 0x29a4 <vfprintf+0x13c>
    2994:	86 36       	cpi	r24, 0x66	; 102
    2996:	21 f4       	brne	.+8      	; 0x29a0 <vfprintf+0x138>
    2998:	39 2f       	mov	r19, r25
    299a:	30 68       	ori	r19, 0x80	; 128
    299c:	93 2e       	mov	r9, r19
    299e:	02 c0       	rjmp	.+4      	; 0x29a4 <vfprintf+0x13c>
    29a0:	11 11       	cpse	r17, r1
    29a2:	11 50       	subi	r17, 0x01	; 1
    29a4:	97 fe       	sbrs	r9, 7
    29a6:	07 c0       	rjmp	.+14     	; 0x29b6 <vfprintf+0x14e>
    29a8:	1c 33       	cpi	r17, 0x3C	; 60
    29aa:	50 f4       	brcc	.+20     	; 0x29c0 <vfprintf+0x158>
    29ac:	44 24       	eor	r4, r4
    29ae:	43 94       	inc	r4
    29b0:	41 0e       	add	r4, r17
    29b2:	27 e0       	ldi	r18, 0x07	; 7
    29b4:	0b c0       	rjmp	.+22     	; 0x29cc <vfprintf+0x164>
    29b6:	18 30       	cpi	r17, 0x08	; 8
    29b8:	38 f0       	brcs	.+14     	; 0x29c8 <vfprintf+0x160>
    29ba:	27 e0       	ldi	r18, 0x07	; 7
    29bc:	17 e0       	ldi	r17, 0x07	; 7
    29be:	05 c0       	rjmp	.+10     	; 0x29ca <vfprintf+0x162>
    29c0:	27 e0       	ldi	r18, 0x07	; 7
    29c2:	9c e3       	ldi	r25, 0x3C	; 60
    29c4:	49 2e       	mov	r4, r25
    29c6:	02 c0       	rjmp	.+4      	; 0x29cc <vfprintf+0x164>
    29c8:	21 2f       	mov	r18, r17
    29ca:	41 2c       	mov	r4, r1
    29cc:	56 01       	movw	r10, r12
    29ce:	84 e0       	ldi	r24, 0x04	; 4
    29d0:	a8 0e       	add	r10, r24
    29d2:	b1 1c       	adc	r11, r1
    29d4:	f6 01       	movw	r30, r12
    29d6:	60 81       	ld	r22, Z
    29d8:	71 81       	ldd	r23, Z+1	; 0x01
    29da:	82 81       	ldd	r24, Z+2	; 0x02
    29dc:	93 81       	ldd	r25, Z+3	; 0x03
    29de:	04 2d       	mov	r16, r4
    29e0:	a3 01       	movw	r20, r6
    29e2:	0e 94 a9 1a 	call	0x3552	; 0x3552 <__ftoa_engine>
    29e6:	6c 01       	movw	r12, r24
    29e8:	f9 81       	ldd	r31, Y+1	; 0x01
    29ea:	fc 87       	std	Y+12, r31	; 0x0c
    29ec:	f0 ff       	sbrs	r31, 0
    29ee:	02 c0       	rjmp	.+4      	; 0x29f4 <vfprintf+0x18c>
    29f0:	f3 ff       	sbrs	r31, 3
    29f2:	06 c0       	rjmp	.+12     	; 0x2a00 <vfprintf+0x198>
    29f4:	91 fc       	sbrc	r9, 1
    29f6:	06 c0       	rjmp	.+12     	; 0x2a04 <vfprintf+0x19c>
    29f8:	92 fe       	sbrs	r9, 2
    29fa:	06 c0       	rjmp	.+12     	; 0x2a08 <vfprintf+0x1a0>
    29fc:	00 e2       	ldi	r16, 0x20	; 32
    29fe:	05 c0       	rjmp	.+10     	; 0x2a0a <vfprintf+0x1a2>
    2a00:	0d e2       	ldi	r16, 0x2D	; 45
    2a02:	03 c0       	rjmp	.+6      	; 0x2a0a <vfprintf+0x1a2>
    2a04:	0b e2       	ldi	r16, 0x2B	; 43
    2a06:	01 c0       	rjmp	.+2      	; 0x2a0a <vfprintf+0x1a2>
    2a08:	00 e0       	ldi	r16, 0x00	; 0
    2a0a:	8c 85       	ldd	r24, Y+12	; 0x0c
    2a0c:	8c 70       	andi	r24, 0x0C	; 12
    2a0e:	19 f0       	breq	.+6      	; 0x2a16 <vfprintf+0x1ae>
    2a10:	01 11       	cpse	r16, r1
    2a12:	5a c2       	rjmp	.+1204   	; 0x2ec8 <vfprintf+0x660>
    2a14:	9b c2       	rjmp	.+1334   	; 0x2f4c <vfprintf+0x6e4>
    2a16:	97 fe       	sbrs	r9, 7
    2a18:	10 c0       	rjmp	.+32     	; 0x2a3a <vfprintf+0x1d2>
    2a1a:	4c 0c       	add	r4, r12
    2a1c:	fc 85       	ldd	r31, Y+12	; 0x0c
    2a1e:	f4 ff       	sbrs	r31, 4
    2a20:	04 c0       	rjmp	.+8      	; 0x2a2a <vfprintf+0x1c2>
    2a22:	8a 81       	ldd	r24, Y+2	; 0x02
    2a24:	81 33       	cpi	r24, 0x31	; 49
    2a26:	09 f4       	brne	.+2      	; 0x2a2a <vfprintf+0x1c2>
    2a28:	4a 94       	dec	r4
    2a2a:	14 14       	cp	r1, r4
    2a2c:	74 f5       	brge	.+92     	; 0x2a8a <vfprintf+0x222>
    2a2e:	28 e0       	ldi	r18, 0x08	; 8
    2a30:	24 15       	cp	r18, r4
    2a32:	78 f5       	brcc	.+94     	; 0x2a92 <vfprintf+0x22a>
    2a34:	88 e0       	ldi	r24, 0x08	; 8
    2a36:	48 2e       	mov	r4, r24
    2a38:	2c c0       	rjmp	.+88     	; 0x2a92 <vfprintf+0x22a>
    2a3a:	96 fc       	sbrc	r9, 6
    2a3c:	2a c0       	rjmp	.+84     	; 0x2a92 <vfprintf+0x22a>
    2a3e:	81 2f       	mov	r24, r17
    2a40:	90 e0       	ldi	r25, 0x00	; 0
    2a42:	8c 15       	cp	r24, r12
    2a44:	9d 05       	cpc	r25, r13
    2a46:	9c f0       	brlt	.+38     	; 0x2a6e <vfprintf+0x206>
    2a48:	3c ef       	ldi	r19, 0xFC	; 252
    2a4a:	c3 16       	cp	r12, r19
    2a4c:	3f ef       	ldi	r19, 0xFF	; 255
    2a4e:	d3 06       	cpc	r13, r19
    2a50:	74 f0       	brlt	.+28     	; 0x2a6e <vfprintf+0x206>
    2a52:	89 2d       	mov	r24, r9
    2a54:	80 68       	ori	r24, 0x80	; 128
    2a56:	98 2e       	mov	r9, r24
    2a58:	0a c0       	rjmp	.+20     	; 0x2a6e <vfprintf+0x206>
    2a5a:	e2 e0       	ldi	r30, 0x02	; 2
    2a5c:	f0 e0       	ldi	r31, 0x00	; 0
    2a5e:	ec 0f       	add	r30, r28
    2a60:	fd 1f       	adc	r31, r29
    2a62:	e1 0f       	add	r30, r17
    2a64:	f1 1d       	adc	r31, r1
    2a66:	80 81       	ld	r24, Z
    2a68:	80 33       	cpi	r24, 0x30	; 48
    2a6a:	19 f4       	brne	.+6      	; 0x2a72 <vfprintf+0x20a>
    2a6c:	11 50       	subi	r17, 0x01	; 1
    2a6e:	11 11       	cpse	r17, r1
    2a70:	f4 cf       	rjmp	.-24     	; 0x2a5a <vfprintf+0x1f2>
    2a72:	97 fe       	sbrs	r9, 7
    2a74:	0e c0       	rjmp	.+28     	; 0x2a92 <vfprintf+0x22a>
    2a76:	44 24       	eor	r4, r4
    2a78:	43 94       	inc	r4
    2a7a:	41 0e       	add	r4, r17
    2a7c:	81 2f       	mov	r24, r17
    2a7e:	90 e0       	ldi	r25, 0x00	; 0
    2a80:	c8 16       	cp	r12, r24
    2a82:	d9 06       	cpc	r13, r25
    2a84:	2c f4       	brge	.+10     	; 0x2a90 <vfprintf+0x228>
    2a86:	1c 19       	sub	r17, r12
    2a88:	04 c0       	rjmp	.+8      	; 0x2a92 <vfprintf+0x22a>
    2a8a:	44 24       	eor	r4, r4
    2a8c:	43 94       	inc	r4
    2a8e:	01 c0       	rjmp	.+2      	; 0x2a92 <vfprintf+0x22a>
    2a90:	10 e0       	ldi	r17, 0x00	; 0
    2a92:	97 fe       	sbrs	r9, 7
    2a94:	06 c0       	rjmp	.+12     	; 0x2aa2 <vfprintf+0x23a>
    2a96:	1c 14       	cp	r1, r12
    2a98:	1d 04       	cpc	r1, r13
    2a9a:	34 f4       	brge	.+12     	; 0x2aa8 <vfprintf+0x240>
    2a9c:	c6 01       	movw	r24, r12
    2a9e:	01 96       	adiw	r24, 0x01	; 1
    2aa0:	05 c0       	rjmp	.+10     	; 0x2aac <vfprintf+0x244>
    2aa2:	85 e0       	ldi	r24, 0x05	; 5
    2aa4:	90 e0       	ldi	r25, 0x00	; 0
    2aa6:	02 c0       	rjmp	.+4      	; 0x2aac <vfprintf+0x244>
    2aa8:	81 e0       	ldi	r24, 0x01	; 1
    2aaa:	90 e0       	ldi	r25, 0x00	; 0
    2aac:	01 11       	cpse	r16, r1
    2aae:	01 96       	adiw	r24, 0x01	; 1
    2ab0:	11 23       	and	r17, r17
    2ab2:	31 f0       	breq	.+12     	; 0x2ac0 <vfprintf+0x258>
    2ab4:	21 2f       	mov	r18, r17
    2ab6:	30 e0       	ldi	r19, 0x00	; 0
    2ab8:	2f 5f       	subi	r18, 0xFF	; 255
    2aba:	3f 4f       	sbci	r19, 0xFF	; 255
    2abc:	82 0f       	add	r24, r18
    2abe:	93 1f       	adc	r25, r19
    2ac0:	25 2d       	mov	r18, r5
    2ac2:	30 e0       	ldi	r19, 0x00	; 0
    2ac4:	82 17       	cp	r24, r18
    2ac6:	93 07       	cpc	r25, r19
    2ac8:	14 f4       	brge	.+4      	; 0x2ace <vfprintf+0x266>
    2aca:	58 1a       	sub	r5, r24
    2acc:	01 c0       	rjmp	.+2      	; 0x2ad0 <vfprintf+0x268>
    2ace:	51 2c       	mov	r5, r1
    2ad0:	89 2d       	mov	r24, r9
    2ad2:	89 70       	andi	r24, 0x09	; 9
    2ad4:	49 f4       	brne	.+18     	; 0x2ae8 <vfprintf+0x280>
    2ad6:	55 20       	and	r5, r5
    2ad8:	39 f0       	breq	.+14     	; 0x2ae8 <vfprintf+0x280>
    2ada:	b7 01       	movw	r22, r14
    2adc:	80 e2       	ldi	r24, 0x20	; 32
    2ade:	90 e0       	ldi	r25, 0x00	; 0
    2ae0:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2ae4:	5a 94       	dec	r5
    2ae6:	f7 cf       	rjmp	.-18     	; 0x2ad6 <vfprintf+0x26e>
    2ae8:	00 23       	and	r16, r16
    2aea:	29 f0       	breq	.+10     	; 0x2af6 <vfprintf+0x28e>
    2aec:	b7 01       	movw	r22, r14
    2aee:	80 2f       	mov	r24, r16
    2af0:	90 e0       	ldi	r25, 0x00	; 0
    2af2:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2af6:	93 fc       	sbrc	r9, 3
    2af8:	09 c0       	rjmp	.+18     	; 0x2b0c <vfprintf+0x2a4>
    2afa:	55 20       	and	r5, r5
    2afc:	39 f0       	breq	.+14     	; 0x2b0c <vfprintf+0x2a4>
    2afe:	b7 01       	movw	r22, r14
    2b00:	80 e3       	ldi	r24, 0x30	; 48
    2b02:	90 e0       	ldi	r25, 0x00	; 0
    2b04:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2b08:	5a 94       	dec	r5
    2b0a:	f7 cf       	rjmp	.-18     	; 0x2afa <vfprintf+0x292>
    2b0c:	97 fe       	sbrs	r9, 7
    2b0e:	4c c0       	rjmp	.+152    	; 0x2ba8 <vfprintf+0x340>
    2b10:	46 01       	movw	r8, r12
    2b12:	d7 fe       	sbrs	r13, 7
    2b14:	02 c0       	rjmp	.+4      	; 0x2b1a <vfprintf+0x2b2>
    2b16:	81 2c       	mov	r8, r1
    2b18:	91 2c       	mov	r9, r1
    2b1a:	c6 01       	movw	r24, r12
    2b1c:	88 19       	sub	r24, r8
    2b1e:	99 09       	sbc	r25, r9
    2b20:	f3 01       	movw	r30, r6
    2b22:	e8 0f       	add	r30, r24
    2b24:	f9 1f       	adc	r31, r25
    2b26:	fe 87       	std	Y+14, r31	; 0x0e
    2b28:	ed 87       	std	Y+13, r30	; 0x0d
    2b2a:	96 01       	movw	r18, r12
    2b2c:	24 19       	sub	r18, r4
    2b2e:	31 09       	sbc	r19, r1
    2b30:	38 8b       	std	Y+16, r19	; 0x10
    2b32:	2f 87       	std	Y+15, r18	; 0x0f
    2b34:	01 2f       	mov	r16, r17
    2b36:	10 e0       	ldi	r17, 0x00	; 0
    2b38:	11 95       	neg	r17
    2b3a:	01 95       	neg	r16
    2b3c:	11 09       	sbc	r17, r1
    2b3e:	3f ef       	ldi	r19, 0xFF	; 255
    2b40:	83 16       	cp	r8, r19
    2b42:	93 06       	cpc	r9, r19
    2b44:	29 f4       	brne	.+10     	; 0x2b50 <vfprintf+0x2e8>
    2b46:	b7 01       	movw	r22, r14
    2b48:	8e e2       	ldi	r24, 0x2E	; 46
    2b4a:	90 e0       	ldi	r25, 0x00	; 0
    2b4c:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2b50:	c8 14       	cp	r12, r8
    2b52:	d9 04       	cpc	r13, r9
    2b54:	4c f0       	brlt	.+18     	; 0x2b68 <vfprintf+0x300>
    2b56:	8f 85       	ldd	r24, Y+15	; 0x0f
    2b58:	98 89       	ldd	r25, Y+16	; 0x10
    2b5a:	88 15       	cp	r24, r8
    2b5c:	99 05       	cpc	r25, r9
    2b5e:	24 f4       	brge	.+8      	; 0x2b68 <vfprintf+0x300>
    2b60:	ed 85       	ldd	r30, Y+13	; 0x0d
    2b62:	fe 85       	ldd	r31, Y+14	; 0x0e
    2b64:	81 81       	ldd	r24, Z+1	; 0x01
    2b66:	01 c0       	rjmp	.+2      	; 0x2b6a <vfprintf+0x302>
    2b68:	80 e3       	ldi	r24, 0x30	; 48
    2b6a:	f1 e0       	ldi	r31, 0x01	; 1
    2b6c:	8f 1a       	sub	r8, r31
    2b6e:	91 08       	sbc	r9, r1
    2b70:	2d 85       	ldd	r18, Y+13	; 0x0d
    2b72:	3e 85       	ldd	r19, Y+14	; 0x0e
    2b74:	2f 5f       	subi	r18, 0xFF	; 255
    2b76:	3f 4f       	sbci	r19, 0xFF	; 255
    2b78:	3e 87       	std	Y+14, r19	; 0x0e
    2b7a:	2d 87       	std	Y+13, r18	; 0x0d
    2b7c:	80 16       	cp	r8, r16
    2b7e:	91 06       	cpc	r9, r17
    2b80:	2c f0       	brlt	.+10     	; 0x2b8c <vfprintf+0x324>
    2b82:	b7 01       	movw	r22, r14
    2b84:	90 e0       	ldi	r25, 0x00	; 0
    2b86:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2b8a:	d9 cf       	rjmp	.-78     	; 0x2b3e <vfprintf+0x2d6>
    2b8c:	c8 14       	cp	r12, r8
    2b8e:	d9 04       	cpc	r13, r9
    2b90:	41 f4       	brne	.+16     	; 0x2ba2 <vfprintf+0x33a>
    2b92:	9a 81       	ldd	r25, Y+2	; 0x02
    2b94:	96 33       	cpi	r25, 0x36	; 54
    2b96:	20 f4       	brcc	.+8      	; 0x2ba0 <vfprintf+0x338>
    2b98:	95 33       	cpi	r25, 0x35	; 53
    2b9a:	19 f4       	brne	.+6      	; 0x2ba2 <vfprintf+0x33a>
    2b9c:	3c 85       	ldd	r19, Y+12	; 0x0c
    2b9e:	34 ff       	sbrs	r19, 4
    2ba0:	81 e3       	ldi	r24, 0x31	; 49
    2ba2:	b7 01       	movw	r22, r14
    2ba4:	90 e0       	ldi	r25, 0x00	; 0
    2ba6:	4e c0       	rjmp	.+156    	; 0x2c44 <vfprintf+0x3dc>
    2ba8:	8a 81       	ldd	r24, Y+2	; 0x02
    2baa:	81 33       	cpi	r24, 0x31	; 49
    2bac:	19 f0       	breq	.+6      	; 0x2bb4 <vfprintf+0x34c>
    2bae:	9c 85       	ldd	r25, Y+12	; 0x0c
    2bb0:	9f 7e       	andi	r25, 0xEF	; 239
    2bb2:	9c 87       	std	Y+12, r25	; 0x0c
    2bb4:	b7 01       	movw	r22, r14
    2bb6:	90 e0       	ldi	r25, 0x00	; 0
    2bb8:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2bbc:	11 11       	cpse	r17, r1
    2bbe:	05 c0       	rjmp	.+10     	; 0x2bca <vfprintf+0x362>
    2bc0:	94 fc       	sbrc	r9, 4
    2bc2:	18 c0       	rjmp	.+48     	; 0x2bf4 <vfprintf+0x38c>
    2bc4:	85 e6       	ldi	r24, 0x65	; 101
    2bc6:	90 e0       	ldi	r25, 0x00	; 0
    2bc8:	17 c0       	rjmp	.+46     	; 0x2bf8 <vfprintf+0x390>
    2bca:	b7 01       	movw	r22, r14
    2bcc:	8e e2       	ldi	r24, 0x2E	; 46
    2bce:	90 e0       	ldi	r25, 0x00	; 0
    2bd0:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2bd4:	1e 5f       	subi	r17, 0xFE	; 254
    2bd6:	82 e0       	ldi	r24, 0x02	; 2
    2bd8:	01 e0       	ldi	r16, 0x01	; 1
    2bda:	08 0f       	add	r16, r24
    2bdc:	f3 01       	movw	r30, r6
    2bde:	e8 0f       	add	r30, r24
    2be0:	f1 1d       	adc	r31, r1
    2be2:	80 81       	ld	r24, Z
    2be4:	b7 01       	movw	r22, r14
    2be6:	90 e0       	ldi	r25, 0x00	; 0
    2be8:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2bec:	80 2f       	mov	r24, r16
    2bee:	01 13       	cpse	r16, r17
    2bf0:	f3 cf       	rjmp	.-26     	; 0x2bd8 <vfprintf+0x370>
    2bf2:	e6 cf       	rjmp	.-52     	; 0x2bc0 <vfprintf+0x358>
    2bf4:	85 e4       	ldi	r24, 0x45	; 69
    2bf6:	90 e0       	ldi	r25, 0x00	; 0
    2bf8:	b7 01       	movw	r22, r14
    2bfa:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2bfe:	d7 fc       	sbrc	r13, 7
    2c00:	06 c0       	rjmp	.+12     	; 0x2c0e <vfprintf+0x3a6>
    2c02:	c1 14       	cp	r12, r1
    2c04:	d1 04       	cpc	r13, r1
    2c06:	41 f4       	brne	.+16     	; 0x2c18 <vfprintf+0x3b0>
    2c08:	ec 85       	ldd	r30, Y+12	; 0x0c
    2c0a:	e4 ff       	sbrs	r30, 4
    2c0c:	05 c0       	rjmp	.+10     	; 0x2c18 <vfprintf+0x3b0>
    2c0e:	d1 94       	neg	r13
    2c10:	c1 94       	neg	r12
    2c12:	d1 08       	sbc	r13, r1
    2c14:	8d e2       	ldi	r24, 0x2D	; 45
    2c16:	01 c0       	rjmp	.+2      	; 0x2c1a <vfprintf+0x3b2>
    2c18:	8b e2       	ldi	r24, 0x2B	; 43
    2c1a:	b7 01       	movw	r22, r14
    2c1c:	90 e0       	ldi	r25, 0x00	; 0
    2c1e:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2c22:	80 e3       	ldi	r24, 0x30	; 48
    2c24:	2a e0       	ldi	r18, 0x0A	; 10
    2c26:	c2 16       	cp	r12, r18
    2c28:	d1 04       	cpc	r13, r1
    2c2a:	2c f0       	brlt	.+10     	; 0x2c36 <vfprintf+0x3ce>
    2c2c:	8f 5f       	subi	r24, 0xFF	; 255
    2c2e:	fa e0       	ldi	r31, 0x0A	; 10
    2c30:	cf 1a       	sub	r12, r31
    2c32:	d1 08       	sbc	r13, r1
    2c34:	f7 cf       	rjmp	.-18     	; 0x2c24 <vfprintf+0x3bc>
    2c36:	b7 01       	movw	r22, r14
    2c38:	90 e0       	ldi	r25, 0x00	; 0
    2c3a:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2c3e:	b7 01       	movw	r22, r14
    2c40:	c6 01       	movw	r24, r12
    2c42:	c0 96       	adiw	r24, 0x30	; 48
    2c44:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2c48:	54 c1       	rjmp	.+680    	; 0x2ef2 <vfprintf+0x68a>
    2c4a:	83 36       	cpi	r24, 0x63	; 99
    2c4c:	31 f0       	breq	.+12     	; 0x2c5a <vfprintf+0x3f2>
    2c4e:	83 37       	cpi	r24, 0x73	; 115
    2c50:	79 f0       	breq	.+30     	; 0x2c70 <vfprintf+0x408>
    2c52:	83 35       	cpi	r24, 0x53	; 83
    2c54:	09 f0       	breq	.+2      	; 0x2c58 <vfprintf+0x3f0>
    2c56:	56 c0       	rjmp	.+172    	; 0x2d04 <vfprintf+0x49c>
    2c58:	20 c0       	rjmp	.+64     	; 0x2c9a <vfprintf+0x432>
    2c5a:	56 01       	movw	r10, r12
    2c5c:	32 e0       	ldi	r19, 0x02	; 2
    2c5e:	a3 0e       	add	r10, r19
    2c60:	b1 1c       	adc	r11, r1
    2c62:	f6 01       	movw	r30, r12
    2c64:	80 81       	ld	r24, Z
    2c66:	89 83       	std	Y+1, r24	; 0x01
    2c68:	01 e0       	ldi	r16, 0x01	; 1
    2c6a:	10 e0       	ldi	r17, 0x00	; 0
    2c6c:	63 01       	movw	r12, r6
    2c6e:	12 c0       	rjmp	.+36     	; 0x2c94 <vfprintf+0x42c>
    2c70:	56 01       	movw	r10, r12
    2c72:	f2 e0       	ldi	r31, 0x02	; 2
    2c74:	af 0e       	add	r10, r31
    2c76:	b1 1c       	adc	r11, r1
    2c78:	f6 01       	movw	r30, r12
    2c7a:	c0 80       	ld	r12, Z
    2c7c:	d1 80       	ldd	r13, Z+1	; 0x01
    2c7e:	96 fe       	sbrs	r9, 6
    2c80:	03 c0       	rjmp	.+6      	; 0x2c88 <vfprintf+0x420>
    2c82:	61 2f       	mov	r22, r17
    2c84:	70 e0       	ldi	r23, 0x00	; 0
    2c86:	02 c0       	rjmp	.+4      	; 0x2c8c <vfprintf+0x424>
    2c88:	6f ef       	ldi	r22, 0xFF	; 255
    2c8a:	7f ef       	ldi	r23, 0xFF	; 255
    2c8c:	c6 01       	movw	r24, r12
    2c8e:	0e 94 a8 1b 	call	0x3750	; 0x3750 <strnlen>
    2c92:	8c 01       	movw	r16, r24
    2c94:	f9 2d       	mov	r31, r9
    2c96:	ff 77       	andi	r31, 0x7F	; 127
    2c98:	14 c0       	rjmp	.+40     	; 0x2cc2 <vfprintf+0x45a>
    2c9a:	56 01       	movw	r10, r12
    2c9c:	22 e0       	ldi	r18, 0x02	; 2
    2c9e:	a2 0e       	add	r10, r18
    2ca0:	b1 1c       	adc	r11, r1
    2ca2:	f6 01       	movw	r30, r12
    2ca4:	c0 80       	ld	r12, Z
    2ca6:	d1 80       	ldd	r13, Z+1	; 0x01
    2ca8:	96 fe       	sbrs	r9, 6
    2caa:	03 c0       	rjmp	.+6      	; 0x2cb2 <vfprintf+0x44a>
    2cac:	61 2f       	mov	r22, r17
    2cae:	70 e0       	ldi	r23, 0x00	; 0
    2cb0:	02 c0       	rjmp	.+4      	; 0x2cb6 <vfprintf+0x44e>
    2cb2:	6f ef       	ldi	r22, 0xFF	; 255
    2cb4:	7f ef       	ldi	r23, 0xFF	; 255
    2cb6:	c6 01       	movw	r24, r12
    2cb8:	0e 94 81 1b 	call	0x3702	; 0x3702 <strnlen_P>
    2cbc:	8c 01       	movw	r16, r24
    2cbe:	f9 2d       	mov	r31, r9
    2cc0:	f0 68       	ori	r31, 0x80	; 128
    2cc2:	9f 2e       	mov	r9, r31
    2cc4:	f3 fd       	sbrc	r31, 3
    2cc6:	1a c0       	rjmp	.+52     	; 0x2cfc <vfprintf+0x494>
    2cc8:	85 2d       	mov	r24, r5
    2cca:	90 e0       	ldi	r25, 0x00	; 0
    2ccc:	08 17       	cp	r16, r24
    2cce:	19 07       	cpc	r17, r25
    2cd0:	a8 f4       	brcc	.+42     	; 0x2cfc <vfprintf+0x494>
    2cd2:	b7 01       	movw	r22, r14
    2cd4:	80 e2       	ldi	r24, 0x20	; 32
    2cd6:	90 e0       	ldi	r25, 0x00	; 0
    2cd8:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2cdc:	5a 94       	dec	r5
    2cde:	f4 cf       	rjmp	.-24     	; 0x2cc8 <vfprintf+0x460>
    2ce0:	f6 01       	movw	r30, r12
    2ce2:	97 fc       	sbrc	r9, 7
    2ce4:	85 91       	lpm	r24, Z+
    2ce6:	97 fe       	sbrs	r9, 7
    2ce8:	81 91       	ld	r24, Z+
    2cea:	6f 01       	movw	r12, r30
    2cec:	b7 01       	movw	r22, r14
    2cee:	90 e0       	ldi	r25, 0x00	; 0
    2cf0:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2cf4:	51 10       	cpse	r5, r1
    2cf6:	5a 94       	dec	r5
    2cf8:	01 50       	subi	r16, 0x01	; 1
    2cfa:	11 09       	sbc	r17, r1
    2cfc:	01 15       	cp	r16, r1
    2cfe:	11 05       	cpc	r17, r1
    2d00:	79 f7       	brne	.-34     	; 0x2ce0 <vfprintf+0x478>
    2d02:	f7 c0       	rjmp	.+494    	; 0x2ef2 <vfprintf+0x68a>
    2d04:	84 36       	cpi	r24, 0x64	; 100
    2d06:	11 f0       	breq	.+4      	; 0x2d0c <vfprintf+0x4a4>
    2d08:	89 36       	cpi	r24, 0x69	; 105
    2d0a:	61 f5       	brne	.+88     	; 0x2d64 <vfprintf+0x4fc>
    2d0c:	56 01       	movw	r10, r12
    2d0e:	97 fe       	sbrs	r9, 7
    2d10:	09 c0       	rjmp	.+18     	; 0x2d24 <vfprintf+0x4bc>
    2d12:	24 e0       	ldi	r18, 0x04	; 4
    2d14:	a2 0e       	add	r10, r18
    2d16:	b1 1c       	adc	r11, r1
    2d18:	f6 01       	movw	r30, r12
    2d1a:	60 81       	ld	r22, Z
    2d1c:	71 81       	ldd	r23, Z+1	; 0x01
    2d1e:	82 81       	ldd	r24, Z+2	; 0x02
    2d20:	93 81       	ldd	r25, Z+3	; 0x03
    2d22:	0a c0       	rjmp	.+20     	; 0x2d38 <vfprintf+0x4d0>
    2d24:	f2 e0       	ldi	r31, 0x02	; 2
    2d26:	af 0e       	add	r10, r31
    2d28:	b1 1c       	adc	r11, r1
    2d2a:	f6 01       	movw	r30, r12
    2d2c:	60 81       	ld	r22, Z
    2d2e:	71 81       	ldd	r23, Z+1	; 0x01
    2d30:	07 2e       	mov	r0, r23
    2d32:	00 0c       	add	r0, r0
    2d34:	88 0b       	sbc	r24, r24
    2d36:	99 0b       	sbc	r25, r25
    2d38:	f9 2d       	mov	r31, r9
    2d3a:	ff 76       	andi	r31, 0x6F	; 111
    2d3c:	9f 2e       	mov	r9, r31
    2d3e:	97 ff       	sbrs	r25, 7
    2d40:	09 c0       	rjmp	.+18     	; 0x2d54 <vfprintf+0x4ec>
    2d42:	90 95       	com	r25
    2d44:	80 95       	com	r24
    2d46:	70 95       	com	r23
    2d48:	61 95       	neg	r22
    2d4a:	7f 4f       	sbci	r23, 0xFF	; 255
    2d4c:	8f 4f       	sbci	r24, 0xFF	; 255
    2d4e:	9f 4f       	sbci	r25, 0xFF	; 255
    2d50:	f0 68       	ori	r31, 0x80	; 128
    2d52:	9f 2e       	mov	r9, r31
    2d54:	2a e0       	ldi	r18, 0x0A	; 10
    2d56:	30 e0       	ldi	r19, 0x00	; 0
    2d58:	a3 01       	movw	r20, r6
    2d5a:	0e 94 72 1c 	call	0x38e4	; 0x38e4 <__ultoa_invert>
    2d5e:	c8 2e       	mov	r12, r24
    2d60:	c6 18       	sub	r12, r6
    2d62:	3f c0       	rjmp	.+126    	; 0x2de2 <vfprintf+0x57a>
    2d64:	09 2d       	mov	r16, r9
    2d66:	85 37       	cpi	r24, 0x75	; 117
    2d68:	21 f4       	brne	.+8      	; 0x2d72 <vfprintf+0x50a>
    2d6a:	0f 7e       	andi	r16, 0xEF	; 239
    2d6c:	2a e0       	ldi	r18, 0x0A	; 10
    2d6e:	30 e0       	ldi	r19, 0x00	; 0
    2d70:	1d c0       	rjmp	.+58     	; 0x2dac <vfprintf+0x544>
    2d72:	09 7f       	andi	r16, 0xF9	; 249
    2d74:	8f 36       	cpi	r24, 0x6F	; 111
    2d76:	91 f0       	breq	.+36     	; 0x2d9c <vfprintf+0x534>
    2d78:	18 f4       	brcc	.+6      	; 0x2d80 <vfprintf+0x518>
    2d7a:	88 35       	cpi	r24, 0x58	; 88
    2d7c:	59 f0       	breq	.+22     	; 0x2d94 <vfprintf+0x52c>
    2d7e:	c3 c0       	rjmp	.+390    	; 0x2f06 <vfprintf+0x69e>
    2d80:	80 37       	cpi	r24, 0x70	; 112
    2d82:	19 f0       	breq	.+6      	; 0x2d8a <vfprintf+0x522>
    2d84:	88 37       	cpi	r24, 0x78	; 120
    2d86:	11 f0       	breq	.+4      	; 0x2d8c <vfprintf+0x524>
    2d88:	be c0       	rjmp	.+380    	; 0x2f06 <vfprintf+0x69e>
    2d8a:	00 61       	ori	r16, 0x10	; 16
    2d8c:	04 ff       	sbrs	r16, 4
    2d8e:	09 c0       	rjmp	.+18     	; 0x2da2 <vfprintf+0x53a>
    2d90:	04 60       	ori	r16, 0x04	; 4
    2d92:	07 c0       	rjmp	.+14     	; 0x2da2 <vfprintf+0x53a>
    2d94:	94 fe       	sbrs	r9, 4
    2d96:	08 c0       	rjmp	.+16     	; 0x2da8 <vfprintf+0x540>
    2d98:	06 60       	ori	r16, 0x06	; 6
    2d9a:	06 c0       	rjmp	.+12     	; 0x2da8 <vfprintf+0x540>
    2d9c:	28 e0       	ldi	r18, 0x08	; 8
    2d9e:	30 e0       	ldi	r19, 0x00	; 0
    2da0:	05 c0       	rjmp	.+10     	; 0x2dac <vfprintf+0x544>
    2da2:	20 e1       	ldi	r18, 0x10	; 16
    2da4:	30 e0       	ldi	r19, 0x00	; 0
    2da6:	02 c0       	rjmp	.+4      	; 0x2dac <vfprintf+0x544>
    2da8:	20 e1       	ldi	r18, 0x10	; 16
    2daa:	32 e0       	ldi	r19, 0x02	; 2
    2dac:	56 01       	movw	r10, r12
    2dae:	07 ff       	sbrs	r16, 7
    2db0:	09 c0       	rjmp	.+18     	; 0x2dc4 <vfprintf+0x55c>
    2db2:	84 e0       	ldi	r24, 0x04	; 4
    2db4:	a8 0e       	add	r10, r24
    2db6:	b1 1c       	adc	r11, r1
    2db8:	f6 01       	movw	r30, r12
    2dba:	60 81       	ld	r22, Z
    2dbc:	71 81       	ldd	r23, Z+1	; 0x01
    2dbe:	82 81       	ldd	r24, Z+2	; 0x02
    2dc0:	93 81       	ldd	r25, Z+3	; 0x03
    2dc2:	08 c0       	rjmp	.+16     	; 0x2dd4 <vfprintf+0x56c>
    2dc4:	f2 e0       	ldi	r31, 0x02	; 2
    2dc6:	af 0e       	add	r10, r31
    2dc8:	b1 1c       	adc	r11, r1
    2dca:	f6 01       	movw	r30, r12
    2dcc:	60 81       	ld	r22, Z
    2dce:	71 81       	ldd	r23, Z+1	; 0x01
    2dd0:	80 e0       	ldi	r24, 0x00	; 0
    2dd2:	90 e0       	ldi	r25, 0x00	; 0
    2dd4:	a3 01       	movw	r20, r6
    2dd6:	0e 94 72 1c 	call	0x38e4	; 0x38e4 <__ultoa_invert>
    2dda:	c8 2e       	mov	r12, r24
    2ddc:	c6 18       	sub	r12, r6
    2dde:	0f 77       	andi	r16, 0x7F	; 127
    2de0:	90 2e       	mov	r9, r16
    2de2:	96 fe       	sbrs	r9, 6
    2de4:	0b c0       	rjmp	.+22     	; 0x2dfc <vfprintf+0x594>
    2de6:	09 2d       	mov	r16, r9
    2de8:	0e 7f       	andi	r16, 0xFE	; 254
    2dea:	c1 16       	cp	r12, r17
    2dec:	50 f4       	brcc	.+20     	; 0x2e02 <vfprintf+0x59a>
    2dee:	94 fe       	sbrs	r9, 4
    2df0:	0a c0       	rjmp	.+20     	; 0x2e06 <vfprintf+0x59e>
    2df2:	92 fc       	sbrc	r9, 2
    2df4:	08 c0       	rjmp	.+16     	; 0x2e06 <vfprintf+0x59e>
    2df6:	09 2d       	mov	r16, r9
    2df8:	0e 7e       	andi	r16, 0xEE	; 238
    2dfa:	05 c0       	rjmp	.+10     	; 0x2e06 <vfprintf+0x59e>
    2dfc:	dc 2c       	mov	r13, r12
    2dfe:	09 2d       	mov	r16, r9
    2e00:	03 c0       	rjmp	.+6      	; 0x2e08 <vfprintf+0x5a0>
    2e02:	dc 2c       	mov	r13, r12
    2e04:	01 c0       	rjmp	.+2      	; 0x2e08 <vfprintf+0x5a0>
    2e06:	d1 2e       	mov	r13, r17
    2e08:	04 ff       	sbrs	r16, 4
    2e0a:	0d c0       	rjmp	.+26     	; 0x2e26 <vfprintf+0x5be>
    2e0c:	fe 01       	movw	r30, r28
    2e0e:	ec 0d       	add	r30, r12
    2e10:	f1 1d       	adc	r31, r1
    2e12:	80 81       	ld	r24, Z
    2e14:	80 33       	cpi	r24, 0x30	; 48
    2e16:	11 f4       	brne	.+4      	; 0x2e1c <vfprintf+0x5b4>
    2e18:	09 7e       	andi	r16, 0xE9	; 233
    2e1a:	09 c0       	rjmp	.+18     	; 0x2e2e <vfprintf+0x5c6>
    2e1c:	02 ff       	sbrs	r16, 2
    2e1e:	06 c0       	rjmp	.+12     	; 0x2e2c <vfprintf+0x5c4>
    2e20:	d3 94       	inc	r13
    2e22:	d3 94       	inc	r13
    2e24:	04 c0       	rjmp	.+8      	; 0x2e2e <vfprintf+0x5c6>
    2e26:	80 2f       	mov	r24, r16
    2e28:	86 78       	andi	r24, 0x86	; 134
    2e2a:	09 f0       	breq	.+2      	; 0x2e2e <vfprintf+0x5c6>
    2e2c:	d3 94       	inc	r13
    2e2e:	03 fd       	sbrc	r16, 3
    2e30:	11 c0       	rjmp	.+34     	; 0x2e54 <vfprintf+0x5ec>
    2e32:	00 ff       	sbrs	r16, 0
    2e34:	06 c0       	rjmp	.+12     	; 0x2e42 <vfprintf+0x5da>
    2e36:	1c 2d       	mov	r17, r12
    2e38:	d5 14       	cp	r13, r5
    2e3a:	80 f4       	brcc	.+32     	; 0x2e5c <vfprintf+0x5f4>
    2e3c:	15 0d       	add	r17, r5
    2e3e:	1d 19       	sub	r17, r13
    2e40:	0d c0       	rjmp	.+26     	; 0x2e5c <vfprintf+0x5f4>
    2e42:	d5 14       	cp	r13, r5
    2e44:	58 f4       	brcc	.+22     	; 0x2e5c <vfprintf+0x5f4>
    2e46:	b7 01       	movw	r22, r14
    2e48:	80 e2       	ldi	r24, 0x20	; 32
    2e4a:	90 e0       	ldi	r25, 0x00	; 0
    2e4c:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2e50:	d3 94       	inc	r13
    2e52:	f7 cf       	rjmp	.-18     	; 0x2e42 <vfprintf+0x5da>
    2e54:	d5 14       	cp	r13, r5
    2e56:	10 f4       	brcc	.+4      	; 0x2e5c <vfprintf+0x5f4>
    2e58:	5d 18       	sub	r5, r13
    2e5a:	01 c0       	rjmp	.+2      	; 0x2e5e <vfprintf+0x5f6>
    2e5c:	51 2c       	mov	r5, r1
    2e5e:	04 ff       	sbrs	r16, 4
    2e60:	10 c0       	rjmp	.+32     	; 0x2e82 <vfprintf+0x61a>
    2e62:	b7 01       	movw	r22, r14
    2e64:	80 e3       	ldi	r24, 0x30	; 48
    2e66:	90 e0       	ldi	r25, 0x00	; 0
    2e68:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2e6c:	02 ff       	sbrs	r16, 2
    2e6e:	17 c0       	rjmp	.+46     	; 0x2e9e <vfprintf+0x636>
    2e70:	01 fd       	sbrc	r16, 1
    2e72:	03 c0       	rjmp	.+6      	; 0x2e7a <vfprintf+0x612>
    2e74:	88 e7       	ldi	r24, 0x78	; 120
    2e76:	90 e0       	ldi	r25, 0x00	; 0
    2e78:	02 c0       	rjmp	.+4      	; 0x2e7e <vfprintf+0x616>
    2e7a:	88 e5       	ldi	r24, 0x58	; 88
    2e7c:	90 e0       	ldi	r25, 0x00	; 0
    2e7e:	b7 01       	movw	r22, r14
    2e80:	0c c0       	rjmp	.+24     	; 0x2e9a <vfprintf+0x632>
    2e82:	80 2f       	mov	r24, r16
    2e84:	86 78       	andi	r24, 0x86	; 134
    2e86:	59 f0       	breq	.+22     	; 0x2e9e <vfprintf+0x636>
    2e88:	01 ff       	sbrs	r16, 1
    2e8a:	02 c0       	rjmp	.+4      	; 0x2e90 <vfprintf+0x628>
    2e8c:	8b e2       	ldi	r24, 0x2B	; 43
    2e8e:	01 c0       	rjmp	.+2      	; 0x2e92 <vfprintf+0x62a>
    2e90:	80 e2       	ldi	r24, 0x20	; 32
    2e92:	07 fd       	sbrc	r16, 7
    2e94:	8d e2       	ldi	r24, 0x2D	; 45
    2e96:	b7 01       	movw	r22, r14
    2e98:	90 e0       	ldi	r25, 0x00	; 0
    2e9a:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2e9e:	c1 16       	cp	r12, r17
    2ea0:	38 f4       	brcc	.+14     	; 0x2eb0 <vfprintf+0x648>
    2ea2:	b7 01       	movw	r22, r14
    2ea4:	80 e3       	ldi	r24, 0x30	; 48
    2ea6:	90 e0       	ldi	r25, 0x00	; 0
    2ea8:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2eac:	11 50       	subi	r17, 0x01	; 1
    2eae:	f7 cf       	rjmp	.-18     	; 0x2e9e <vfprintf+0x636>
    2eb0:	ca 94       	dec	r12
    2eb2:	f3 01       	movw	r30, r6
    2eb4:	ec 0d       	add	r30, r12
    2eb6:	f1 1d       	adc	r31, r1
    2eb8:	80 81       	ld	r24, Z
    2eba:	b7 01       	movw	r22, r14
    2ebc:	90 e0       	ldi	r25, 0x00	; 0
    2ebe:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2ec2:	c1 10       	cpse	r12, r1
    2ec4:	f5 cf       	rjmp	.-22     	; 0x2eb0 <vfprintf+0x648>
    2ec6:	15 c0       	rjmp	.+42     	; 0x2ef2 <vfprintf+0x68a>
    2ec8:	f4 e0       	ldi	r31, 0x04	; 4
    2eca:	f5 15       	cp	r31, r5
    2ecc:	60 f5       	brcc	.+88     	; 0x2f26 <vfprintf+0x6be>
    2ece:	84 e0       	ldi	r24, 0x04	; 4
    2ed0:	58 1a       	sub	r5, r24
    2ed2:	93 fe       	sbrs	r9, 3
    2ed4:	1f c0       	rjmp	.+62     	; 0x2f14 <vfprintf+0x6ac>
    2ed6:	01 11       	cpse	r16, r1
    2ed8:	27 c0       	rjmp	.+78     	; 0x2f28 <vfprintf+0x6c0>
    2eda:	2c 85       	ldd	r18, Y+12	; 0x0c
    2edc:	23 ff       	sbrs	r18, 3
    2ede:	2a c0       	rjmp	.+84     	; 0x2f34 <vfprintf+0x6cc>
    2ee0:	08 e6       	ldi	r16, 0x68	; 104
    2ee2:	10 e0       	ldi	r17, 0x00	; 0
    2ee4:	39 2d       	mov	r19, r9
    2ee6:	30 71       	andi	r19, 0x10	; 16
    2ee8:	93 2e       	mov	r9, r19
    2eea:	f8 01       	movw	r30, r16
    2eec:	84 91       	lpm	r24, Z
    2eee:	81 11       	cpse	r24, r1
    2ef0:	24 c0       	rjmp	.+72     	; 0x2f3a <vfprintf+0x6d2>
    2ef2:	55 20       	and	r5, r5
    2ef4:	09 f4       	brne	.+2      	; 0x2ef8 <vfprintf+0x690>
    2ef6:	e4 cc       	rjmp	.-1592   	; 0x28c0 <vfprintf+0x58>
    2ef8:	b7 01       	movw	r22, r14
    2efa:	80 e2       	ldi	r24, 0x20	; 32
    2efc:	90 e0       	ldi	r25, 0x00	; 0
    2efe:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2f02:	5a 94       	dec	r5
    2f04:	f6 cf       	rjmp	.-20     	; 0x2ef2 <vfprintf+0x68a>
    2f06:	f7 01       	movw	r30, r14
    2f08:	86 81       	ldd	r24, Z+6	; 0x06
    2f0a:	97 81       	ldd	r25, Z+7	; 0x07
    2f0c:	26 c0       	rjmp	.+76     	; 0x2f5a <vfprintf+0x6f2>
    2f0e:	8f ef       	ldi	r24, 0xFF	; 255
    2f10:	9f ef       	ldi	r25, 0xFF	; 255
    2f12:	23 c0       	rjmp	.+70     	; 0x2f5a <vfprintf+0x6f2>
    2f14:	b7 01       	movw	r22, r14
    2f16:	80 e2       	ldi	r24, 0x20	; 32
    2f18:	90 e0       	ldi	r25, 0x00	; 0
    2f1a:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2f1e:	5a 94       	dec	r5
    2f20:	51 10       	cpse	r5, r1
    2f22:	f8 cf       	rjmp	.-16     	; 0x2f14 <vfprintf+0x6ac>
    2f24:	d8 cf       	rjmp	.-80     	; 0x2ed6 <vfprintf+0x66e>
    2f26:	51 2c       	mov	r5, r1
    2f28:	b7 01       	movw	r22, r14
    2f2a:	80 2f       	mov	r24, r16
    2f2c:	90 e0       	ldi	r25, 0x00	; 0
    2f2e:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2f32:	d3 cf       	rjmp	.-90     	; 0x2eda <vfprintf+0x672>
    2f34:	0c e6       	ldi	r16, 0x6C	; 108
    2f36:	10 e0       	ldi	r17, 0x00	; 0
    2f38:	d5 cf       	rjmp	.-86     	; 0x2ee4 <vfprintf+0x67c>
    2f3a:	91 10       	cpse	r9, r1
    2f3c:	80 52       	subi	r24, 0x20	; 32
    2f3e:	b7 01       	movw	r22, r14
    2f40:	90 e0       	ldi	r25, 0x00	; 0
    2f42:	0e 94 20 1c 	call	0x3840	; 0x3840 <fputc>
    2f46:	0f 5f       	subi	r16, 0xFF	; 255
    2f48:	1f 4f       	sbci	r17, 0xFF	; 255
    2f4a:	cf cf       	rjmp	.-98     	; 0x2eea <vfprintf+0x682>
    2f4c:	23 e0       	ldi	r18, 0x03	; 3
    2f4e:	25 15       	cp	r18, r5
    2f50:	10 f4       	brcc	.+4      	; 0x2f56 <vfprintf+0x6ee>
    2f52:	83 e0       	ldi	r24, 0x03	; 3
    2f54:	bd cf       	rjmp	.-134    	; 0x2ed0 <vfprintf+0x668>
    2f56:	51 2c       	mov	r5, r1
    2f58:	c0 cf       	rjmp	.-128    	; 0x2eda <vfprintf+0x672>
    2f5a:	60 96       	adiw	r28, 0x10	; 16
    2f5c:	e2 e1       	ldi	r30, 0x12	; 18
    2f5e:	0c 94 5a 18 	jmp	0x30b4	; 0x30b4 <__epilogue_restores__>

00002f62 <main>:
#define stack_size ((unsigned short)300)

static void pidControllerTask(void *pvParameters);
static void uartControllerTask(void *pvParameters);

int main(void) {
    2f62:	ef 92       	push	r14
    2f64:	ff 92       	push	r15
    2f66:	0f 93       	push	r16
    2f68:	cf 93       	push	r28
    2f6a:	df 93       	push	r29
    2f6c:	00 d0       	rcall	.+0      	; 0x2f6e <main+0xc>
    2f6e:	00 d0       	rcall	.+0      	; 0x2f70 <main+0xe>
    2f70:	cd b7       	in	r28, 0x3d	; 61
    2f72:	de b7       	in	r29, 0x3e	; 62
  uart_init();
    2f74:	0e 94 4a 02 	call	0x494	; 0x494 <uart_init>
  stdin = stdout = stderr = &uart_file;
    2f78:	ed ef       	ldi	r30, 0xFD	; 253
    2f7a:	f7 e0       	ldi	r31, 0x07	; 7
    2f7c:	82 e0       	ldi	r24, 0x02	; 2
    2f7e:	91 e0       	ldi	r25, 0x01	; 1
    2f80:	95 83       	std	Z+5, r25	; 0x05
    2f82:	84 83       	std	Z+4, r24	; 0x04
    2f84:	93 83       	std	Z+3, r25	; 0x03
    2f86:	82 83       	std	Z+2, r24	; 0x02
    2f88:	91 83       	std	Z+1, r25	; 0x01
    2f8a:	80 83       	st	Z, r24

  xTaskHandle trace_handle;
  xTaskHandle shifting_handle;

  xTaskCreate(pidControllerTask, "trace", stack_size, NULL,
    2f8c:	ce 01       	movw	r24, r28
    2f8e:	03 96       	adiw	r24, 0x03	; 3
    2f90:	7c 01       	movw	r14, r24
    2f92:	02 e0       	ldi	r16, 0x02	; 2
    2f94:	20 e0       	ldi	r18, 0x00	; 0
    2f96:	30 e0       	ldi	r19, 0x00	; 0
    2f98:	4c e2       	ldi	r20, 0x2C	; 44
    2f9a:	51 e0       	ldi	r21, 0x01	; 1
    2f9c:	67 e6       	ldi	r22, 0x67	; 103
    2f9e:	71 e0       	ldi	r23, 0x01	; 1
    2fa0:	8c ef       	ldi	r24, 0xFC	; 252
    2fa2:	90 e0       	ldi	r25, 0x00	; 0
    2fa4:	0e 94 ed 03 	call	0x7da	; 0x7da <xTaskCreate>
              mainTRACE_TASK_PRIORITY, &trace_handle);

  xTaskCreate(uartControllerTask, "shift", stack_size, NULL,
    2fa8:	ce 01       	movw	r24, r28
    2faa:	01 96       	adiw	r24, 0x01	; 1
    2fac:	7c 01       	movw	r14, r24
    2fae:	20 e0       	ldi	r18, 0x00	; 0
    2fb0:	30 e0       	ldi	r19, 0x00	; 0
    2fb2:	4c e2       	ldi	r20, 0x2C	; 44
    2fb4:	51 e0       	ldi	r21, 0x01	; 1
    2fb6:	6d e6       	ldi	r22, 0x6D	; 109
    2fb8:	71 e0       	ldi	r23, 0x01	; 1
    2fba:	8a ec       	ldi	r24, 0xCA	; 202
    2fbc:	91 e0       	ldi	r25, 0x01	; 1
    2fbe:	0e 94 ed 03 	call	0x7da	; 0x7da <xTaskCreate>
              mainSHIFTING_TASK_PRIORITY, &shifting_handle);

  vTaskStartScheduler();
    2fc2:	0e 94 d2 05 	call	0xba4	; 0xba4 <vTaskStartScheduler>

  return 0;
}
    2fc6:	80 e0       	ldi	r24, 0x00	; 0
    2fc8:	90 e0       	ldi	r25, 0x00	; 0
    2fca:	0f 90       	pop	r0
    2fcc:	0f 90       	pop	r0
    2fce:	0f 90       	pop	r0
    2fd0:	0f 90       	pop	r0
    2fd2:	df 91       	pop	r29
    2fd4:	cf 91       	pop	r28
    2fd6:	0f 91       	pop	r16
    2fd8:	ff 90       	pop	r15
    2fda:	ef 90       	pop	r14
    2fdc:	08 95       	ret

00002fde <__udivmodhi4>:
    2fde:	aa 1b       	sub	r26, r26
    2fe0:	bb 1b       	sub	r27, r27
    2fe2:	51 e1       	ldi	r21, 0x11	; 17
    2fe4:	07 c0       	rjmp	.+14     	; 0x2ff4 <__udivmodhi4_ep>

00002fe6 <__udivmodhi4_loop>:
    2fe6:	aa 1f       	adc	r26, r26
    2fe8:	bb 1f       	adc	r27, r27
    2fea:	a6 17       	cp	r26, r22
    2fec:	b7 07       	cpc	r27, r23
    2fee:	10 f0       	brcs	.+4      	; 0x2ff4 <__udivmodhi4_ep>
    2ff0:	a6 1b       	sub	r26, r22
    2ff2:	b7 0b       	sbc	r27, r23

00002ff4 <__udivmodhi4_ep>:
    2ff4:	88 1f       	adc	r24, r24
    2ff6:	99 1f       	adc	r25, r25
    2ff8:	5a 95       	dec	r21
    2ffa:	a9 f7       	brne	.-22     	; 0x2fe6 <__udivmodhi4_loop>
    2ffc:	80 95       	com	r24
    2ffe:	90 95       	com	r25
    3000:	bc 01       	movw	r22, r24
    3002:	cd 01       	movw	r24, r26
    3004:	08 95       	ret

00003006 <__divmodhi4>:
    3006:	97 fb       	bst	r25, 7
    3008:	07 2e       	mov	r0, r23
    300a:	16 f4       	brtc	.+4      	; 0x3010 <__divmodhi4+0xa>
    300c:	00 94       	com	r0
    300e:	07 d0       	rcall	.+14     	; 0x301e <__divmodhi4_neg1>
    3010:	77 fd       	sbrc	r23, 7
    3012:	09 d0       	rcall	.+18     	; 0x3026 <__divmodhi4_neg2>
    3014:	0e 94 ef 17 	call	0x2fde	; 0x2fde <__udivmodhi4>
    3018:	07 fc       	sbrc	r0, 7
    301a:	05 d0       	rcall	.+10     	; 0x3026 <__divmodhi4_neg2>
    301c:	3e f4       	brtc	.+14     	; 0x302c <__divmodhi4_exit>

0000301e <__divmodhi4_neg1>:
    301e:	90 95       	com	r25
    3020:	81 95       	neg	r24
    3022:	9f 4f       	sbci	r25, 0xFF	; 255
    3024:	08 95       	ret

00003026 <__divmodhi4_neg2>:
    3026:	70 95       	com	r23
    3028:	61 95       	neg	r22
    302a:	7f 4f       	sbci	r23, 0xFF	; 255

0000302c <__divmodhi4_exit>:
    302c:	08 95       	ret

0000302e <__divmodsi4>:
    302e:	05 2e       	mov	r0, r21
    3030:	97 fb       	bst	r25, 7
    3032:	1e f4       	brtc	.+6      	; 0x303a <__divmodsi4+0xc>
    3034:	00 94       	com	r0
    3036:	0e 94 2e 18 	call	0x305c	; 0x305c <__negsi2>
    303a:	57 fd       	sbrc	r21, 7
    303c:	07 d0       	rcall	.+14     	; 0x304c <__divmodsi4_neg2>
    303e:	0e 94 75 18 	call	0x30ea	; 0x30ea <__udivmodsi4>
    3042:	07 fc       	sbrc	r0, 7
    3044:	03 d0       	rcall	.+6      	; 0x304c <__divmodsi4_neg2>
    3046:	4e f4       	brtc	.+18     	; 0x305a <__divmodsi4_exit>
    3048:	0c 94 2e 18 	jmp	0x305c	; 0x305c <__negsi2>

0000304c <__divmodsi4_neg2>:
    304c:	50 95       	com	r21
    304e:	40 95       	com	r20
    3050:	30 95       	com	r19
    3052:	21 95       	neg	r18
    3054:	3f 4f       	sbci	r19, 0xFF	; 255
    3056:	4f 4f       	sbci	r20, 0xFF	; 255
    3058:	5f 4f       	sbci	r21, 0xFF	; 255

0000305a <__divmodsi4_exit>:
    305a:	08 95       	ret

0000305c <__negsi2>:
    305c:	90 95       	com	r25
    305e:	80 95       	com	r24
    3060:	70 95       	com	r23
    3062:	61 95       	neg	r22
    3064:	7f 4f       	sbci	r23, 0xFF	; 255
    3066:	8f 4f       	sbci	r24, 0xFF	; 255
    3068:	9f 4f       	sbci	r25, 0xFF	; 255
    306a:	08 95       	ret

0000306c <__mulshisi3>:
    306c:	b7 ff       	sbrs	r27, 7
    306e:	0c 94 97 18 	jmp	0x312e	; 0x312e <__muluhisi3>

00003072 <__mulohisi3>:
    3072:	0e 94 97 18 	call	0x312e	; 0x312e <__muluhisi3>
    3076:	82 1b       	sub	r24, r18
    3078:	93 0b       	sbc	r25, r19
    307a:	08 95       	ret

0000307c <__prologue_saves__>:
    307c:	2f 92       	push	r2
    307e:	3f 92       	push	r3
    3080:	4f 92       	push	r4
    3082:	5f 92       	push	r5
    3084:	6f 92       	push	r6
    3086:	7f 92       	push	r7
    3088:	8f 92       	push	r8
    308a:	9f 92       	push	r9
    308c:	af 92       	push	r10
    308e:	bf 92       	push	r11
    3090:	cf 92       	push	r12
    3092:	df 92       	push	r13
    3094:	ef 92       	push	r14
    3096:	ff 92       	push	r15
    3098:	0f 93       	push	r16
    309a:	1f 93       	push	r17
    309c:	cf 93       	push	r28
    309e:	df 93       	push	r29
    30a0:	cd b7       	in	r28, 0x3d	; 61
    30a2:	de b7       	in	r29, 0x3e	; 62
    30a4:	ca 1b       	sub	r28, r26
    30a6:	db 0b       	sbc	r29, r27
    30a8:	0f b6       	in	r0, 0x3f	; 63
    30aa:	f8 94       	cli
    30ac:	de bf       	out	0x3e, r29	; 62
    30ae:	0f be       	out	0x3f, r0	; 63
    30b0:	cd bf       	out	0x3d, r28	; 61
    30b2:	09 94       	ijmp

000030b4 <__epilogue_restores__>:
    30b4:	2a 88       	ldd	r2, Y+18	; 0x12
    30b6:	39 88       	ldd	r3, Y+17	; 0x11
    30b8:	48 88       	ldd	r4, Y+16	; 0x10
    30ba:	5f 84       	ldd	r5, Y+15	; 0x0f
    30bc:	6e 84       	ldd	r6, Y+14	; 0x0e
    30be:	7d 84       	ldd	r7, Y+13	; 0x0d
    30c0:	8c 84       	ldd	r8, Y+12	; 0x0c
    30c2:	9b 84       	ldd	r9, Y+11	; 0x0b
    30c4:	aa 84       	ldd	r10, Y+10	; 0x0a
    30c6:	b9 84       	ldd	r11, Y+9	; 0x09
    30c8:	c8 84       	ldd	r12, Y+8	; 0x08
    30ca:	df 80       	ldd	r13, Y+7	; 0x07
    30cc:	ee 80       	ldd	r14, Y+6	; 0x06
    30ce:	fd 80       	ldd	r15, Y+5	; 0x05
    30d0:	0c 81       	ldd	r16, Y+4	; 0x04
    30d2:	1b 81       	ldd	r17, Y+3	; 0x03
    30d4:	aa 81       	ldd	r26, Y+2	; 0x02
    30d6:	b9 81       	ldd	r27, Y+1	; 0x01
    30d8:	ce 0f       	add	r28, r30
    30da:	d1 1d       	adc	r29, r1
    30dc:	0f b6       	in	r0, 0x3f	; 63
    30de:	f8 94       	cli
    30e0:	de bf       	out	0x3e, r29	; 62
    30e2:	0f be       	out	0x3f, r0	; 63
    30e4:	cd bf       	out	0x3d, r28	; 61
    30e6:	ed 01       	movw	r28, r26
    30e8:	08 95       	ret

000030ea <__udivmodsi4>:
    30ea:	a1 e2       	ldi	r26, 0x21	; 33
    30ec:	1a 2e       	mov	r1, r26
    30ee:	aa 1b       	sub	r26, r26
    30f0:	bb 1b       	sub	r27, r27
    30f2:	fd 01       	movw	r30, r26
    30f4:	0d c0       	rjmp	.+26     	; 0x3110 <__udivmodsi4_ep>

000030f6 <__udivmodsi4_loop>:
    30f6:	aa 1f       	adc	r26, r26
    30f8:	bb 1f       	adc	r27, r27
    30fa:	ee 1f       	adc	r30, r30
    30fc:	ff 1f       	adc	r31, r31
    30fe:	a2 17       	cp	r26, r18
    3100:	b3 07       	cpc	r27, r19
    3102:	e4 07       	cpc	r30, r20
    3104:	f5 07       	cpc	r31, r21
    3106:	20 f0       	brcs	.+8      	; 0x3110 <__udivmodsi4_ep>
    3108:	a2 1b       	sub	r26, r18
    310a:	b3 0b       	sbc	r27, r19
    310c:	e4 0b       	sbc	r30, r20
    310e:	f5 0b       	sbc	r31, r21

00003110 <__udivmodsi4_ep>:
    3110:	66 1f       	adc	r22, r22
    3112:	77 1f       	adc	r23, r23
    3114:	88 1f       	adc	r24, r24
    3116:	99 1f       	adc	r25, r25
    3118:	1a 94       	dec	r1
    311a:	69 f7       	brne	.-38     	; 0x30f6 <__udivmodsi4_loop>
    311c:	60 95       	com	r22
    311e:	70 95       	com	r23
    3120:	80 95       	com	r24
    3122:	90 95       	com	r25
    3124:	9b 01       	movw	r18, r22
    3126:	ac 01       	movw	r20, r24
    3128:	bd 01       	movw	r22, r26
    312a:	cf 01       	movw	r24, r30
    312c:	08 95       	ret

0000312e <__muluhisi3>:
    312e:	0e 94 a2 18 	call	0x3144	; 0x3144 <__umulhisi3>
    3132:	a5 9f       	mul	r26, r21
    3134:	90 0d       	add	r25, r0
    3136:	b4 9f       	mul	r27, r20
    3138:	90 0d       	add	r25, r0
    313a:	a4 9f       	mul	r26, r20
    313c:	80 0d       	add	r24, r0
    313e:	91 1d       	adc	r25, r1
    3140:	11 24       	eor	r1, r1
    3142:	08 95       	ret

00003144 <__umulhisi3>:
    3144:	a2 9f       	mul	r26, r18
    3146:	b0 01       	movw	r22, r0
    3148:	b3 9f       	mul	r27, r19
    314a:	c0 01       	movw	r24, r0
    314c:	a3 9f       	mul	r26, r19
    314e:	70 0d       	add	r23, r0
    3150:	81 1d       	adc	r24, r1
    3152:	11 24       	eor	r1, r1
    3154:	91 1d       	adc	r25, r1
    3156:	b2 9f       	mul	r27, r18
    3158:	70 0d       	add	r23, r0
    315a:	81 1d       	adc	r24, r1
    315c:	11 24       	eor	r1, r1
    315e:	91 1d       	adc	r25, r1
    3160:	08 95       	ret

00003162 <__subsf3>:
    3162:	50 58       	subi	r21, 0x80	; 128

00003164 <__addsf3>:
    3164:	bb 27       	eor	r27, r27
    3166:	aa 27       	eor	r26, r26
    3168:	0e 94 c9 18 	call	0x3192	; 0x3192 <__addsf3x>
    316c:	0c 94 e4 19 	jmp	0x33c8	; 0x33c8 <__fp_round>
    3170:	0e 94 d6 19 	call	0x33ac	; 0x33ac <__fp_pscA>
    3174:	38 f0       	brcs	.+14     	; 0x3184 <__addsf3+0x20>
    3176:	0e 94 dd 19 	call	0x33ba	; 0x33ba <__fp_pscB>
    317a:	20 f0       	brcs	.+8      	; 0x3184 <__addsf3+0x20>
    317c:	39 f4       	brne	.+14     	; 0x318c <__addsf3+0x28>
    317e:	9f 3f       	cpi	r25, 0xFF	; 255
    3180:	19 f4       	brne	.+6      	; 0x3188 <__addsf3+0x24>
    3182:	26 f4       	brtc	.+8      	; 0x318c <__addsf3+0x28>
    3184:	0c 94 d3 19 	jmp	0x33a6	; 0x33a6 <__fp_nan>
    3188:	0e f4       	brtc	.+2      	; 0x318c <__addsf3+0x28>
    318a:	e0 95       	com	r30
    318c:	e7 fb       	bst	r30, 7
    318e:	0c 94 cd 19 	jmp	0x339a	; 0x339a <__fp_inf>

00003192 <__addsf3x>:
    3192:	e9 2f       	mov	r30, r25
    3194:	0e 94 f5 19 	call	0x33ea	; 0x33ea <__fp_split3>
    3198:	58 f3       	brcs	.-42     	; 0x3170 <__addsf3+0xc>
    319a:	ba 17       	cp	r27, r26
    319c:	62 07       	cpc	r22, r18
    319e:	73 07       	cpc	r23, r19
    31a0:	84 07       	cpc	r24, r20
    31a2:	95 07       	cpc	r25, r21
    31a4:	20 f0       	brcs	.+8      	; 0x31ae <__addsf3x+0x1c>
    31a6:	79 f4       	brne	.+30     	; 0x31c6 <__addsf3x+0x34>
    31a8:	a6 f5       	brtc	.+104    	; 0x3212 <__addsf3x+0x80>
    31aa:	0c 94 17 1a 	jmp	0x342e	; 0x342e <__fp_zero>
    31ae:	0e f4       	brtc	.+2      	; 0x31b2 <__addsf3x+0x20>
    31b0:	e0 95       	com	r30
    31b2:	0b 2e       	mov	r0, r27
    31b4:	ba 2f       	mov	r27, r26
    31b6:	a0 2d       	mov	r26, r0
    31b8:	0b 01       	movw	r0, r22
    31ba:	b9 01       	movw	r22, r18
    31bc:	90 01       	movw	r18, r0
    31be:	0c 01       	movw	r0, r24
    31c0:	ca 01       	movw	r24, r20
    31c2:	a0 01       	movw	r20, r0
    31c4:	11 24       	eor	r1, r1
    31c6:	ff 27       	eor	r31, r31
    31c8:	59 1b       	sub	r21, r25
    31ca:	99 f0       	breq	.+38     	; 0x31f2 <__addsf3x+0x60>
    31cc:	59 3f       	cpi	r21, 0xF9	; 249
    31ce:	50 f4       	brcc	.+20     	; 0x31e4 <__addsf3x+0x52>
    31d0:	50 3e       	cpi	r21, 0xE0	; 224
    31d2:	68 f1       	brcs	.+90     	; 0x322e <__addsf3x+0x9c>
    31d4:	1a 16       	cp	r1, r26
    31d6:	f0 40       	sbci	r31, 0x00	; 0
    31d8:	a2 2f       	mov	r26, r18
    31da:	23 2f       	mov	r18, r19
    31dc:	34 2f       	mov	r19, r20
    31de:	44 27       	eor	r20, r20
    31e0:	58 5f       	subi	r21, 0xF8	; 248
    31e2:	f3 cf       	rjmp	.-26     	; 0x31ca <__addsf3x+0x38>
    31e4:	46 95       	lsr	r20
    31e6:	37 95       	ror	r19
    31e8:	27 95       	ror	r18
    31ea:	a7 95       	ror	r26
    31ec:	f0 40       	sbci	r31, 0x00	; 0
    31ee:	53 95       	inc	r21
    31f0:	c9 f7       	brne	.-14     	; 0x31e4 <__addsf3x+0x52>
    31f2:	7e f4       	brtc	.+30     	; 0x3212 <__addsf3x+0x80>
    31f4:	1f 16       	cp	r1, r31
    31f6:	ba 0b       	sbc	r27, r26
    31f8:	62 0b       	sbc	r22, r18
    31fa:	73 0b       	sbc	r23, r19
    31fc:	84 0b       	sbc	r24, r20
    31fe:	ba f0       	brmi	.+46     	; 0x322e <__addsf3x+0x9c>
    3200:	91 50       	subi	r25, 0x01	; 1
    3202:	a1 f0       	breq	.+40     	; 0x322c <__addsf3x+0x9a>
    3204:	ff 0f       	add	r31, r31
    3206:	bb 1f       	adc	r27, r27
    3208:	66 1f       	adc	r22, r22
    320a:	77 1f       	adc	r23, r23
    320c:	88 1f       	adc	r24, r24
    320e:	c2 f7       	brpl	.-16     	; 0x3200 <__addsf3x+0x6e>
    3210:	0e c0       	rjmp	.+28     	; 0x322e <__addsf3x+0x9c>
    3212:	ba 0f       	add	r27, r26
    3214:	62 1f       	adc	r22, r18
    3216:	73 1f       	adc	r23, r19
    3218:	84 1f       	adc	r24, r20
    321a:	48 f4       	brcc	.+18     	; 0x322e <__addsf3x+0x9c>
    321c:	87 95       	ror	r24
    321e:	77 95       	ror	r23
    3220:	67 95       	ror	r22
    3222:	b7 95       	ror	r27
    3224:	f7 95       	ror	r31
    3226:	9e 3f       	cpi	r25, 0xFE	; 254
    3228:	08 f0       	brcs	.+2      	; 0x322c <__addsf3x+0x9a>
    322a:	b0 cf       	rjmp	.-160    	; 0x318c <__addsf3+0x28>
    322c:	93 95       	inc	r25
    322e:	88 0f       	add	r24, r24
    3230:	08 f0       	brcs	.+2      	; 0x3234 <__addsf3x+0xa2>
    3232:	99 27       	eor	r25, r25
    3234:	ee 0f       	add	r30, r30
    3236:	97 95       	ror	r25
    3238:	87 95       	ror	r24
    323a:	08 95       	ret

0000323c <__divsf3>:
    323c:	0e 94 32 19 	call	0x3264	; 0x3264 <__divsf3x>
    3240:	0c 94 e4 19 	jmp	0x33c8	; 0x33c8 <__fp_round>
    3244:	0e 94 dd 19 	call	0x33ba	; 0x33ba <__fp_pscB>
    3248:	58 f0       	brcs	.+22     	; 0x3260 <__divsf3+0x24>
    324a:	0e 94 d6 19 	call	0x33ac	; 0x33ac <__fp_pscA>
    324e:	40 f0       	brcs	.+16     	; 0x3260 <__divsf3+0x24>
    3250:	29 f4       	brne	.+10     	; 0x325c <__divsf3+0x20>
    3252:	5f 3f       	cpi	r21, 0xFF	; 255
    3254:	29 f0       	breq	.+10     	; 0x3260 <__divsf3+0x24>
    3256:	0c 94 cd 19 	jmp	0x339a	; 0x339a <__fp_inf>
    325a:	51 11       	cpse	r21, r1
    325c:	0c 94 18 1a 	jmp	0x3430	; 0x3430 <__fp_szero>
    3260:	0c 94 d3 19 	jmp	0x33a6	; 0x33a6 <__fp_nan>

00003264 <__divsf3x>:
    3264:	0e 94 f5 19 	call	0x33ea	; 0x33ea <__fp_split3>
    3268:	68 f3       	brcs	.-38     	; 0x3244 <__divsf3+0x8>

0000326a <__divsf3_pse>:
    326a:	99 23       	and	r25, r25
    326c:	b1 f3       	breq	.-20     	; 0x325a <__divsf3+0x1e>
    326e:	55 23       	and	r21, r21
    3270:	91 f3       	breq	.-28     	; 0x3256 <__divsf3+0x1a>
    3272:	95 1b       	sub	r25, r21
    3274:	55 0b       	sbc	r21, r21
    3276:	bb 27       	eor	r27, r27
    3278:	aa 27       	eor	r26, r26
    327a:	62 17       	cp	r22, r18
    327c:	73 07       	cpc	r23, r19
    327e:	84 07       	cpc	r24, r20
    3280:	38 f0       	brcs	.+14     	; 0x3290 <__divsf3_pse+0x26>
    3282:	9f 5f       	subi	r25, 0xFF	; 255
    3284:	5f 4f       	sbci	r21, 0xFF	; 255
    3286:	22 0f       	add	r18, r18
    3288:	33 1f       	adc	r19, r19
    328a:	44 1f       	adc	r20, r20
    328c:	aa 1f       	adc	r26, r26
    328e:	a9 f3       	breq	.-22     	; 0x327a <__divsf3_pse+0x10>
    3290:	35 d0       	rcall	.+106    	; 0x32fc <__divsf3_pse+0x92>
    3292:	0e 2e       	mov	r0, r30
    3294:	3a f0       	brmi	.+14     	; 0x32a4 <__divsf3_pse+0x3a>
    3296:	e0 e8       	ldi	r30, 0x80	; 128
    3298:	32 d0       	rcall	.+100    	; 0x32fe <__divsf3_pse+0x94>
    329a:	91 50       	subi	r25, 0x01	; 1
    329c:	50 40       	sbci	r21, 0x00	; 0
    329e:	e6 95       	lsr	r30
    32a0:	00 1c       	adc	r0, r0
    32a2:	ca f7       	brpl	.-14     	; 0x3296 <__divsf3_pse+0x2c>
    32a4:	2b d0       	rcall	.+86     	; 0x32fc <__divsf3_pse+0x92>
    32a6:	fe 2f       	mov	r31, r30
    32a8:	29 d0       	rcall	.+82     	; 0x32fc <__divsf3_pse+0x92>
    32aa:	66 0f       	add	r22, r22
    32ac:	77 1f       	adc	r23, r23
    32ae:	88 1f       	adc	r24, r24
    32b0:	bb 1f       	adc	r27, r27
    32b2:	26 17       	cp	r18, r22
    32b4:	37 07       	cpc	r19, r23
    32b6:	48 07       	cpc	r20, r24
    32b8:	ab 07       	cpc	r26, r27
    32ba:	b0 e8       	ldi	r27, 0x80	; 128
    32bc:	09 f0       	breq	.+2      	; 0x32c0 <__divsf3_pse+0x56>
    32be:	bb 0b       	sbc	r27, r27
    32c0:	80 2d       	mov	r24, r0
    32c2:	bf 01       	movw	r22, r30
    32c4:	ff 27       	eor	r31, r31
    32c6:	93 58       	subi	r25, 0x83	; 131
    32c8:	5f 4f       	sbci	r21, 0xFF	; 255
    32ca:	3a f0       	brmi	.+14     	; 0x32da <__divsf3_pse+0x70>
    32cc:	9e 3f       	cpi	r25, 0xFE	; 254
    32ce:	51 05       	cpc	r21, r1
    32d0:	78 f0       	brcs	.+30     	; 0x32f0 <__divsf3_pse+0x86>
    32d2:	0c 94 cd 19 	jmp	0x339a	; 0x339a <__fp_inf>
    32d6:	0c 94 18 1a 	jmp	0x3430	; 0x3430 <__fp_szero>
    32da:	5f 3f       	cpi	r21, 0xFF	; 255
    32dc:	e4 f3       	brlt	.-8      	; 0x32d6 <__divsf3_pse+0x6c>
    32de:	98 3e       	cpi	r25, 0xE8	; 232
    32e0:	d4 f3       	brlt	.-12     	; 0x32d6 <__divsf3_pse+0x6c>
    32e2:	86 95       	lsr	r24
    32e4:	77 95       	ror	r23
    32e6:	67 95       	ror	r22
    32e8:	b7 95       	ror	r27
    32ea:	f7 95       	ror	r31
    32ec:	9f 5f       	subi	r25, 0xFF	; 255
    32ee:	c9 f7       	brne	.-14     	; 0x32e2 <__divsf3_pse+0x78>
    32f0:	88 0f       	add	r24, r24
    32f2:	91 1d       	adc	r25, r1
    32f4:	96 95       	lsr	r25
    32f6:	87 95       	ror	r24
    32f8:	97 f9       	bld	r25, 7
    32fa:	08 95       	ret
    32fc:	e1 e0       	ldi	r30, 0x01	; 1
    32fe:	66 0f       	add	r22, r22
    3300:	77 1f       	adc	r23, r23
    3302:	88 1f       	adc	r24, r24
    3304:	bb 1f       	adc	r27, r27
    3306:	62 17       	cp	r22, r18
    3308:	73 07       	cpc	r23, r19
    330a:	84 07       	cpc	r24, r20
    330c:	ba 07       	cpc	r27, r26
    330e:	20 f0       	brcs	.+8      	; 0x3318 <__divsf3_pse+0xae>
    3310:	62 1b       	sub	r22, r18
    3312:	73 0b       	sbc	r23, r19
    3314:	84 0b       	sbc	r24, r20
    3316:	ba 0b       	sbc	r27, r26
    3318:	ee 1f       	adc	r30, r30
    331a:	88 f7       	brcc	.-30     	; 0x32fe <__divsf3_pse+0x94>
    331c:	e0 95       	com	r30
    331e:	08 95       	ret

00003320 <__floatunsisf>:
    3320:	e8 94       	clt
    3322:	09 c0       	rjmp	.+18     	; 0x3336 <__floatsisf+0x12>

00003324 <__floatsisf>:
    3324:	97 fb       	bst	r25, 7
    3326:	3e f4       	brtc	.+14     	; 0x3336 <__floatsisf+0x12>
    3328:	90 95       	com	r25
    332a:	80 95       	com	r24
    332c:	70 95       	com	r23
    332e:	61 95       	neg	r22
    3330:	7f 4f       	sbci	r23, 0xFF	; 255
    3332:	8f 4f       	sbci	r24, 0xFF	; 255
    3334:	9f 4f       	sbci	r25, 0xFF	; 255
    3336:	99 23       	and	r25, r25
    3338:	a9 f0       	breq	.+42     	; 0x3364 <__floatsisf+0x40>
    333a:	f9 2f       	mov	r31, r25
    333c:	96 e9       	ldi	r25, 0x96	; 150
    333e:	bb 27       	eor	r27, r27
    3340:	93 95       	inc	r25
    3342:	f6 95       	lsr	r31
    3344:	87 95       	ror	r24
    3346:	77 95       	ror	r23
    3348:	67 95       	ror	r22
    334a:	b7 95       	ror	r27
    334c:	f1 11       	cpse	r31, r1
    334e:	f8 cf       	rjmp	.-16     	; 0x3340 <__floatsisf+0x1c>
    3350:	fa f4       	brpl	.+62     	; 0x3390 <__floatsisf+0x6c>
    3352:	bb 0f       	add	r27, r27
    3354:	11 f4       	brne	.+4      	; 0x335a <__floatsisf+0x36>
    3356:	60 ff       	sbrs	r22, 0
    3358:	1b c0       	rjmp	.+54     	; 0x3390 <__floatsisf+0x6c>
    335a:	6f 5f       	subi	r22, 0xFF	; 255
    335c:	7f 4f       	sbci	r23, 0xFF	; 255
    335e:	8f 4f       	sbci	r24, 0xFF	; 255
    3360:	9f 4f       	sbci	r25, 0xFF	; 255
    3362:	16 c0       	rjmp	.+44     	; 0x3390 <__floatsisf+0x6c>
    3364:	88 23       	and	r24, r24
    3366:	11 f0       	breq	.+4      	; 0x336c <__floatsisf+0x48>
    3368:	96 e9       	ldi	r25, 0x96	; 150
    336a:	11 c0       	rjmp	.+34     	; 0x338e <__floatsisf+0x6a>
    336c:	77 23       	and	r23, r23
    336e:	21 f0       	breq	.+8      	; 0x3378 <__floatsisf+0x54>
    3370:	9e e8       	ldi	r25, 0x8E	; 142
    3372:	87 2f       	mov	r24, r23
    3374:	76 2f       	mov	r23, r22
    3376:	05 c0       	rjmp	.+10     	; 0x3382 <__floatsisf+0x5e>
    3378:	66 23       	and	r22, r22
    337a:	71 f0       	breq	.+28     	; 0x3398 <__floatsisf+0x74>
    337c:	96 e8       	ldi	r25, 0x86	; 134
    337e:	86 2f       	mov	r24, r22
    3380:	70 e0       	ldi	r23, 0x00	; 0
    3382:	60 e0       	ldi	r22, 0x00	; 0
    3384:	2a f0       	brmi	.+10     	; 0x3390 <__floatsisf+0x6c>
    3386:	9a 95       	dec	r25
    3388:	66 0f       	add	r22, r22
    338a:	77 1f       	adc	r23, r23
    338c:	88 1f       	adc	r24, r24
    338e:	da f7       	brpl	.-10     	; 0x3386 <__floatsisf+0x62>
    3390:	88 0f       	add	r24, r24
    3392:	96 95       	lsr	r25
    3394:	87 95       	ror	r24
    3396:	97 f9       	bld	r25, 7
    3398:	08 95       	ret

0000339a <__fp_inf>:
    339a:	97 f9       	bld	r25, 7
    339c:	9f 67       	ori	r25, 0x7F	; 127
    339e:	80 e8       	ldi	r24, 0x80	; 128
    33a0:	70 e0       	ldi	r23, 0x00	; 0
    33a2:	60 e0       	ldi	r22, 0x00	; 0
    33a4:	08 95       	ret

000033a6 <__fp_nan>:
    33a6:	9f ef       	ldi	r25, 0xFF	; 255
    33a8:	80 ec       	ldi	r24, 0xC0	; 192
    33aa:	08 95       	ret

000033ac <__fp_pscA>:
    33ac:	00 24       	eor	r0, r0
    33ae:	0a 94       	dec	r0
    33b0:	16 16       	cp	r1, r22
    33b2:	17 06       	cpc	r1, r23
    33b4:	18 06       	cpc	r1, r24
    33b6:	09 06       	cpc	r0, r25
    33b8:	08 95       	ret

000033ba <__fp_pscB>:
    33ba:	00 24       	eor	r0, r0
    33bc:	0a 94       	dec	r0
    33be:	12 16       	cp	r1, r18
    33c0:	13 06       	cpc	r1, r19
    33c2:	14 06       	cpc	r1, r20
    33c4:	05 06       	cpc	r0, r21
    33c6:	08 95       	ret

000033c8 <__fp_round>:
    33c8:	09 2e       	mov	r0, r25
    33ca:	03 94       	inc	r0
    33cc:	00 0c       	add	r0, r0
    33ce:	11 f4       	brne	.+4      	; 0x33d4 <__fp_round+0xc>
    33d0:	88 23       	and	r24, r24
    33d2:	52 f0       	brmi	.+20     	; 0x33e8 <__fp_round+0x20>
    33d4:	bb 0f       	add	r27, r27
    33d6:	40 f4       	brcc	.+16     	; 0x33e8 <__fp_round+0x20>
    33d8:	bf 2b       	or	r27, r31
    33da:	11 f4       	brne	.+4      	; 0x33e0 <__fp_round+0x18>
    33dc:	60 ff       	sbrs	r22, 0
    33de:	04 c0       	rjmp	.+8      	; 0x33e8 <__fp_round+0x20>
    33e0:	6f 5f       	subi	r22, 0xFF	; 255
    33e2:	7f 4f       	sbci	r23, 0xFF	; 255
    33e4:	8f 4f       	sbci	r24, 0xFF	; 255
    33e6:	9f 4f       	sbci	r25, 0xFF	; 255
    33e8:	08 95       	ret

000033ea <__fp_split3>:
    33ea:	57 fd       	sbrc	r21, 7
    33ec:	90 58       	subi	r25, 0x80	; 128
    33ee:	44 0f       	add	r20, r20
    33f0:	55 1f       	adc	r21, r21
    33f2:	59 f0       	breq	.+22     	; 0x340a <__fp_splitA+0x10>
    33f4:	5f 3f       	cpi	r21, 0xFF	; 255
    33f6:	71 f0       	breq	.+28     	; 0x3414 <__fp_splitA+0x1a>
    33f8:	47 95       	ror	r20

000033fa <__fp_splitA>:
    33fa:	88 0f       	add	r24, r24
    33fc:	97 fb       	bst	r25, 7
    33fe:	99 1f       	adc	r25, r25
    3400:	61 f0       	breq	.+24     	; 0x341a <__fp_splitA+0x20>
    3402:	9f 3f       	cpi	r25, 0xFF	; 255
    3404:	79 f0       	breq	.+30     	; 0x3424 <__fp_splitA+0x2a>
    3406:	87 95       	ror	r24
    3408:	08 95       	ret
    340a:	12 16       	cp	r1, r18
    340c:	13 06       	cpc	r1, r19
    340e:	14 06       	cpc	r1, r20
    3410:	55 1f       	adc	r21, r21
    3412:	f2 cf       	rjmp	.-28     	; 0x33f8 <__fp_split3+0xe>
    3414:	46 95       	lsr	r20
    3416:	f1 df       	rcall	.-30     	; 0x33fa <__fp_splitA>
    3418:	08 c0       	rjmp	.+16     	; 0x342a <__fp_splitA+0x30>
    341a:	16 16       	cp	r1, r22
    341c:	17 06       	cpc	r1, r23
    341e:	18 06       	cpc	r1, r24
    3420:	99 1f       	adc	r25, r25
    3422:	f1 cf       	rjmp	.-30     	; 0x3406 <__fp_splitA+0xc>
    3424:	86 95       	lsr	r24
    3426:	71 05       	cpc	r23, r1
    3428:	61 05       	cpc	r22, r1
    342a:	08 94       	sec
    342c:	08 95       	ret

0000342e <__fp_zero>:
    342e:	e8 94       	clt

00003430 <__fp_szero>:
    3430:	bb 27       	eor	r27, r27
    3432:	66 27       	eor	r22, r22
    3434:	77 27       	eor	r23, r23
    3436:	cb 01       	movw	r24, r22
    3438:	97 f9       	bld	r25, 7
    343a:	08 95       	ret

0000343c <__mulsf3>:
    343c:	0e 94 31 1a 	call	0x3462	; 0x3462 <__mulsf3x>
    3440:	0c 94 e4 19 	jmp	0x33c8	; 0x33c8 <__fp_round>
    3444:	0e 94 d6 19 	call	0x33ac	; 0x33ac <__fp_pscA>
    3448:	38 f0       	brcs	.+14     	; 0x3458 <__mulsf3+0x1c>
    344a:	0e 94 dd 19 	call	0x33ba	; 0x33ba <__fp_pscB>
    344e:	20 f0       	brcs	.+8      	; 0x3458 <__mulsf3+0x1c>
    3450:	95 23       	and	r25, r21
    3452:	11 f0       	breq	.+4      	; 0x3458 <__mulsf3+0x1c>
    3454:	0c 94 cd 19 	jmp	0x339a	; 0x339a <__fp_inf>
    3458:	0c 94 d3 19 	jmp	0x33a6	; 0x33a6 <__fp_nan>
    345c:	11 24       	eor	r1, r1
    345e:	0c 94 18 1a 	jmp	0x3430	; 0x3430 <__fp_szero>

00003462 <__mulsf3x>:
    3462:	0e 94 f5 19 	call	0x33ea	; 0x33ea <__fp_split3>
    3466:	70 f3       	brcs	.-36     	; 0x3444 <__mulsf3+0x8>

00003468 <__mulsf3_pse>:
    3468:	95 9f       	mul	r25, r21
    346a:	c1 f3       	breq	.-16     	; 0x345c <__mulsf3+0x20>
    346c:	95 0f       	add	r25, r21
    346e:	50 e0       	ldi	r21, 0x00	; 0
    3470:	55 1f       	adc	r21, r21
    3472:	62 9f       	mul	r22, r18
    3474:	f0 01       	movw	r30, r0
    3476:	72 9f       	mul	r23, r18
    3478:	bb 27       	eor	r27, r27
    347a:	f0 0d       	add	r31, r0
    347c:	b1 1d       	adc	r27, r1
    347e:	63 9f       	mul	r22, r19
    3480:	aa 27       	eor	r26, r26
    3482:	f0 0d       	add	r31, r0
    3484:	b1 1d       	adc	r27, r1
    3486:	aa 1f       	adc	r26, r26
    3488:	64 9f       	mul	r22, r20
    348a:	66 27       	eor	r22, r22
    348c:	b0 0d       	add	r27, r0
    348e:	a1 1d       	adc	r26, r1
    3490:	66 1f       	adc	r22, r22
    3492:	82 9f       	mul	r24, r18
    3494:	22 27       	eor	r18, r18
    3496:	b0 0d       	add	r27, r0
    3498:	a1 1d       	adc	r26, r1
    349a:	62 1f       	adc	r22, r18
    349c:	73 9f       	mul	r23, r19
    349e:	b0 0d       	add	r27, r0
    34a0:	a1 1d       	adc	r26, r1
    34a2:	62 1f       	adc	r22, r18
    34a4:	83 9f       	mul	r24, r19
    34a6:	a0 0d       	add	r26, r0
    34a8:	61 1d       	adc	r22, r1
    34aa:	22 1f       	adc	r18, r18
    34ac:	74 9f       	mul	r23, r20
    34ae:	33 27       	eor	r19, r19
    34b0:	a0 0d       	add	r26, r0
    34b2:	61 1d       	adc	r22, r1
    34b4:	23 1f       	adc	r18, r19
    34b6:	84 9f       	mul	r24, r20
    34b8:	60 0d       	add	r22, r0
    34ba:	21 1d       	adc	r18, r1
    34bc:	82 2f       	mov	r24, r18
    34be:	76 2f       	mov	r23, r22
    34c0:	6a 2f       	mov	r22, r26
    34c2:	11 24       	eor	r1, r1
    34c4:	9f 57       	subi	r25, 0x7F	; 127
    34c6:	50 40       	sbci	r21, 0x00	; 0
    34c8:	9a f0       	brmi	.+38     	; 0x34f0 <__mulsf3_pse+0x88>
    34ca:	f1 f0       	breq	.+60     	; 0x3508 <__mulsf3_pse+0xa0>
    34cc:	88 23       	and	r24, r24
    34ce:	4a f0       	brmi	.+18     	; 0x34e2 <__mulsf3_pse+0x7a>
    34d0:	ee 0f       	add	r30, r30
    34d2:	ff 1f       	adc	r31, r31
    34d4:	bb 1f       	adc	r27, r27
    34d6:	66 1f       	adc	r22, r22
    34d8:	77 1f       	adc	r23, r23
    34da:	88 1f       	adc	r24, r24
    34dc:	91 50       	subi	r25, 0x01	; 1
    34de:	50 40       	sbci	r21, 0x00	; 0
    34e0:	a9 f7       	brne	.-22     	; 0x34cc <__mulsf3_pse+0x64>
    34e2:	9e 3f       	cpi	r25, 0xFE	; 254
    34e4:	51 05       	cpc	r21, r1
    34e6:	80 f0       	brcs	.+32     	; 0x3508 <__mulsf3_pse+0xa0>
    34e8:	0c 94 cd 19 	jmp	0x339a	; 0x339a <__fp_inf>
    34ec:	0c 94 18 1a 	jmp	0x3430	; 0x3430 <__fp_szero>
    34f0:	5f 3f       	cpi	r21, 0xFF	; 255
    34f2:	e4 f3       	brlt	.-8      	; 0x34ec <__mulsf3_pse+0x84>
    34f4:	98 3e       	cpi	r25, 0xE8	; 232
    34f6:	d4 f3       	brlt	.-12     	; 0x34ec <__mulsf3_pse+0x84>
    34f8:	86 95       	lsr	r24
    34fa:	77 95       	ror	r23
    34fc:	67 95       	ror	r22
    34fe:	b7 95       	ror	r27
    3500:	f7 95       	ror	r31
    3502:	e7 95       	ror	r30
    3504:	9f 5f       	subi	r25, 0xFF	; 255
    3506:	c1 f7       	brne	.-16     	; 0x34f8 <__mulsf3_pse+0x90>
    3508:	fe 2b       	or	r31, r30
    350a:	88 0f       	add	r24, r24
    350c:	91 1d       	adc	r25, r1
    350e:	96 95       	lsr	r25
    3510:	87 95       	ror	r24
    3512:	97 f9       	bld	r25, 7
    3514:	08 95       	ret

00003516 <atoi>:
    3516:	fc 01       	movw	r30, r24
    3518:	88 27       	eor	r24, r24
    351a:	99 27       	eor	r25, r25
    351c:	e8 94       	clt
    351e:	21 91       	ld	r18, Z+
    3520:	20 32       	cpi	r18, 0x20	; 32
    3522:	e9 f3       	breq	.-6      	; 0x351e <atoi+0x8>
    3524:	29 30       	cpi	r18, 0x09	; 9
    3526:	10 f0       	brcs	.+4      	; 0x352c <atoi+0x16>
    3528:	2e 30       	cpi	r18, 0x0E	; 14
    352a:	c8 f3       	brcs	.-14     	; 0x351e <atoi+0x8>
    352c:	2b 32       	cpi	r18, 0x2B	; 43
    352e:	41 f0       	breq	.+16     	; 0x3540 <atoi+0x2a>
    3530:	2d 32       	cpi	r18, 0x2D	; 45
    3532:	39 f4       	brne	.+14     	; 0x3542 <atoi+0x2c>
    3534:	68 94       	set
    3536:	04 c0       	rjmp	.+8      	; 0x3540 <atoi+0x2a>
    3538:	0e 94 da 1b 	call	0x37b4	; 0x37b4 <__mulhi_const_10>
    353c:	82 0f       	add	r24, r18
    353e:	91 1d       	adc	r25, r1
    3540:	21 91       	ld	r18, Z+
    3542:	20 53       	subi	r18, 0x30	; 48
    3544:	2a 30       	cpi	r18, 0x0A	; 10
    3546:	c0 f3       	brcs	.-16     	; 0x3538 <atoi+0x22>
    3548:	1e f4       	brtc	.+6      	; 0x3550 <atoi+0x3a>
    354a:	90 95       	com	r25
    354c:	81 95       	neg	r24
    354e:	9f 4f       	sbci	r25, 0xFF	; 255
    3550:	08 95       	ret

00003552 <__ftoa_engine>:
    3552:	28 30       	cpi	r18, 0x08	; 8
    3554:	08 f0       	brcs	.+2      	; 0x3558 <__ftoa_engine+0x6>
    3556:	27 e0       	ldi	r18, 0x07	; 7
    3558:	33 27       	eor	r19, r19
    355a:	da 01       	movw	r26, r20
    355c:	99 0f       	add	r25, r25
    355e:	31 1d       	adc	r19, r1
    3560:	87 fd       	sbrc	r24, 7
    3562:	91 60       	ori	r25, 0x01	; 1
    3564:	00 96       	adiw	r24, 0x00	; 0
    3566:	61 05       	cpc	r22, r1
    3568:	71 05       	cpc	r23, r1
    356a:	39 f4       	brne	.+14     	; 0x357a <__ftoa_engine+0x28>
    356c:	32 60       	ori	r19, 0x02	; 2
    356e:	2e 5f       	subi	r18, 0xFE	; 254
    3570:	3d 93       	st	X+, r19
    3572:	30 e3       	ldi	r19, 0x30	; 48
    3574:	2a 95       	dec	r18
    3576:	e1 f7       	brne	.-8      	; 0x3570 <__ftoa_engine+0x1e>
    3578:	08 95       	ret
    357a:	9f 3f       	cpi	r25, 0xFF	; 255
    357c:	30 f0       	brcs	.+12     	; 0x358a <__ftoa_engine+0x38>
    357e:	80 38       	cpi	r24, 0x80	; 128
    3580:	71 05       	cpc	r23, r1
    3582:	61 05       	cpc	r22, r1
    3584:	09 f0       	breq	.+2      	; 0x3588 <__ftoa_engine+0x36>
    3586:	3c 5f       	subi	r19, 0xFC	; 252
    3588:	3c 5f       	subi	r19, 0xFC	; 252
    358a:	3d 93       	st	X+, r19
    358c:	91 30       	cpi	r25, 0x01	; 1
    358e:	08 f0       	brcs	.+2      	; 0x3592 <__ftoa_engine+0x40>
    3590:	80 68       	ori	r24, 0x80	; 128
    3592:	91 1d       	adc	r25, r1
    3594:	df 93       	push	r29
    3596:	cf 93       	push	r28
    3598:	1f 93       	push	r17
    359a:	0f 93       	push	r16
    359c:	ff 92       	push	r15
    359e:	ef 92       	push	r14
    35a0:	19 2f       	mov	r17, r25
    35a2:	98 7f       	andi	r25, 0xF8	; 248
    35a4:	96 95       	lsr	r25
    35a6:	e9 2f       	mov	r30, r25
    35a8:	96 95       	lsr	r25
    35aa:	96 95       	lsr	r25
    35ac:	e9 0f       	add	r30, r25
    35ae:	ff 27       	eor	r31, r31
    35b0:	e6 53       	subi	r30, 0x36	; 54
    35b2:	ff 4f       	sbci	r31, 0xFF	; 255
    35b4:	99 27       	eor	r25, r25
    35b6:	33 27       	eor	r19, r19
    35b8:	ee 24       	eor	r14, r14
    35ba:	ff 24       	eor	r15, r15
    35bc:	a7 01       	movw	r20, r14
    35be:	e7 01       	movw	r28, r14
    35c0:	05 90       	lpm	r0, Z+
    35c2:	08 94       	sec
    35c4:	07 94       	ror	r0
    35c6:	28 f4       	brcc	.+10     	; 0x35d2 <__ftoa_engine+0x80>
    35c8:	36 0f       	add	r19, r22
    35ca:	e7 1e       	adc	r14, r23
    35cc:	f8 1e       	adc	r15, r24
    35ce:	49 1f       	adc	r20, r25
    35d0:	51 1d       	adc	r21, r1
    35d2:	66 0f       	add	r22, r22
    35d4:	77 1f       	adc	r23, r23
    35d6:	88 1f       	adc	r24, r24
    35d8:	99 1f       	adc	r25, r25
    35da:	06 94       	lsr	r0
    35dc:	a1 f7       	brne	.-24     	; 0x35c6 <__ftoa_engine+0x74>
    35de:	05 90       	lpm	r0, Z+
    35e0:	07 94       	ror	r0
    35e2:	28 f4       	brcc	.+10     	; 0x35ee <__ftoa_engine+0x9c>
    35e4:	e7 0e       	add	r14, r23
    35e6:	f8 1e       	adc	r15, r24
    35e8:	49 1f       	adc	r20, r25
    35ea:	56 1f       	adc	r21, r22
    35ec:	c1 1d       	adc	r28, r1
    35ee:	77 0f       	add	r23, r23
    35f0:	88 1f       	adc	r24, r24
    35f2:	99 1f       	adc	r25, r25
    35f4:	66 1f       	adc	r22, r22
    35f6:	06 94       	lsr	r0
    35f8:	a1 f7       	brne	.-24     	; 0x35e2 <__ftoa_engine+0x90>
    35fa:	05 90       	lpm	r0, Z+
    35fc:	07 94       	ror	r0
    35fe:	28 f4       	brcc	.+10     	; 0x360a <__ftoa_engine+0xb8>
    3600:	f8 0e       	add	r15, r24
    3602:	49 1f       	adc	r20, r25
    3604:	56 1f       	adc	r21, r22
    3606:	c7 1f       	adc	r28, r23
    3608:	d1 1d       	adc	r29, r1
    360a:	88 0f       	add	r24, r24
    360c:	99 1f       	adc	r25, r25
    360e:	66 1f       	adc	r22, r22
    3610:	77 1f       	adc	r23, r23
    3612:	06 94       	lsr	r0
    3614:	a1 f7       	brne	.-24     	; 0x35fe <__ftoa_engine+0xac>
    3616:	05 90       	lpm	r0, Z+
    3618:	07 94       	ror	r0
    361a:	20 f4       	brcc	.+8      	; 0x3624 <__ftoa_engine+0xd2>
    361c:	49 0f       	add	r20, r25
    361e:	56 1f       	adc	r21, r22
    3620:	c7 1f       	adc	r28, r23
    3622:	d8 1f       	adc	r29, r24
    3624:	99 0f       	add	r25, r25
    3626:	66 1f       	adc	r22, r22
    3628:	77 1f       	adc	r23, r23
    362a:	88 1f       	adc	r24, r24
    362c:	06 94       	lsr	r0
    362e:	a9 f7       	brne	.-22     	; 0x361a <__ftoa_engine+0xc8>
    3630:	84 91       	lpm	r24, Z
    3632:	10 95       	com	r17
    3634:	17 70       	andi	r17, 0x07	; 7
    3636:	41 f0       	breq	.+16     	; 0x3648 <__ftoa_engine+0xf6>
    3638:	d6 95       	lsr	r29
    363a:	c7 95       	ror	r28
    363c:	57 95       	ror	r21
    363e:	47 95       	ror	r20
    3640:	f7 94       	ror	r15
    3642:	e7 94       	ror	r14
    3644:	1a 95       	dec	r17
    3646:	c1 f7       	brne	.-16     	; 0x3638 <__ftoa_engine+0xe6>
    3648:	e0 e7       	ldi	r30, 0x70	; 112
    364a:	f0 e0       	ldi	r31, 0x00	; 0
    364c:	68 94       	set
    364e:	15 90       	lpm	r1, Z+
    3650:	15 91       	lpm	r17, Z+
    3652:	35 91       	lpm	r19, Z+
    3654:	65 91       	lpm	r22, Z+
    3656:	95 91       	lpm	r25, Z+
    3658:	05 90       	lpm	r0, Z+
    365a:	7f e2       	ldi	r23, 0x2F	; 47
    365c:	73 95       	inc	r23
    365e:	e1 18       	sub	r14, r1
    3660:	f1 0a       	sbc	r15, r17
    3662:	43 0b       	sbc	r20, r19
    3664:	56 0b       	sbc	r21, r22
    3666:	c9 0b       	sbc	r28, r25
    3668:	d0 09       	sbc	r29, r0
    366a:	c0 f7       	brcc	.-16     	; 0x365c <__ftoa_engine+0x10a>
    366c:	e1 0c       	add	r14, r1
    366e:	f1 1e       	adc	r15, r17
    3670:	43 1f       	adc	r20, r19
    3672:	56 1f       	adc	r21, r22
    3674:	c9 1f       	adc	r28, r25
    3676:	d0 1d       	adc	r29, r0
    3678:	7e f4       	brtc	.+30     	; 0x3698 <__ftoa_engine+0x146>
    367a:	70 33       	cpi	r23, 0x30	; 48
    367c:	11 f4       	brne	.+4      	; 0x3682 <__ftoa_engine+0x130>
    367e:	8a 95       	dec	r24
    3680:	e6 cf       	rjmp	.-52     	; 0x364e <__ftoa_engine+0xfc>
    3682:	e8 94       	clt
    3684:	01 50       	subi	r16, 0x01	; 1
    3686:	30 f0       	brcs	.+12     	; 0x3694 <__ftoa_engine+0x142>
    3688:	08 0f       	add	r16, r24
    368a:	0a f4       	brpl	.+2      	; 0x368e <__ftoa_engine+0x13c>
    368c:	00 27       	eor	r16, r16
    368e:	02 17       	cp	r16, r18
    3690:	08 f4       	brcc	.+2      	; 0x3694 <__ftoa_engine+0x142>
    3692:	20 2f       	mov	r18, r16
    3694:	23 95       	inc	r18
    3696:	02 2f       	mov	r16, r18
    3698:	7a 33       	cpi	r23, 0x3A	; 58
    369a:	28 f0       	brcs	.+10     	; 0x36a6 <__ftoa_engine+0x154>
    369c:	79 e3       	ldi	r23, 0x39	; 57
    369e:	7d 93       	st	X+, r23
    36a0:	2a 95       	dec	r18
    36a2:	e9 f7       	brne	.-6      	; 0x369e <__ftoa_engine+0x14c>
    36a4:	10 c0       	rjmp	.+32     	; 0x36c6 <__ftoa_engine+0x174>
    36a6:	7d 93       	st	X+, r23
    36a8:	2a 95       	dec	r18
    36aa:	89 f6       	brne	.-94     	; 0x364e <__ftoa_engine+0xfc>
    36ac:	06 94       	lsr	r0
    36ae:	97 95       	ror	r25
    36b0:	67 95       	ror	r22
    36b2:	37 95       	ror	r19
    36b4:	17 95       	ror	r17
    36b6:	17 94       	ror	r1
    36b8:	e1 18       	sub	r14, r1
    36ba:	f1 0a       	sbc	r15, r17
    36bc:	43 0b       	sbc	r20, r19
    36be:	56 0b       	sbc	r21, r22
    36c0:	c9 0b       	sbc	r28, r25
    36c2:	d0 09       	sbc	r29, r0
    36c4:	98 f0       	brcs	.+38     	; 0x36ec <__ftoa_engine+0x19a>
    36c6:	23 95       	inc	r18
    36c8:	7e 91       	ld	r23, -X
    36ca:	73 95       	inc	r23
    36cc:	7a 33       	cpi	r23, 0x3A	; 58
    36ce:	08 f0       	brcs	.+2      	; 0x36d2 <__ftoa_engine+0x180>
    36d0:	70 e3       	ldi	r23, 0x30	; 48
    36d2:	7c 93       	st	X, r23
    36d4:	20 13       	cpse	r18, r16
    36d6:	b8 f7       	brcc	.-18     	; 0x36c6 <__ftoa_engine+0x174>
    36d8:	7e 91       	ld	r23, -X
    36da:	70 61       	ori	r23, 0x10	; 16
    36dc:	7d 93       	st	X+, r23
    36de:	30 f0       	brcs	.+12     	; 0x36ec <__ftoa_engine+0x19a>
    36e0:	83 95       	inc	r24
    36e2:	71 e3       	ldi	r23, 0x31	; 49
    36e4:	7d 93       	st	X+, r23
    36e6:	70 e3       	ldi	r23, 0x30	; 48
    36e8:	2a 95       	dec	r18
    36ea:	e1 f7       	brne	.-8      	; 0x36e4 <__ftoa_engine+0x192>
    36ec:	11 24       	eor	r1, r1
    36ee:	ef 90       	pop	r14
    36f0:	ff 90       	pop	r15
    36f2:	0f 91       	pop	r16
    36f4:	1f 91       	pop	r17
    36f6:	cf 91       	pop	r28
    36f8:	df 91       	pop	r29
    36fa:	99 27       	eor	r25, r25
    36fc:	87 fd       	sbrc	r24, 7
    36fe:	90 95       	com	r25
    3700:	08 95       	ret

00003702 <strnlen_P>:
    3702:	fc 01       	movw	r30, r24
    3704:	05 90       	lpm	r0, Z+
    3706:	61 50       	subi	r22, 0x01	; 1
    3708:	70 40       	sbci	r23, 0x00	; 0
    370a:	01 10       	cpse	r0, r1
    370c:	d8 f7       	brcc	.-10     	; 0x3704 <strnlen_P+0x2>
    370e:	80 95       	com	r24
    3710:	90 95       	com	r25
    3712:	8e 0f       	add	r24, r30
    3714:	9f 1f       	adc	r25, r31
    3716:	08 95       	ret

00003718 <strtok>:
    3718:	49 ef       	ldi	r20, 0xF9	; 249
    371a:	57 e0       	ldi	r21, 0x07	; 7
    371c:	0e 94 b3 1b 	call	0x3766	; 0x3766 <strtok_r>
    3720:	08 95       	ret

00003722 <memcpy>:
    3722:	fb 01       	movw	r30, r22
    3724:	dc 01       	movw	r26, r24
    3726:	02 c0       	rjmp	.+4      	; 0x372c <memcpy+0xa>
    3728:	01 90       	ld	r0, Z+
    372a:	0d 92       	st	X+, r0
    372c:	41 50       	subi	r20, 0x01	; 1
    372e:	50 40       	sbci	r21, 0x00	; 0
    3730:	d8 f7       	brcc	.-10     	; 0x3728 <memcpy+0x6>
    3732:	08 95       	ret

00003734 <strncmp>:
    3734:	fb 01       	movw	r30, r22
    3736:	dc 01       	movw	r26, r24
    3738:	41 50       	subi	r20, 0x01	; 1
    373a:	50 40       	sbci	r21, 0x00	; 0
    373c:	30 f0       	brcs	.+12     	; 0x374a <strncmp+0x16>
    373e:	8d 91       	ld	r24, X+
    3740:	01 90       	ld	r0, Z+
    3742:	80 19       	sub	r24, r0
    3744:	19 f4       	brne	.+6      	; 0x374c <strncmp+0x18>
    3746:	00 20       	and	r0, r0
    3748:	b9 f7       	brne	.-18     	; 0x3738 <strncmp+0x4>
    374a:	88 1b       	sub	r24, r24
    374c:	99 0b       	sbc	r25, r25
    374e:	08 95       	ret

00003750 <strnlen>:
    3750:	fc 01       	movw	r30, r24
    3752:	61 50       	subi	r22, 0x01	; 1
    3754:	70 40       	sbci	r23, 0x00	; 0
    3756:	01 90       	ld	r0, Z+
    3758:	01 10       	cpse	r0, r1
    375a:	d8 f7       	brcc	.-10     	; 0x3752 <strnlen+0x2>
    375c:	80 95       	com	r24
    375e:	90 95       	com	r25
    3760:	8e 0f       	add	r24, r30
    3762:	9f 1f       	adc	r25, r31
    3764:	08 95       	ret

00003766 <strtok_r>:
    3766:	fa 01       	movw	r30, r20
    3768:	a1 91       	ld	r26, Z+
    376a:	b0 81       	ld	r27, Z
    376c:	00 97       	sbiw	r24, 0x00	; 0
    376e:	19 f4       	brne	.+6      	; 0x3776 <strtok_r+0x10>
    3770:	10 97       	sbiw	r26, 0x00	; 0
    3772:	e1 f0       	breq	.+56     	; 0x37ac <strtok_r+0x46>
    3774:	cd 01       	movw	r24, r26
    3776:	dc 01       	movw	r26, r24
    3778:	cd 01       	movw	r24, r26
    377a:	0d 90       	ld	r0, X+
    377c:	00 20       	and	r0, r0
    377e:	11 f4       	brne	.+4      	; 0x3784 <strtok_r+0x1e>
    3780:	c0 01       	movw	r24, r0
    3782:	13 c0       	rjmp	.+38     	; 0x37aa <strtok_r+0x44>
    3784:	fb 01       	movw	r30, r22
    3786:	21 91       	ld	r18, Z+
    3788:	22 23       	and	r18, r18
    378a:	19 f0       	breq	.+6      	; 0x3792 <strtok_r+0x2c>
    378c:	20 15       	cp	r18, r0
    378e:	d9 f7       	brne	.-10     	; 0x3786 <strtok_r+0x20>
    3790:	f3 cf       	rjmp	.-26     	; 0x3778 <strtok_r+0x12>
    3792:	fb 01       	movw	r30, r22
    3794:	21 91       	ld	r18, Z+
    3796:	20 15       	cp	r18, r0
    3798:	19 f4       	brne	.+6      	; 0x37a0 <strtok_r+0x3a>
    379a:	1e 92       	st	-X, r1
    379c:	11 96       	adiw	r26, 0x01	; 1
    379e:	06 c0       	rjmp	.+12     	; 0x37ac <strtok_r+0x46>
    37a0:	22 23       	and	r18, r18
    37a2:	c1 f7       	brne	.-16     	; 0x3794 <strtok_r+0x2e>
    37a4:	0d 90       	ld	r0, X+
    37a6:	00 20       	and	r0, r0
    37a8:	a1 f7       	brne	.-24     	; 0x3792 <strtok_r+0x2c>
    37aa:	d0 01       	movw	r26, r0
    37ac:	fa 01       	movw	r30, r20
    37ae:	a1 93       	st	Z+, r26
    37b0:	b0 83       	st	Z, r27
    37b2:	08 95       	ret

000037b4 <__mulhi_const_10>:
    37b4:	7a e0       	ldi	r23, 0x0A	; 10
    37b6:	97 9f       	mul	r25, r23
    37b8:	90 2d       	mov	r25, r0
    37ba:	87 9f       	mul	r24, r23
    37bc:	80 2d       	mov	r24, r0
    37be:	91 0d       	add	r25, r1
    37c0:	11 24       	eor	r1, r1
    37c2:	08 95       	ret

000037c4 <fgetc>:
    37c4:	cf 93       	push	r28
    37c6:	df 93       	push	r29
    37c8:	ec 01       	movw	r28, r24
    37ca:	2b 81       	ldd	r18, Y+3	; 0x03
    37cc:	20 ff       	sbrs	r18, 0
    37ce:	33 c0       	rjmp	.+102    	; 0x3836 <fgetc+0x72>
    37d0:	26 ff       	sbrs	r18, 6
    37d2:	0a c0       	rjmp	.+20     	; 0x37e8 <fgetc+0x24>
    37d4:	2f 7b       	andi	r18, 0xBF	; 191
    37d6:	2b 83       	std	Y+3, r18	; 0x03
    37d8:	8e 81       	ldd	r24, Y+6	; 0x06
    37da:	9f 81       	ldd	r25, Y+7	; 0x07
    37dc:	01 96       	adiw	r24, 0x01	; 1
    37de:	9f 83       	std	Y+7, r25	; 0x07
    37e0:	8e 83       	std	Y+6, r24	; 0x06
    37e2:	8a 81       	ldd	r24, Y+2	; 0x02
    37e4:	90 e0       	ldi	r25, 0x00	; 0
    37e6:	29 c0       	rjmp	.+82     	; 0x383a <fgetc+0x76>
    37e8:	22 ff       	sbrs	r18, 2
    37ea:	0f c0       	rjmp	.+30     	; 0x380a <fgetc+0x46>
    37ec:	e8 81       	ld	r30, Y
    37ee:	f9 81       	ldd	r31, Y+1	; 0x01
    37f0:	80 81       	ld	r24, Z
    37f2:	08 2e       	mov	r0, r24
    37f4:	00 0c       	add	r0, r0
    37f6:	99 0b       	sbc	r25, r25
    37f8:	00 97       	sbiw	r24, 0x00	; 0
    37fa:	19 f4       	brne	.+6      	; 0x3802 <fgetc+0x3e>
    37fc:	20 62       	ori	r18, 0x20	; 32
    37fe:	2b 83       	std	Y+3, r18	; 0x03
    3800:	1a c0       	rjmp	.+52     	; 0x3836 <fgetc+0x72>
    3802:	31 96       	adiw	r30, 0x01	; 1
    3804:	f9 83       	std	Y+1, r31	; 0x01
    3806:	e8 83       	st	Y, r30
    3808:	0e c0       	rjmp	.+28     	; 0x3826 <fgetc+0x62>
    380a:	ea 85       	ldd	r30, Y+10	; 0x0a
    380c:	fb 85       	ldd	r31, Y+11	; 0x0b
    380e:	09 95       	icall
    3810:	97 ff       	sbrs	r25, 7
    3812:	09 c0       	rjmp	.+18     	; 0x3826 <fgetc+0x62>
    3814:	2b 81       	ldd	r18, Y+3	; 0x03
    3816:	01 96       	adiw	r24, 0x01	; 1
    3818:	11 f0       	breq	.+4      	; 0x381e <fgetc+0x5a>
    381a:	80 e2       	ldi	r24, 0x20	; 32
    381c:	01 c0       	rjmp	.+2      	; 0x3820 <fgetc+0x5c>
    381e:	80 e1       	ldi	r24, 0x10	; 16
    3820:	82 2b       	or	r24, r18
    3822:	8b 83       	std	Y+3, r24	; 0x03
    3824:	08 c0       	rjmp	.+16     	; 0x3836 <fgetc+0x72>
    3826:	2e 81       	ldd	r18, Y+6	; 0x06
    3828:	3f 81       	ldd	r19, Y+7	; 0x07
    382a:	2f 5f       	subi	r18, 0xFF	; 255
    382c:	3f 4f       	sbci	r19, 0xFF	; 255
    382e:	3f 83       	std	Y+7, r19	; 0x07
    3830:	2e 83       	std	Y+6, r18	; 0x06
    3832:	99 27       	eor	r25, r25
    3834:	02 c0       	rjmp	.+4      	; 0x383a <fgetc+0x76>
    3836:	8f ef       	ldi	r24, 0xFF	; 255
    3838:	9f ef       	ldi	r25, 0xFF	; 255
    383a:	df 91       	pop	r29
    383c:	cf 91       	pop	r28
    383e:	08 95       	ret

00003840 <fputc>:
    3840:	0f 93       	push	r16
    3842:	1f 93       	push	r17
    3844:	cf 93       	push	r28
    3846:	df 93       	push	r29
    3848:	fb 01       	movw	r30, r22
    384a:	23 81       	ldd	r18, Z+3	; 0x03
    384c:	21 fd       	sbrc	r18, 1
    384e:	03 c0       	rjmp	.+6      	; 0x3856 <fputc+0x16>
    3850:	8f ef       	ldi	r24, 0xFF	; 255
    3852:	9f ef       	ldi	r25, 0xFF	; 255
    3854:	2c c0       	rjmp	.+88     	; 0x38ae <fputc+0x6e>
    3856:	22 ff       	sbrs	r18, 2
    3858:	16 c0       	rjmp	.+44     	; 0x3886 <fputc+0x46>
    385a:	46 81       	ldd	r20, Z+6	; 0x06
    385c:	57 81       	ldd	r21, Z+7	; 0x07
    385e:	24 81       	ldd	r18, Z+4	; 0x04
    3860:	35 81       	ldd	r19, Z+5	; 0x05
    3862:	42 17       	cp	r20, r18
    3864:	53 07       	cpc	r21, r19
    3866:	44 f4       	brge	.+16     	; 0x3878 <fputc+0x38>
    3868:	a0 81       	ld	r26, Z
    386a:	b1 81       	ldd	r27, Z+1	; 0x01
    386c:	9d 01       	movw	r18, r26
    386e:	2f 5f       	subi	r18, 0xFF	; 255
    3870:	3f 4f       	sbci	r19, 0xFF	; 255
    3872:	31 83       	std	Z+1, r19	; 0x01
    3874:	20 83       	st	Z, r18
    3876:	8c 93       	st	X, r24
    3878:	26 81       	ldd	r18, Z+6	; 0x06
    387a:	37 81       	ldd	r19, Z+7	; 0x07
    387c:	2f 5f       	subi	r18, 0xFF	; 255
    387e:	3f 4f       	sbci	r19, 0xFF	; 255
    3880:	37 83       	std	Z+7, r19	; 0x07
    3882:	26 83       	std	Z+6, r18	; 0x06
    3884:	14 c0       	rjmp	.+40     	; 0x38ae <fputc+0x6e>
    3886:	8b 01       	movw	r16, r22
    3888:	ec 01       	movw	r28, r24
    388a:	fb 01       	movw	r30, r22
    388c:	00 84       	ldd	r0, Z+8	; 0x08
    388e:	f1 85       	ldd	r31, Z+9	; 0x09
    3890:	e0 2d       	mov	r30, r0
    3892:	09 95       	icall
    3894:	89 2b       	or	r24, r25
    3896:	e1 f6       	brne	.-72     	; 0x3850 <fputc+0x10>
    3898:	d8 01       	movw	r26, r16
    389a:	16 96       	adiw	r26, 0x06	; 6
    389c:	8d 91       	ld	r24, X+
    389e:	9c 91       	ld	r25, X
    38a0:	17 97       	sbiw	r26, 0x07	; 7
    38a2:	01 96       	adiw	r24, 0x01	; 1
    38a4:	17 96       	adiw	r26, 0x07	; 7
    38a6:	9c 93       	st	X, r25
    38a8:	8e 93       	st	-X, r24
    38aa:	16 97       	sbiw	r26, 0x06	; 6
    38ac:	ce 01       	movw	r24, r28
    38ae:	df 91       	pop	r29
    38b0:	cf 91       	pop	r28
    38b2:	1f 91       	pop	r17
    38b4:	0f 91       	pop	r16
    38b6:	08 95       	ret

000038b8 <printf>:
    38b8:	a0 e0       	ldi	r26, 0x00	; 0
    38ba:	b0 e0       	ldi	r27, 0x00	; 0
    38bc:	e2 e6       	ldi	r30, 0x62	; 98
    38be:	fc e1       	ldi	r31, 0x1C	; 28
    38c0:	0c 94 4e 18 	jmp	0x309c	; 0x309c <__prologue_saves__+0x20>
    38c4:	ae 01       	movw	r20, r28
    38c6:	4b 5f       	subi	r20, 0xFB	; 251
    38c8:	5f 4f       	sbci	r21, 0xFF	; 255
    38ca:	fa 01       	movw	r30, r20
    38cc:	61 91       	ld	r22, Z+
    38ce:	71 91       	ld	r23, Z+
    38d0:	af 01       	movw	r20, r30
    38d2:	80 91 ff 07 	lds	r24, 0x07FF	; 0x8007ff <__iob+0x2>
    38d6:	90 91 00 08 	lds	r25, 0x0800	; 0x800800 <__iob+0x3>
    38da:	0e 94 34 14 	call	0x2868	; 0x2868 <vfprintf>
    38de:	e2 e0       	ldi	r30, 0x02	; 2
    38e0:	0c 94 6a 18 	jmp	0x30d4	; 0x30d4 <__epilogue_restores__+0x20>

000038e4 <__ultoa_invert>:
    38e4:	fa 01       	movw	r30, r20
    38e6:	aa 27       	eor	r26, r26
    38e8:	28 30       	cpi	r18, 0x08	; 8
    38ea:	51 f1       	breq	.+84     	; 0x3940 <__ultoa_invert+0x5c>
    38ec:	20 31       	cpi	r18, 0x10	; 16
    38ee:	81 f1       	breq	.+96     	; 0x3950 <__ultoa_invert+0x6c>
    38f0:	e8 94       	clt
    38f2:	6f 93       	push	r22
    38f4:	6e 7f       	andi	r22, 0xFE	; 254
    38f6:	6e 5f       	subi	r22, 0xFE	; 254
    38f8:	7f 4f       	sbci	r23, 0xFF	; 255
    38fa:	8f 4f       	sbci	r24, 0xFF	; 255
    38fc:	9f 4f       	sbci	r25, 0xFF	; 255
    38fe:	af 4f       	sbci	r26, 0xFF	; 255
    3900:	b1 e0       	ldi	r27, 0x01	; 1
    3902:	3e d0       	rcall	.+124    	; 0x3980 <__ultoa_invert+0x9c>
    3904:	b4 e0       	ldi	r27, 0x04	; 4
    3906:	3c d0       	rcall	.+120    	; 0x3980 <__ultoa_invert+0x9c>
    3908:	67 0f       	add	r22, r23
    390a:	78 1f       	adc	r23, r24
    390c:	89 1f       	adc	r24, r25
    390e:	9a 1f       	adc	r25, r26
    3910:	a1 1d       	adc	r26, r1
    3912:	68 0f       	add	r22, r24
    3914:	79 1f       	adc	r23, r25
    3916:	8a 1f       	adc	r24, r26
    3918:	91 1d       	adc	r25, r1
    391a:	a1 1d       	adc	r26, r1
    391c:	6a 0f       	add	r22, r26
    391e:	71 1d       	adc	r23, r1
    3920:	81 1d       	adc	r24, r1
    3922:	91 1d       	adc	r25, r1
    3924:	a1 1d       	adc	r26, r1
    3926:	20 d0       	rcall	.+64     	; 0x3968 <__ultoa_invert+0x84>
    3928:	09 f4       	brne	.+2      	; 0x392c <__ultoa_invert+0x48>
    392a:	68 94       	set
    392c:	3f 91       	pop	r19
    392e:	2a e0       	ldi	r18, 0x0A	; 10
    3930:	26 9f       	mul	r18, r22
    3932:	11 24       	eor	r1, r1
    3934:	30 19       	sub	r19, r0
    3936:	30 5d       	subi	r19, 0xD0	; 208
    3938:	31 93       	st	Z+, r19
    393a:	de f6       	brtc	.-74     	; 0x38f2 <__ultoa_invert+0xe>
    393c:	cf 01       	movw	r24, r30
    393e:	08 95       	ret
    3940:	46 2f       	mov	r20, r22
    3942:	47 70       	andi	r20, 0x07	; 7
    3944:	40 5d       	subi	r20, 0xD0	; 208
    3946:	41 93       	st	Z+, r20
    3948:	b3 e0       	ldi	r27, 0x03	; 3
    394a:	0f d0       	rcall	.+30     	; 0x396a <__ultoa_invert+0x86>
    394c:	c9 f7       	brne	.-14     	; 0x3940 <__ultoa_invert+0x5c>
    394e:	f6 cf       	rjmp	.-20     	; 0x393c <__ultoa_invert+0x58>
    3950:	46 2f       	mov	r20, r22
    3952:	4f 70       	andi	r20, 0x0F	; 15
    3954:	40 5d       	subi	r20, 0xD0	; 208
    3956:	4a 33       	cpi	r20, 0x3A	; 58
    3958:	18 f0       	brcs	.+6      	; 0x3960 <__ultoa_invert+0x7c>
    395a:	49 5d       	subi	r20, 0xD9	; 217
    395c:	31 fd       	sbrc	r19, 1
    395e:	40 52       	subi	r20, 0x20	; 32
    3960:	41 93       	st	Z+, r20
    3962:	02 d0       	rcall	.+4      	; 0x3968 <__ultoa_invert+0x84>
    3964:	a9 f7       	brne	.-22     	; 0x3950 <__ultoa_invert+0x6c>
    3966:	ea cf       	rjmp	.-44     	; 0x393c <__ultoa_invert+0x58>
    3968:	b4 e0       	ldi	r27, 0x04	; 4
    396a:	a6 95       	lsr	r26
    396c:	97 95       	ror	r25
    396e:	87 95       	ror	r24
    3970:	77 95       	ror	r23
    3972:	67 95       	ror	r22
    3974:	ba 95       	dec	r27
    3976:	c9 f7       	brne	.-14     	; 0x396a <__ultoa_invert+0x86>
    3978:	00 97       	sbiw	r24, 0x00	; 0
    397a:	61 05       	cpc	r22, r1
    397c:	71 05       	cpc	r23, r1
    397e:	08 95       	ret
    3980:	9b 01       	movw	r18, r22
    3982:	ac 01       	movw	r20, r24
    3984:	0a 2e       	mov	r0, r26
    3986:	06 94       	lsr	r0
    3988:	57 95       	ror	r21
    398a:	47 95       	ror	r20
    398c:	37 95       	ror	r19
    398e:	27 95       	ror	r18
    3990:	ba 95       	dec	r27
    3992:	c9 f7       	brne	.-14     	; 0x3986 <__ultoa_invert+0xa2>
    3994:	62 0f       	add	r22, r18
    3996:	73 1f       	adc	r23, r19
    3998:	84 1f       	adc	r24, r20
    399a:	95 1f       	adc	r25, r21
    399c:	a0 1d       	adc	r26, r0
    399e:	08 95       	ret

000039a0 <_exit>:
    39a0:	f8 94       	cli

000039a2 <__stop_program>:
    39a2:	ff cf       	rjmp	.-2      	; 0x39a2 <__stop_program>

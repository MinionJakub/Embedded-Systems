
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  000024ae  00002542  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000024ae  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006a0  00800112  00800112  00002554  2**0
                  ALLOC
  3 .stab         000072cc  00000000  00000000  00002554  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004385  00000000  00000000  00009820  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000dba5  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000dbb8  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000dbf8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000e1ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000e78e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0000e7a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 16 12 	jmp	0x242c	; 0x242c <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ee ea       	ldi	r30, 0xAE	; 174
      7c:	f4 e2       	ldi	r31, 0x24	; 36
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a2 31       	cpi	r26, 0x12	; 18
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	a2 e1       	ldi	r26, 0x12	; 18
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a2 3b       	cpi	r26, 0xB2	; 178
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 19 12 	call	0x2432	; 0x2432 <main>
      9e:	0c 94 55 12 	jmp	0x24aa	; 0x24aa <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vButton>:
}


static void vButton(void* pvParameters)
{
    BUTTON_DDR &= ~_BV(BUTTON);
      a6:	3c 98       	cbi	0x07, 4	; 7
    BUTTON_PORT |= _BV(BUTTON);
      a8:	44 9a       	sbi	0x08, 4	; 8

    LED_DDR2  |= _BV(LED);
      aa:	21 9a       	sbi	0x04, 1	; 4
    uint8_t crossed_100 = 0;
    uint8_t place;
    uint8_t bit;
    uint8_t writer = 0;
      ac:	c0 e0       	ldi	r28, 0x00	; 0
{
    BUTTON_DDR &= ~_BV(BUTTON);
    BUTTON_PORT |= _BV(BUTTON);

    LED_DDR2  |= _BV(LED);
    uint8_t crossed_100 = 0;
      ae:	f1 2c       	mov	r15, r1
    uint8_t place;
    uint8_t bit;
    uint8_t writer = 0;
    uint8_t reader = 0;
      b0:	d0 e0       	ldi	r29, 0x00	; 0
        bit = get_bit(writer);
        if(!(PINC&_BV(BUTTON))){
            cirular_buffer[place] |= _BV(bit);
        }
        else{
            cirular_buffer[place] &= ~_BV(bit);
      b2:	01 e0       	ldi	r16, 0x01	; 1
      b4:	10 e0       	ldi	r17, 0x00	; 0
    uint8_t reader = 0;
    // while(1) LED_PORT2 |= _BV(LED);
    while(1){
        if(reader == 255)
            reader = 0;
        if(writer == 255)
      b6:	cf 3f       	cpi	r28, 0xFF	; 255
      b8:	29 f0       	breq	.+10     	; 0xc4 <vButton+0x1e>
            writer = 0;
        if(!crossed_100 && writer == 100)
      ba:	f1 10       	cpse	r15, r1
      bc:	0a c0       	rjmp	.+20     	; 0xd2 <vButton+0x2c>
      be:	c4 36       	cpi	r28, 0x64	; 100
      c0:	21 f4       	brne	.+8      	; 0xca <vButton+0x24>
      c2:	05 c0       	rjmp	.+10     	; 0xce <vButton+0x28>
    // while(1) LED_PORT2 |= _BV(LED);
    while(1){
        if(reader == 255)
            reader = 0;
        if(writer == 255)
            writer = 0;
      c4:	c0 e0       	ldi	r28, 0x00	; 0
        if(!crossed_100 && writer == 100)
      c6:	f1 10       	cpse	r15, r1
      c8:	04 c0       	rjmp	.+8      	; 0xd2 <vButton+0x2c>
    // while(1) LED_PORT2 |= _BV(LED);
    while(1){
        if(reader == 255)
            reader = 0;
        if(writer == 255)
            writer = 0;
      ca:	f1 2c       	mov	r15, r1
      cc:	02 c0       	rjmp	.+4      	; 0xd2 <vButton+0x2c>
        if(!crossed_100 && writer == 100)
            crossed_100 = 1;
      ce:	ff 24       	eor	r15, r15
      d0:	f3 94       	inc	r15
static inline uint8_t get_place(uint8_t value){
    return (value >> 3);
}

static inline uint8_t get_bit(uint8_t value){
    return (value&7);
      d2:	8c 2f       	mov	r24, r28
      d4:	87 70       	andi	r24, 0x07	; 7
      d6:	ec 2f       	mov	r30, r28
      d8:	e6 95       	lsr	r30
      da:	e6 95       	lsr	r30
      dc:	e6 95       	lsr	r30
      de:	f0 e0       	ldi	r31, 0x00	; 0
        if(!crossed_100 && writer == 100)
            crossed_100 = 1;
        place = get_place(writer);
        bit = get_bit(writer);
        if(!(PINC&_BV(BUTTON))){
            cirular_buffer[place] |= _BV(bit);
      e0:	ee 5e       	subi	r30, 0xEE	; 238
      e2:	fe 4f       	sbci	r31, 0xFE	; 254
      e4:	98 01       	movw	r18, r16
      e6:	02 c0       	rjmp	.+4      	; 0xec <vButton+0x46>
      e8:	22 0f       	add	r18, r18
      ea:	33 1f       	adc	r19, r19
      ec:	8a 95       	dec	r24
      ee:	e2 f7       	brpl	.-8      	; 0xe8 <vButton+0x42>
      f0:	c9 01       	movw	r24, r18
            writer = 0;
        if(!crossed_100 && writer == 100)
            crossed_100 = 1;
        place = get_place(writer);
        bit = get_bit(writer);
        if(!(PINC&_BV(BUTTON))){
      f2:	34 99       	sbic	0x06, 4	; 6
      f4:	03 c0       	rjmp	.+6      	; 0xfc <vButton+0x56>
            cirular_buffer[place] |= _BV(bit);
      f6:	90 81       	ld	r25, Z
      f8:	89 2b       	or	r24, r25
      fa:	03 c0       	rjmp	.+6      	; 0x102 <vButton+0x5c>
        }
        else{
            cirular_buffer[place] &= ~_BV(bit);
      fc:	80 95       	com	r24
      fe:	90 81       	ld	r25, Z
     100:	89 23       	and	r24, r25
     102:	80 83       	st	Z, r24
        }
        writer++;
     104:	cf 5f       	subi	r28, 0xFF	; 255
        if(crossed_100){
     106:	ff 20       	and	r15, r15
     108:	b9 f0       	breq	.+46     	; 0x138 <vButton+0x92>
            place = get_place(reader);
            bit = get_bit(reader);
            light(cirular_buffer[place]&_BV(bit));
     10a:	ed 2f       	mov	r30, r29
     10c:	e6 95       	lsr	r30
     10e:	e6 95       	lsr	r30
     110:	e6 95       	lsr	r30
     112:	f0 e0       	ldi	r31, 0x00	; 0
     114:	ee 5e       	subi	r30, 0xEE	; 238
     116:	fe 4f       	sbci	r31, 0xFE	; 254
static inline uint8_t get_bit(uint8_t value){
    return (value&7);
}

static inline void light(uint8_t value){
    if(value)
     118:	8d 2f       	mov	r24, r29
     11a:	87 70       	andi	r24, 0x07	; 7
     11c:	98 01       	movw	r18, r16
     11e:	02 c0       	rjmp	.+4      	; 0x124 <vButton+0x7e>
     120:	22 0f       	add	r18, r18
     122:	33 1f       	adc	r19, r19
     124:	8a 95       	dec	r24
     126:	e2 f7       	brpl	.-8      	; 0x120 <vButton+0x7a>
     128:	c9 01       	movw	r24, r18
     12a:	90 81       	ld	r25, Z
     12c:	89 23       	and	r24, r25
     12e:	11 f0       	breq	.+4      	; 0x134 <vButton+0x8e>
        LED_PORT2 |= _BV(LED);
     130:	29 9a       	sbi	0x05, 1	; 5
     132:	01 c0       	rjmp	.+2      	; 0x136 <vButton+0x90>
    else
        LED_PORT2 &= ~_BV(LED);
     134:	29 98       	cbi	0x05, 1	; 5
        writer++;
        if(crossed_100){
            place = get_place(reader);
            bit = get_bit(reader);
            light(cirular_buffer[place]&_BV(bit));
            reader++;
     136:	df 5f       	subi	r29, 0xFF	; 255
        }
        vTaskDelay(10/portTICK_PERIOD_MS);
     138:	8a e0       	ldi	r24, 0x0A	; 10
     13a:	90 e0       	ldi	r25, 0x00	; 0
     13c:	0e 94 5e 05 	call	0xabc	; 0xabc <vTaskDelay>
    uint8_t bit;
    uint8_t writer = 0;
    uint8_t reader = 0;
    // while(1) LED_PORT2 |= _BV(LED);
    while(1){
        if(reader == 255)
     140:	df 3f       	cpi	r29, 0xFF	; 255
     142:	09 f0       	breq	.+2      	; 0x146 <vButton+0xa0>
     144:	b8 cf       	rjmp	.-144    	; 0xb6 <vButton+0x10>
            reader = 0;
     146:	d0 e0       	ldi	r29, 0x00	; 0
     148:	b6 cf       	rjmp	.-148    	; 0xb6 <vButton+0x10>

0000014a <vLED_counter>:
#define LED_DDR DDRD
#define LED_PORT PORTD

static void vLED_counter(void* pvParameters)
{
    UCSR0B &= ~_BV(RXEN0) & ~_BV(TXEN0);
     14a:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     14e:	87 7e       	andi	r24, 0xE7	; 231
     150:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
    LED_DDR = 0xff;
     154:	8f ef       	ldi	r24, 0xFF	; 255
     156:	8a b9       	out	0x0a, r24	; 10
    LED_PORT = 0;
     158:	1b b8       	out	0x0b, r1	; 11
                LED_PORT &= ~_BV(i-1);
            }
            if(i > 1){
                LED_PORT &= ~_BV(i-2);
            }
            LED_PORT |= _BV(i);
     15a:	01 e0       	ldi	r16, 0x01	; 1
     15c:	10 e0       	ldi	r17, 0x00	; 0
// #define LED PD0
#define LED_DDR DDRD
#define LED_PORT PORTD

static void vLED_counter(void* pvParameters)
{
     15e:	c1 e0       	ldi	r28, 0x01	; 1
     160:	d0 e0       	ldi	r29, 0x00	; 0
     162:	e1 2c       	mov	r14, r1
     164:	f1 2c       	mov	r15, r1
                LED_PORT &= ~_BV(i-1);
            }
            if(i > 1){
                LED_PORT &= ~_BV(i-2);
            }
            LED_PORT |= _BV(i);
     166:	8b b1       	in	r24, 0x0b	; 11
     168:	68 01       	movw	r12, r16
     16a:	0e 2c       	mov	r0, r14
     16c:	01 c0       	rjmp	.+2      	; 0x170 <vLED_counter+0x26>
     16e:	cc 0c       	add	r12, r12
     170:	0a 94       	dec	r0
     172:	ea f7       	brpl	.-6      	; 0x16e <vLED_counter+0x24>
     174:	8c 29       	or	r24, r12
     176:	8b b9       	out	0x0b, r24	; 11
            LED_PORT |= _BV(i+1);
     178:	2b b1       	in	r18, 0x0b	; 11
     17a:	c8 01       	movw	r24, r16
     17c:	0c 2e       	mov	r0, r28
     17e:	01 c0       	rjmp	.+2      	; 0x182 <vLED_counter+0x38>
     180:	88 0f       	add	r24, r24
     182:	0a 94       	dec	r0
     184:	ea f7       	brpl	.-6      	; 0x180 <vLED_counter+0x36>
     186:	82 2b       	or	r24, r18
     188:	8b b9       	out	0x0b, r24	; 11
            LED_PORT |= _BV(i+2);
     18a:	2b b1       	in	r18, 0x0b	; 11
     18c:	c7 01       	movw	r24, r14
     18e:	02 96       	adiw	r24, 0x02	; 2
     190:	a8 01       	movw	r20, r16
     192:	02 c0       	rjmp	.+4      	; 0x198 <vLED_counter+0x4e>
     194:	44 0f       	add	r20, r20
     196:	55 1f       	adc	r21, r21
     198:	8a 95       	dec	r24
     19a:	e2 f7       	brpl	.-8      	; 0x194 <vLED_counter+0x4a>
     19c:	ca 01       	movw	r24, r20
     19e:	82 2b       	or	r24, r18
     1a0:	8b b9       	out	0x0b, r24	; 11
            vTaskDelay(100/portTICK_PERIOD_MS);
     1a2:	84 e6       	ldi	r24, 0x64	; 100
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	0e 94 5e 05 	call	0xabc	; 0xabc <vTaskDelay>
{
    UCSR0B &= ~_BV(RXEN0) & ~_BV(TXEN0);
    LED_DDR = 0xff;
    LED_PORT = 0;
    while (1) {
        for(int8_t i = 0; i <= 5; i++){
     1aa:	c6 30       	cpi	r28, 0x06	; 6
     1ac:	d1 05       	cpc	r29, r1
     1ae:	c9 f0       	breq	.+50     	; 0x1e2 <vLED_counter+0x98>
            if(i > 0){
                LED_PORT &= ~_BV(i-1);
     1b0:	8b b1       	in	r24, 0x0b	; 11
     1b2:	c0 94       	com	r12
     1b4:	c8 22       	and	r12, r24
     1b6:	cb b8       	out	0x0b, r12	; 11
            }
            if(i > 1){
     1b8:	c1 30       	cpi	r28, 0x01	; 1
     1ba:	71 f0       	breq	.+28     	; 0x1d8 <vLED_counter+0x8e>
                LED_PORT &= ~_BV(i-2);
     1bc:	9b b1       	in	r25, 0x0b	; 11
     1be:	97 01       	movw	r18, r14
     1c0:	21 50       	subi	r18, 0x01	; 1
     1c2:	31 09       	sbc	r19, r1
     1c4:	a8 01       	movw	r20, r16
     1c6:	02 c0       	rjmp	.+4      	; 0x1cc <vLED_counter+0x82>
     1c8:	44 0f       	add	r20, r20
     1ca:	55 1f       	adc	r21, r21
     1cc:	2a 95       	dec	r18
     1ce:	e2 f7       	brpl	.-8      	; 0x1c8 <vLED_counter+0x7e>
     1d0:	84 2f       	mov	r24, r20
     1d2:	80 95       	com	r24
     1d4:	89 23       	and	r24, r25
     1d6:	8b b9       	out	0x0b, r24	; 11
     1d8:	5f ef       	ldi	r21, 0xFF	; 255
     1da:	e5 1a       	sub	r14, r21
     1dc:	f5 0a       	sbc	r15, r21
     1de:	21 96       	adiw	r28, 0x01	; 1
     1e0:	c2 cf       	rjmp	.-124    	; 0x166 <vLED_counter+0x1c>
     1e2:	87 e0       	ldi	r24, 0x07	; 7
     1e4:	a8 2e       	mov	r10, r24
     1e6:	b1 2c       	mov	r11, r1
            }
            if(i < 6){
                LED_PORT &= ~_BV(i+2);
            }

            LED_PORT |= _BV(i);
     1e8:	8b b1       	in	r24, 0x0b	; 11
     1ea:	78 01       	movw	r14, r16
     1ec:	0a 2c       	mov	r0, r10
     1ee:	01 c0       	rjmp	.+2      	; 0x1f2 <vLED_counter+0xa8>
     1f0:	ee 0c       	add	r14, r14
     1f2:	0a 94       	dec	r0
     1f4:	ea f7       	brpl	.-6      	; 0x1f0 <vLED_counter+0xa6>
     1f6:	8e 29       	or	r24, r14
     1f8:	8b b9       	out	0x0b, r24	; 11
            LED_PORT |= _BV(i-1);
     1fa:	2b b1       	in	r18, 0x0b	; 11
     1fc:	c8 01       	movw	r24, r16
     1fe:	0c 2e       	mov	r0, r28
     200:	01 c0       	rjmp	.+2      	; 0x204 <vLED_counter+0xba>
     202:	88 0f       	add	r24, r24
     204:	0a 94       	dec	r0
     206:	ea f7       	brpl	.-6      	; 0x202 <vLED_counter+0xb8>
     208:	82 2b       	or	r24, r18
     20a:	8b b9       	out	0x0b, r24	; 11
            LED_PORT |= _BV(i-2);
     20c:	2b b1       	in	r18, 0x0b	; 11
     20e:	6e 01       	movw	r12, r28
     210:	51 e0       	ldi	r21, 0x01	; 1
     212:	c5 1a       	sub	r12, r21
     214:	d1 08       	sbc	r13, r1
     216:	c8 01       	movw	r24, r16
     218:	0c 2c       	mov	r0, r12
     21a:	01 c0       	rjmp	.+2      	; 0x21e <vLED_counter+0xd4>
     21c:	88 0f       	add	r24, r24
     21e:	0a 94       	dec	r0
     220:	ea f7       	brpl	.-6      	; 0x21c <vLED_counter+0xd2>
     222:	82 2b       	or	r24, r18
     224:	8b b9       	out	0x0b, r24	; 11
            vTaskDelay(100/portTICK_PERIOD_MS);
     226:	84 e6       	ldi	r24, 0x64	; 100
     228:	90 e0       	ldi	r25, 0x00	; 0
     22a:	0e 94 5e 05 	call	0xabc	; 0xabc <vTaskDelay>
            LED_PORT |= _BV(i);
            LED_PORT |= _BV(i+1);
            LED_PORT |= _BV(i+2);
            vTaskDelay(100/portTICK_PERIOD_MS);
        }
        for(int8_t i = 7;i >= 2; i--){
     22e:	c1 30       	cpi	r28, 0x01	; 1
     230:	d1 05       	cpc	r29, r1
     232:	09 f4       	brne	.+2      	; 0x236 <vLED_counter+0xec>
     234:	94 cf       	rjmp	.-216    	; 0x15e <vLED_counter+0x14>
            if(i < 7){
                LED_PORT &= ~_BV(i+1);
     236:	8b b1       	in	r24, 0x0b	; 11
     238:	e0 94       	com	r14
     23a:	e8 22       	and	r14, r24
     23c:	eb b8       	out	0x0b, r14	; 11
            }
            if(i < 6){
     23e:	c6 30       	cpi	r28, 0x06	; 6
     240:	59 f0       	breq	.+22     	; 0x258 <vLED_counter+0x10e>
                LED_PORT &= ~_BV(i+2);
     242:	9b b1       	in	r25, 0x0b	; 11
     244:	22 96       	adiw	r28, 0x02	; 2
     246:	98 01       	movw	r18, r16
     248:	01 c0       	rjmp	.+2      	; 0x24c <vLED_counter+0x102>
     24a:	22 0f       	add	r18, r18
     24c:	ca 95       	dec	r28
     24e:	ea f7       	brpl	.-6      	; 0x24a <vLED_counter+0x100>
     250:	82 2f       	mov	r24, r18
     252:	80 95       	com	r24
     254:	89 23       	and	r24, r25
     256:	8b b9       	out	0x0b, r24	; 11
     258:	31 e0       	ldi	r19, 0x01	; 1
     25a:	a3 1a       	sub	r10, r19
     25c:	b1 08       	sbc	r11, r1
     25e:	e6 01       	movw	r28, r12
     260:	c3 cf       	rjmp	.-122    	; 0x1e8 <vLED_counter+0x9e>

00000262 <vApplicationIdleHook>:
 * \fn static vApplicationIdleHook(void)
 *
 * \brief
 ******************************************************************************/
void vApplicationIdleHook(void)
{
     262:	08 95       	ret

00000264 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     264:	e0 91 60 01 	lds	r30, 0x0160	; 0x800160 <pxDelayedTaskList>
     268:	f0 91 61 01 	lds	r31, 0x0161	; 0x800161 <pxDelayedTaskList+0x1>
     26c:	80 81       	ld	r24, Z
     26e:	81 11       	cpse	r24, r1
     270:	03 c0       	rjmp	.+6      	; 0x278 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     272:	8f ef       	ldi	r24, 0xFF	; 255
     274:	9f ef       	ldi	r25, 0xFF	; 255
     276:	0c c0       	rjmp	.+24     	; 0x290 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     278:	e0 91 60 01 	lds	r30, 0x0160	; 0x800160 <pxDelayedTaskList>
     27c:	f0 91 61 01 	lds	r31, 0x0161	; 0x800161 <pxDelayedTaskList+0x1>
     280:	05 80       	ldd	r0, Z+5	; 0x05
     282:	f6 81       	ldd	r31, Z+6	; 0x06
     284:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     286:	06 80       	ldd	r0, Z+6	; 0x06
     288:	f7 81       	ldd	r31, Z+7	; 0x07
     28a:	e0 2d       	mov	r30, r0
     28c:	82 81       	ldd	r24, Z+2	; 0x02
     28e:	93 81       	ldd	r25, Z+3	; 0x03
     290:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <xNextTaskUnblockTime+0x1>
     294:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xNextTaskUnblockTime>
     298:	08 95       	ret

0000029a <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     29a:	ff 92       	push	r15
     29c:	0f 93       	push	r16
     29e:	1f 93       	push	r17
     2a0:	cf 93       	push	r28
     2a2:	df 93       	push	r29
     2a4:	ec 01       	movw	r28, r24
     2a6:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     2a8:	00 91 3f 01 	lds	r16, 0x013F	; 0x80013f <xTickCount>
     2ac:	10 91 40 01 	lds	r17, 0x0140	; 0x800140 <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     2b0:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <pxCurrentTCB>
     2b4:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     2b8:	02 96       	adiw	r24, 0x02	; 2
     2ba:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     2be:	cf 3f       	cpi	r28, 0xFF	; 255
     2c0:	8f ef       	ldi	r24, 0xFF	; 255
     2c2:	d8 07       	cpc	r29, r24
     2c4:	89 f4       	brne	.+34     	; 0x2e8 <prvAddCurrentTaskToDelayedList+0x4e>
     2c6:	ff 20       	and	r15, r15
     2c8:	79 f0       	breq	.+30     	; 0x2e8 <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2ca:	60 91 32 01 	lds	r22, 0x0132	; 0x800132 <pxCurrentTCB>
     2ce:	70 91 33 01 	lds	r23, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     2d2:	6e 5f       	subi	r22, 0xFE	; 254
     2d4:	7f 4f       	sbci	r23, 0xFF	; 255
     2d6:	82 e4       	ldi	r24, 0x42	; 66
     2d8:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     2da:	df 91       	pop	r29
     2dc:	cf 91       	pop	r28
     2de:	1f 91       	pop	r17
     2e0:	0f 91       	pop	r16
     2e2:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2e4:	0c 94 30 0e 	jmp	0x1c60	; 0x1c60 <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     2e8:	c0 0f       	add	r28, r16
     2ea:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     2ec:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     2f0:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     2f4:	d3 83       	std	Z+3, r29	; 0x03
     2f6:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2f8:	60 91 32 01 	lds	r22, 0x0132	; 0x800132 <pxCurrentTCB>
     2fc:	70 91 33 01 	lds	r23, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     300:	c0 17       	cp	r28, r16
     302:	d1 07       	cpc	r29, r17
     304:	68 f4       	brcc	.+26     	; 0x320 <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     306:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <pxOverflowDelayedTaskList>
     30a:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <pxOverflowDelayedTaskList+0x1>
     30e:	6e 5f       	subi	r22, 0xFE	; 254
     310:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     312:	df 91       	pop	r29
     314:	cf 91       	pop	r28
     316:	1f 91       	pop	r17
     318:	0f 91       	pop	r16
     31a:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     31c:	0c 94 51 0e 	jmp	0x1ca2	; 0x1ca2 <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     320:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <pxDelayedTaskList>
     324:	90 91 61 01 	lds	r25, 0x0161	; 0x800161 <pxDelayedTaskList+0x1>
     328:	6e 5f       	subi	r22, 0xFE	; 254
     32a:	7f 4f       	sbci	r23, 0xFF	; 255
     32c:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     330:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <xNextTaskUnblockTime>
     334:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <xNextTaskUnblockTime+0x1>
     338:	c8 17       	cp	r28, r24
     33a:	d9 07       	cpc	r29, r25
     33c:	20 f4       	brcc	.+8      	; 0x346 <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     33e:	d0 93 38 01 	sts	0x0138, r29	; 0x800138 <xNextTaskUnblockTime+0x1>
     342:	c0 93 37 01 	sts	0x0137, r28	; 0x800137 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     346:	df 91       	pop	r29
     348:	cf 91       	pop	r28
     34a:	1f 91       	pop	r17
     34c:	0f 91       	pop	r16
     34e:	ff 90       	pop	r15
     350:	08 95       	ret

00000352 <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     352:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <uxDeletedTasksWaitingCleanUp>
     356:	88 23       	and	r24, r24
     358:	09 f1       	breq	.+66     	; 0x39c <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     35a:	0f b6       	in	r0, 0x3f	; 63
     35c:	f8 94       	cli
     35e:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     360:	e0 91 51 01 	lds	r30, 0x0151	; 0x800151 <xTasksWaitingTermination+0x5>
     364:	f0 91 52 01 	lds	r31, 0x0152	; 0x800152 <xTasksWaitingTermination+0x6>
     368:	c6 81       	ldd	r28, Z+6	; 0x06
     36a:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     36c:	ce 01       	movw	r24, r28
     36e:	02 96       	adiw	r24, 0x02	; 2
     370:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
				--uxCurrentNumberOfTasks;
     374:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <uxCurrentNumberOfTasks>
     378:	81 50       	subi	r24, 0x01	; 1
     37a:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     37e:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <uxDeletedTasksWaitingCleanUp>
     382:	81 50       	subi	r24, 0x01	; 1
     384:	80 93 4b 01 	sts	0x014B, r24	; 0x80014b <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     388:	0f 90       	pop	r0
     38a:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     38c:	8f 89       	ldd	r24, Y+23	; 0x17
     38e:	98 8d       	ldd	r25, Y+24	; 0x18
     390:	0e 94 a5 10 	call	0x214a	; 0x214a <vPortFree>
			vPortFree( pxTCB );
     394:	ce 01       	movw	r24, r28
     396:	0e 94 a5 10 	call	0x214a	; 0x214a <vPortFree>
     39a:	db cf       	rjmp	.-74     	; 0x352 <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     39c:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <pxReadyTasksLists>
     3a0:	82 30       	cpi	r24, 0x02	; 2
     3a2:	10 f0       	brcs	.+4      	; 0x3a8 <prvIdleTask+0x56>
			{
				taskYIELD();
     3a4:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     3a8:	0e 94 31 01 	call	0x262	; 0x262 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     3ac:	d2 cf       	rjmp	.-92     	; 0x352 <prvIdleTask>

000003ae <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     3ae:	3f 92       	push	r3
     3b0:	4f 92       	push	r4
     3b2:	5f 92       	push	r5
     3b4:	6f 92       	push	r6
     3b6:	7f 92       	push	r7
     3b8:	8f 92       	push	r8
     3ba:	9f 92       	push	r9
     3bc:	af 92       	push	r10
     3be:	bf 92       	push	r11
     3c0:	cf 92       	push	r12
     3c2:	df 92       	push	r13
     3c4:	ef 92       	push	r14
     3c6:	ff 92       	push	r15
     3c8:	0f 93       	push	r16
     3ca:	1f 93       	push	r17
     3cc:	cf 93       	push	r28
     3ce:	df 93       	push	r29
     3d0:	4c 01       	movw	r8, r24
     3d2:	16 2f       	mov	r17, r22
     3d4:	37 2e       	mov	r3, r23
     3d6:	6a 01       	movw	r12, r20
     3d8:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     3da:	ca 01       	movw	r24, r20
     3dc:	0e 94 73 10 	call	0x20e6	; 0x20e6 <pvPortMalloc>
     3e0:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     3e2:	89 2b       	or	r24, r25
     3e4:	09 f4       	brne	.+2      	; 0x3e8 <xTaskCreate+0x3a>
     3e6:	d1 c0       	rjmp	.+418    	; 0x58a <__EEPROM_REGION_LENGTH__+0x18a>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     3e8:	86 e2       	ldi	r24, 0x26	; 38
     3ea:	90 e0       	ldi	r25, 0x00	; 0
     3ec:	0e 94 73 10 	call	0x20e6	; 0x20e6 <pvPortMalloc>
     3f0:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     3f2:	89 2b       	or	r24, r25
     3f4:	79 f0       	breq	.+30     	; 0x414 <__EEPROM_REGION_LENGTH__+0x14>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     3f6:	58 8e       	std	Y+24, r5	; 0x18
     3f8:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     3fa:	c6 01       	movw	r24, r12
     3fc:	01 97       	sbiw	r24, 0x01	; 1
     3fe:	32 01       	movw	r6, r4
     400:	68 0e       	add	r6, r24
     402:	79 1e       	adc	r7, r25
     404:	be 01       	movw	r22, r28
     406:	67 5e       	subi	r22, 0xE7	; 231
     408:	7f 4f       	sbci	r23, 0xFF	; 255
     40a:	e1 2f       	mov	r30, r17
     40c:	f3 2d       	mov	r31, r3
     40e:	cf 01       	movw	r24, r30
     410:	08 96       	adiw	r24, 0x08	; 8
     412:	07 c0       	rjmp	.+14     	; 0x422 <__EEPROM_REGION_LENGTH__+0x22>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     414:	c2 01       	movw	r24, r4
     416:	0e 94 a5 10 	call	0x214a	; 0x214a <vPortFree>
     41a:	b7 c0       	rjmp	.+366    	; 0x58a <__EEPROM_REGION_LENGTH__+0x18a>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     41c:	e8 17       	cp	r30, r24
     41e:	f9 07       	cpc	r31, r25
     420:	49 f0       	breq	.+18     	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
     422:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     424:	41 91       	ld	r20, Z+
     426:	db 01       	movw	r26, r22
     428:	4d 93       	st	X+, r20
     42a:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     42c:	d9 01       	movw	r26, r18
     42e:	2c 91       	ld	r18, X
     430:	21 11       	cpse	r18, r1
     432:	f4 cf       	rjmp	.-24     	; 0x41c <__EEPROM_REGION_LENGTH__+0x1c>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     434:	18 a2       	std	Y+32, r1	; 0x20
     436:	04 30       	cpi	r16, 0x04	; 4
     438:	08 f0       	brcs	.+2      	; 0x43c <__EEPROM_REGION_LENGTH__+0x3c>
     43a:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     43c:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     43e:	6e 01       	movw	r12, r28
     440:	b2 e0       	ldi	r27, 0x02	; 2
     442:	cb 0e       	add	r12, r27
     444:	d1 1c       	adc	r13, r1
     446:	c6 01       	movw	r24, r12
     448:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     44c:	ce 01       	movw	r24, r28
     44e:	0c 96       	adiw	r24, 0x0c	; 12
     450:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     454:	d9 87       	std	Y+9, r29	; 0x09
     456:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     458:	84 e0       	ldi	r24, 0x04	; 4
     45a:	90 e0       	ldi	r25, 0x00	; 0
     45c:	80 1b       	sub	r24, r16
     45e:	91 09       	sbc	r25, r1
     460:	9d 87       	std	Y+13, r25	; 0x0d
     462:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     464:	db 8b       	std	Y+19, r29	; 0x13
     466:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     468:	19 a2       	std	Y+33, r1	; 0x21
     46a:	1a a2       	std	Y+34, r1	; 0x22
     46c:	1b a2       	std	Y+35, r1	; 0x23
     46e:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     470:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     472:	a5 01       	movw	r20, r10
     474:	b4 01       	movw	r22, r8
     476:	c3 01       	movw	r24, r6
     478:	0e 94 b4 10 	call	0x2168	; 0x2168 <pxPortInitialiseStack>
     47c:	99 83       	std	Y+1, r25	; 0x01
     47e:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     480:	e1 14       	cp	r14, r1
     482:	f1 04       	cpc	r15, r1
     484:	19 f0       	breq	.+6      	; 0x48c <__EEPROM_REGION_LENGTH__+0x8c>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     486:	f7 01       	movw	r30, r14
     488:	d1 83       	std	Z+1, r29	; 0x01
     48a:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     48c:	0f b6       	in	r0, 0x3f	; 63
     48e:	f8 94       	cli
     490:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     492:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <uxCurrentNumberOfTasks>
     496:	8f 5f       	subi	r24, 0xFF	; 255
     498:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     49c:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <pxCurrentTCB>
     4a0:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     4a4:	89 2b       	or	r24, r25
     4a6:	d1 f5       	brne	.+116    	; 0x51c <__EEPROM_REGION_LENGTH__+0x11c>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     4a8:	d0 93 33 01 	sts	0x0133, r29	; 0x800133 <pxCurrentTCB+0x1>
     4ac:	c0 93 32 01 	sts	0x0132, r28	; 0x800132 <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     4b0:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <uxCurrentNumberOfTasks>
     4b4:	81 30       	cpi	r24, 0x01	; 1
     4b6:	09 f0       	breq	.+2      	; 0x4ba <__EEPROM_REGION_LENGTH__+0xba>
     4b8:	41 c0       	rjmp	.+130    	; 0x53c <__EEPROM_REGION_LENGTH__+0x13c>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     4ba:	84 e7       	ldi	r24, 0x74	; 116
     4bc:	91 e0       	ldi	r25, 0x01	; 1
     4be:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
     4c2:	8d e7       	ldi	r24, 0x7D	; 125
     4c4:	91 e0       	ldi	r25, 0x01	; 1
     4c6:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
     4ca:	86 e8       	ldi	r24, 0x86	; 134
     4cc:	91 e0       	ldi	r25, 0x01	; 1
     4ce:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
     4d2:	8f e8       	ldi	r24, 0x8F	; 143
     4d4:	91 e0       	ldi	r25, 0x01	; 1
     4d6:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     4da:	8b e6       	ldi	r24, 0x6B	; 107
     4dc:	91 e0       	ldi	r25, 0x01	; 1
     4de:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     4e2:	82 e6       	ldi	r24, 0x62	; 98
     4e4:	91 e0       	ldi	r25, 0x01	; 1
     4e6:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
	vListInitialise( &xPendingReadyList );
     4ea:	85 e5       	ldi	r24, 0x55	; 85
     4ec:	91 e0       	ldi	r25, 0x01	; 1
     4ee:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     4f2:	8c e4       	ldi	r24, 0x4C	; 76
     4f4:	91 e0       	ldi	r25, 0x01	; 1
     4f6:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     4fa:	82 e4       	ldi	r24, 0x42	; 66
     4fc:	91 e0       	ldi	r25, 0x01	; 1
     4fe:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     502:	8b e6       	ldi	r24, 0x6B	; 107
     504:	91 e0       	ldi	r25, 0x01	; 1
     506:	90 93 61 01 	sts	0x0161, r25	; 0x800161 <pxDelayedTaskList+0x1>
     50a:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     50e:	82 e6       	ldi	r24, 0x62	; 98
     510:	91 e0       	ldi	r25, 0x01	; 1
     512:	90 93 5f 01 	sts	0x015F, r25	; 0x80015f <pxOverflowDelayedTaskList+0x1>
     516:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <pxOverflowDelayedTaskList>
     51a:	10 c0       	rjmp	.+32     	; 0x53c <__EEPROM_REGION_LENGTH__+0x13c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     51c:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <xSchedulerRunning>
     520:	81 11       	cpse	r24, r1
     522:	0c c0       	rjmp	.+24     	; 0x53c <__EEPROM_REGION_LENGTH__+0x13c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     524:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     528:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     52c:	96 89       	ldd	r25, Z+22	; 0x16
     52e:	8e 89       	ldd	r24, Y+22	; 0x16
     530:	89 17       	cp	r24, r25
     532:	20 f0       	brcs	.+8      	; 0x53c <__EEPROM_REGION_LENGTH__+0x13c>
				{
					pxCurrentTCB = pxNewTCB;
     534:	d0 93 33 01 	sts	0x0133, r29	; 0x800133 <pxCurrentTCB+0x1>
     538:	c0 93 32 01 	sts	0x0132, r28	; 0x800132 <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     53c:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <uxTaskNumber>
     540:	8f 5f       	subi	r24, 0xFF	; 255
     542:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     546:	8e 89       	ldd	r24, Y+22	; 0x16
     548:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <uxTopReadyPriority>
     54c:	98 17       	cp	r25, r24
     54e:	10 f4       	brcc	.+4      	; 0x554 <__EEPROM_REGION_LENGTH__+0x154>
     550:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxTopReadyPriority>
     554:	f9 e0       	ldi	r31, 0x09	; 9
     556:	8f 9f       	mul	r24, r31
     558:	c0 01       	movw	r24, r0
     55a:	11 24       	eor	r1, r1
     55c:	b6 01       	movw	r22, r12
     55e:	8c 58       	subi	r24, 0x8C	; 140
     560:	9e 4f       	sbci	r25, 0xFE	; 254
     562:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     566:	0f 90       	pop	r0
     568:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     56a:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <xSchedulerRunning>
     56e:	88 23       	and	r24, r24
     570:	51 f0       	breq	.+20     	; 0x586 <__EEPROM_REGION_LENGTH__+0x186>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     572:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     576:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     57a:	96 89       	ldd	r25, Z+22	; 0x16
     57c:	8e 89       	ldd	r24, Y+22	; 0x16
     57e:	98 17       	cp	r25, r24
     580:	10 f4       	brcc	.+4      	; 0x586 <__EEPROM_REGION_LENGTH__+0x186>
		{
			taskYIELD_IF_USING_PREEMPTION();
     582:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     586:	81 e0       	ldi	r24, 0x01	; 1
     588:	01 c0       	rjmp	.+2      	; 0x58c <__EEPROM_REGION_LENGTH__+0x18c>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     58a:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     58c:	df 91       	pop	r29
     58e:	cf 91       	pop	r28
     590:	1f 91       	pop	r17
     592:	0f 91       	pop	r16
     594:	ff 90       	pop	r15
     596:	ef 90       	pop	r14
     598:	df 90       	pop	r13
     59a:	cf 90       	pop	r12
     59c:	bf 90       	pop	r11
     59e:	af 90       	pop	r10
     5a0:	9f 90       	pop	r9
     5a2:	8f 90       	pop	r8
     5a4:	7f 90       	pop	r7
     5a6:	6f 90       	pop	r6
     5a8:	5f 90       	pop	r5
     5aa:	4f 90       	pop	r4
     5ac:	3f 90       	pop	r3
     5ae:	08 95       	ret

000005b0 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     5b0:	0f 93       	push	r16
     5b2:	1f 93       	push	r17
     5b4:	cf 93       	push	r28
     5b6:	df 93       	push	r29
     5b8:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     5ba:	0f b6       	in	r0, 0x3f	; 63
     5bc:	f8 94       	cli
     5be:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     5c0:	89 2b       	or	r24, r25
     5c2:	21 f4       	brne	.+8      	; 0x5cc <vTaskDelete+0x1c>
     5c4:	c0 91 32 01 	lds	r28, 0x0132	; 0x800132 <pxCurrentTCB>
     5c8:	d0 91 33 01 	lds	r29, 0x0133	; 0x800133 <pxCurrentTCB+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     5cc:	8e 01       	movw	r16, r28
     5ce:	0e 5f       	subi	r16, 0xFE	; 254
     5d0:	1f 4f       	sbci	r17, 0xFF	; 255
     5d2:	c8 01       	movw	r24, r16
     5d4:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     5d8:	8c 89       	ldd	r24, Y+20	; 0x14
     5da:	9d 89       	ldd	r25, Y+21	; 0x15
     5dc:	89 2b       	or	r24, r25
     5de:	21 f0       	breq	.+8      	; 0x5e8 <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     5e0:	ce 01       	movw	r24, r28
     5e2:	0c 96       	adiw	r24, 0x0c	; 12
     5e4:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     5e8:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <uxTaskNumber>
     5ec:	8f 5f       	subi	r24, 0xFF	; 255
     5ee:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     5f2:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <pxCurrentTCB>
     5f6:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     5fa:	c8 17       	cp	r28, r24
     5fc:	d9 07       	cpc	r29, r25
     5fe:	59 f4       	brne	.+22     	; 0x616 <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     600:	b8 01       	movw	r22, r16
     602:	8c e4       	ldi	r24, 0x4C	; 76
     604:	91 e0       	ldi	r25, 0x01	; 1
     606:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     60a:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <uxDeletedTasksWaitingCleanUp>
     60e:	8f 5f       	subi	r24, 0xFF	; 255
     610:	80 93 4b 01 	sts	0x014B, r24	; 0x80014b <uxDeletedTasksWaitingCleanUp>
     614:	0e c0       	rjmp	.+28     	; 0x632 <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     616:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <uxCurrentNumberOfTasks>
     61a:	81 50       	subi	r24, 0x01	; 1
     61c:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     620:	8f 89       	ldd	r24, Y+23	; 0x17
     622:	98 8d       	ldd	r25, Y+24	; 0x18
     624:	0e 94 a5 10 	call	0x214a	; 0x214a <vPortFree>
			vPortFree( pxTCB );
     628:	ce 01       	movw	r24, r28
     62a:	0e 94 a5 10 	call	0x214a	; 0x214a <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     62e:	0e 94 32 01 	call	0x264	; 0x264 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     632:	0f 90       	pop	r0
     634:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     636:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <xSchedulerRunning>
     63a:	88 23       	and	r24, r24
     63c:	49 f0       	breq	.+18     	; 0x650 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     63e:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <pxCurrentTCB>
     642:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     646:	c8 17       	cp	r28, r24
     648:	d9 07       	cpc	r29, r25
     64a:	11 f4       	brne	.+4      	; 0x650 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     64c:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     650:	df 91       	pop	r29
     652:	cf 91       	pop	r28
     654:	1f 91       	pop	r17
     656:	0f 91       	pop	r16
     658:	08 95       	ret

0000065a <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     65a:	0f 93       	push	r16
     65c:	1f 93       	push	r17
     65e:	cf 93       	push	r28
     660:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     662:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <pxCurrentTCB>
     666:	30 91 33 01 	lds	r19, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     66a:	82 17       	cp	r24, r18
     66c:	93 07       	cpc	r25, r19
     66e:	b9 f1       	breq	.+110    	; 0x6de <vTaskResume+0x84>
     670:	00 97       	sbiw	r24, 0x00	; 0
     672:	a9 f1       	breq	.+106    	; 0x6de <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     674:	0f b6       	in	r0, 0x3f	; 63
     676:	f8 94       	cli
     678:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     67a:	fc 01       	movw	r30, r24
     67c:	22 85       	ldd	r18, Z+10	; 0x0a
     67e:	33 85       	ldd	r19, Z+11	; 0x0b
     680:	22 54       	subi	r18, 0x42	; 66
     682:	31 40       	sbci	r19, 0x01	; 1
     684:	51 f5       	brne	.+84     	; 0x6da <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     686:	fc 01       	movw	r30, r24
     688:	24 89       	ldd	r18, Z+20	; 0x14
     68a:	35 89       	ldd	r19, Z+21	; 0x15
     68c:	f1 e0       	ldi	r31, 0x01	; 1
     68e:	25 35       	cpi	r18, 0x55	; 85
     690:	3f 07       	cpc	r19, r31
     692:	19 f1       	breq	.+70     	; 0x6da <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     694:	23 2b       	or	r18, r19
     696:	09 f5       	brne	.+66     	; 0x6da <vTaskResume+0x80>
     698:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     69a:	8c 01       	movw	r16, r24
     69c:	0e 5f       	subi	r16, 0xFE	; 254
     69e:	1f 4f       	sbci	r17, 0xFF	; 255
     6a0:	c8 01       	movw	r24, r16
     6a2:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     6a6:	8e 89       	ldd	r24, Y+22	; 0x16
     6a8:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <uxTopReadyPriority>
     6ac:	98 17       	cp	r25, r24
     6ae:	10 f4       	brcc	.+4      	; 0x6b4 <vTaskResume+0x5a>
     6b0:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxTopReadyPriority>
     6b4:	29 e0       	ldi	r18, 0x09	; 9
     6b6:	82 9f       	mul	r24, r18
     6b8:	c0 01       	movw	r24, r0
     6ba:	11 24       	eor	r1, r1
     6bc:	b8 01       	movw	r22, r16
     6be:	8c 58       	subi	r24, 0x8C	; 140
     6c0:	9e 4f       	sbci	r25, 0xFE	; 254
     6c2:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     6c6:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     6ca:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     6ce:	9e 89       	ldd	r25, Y+22	; 0x16
     6d0:	86 89       	ldd	r24, Z+22	; 0x16
     6d2:	98 17       	cp	r25, r24
     6d4:	10 f0       	brcs	.+4      	; 0x6da <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     6d6:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     6da:	0f 90       	pop	r0
     6dc:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     6de:	df 91       	pop	r29
     6e0:	cf 91       	pop	r28
     6e2:	1f 91       	pop	r17
     6e4:	0f 91       	pop	r16
     6e6:	08 95       	ret

000006e8 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     6e8:	ef 92       	push	r14
     6ea:	ff 92       	push	r15
     6ec:	1f 93       	push	r17
     6ee:	cf 93       	push	r28
     6f0:	df 93       	push	r29
     6f2:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     6f4:	8a 85       	ldd	r24, Y+10	; 0x0a
     6f6:	9b 85       	ldd	r25, Y+11	; 0x0b
     6f8:	82 54       	subi	r24, 0x42	; 66
     6fa:	91 40       	sbci	r25, 0x01	; 1
     6fc:	99 f4       	brne	.+38     	; 0x724 <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     6fe:	8c 89       	ldd	r24, Y+20	; 0x14
     700:	9d 89       	ldd	r25, Y+21	; 0x15
     702:	21 e0       	ldi	r18, 0x01	; 1
     704:	85 35       	cpi	r24, 0x55	; 85
     706:	92 07       	cpc	r25, r18
     708:	69 f0       	breq	.+26     	; 0x724 <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     70a:	89 2b       	or	r24, r25
     70c:	59 f4       	brne	.+22     	; 0x724 <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     70e:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxSchedulerSuspended>
     712:	88 23       	and	r24, r24
     714:	49 f0       	breq	.+18     	; 0x728 <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     716:	be 01       	movw	r22, r28
     718:	64 5f       	subi	r22, 0xF4	; 244
     71a:	7f 4f       	sbci	r23, 0xFF	; 255
     71c:	85 e5       	ldi	r24, 0x55	; 85
     71e:	91 e0       	ldi	r25, 0x01	; 1
     720:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     724:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     726:	21 c0       	rjmp	.+66     	; 0x76a <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     728:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     72c:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     730:	11 e0       	ldi	r17, 0x01	; 1
     732:	9e 89       	ldd	r25, Y+22	; 0x16
     734:	86 89       	ldd	r24, Z+22	; 0x16
     736:	98 17       	cp	r25, r24
     738:	08 f4       	brcc	.+2      	; 0x73c <xTaskResumeFromISR+0x54>
     73a:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     73c:	7e 01       	movw	r14, r28
     73e:	82 e0       	ldi	r24, 0x02	; 2
     740:	e8 0e       	add	r14, r24
     742:	f1 1c       	adc	r15, r1
     744:	c7 01       	movw	r24, r14
     746:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     74a:	8e 89       	ldd	r24, Y+22	; 0x16
     74c:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <uxTopReadyPriority>
     750:	98 17       	cp	r25, r24
     752:	10 f4       	brcc	.+4      	; 0x758 <xTaskResumeFromISR+0x70>
     754:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxTopReadyPriority>
     758:	29 e0       	ldi	r18, 0x09	; 9
     75a:	82 9f       	mul	r24, r18
     75c:	c0 01       	movw	r24, r0
     75e:	11 24       	eor	r1, r1
     760:	b7 01       	movw	r22, r14
     762:	8c 58       	subi	r24, 0x8C	; 140
     764:	9e 4f       	sbci	r25, 0xFE	; 254
     766:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     76a:	81 2f       	mov	r24, r17
     76c:	df 91       	pop	r29
     76e:	cf 91       	pop	r28
     770:	1f 91       	pop	r17
     772:	ff 90       	pop	r15
     774:	ef 90       	pop	r14
     776:	08 95       	ret

00000778 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     778:	ef 92       	push	r14
     77a:	ff 92       	push	r15
     77c:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     77e:	85 e3       	ldi	r24, 0x35	; 53
     780:	e8 2e       	mov	r14, r24
     782:	81 e0       	ldi	r24, 0x01	; 1
     784:	f8 2e       	mov	r15, r24
     786:	00 e0       	ldi	r16, 0x00	; 0
     788:	20 e0       	ldi	r18, 0x00	; 0
     78a:	30 e0       	ldi	r19, 0x00	; 0
     78c:	45 e5       	ldi	r20, 0x55	; 85
     78e:	50 e0       	ldi	r21, 0x00	; 0
     790:	6d e0       	ldi	r22, 0x0D	; 13
     792:	71 e0       	ldi	r23, 0x01	; 1
     794:	89 ea       	ldi	r24, 0xA9	; 169
     796:	91 e0       	ldi	r25, 0x01	; 1
     798:	0e 94 d7 01 	call	0x3ae	; 0x3ae <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     79c:	81 30       	cpi	r24, 0x01	; 1
     79e:	91 f4       	brne	.+36     	; 0x7c4 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     7a0:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     7a2:	2f ef       	ldi	r18, 0xFF	; 255
     7a4:	3f ef       	ldi	r19, 0xFF	; 255
     7a6:	30 93 38 01 	sts	0x0138, r19	; 0x800138 <xNextTaskUnblockTime+0x1>
     7aa:	20 93 37 01 	sts	0x0137, r18	; 0x800137 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     7ae:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     7b2:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <xTickCount+0x1>
     7b6:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     7ba:	0f 91       	pop	r16
     7bc:	ff 90       	pop	r15
     7be:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     7c0:	0c 94 20 11 	jmp	0x2240	; 0x2240 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     7c4:	0f 91       	pop	r16
     7c6:	ff 90       	pop	r15
     7c8:	ef 90       	pop	r14
     7ca:	08 95       	ret

000007cc <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     7cc:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     7ce:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <xSchedulerRunning>
	vPortEndScheduler();
     7d2:	0c 94 60 11 	jmp	0x22c0	; 0x22c0 <vPortEndScheduler>

000007d6 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     7d6:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxSchedulerSuspended>
     7da:	8f 5f       	subi	r24, 0xFF	; 255
     7dc:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <uxSchedulerSuspended>
     7e0:	08 95       	ret

000007e2 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     7e2:	0f b6       	in	r0, 0x3f	; 63
     7e4:	f8 94       	cli
     7e6:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     7e8:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <xTickCount>
     7ec:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     7f0:	0f 90       	pop	r0
     7f2:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     7f4:	08 95       	ret

000007f6 <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     7f6:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <xTickCount>
     7fa:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     7fe:	08 95       	ret

00000800 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     800:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <uxCurrentNumberOfTasks>
}
     804:	08 95       	ret

00000806 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     806:	00 97       	sbiw	r24, 0x00	; 0
     808:	21 f4       	brne	.+8      	; 0x812 <pcTaskGetName+0xc>
     80a:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <pxCurrentTCB>
     80e:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     812:	49 96       	adiw	r24, 0x19	; 25
     814:	08 95       	ret

00000816 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     816:	cf 92       	push	r12
     818:	df 92       	push	r13
     81a:	ef 92       	push	r14
     81c:	ff 92       	push	r15
     81e:	0f 93       	push	r16
     820:	1f 93       	push	r17
     822:	cf 93       	push	r28
     824:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     826:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxSchedulerSuspended>
     82a:	81 11       	cpse	r24, r1
     82c:	8c c0       	rjmp	.+280    	; 0x946 <__stack+0x47>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     82e:	00 91 3f 01 	lds	r16, 0x013F	; 0x80013f <xTickCount>
     832:	10 91 40 01 	lds	r17, 0x0140	; 0x800140 <xTickCount+0x1>
     836:	0f 5f       	subi	r16, 0xFF	; 255
     838:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     83a:	10 93 40 01 	sts	0x0140, r17	; 0x800140 <xTickCount+0x1>
     83e:	00 93 3f 01 	sts	0x013F, r16	; 0x80013f <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     842:	01 15       	cp	r16, r1
     844:	11 05       	cpc	r17, r1
     846:	b9 f4       	brne	.+46     	; 0x876 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     848:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <pxDelayedTaskList>
     84c:	90 91 61 01 	lds	r25, 0x0161	; 0x800161 <pxDelayedTaskList+0x1>
     850:	20 91 5e 01 	lds	r18, 0x015E	; 0x80015e <pxOverflowDelayedTaskList>
     854:	30 91 5f 01 	lds	r19, 0x015F	; 0x80015f <pxOverflowDelayedTaskList+0x1>
     858:	30 93 61 01 	sts	0x0161, r19	; 0x800161 <pxDelayedTaskList+0x1>
     85c:	20 93 60 01 	sts	0x0160, r18	; 0x800160 <pxDelayedTaskList>
     860:	90 93 5f 01 	sts	0x015F, r25	; 0x80015f <pxOverflowDelayedTaskList+0x1>
     864:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <pxOverflowDelayedTaskList>
     868:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <xNumOfOverflows>
     86c:	8f 5f       	subi	r24, 0xFF	; 255
     86e:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <xNumOfOverflows>
     872:	0e 94 32 01 	call	0x264	; 0x264 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     876:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <xNextTaskUnblockTime>
     87a:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <xNextTaskUnblockTime+0x1>
     87e:	c0 e0       	ldi	r28, 0x00	; 0
     880:	08 17       	cp	r16, r24
     882:	19 07       	cpc	r17, r25
     884:	08 f4       	brcc	.+2      	; 0x888 <xTaskIncrementTick+0x72>
     886:	4f c0       	rjmp	.+158    	; 0x926 <__stack+0x27>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     888:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     88a:	e0 91 60 01 	lds	r30, 0x0160	; 0x800160 <pxDelayedTaskList>
     88e:	f0 91 61 01 	lds	r31, 0x0161	; 0x800161 <pxDelayedTaskList+0x1>
     892:	80 81       	ld	r24, Z
     894:	81 11       	cpse	r24, r1
     896:	03 c0       	rjmp	.+6      	; 0x89e <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     898:	8f ef       	ldi	r24, 0xFF	; 255
     89a:	9f ef       	ldi	r25, 0xFF	; 255
     89c:	11 c0       	rjmp	.+34     	; 0x8c0 <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     89e:	e0 91 60 01 	lds	r30, 0x0160	; 0x800160 <pxDelayedTaskList>
     8a2:	f0 91 61 01 	lds	r31, 0x0161	; 0x800161 <pxDelayedTaskList+0x1>
     8a6:	05 80       	ldd	r0, Z+5	; 0x05
     8a8:	f6 81       	ldd	r31, Z+6	; 0x06
     8aa:	e0 2d       	mov	r30, r0
     8ac:	e6 80       	ldd	r14, Z+6	; 0x06
     8ae:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     8b0:	d7 01       	movw	r26, r14
     8b2:	12 96       	adiw	r26, 0x02	; 2
     8b4:	8d 91       	ld	r24, X+
     8b6:	9c 91       	ld	r25, X
     8b8:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     8ba:	08 17       	cp	r16, r24
     8bc:	19 07       	cpc	r17, r25
     8be:	28 f4       	brcc	.+10     	; 0x8ca <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     8c0:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <xNextTaskUnblockTime+0x1>
     8c4:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     8c8:	2e c0       	rjmp	.+92     	; 0x926 <__stack+0x27>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     8ca:	67 01       	movw	r12, r14
     8cc:	b2 e0       	ldi	r27, 0x02	; 2
     8ce:	cb 0e       	add	r12, r27
     8d0:	d1 1c       	adc	r13, r1
     8d2:	c6 01       	movw	r24, r12
     8d4:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     8d8:	f7 01       	movw	r30, r14
     8da:	84 89       	ldd	r24, Z+20	; 0x14
     8dc:	95 89       	ldd	r25, Z+21	; 0x15
     8de:	89 2b       	or	r24, r25
     8e0:	21 f0       	breq	.+8      	; 0x8ea <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     8e2:	c7 01       	movw	r24, r14
     8e4:	0c 96       	adiw	r24, 0x0c	; 12
     8e6:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     8ea:	d7 01       	movw	r26, r14
     8ec:	56 96       	adiw	r26, 0x16	; 22
     8ee:	8c 91       	ld	r24, X
     8f0:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <uxTopReadyPriority>
     8f4:	98 17       	cp	r25, r24
     8f6:	10 f4       	brcc	.+4      	; 0x8fc <xTaskIncrementTick+0xe6>
     8f8:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxTopReadyPriority>
     8fc:	d8 9f       	mul	r29, r24
     8fe:	c0 01       	movw	r24, r0
     900:	11 24       	eor	r1, r1
     902:	b6 01       	movw	r22, r12
     904:	8c 58       	subi	r24, 0x8C	; 140
     906:	9e 4f       	sbci	r25, 0xFE	; 254
     908:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     90c:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     910:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     914:	d7 01       	movw	r26, r14
     916:	56 96       	adiw	r26, 0x16	; 22
     918:	9c 91       	ld	r25, X
     91a:	86 89       	ldd	r24, Z+22	; 0x16
     91c:	98 17       	cp	r25, r24
     91e:	08 f4       	brcc	.+2      	; 0x922 <__stack+0x23>
     920:	b4 cf       	rjmp	.-152    	; 0x88a <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     922:	c1 e0       	ldi	r28, 0x01	; 1
     924:	b2 cf       	rjmp	.-156    	; 0x88a <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     926:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     92a:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     92e:	e6 89       	ldd	r30, Z+22	; 0x16
     930:	b9 e0       	ldi	r27, 0x09	; 9
     932:	eb 9f       	mul	r30, r27
     934:	f0 01       	movw	r30, r0
     936:	11 24       	eor	r1, r1
     938:	ec 58       	subi	r30, 0x8C	; 140
     93a:	fe 4f       	sbci	r31, 0xFE	; 254
     93c:	80 81       	ld	r24, Z
     93e:	82 30       	cpi	r24, 0x02	; 2
     940:	40 f0       	brcs	.+16     	; 0x952 <__stack+0x53>
			{
				xSwitchRequired = pdTRUE;
     942:	c1 e0       	ldi	r28, 0x01	; 1
     944:	06 c0       	rjmp	.+12     	; 0x952 <__stack+0x53>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     946:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <uxPendedTicks>
     94a:	8f 5f       	subi	r24, 0xFF	; 255
     94c:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     950:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     952:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <xYieldPending>
     956:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     958:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     95a:	8c 2f       	mov	r24, r28
     95c:	df 91       	pop	r29
     95e:	cf 91       	pop	r28
     960:	1f 91       	pop	r17
     962:	0f 91       	pop	r16
     964:	ff 90       	pop	r15
     966:	ef 90       	pop	r14
     968:	df 90       	pop	r13
     96a:	cf 90       	pop	r12
     96c:	08 95       	ret

0000096e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     96e:	ef 92       	push	r14
     970:	ff 92       	push	r15
     972:	0f 93       	push	r16
     974:	1f 93       	push	r17
     976:	cf 93       	push	r28
     978:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     97a:	0f b6       	in	r0, 0x3f	; 63
     97c:	f8 94       	cli
     97e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     980:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxSchedulerSuspended>
     984:	81 50       	subi	r24, 0x01	; 1
     986:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     98a:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxSchedulerSuspended>
     98e:	88 23       	and	r24, r24
     990:	11 f0       	breq	.+4      	; 0x996 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     992:	80 e0       	ldi	r24, 0x00	; 0
     994:	52 c0       	rjmp	.+164    	; 0xa3a <xTaskResumeAll+0xcc>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     996:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <uxCurrentNumberOfTasks>
     99a:	88 23       	and	r24, r24
     99c:	d1 f3       	breq	.-12     	; 0x992 <xTaskResumeAll+0x24>
     99e:	c0 e0       	ldi	r28, 0x00	; 0
     9a0:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     9a2:	89 e0       	ldi	r24, 0x09	; 9
     9a4:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     9a6:	ee 24       	eor	r14, r14
     9a8:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     9aa:	80 91 55 01 	lds	r24, 0x0155	; 0x800155 <xPendingReadyList>
     9ae:	88 23       	and	r24, r24
     9b0:	51 f1       	breq	.+84     	; 0xa06 <xTaskResumeAll+0x98>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     9b2:	e0 91 5a 01 	lds	r30, 0x015A	; 0x80015a <xPendingReadyList+0x5>
     9b6:	f0 91 5b 01 	lds	r31, 0x015B	; 0x80015b <xPendingReadyList+0x6>
     9ba:	c6 81       	ldd	r28, Z+6	; 0x06
     9bc:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     9be:	ce 01       	movw	r24, r28
     9c0:	0c 96       	adiw	r24, 0x0c	; 12
     9c2:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     9c6:	8e 01       	movw	r16, r28
     9c8:	0e 5f       	subi	r16, 0xFE	; 254
     9ca:	1f 4f       	sbci	r17, 0xFF	; 255
     9cc:	c8 01       	movw	r24, r16
     9ce:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     9d2:	8e 89       	ldd	r24, Y+22	; 0x16
     9d4:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <uxTopReadyPriority>
     9d8:	98 17       	cp	r25, r24
     9da:	10 f4       	brcc	.+4      	; 0x9e0 <xTaskResumeAll+0x72>
     9dc:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxTopReadyPriority>
     9e0:	f8 9e       	mul	r15, r24
     9e2:	c0 01       	movw	r24, r0
     9e4:	11 24       	eor	r1, r1
     9e6:	b8 01       	movw	r22, r16
     9e8:	8c 58       	subi	r24, 0x8C	; 140
     9ea:	9e 4f       	sbci	r25, 0xFE	; 254
     9ec:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     9f0:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     9f4:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     9f8:	9e 89       	ldd	r25, Y+22	; 0x16
     9fa:	86 89       	ldd	r24, Z+22	; 0x16
     9fc:	98 17       	cp	r25, r24
     9fe:	a8 f2       	brcs	.-86     	; 0x9aa <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     a00:	e0 92 3b 01 	sts	0x013B, r14	; 0x80013b <xYieldPending>
     a04:	d2 cf       	rjmp	.-92     	; 0x9aa <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     a06:	cd 2b       	or	r28, r29
     a08:	11 f0       	breq	.+4      	; 0xa0e <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     a0a:	0e 94 32 01 	call	0x264	; 0x264 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     a0e:	c0 91 3c 01 	lds	r28, 0x013C	; 0x80013c <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     a12:	cc 23       	and	r28, r28
     a14:	51 f0       	breq	.+20     	; 0xa2a <xTaskResumeAll+0xbc>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     a16:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     a18:	0e 94 0b 04 	call	0x816	; 0x816 <xTaskIncrementTick>
     a1c:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     a1e:	d0 93 3b 01 	sts	0x013B, r29	; 0x80013b <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     a22:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     a24:	c9 f7       	brne	.-14     	; 0xa18 <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     a26:	10 92 3c 01 	sts	0x013C, r1	; 0x80013c <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     a2a:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <xYieldPending>
     a2e:	88 23       	and	r24, r24
     a30:	09 f4       	brne	.+2      	; 0xa34 <xTaskResumeAll+0xc6>
     a32:	af cf       	rjmp	.-162    	; 0x992 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     a34:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     a38:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     a3a:	0f 90       	pop	r0
     a3c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     a3e:	df 91       	pop	r29
     a40:	cf 91       	pop	r28
     a42:	1f 91       	pop	r17
     a44:	0f 91       	pop	r16
     a46:	ff 90       	pop	r15
     a48:	ef 90       	pop	r14
     a4a:	08 95       	ret

00000a4c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     a4c:	0f 93       	push	r16
     a4e:	1f 93       	push	r17
     a50:	cf 93       	push	r28
     a52:	df 93       	push	r29
     a54:	8c 01       	movw	r16, r24
     a56:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     a58:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     a5c:	40 91 3f 01 	lds	r20, 0x013F	; 0x80013f <xTickCount>
     a60:	50 91 40 01 	lds	r21, 0x0140	; 0x800140 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     a64:	f8 01       	movw	r30, r16
     a66:	20 81       	ld	r18, Z
     a68:	31 81       	ldd	r19, Z+1	; 0x01
     a6a:	c9 01       	movw	r24, r18
     a6c:	8c 0f       	add	r24, r28
     a6e:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     a70:	42 17       	cp	r20, r18
     a72:	53 07       	cpc	r21, r19
     a74:	20 f4       	brcc	.+8      	; 0xa7e <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     a76:	82 17       	cp	r24, r18
     a78:	93 07       	cpc	r25, r19
     a7a:	40 f4       	brcc	.+16     	; 0xa8c <vTaskDelayUntil+0x40>
     a7c:	03 c0       	rjmp	.+6      	; 0xa84 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     a7e:	82 17       	cp	r24, r18
     a80:	93 07       	cpc	r25, r19
     a82:	30 f0       	brcs	.+12     	; 0xa90 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     a84:	21 e0       	ldi	r18, 0x01	; 1
     a86:	48 17       	cp	r20, r24
     a88:	59 07       	cpc	r21, r25
     a8a:	18 f0       	brcs	.+6      	; 0xa92 <vTaskDelayUntil+0x46>
     a8c:	20 e0       	ldi	r18, 0x00	; 0
     a8e:	01 c0       	rjmp	.+2      	; 0xa92 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     a90:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     a92:	f8 01       	movw	r30, r16
     a94:	91 83       	std	Z+1, r25	; 0x01
     a96:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     a98:	22 23       	and	r18, r18
     a9a:	29 f0       	breq	.+10     	; 0xaa6 <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     a9c:	60 e0       	ldi	r22, 0x00	; 0
     a9e:	84 1b       	sub	r24, r20
     aa0:	95 0b       	sbc	r25, r21
     aa2:	0e 94 4d 01 	call	0x29a	; 0x29a <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     aa6:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     aaa:	81 11       	cpse	r24, r1
     aac:	02 c0       	rjmp	.+4      	; 0xab2 <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     aae:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     ab2:	df 91       	pop	r29
     ab4:	cf 91       	pop	r28
     ab6:	1f 91       	pop	r17
     ab8:	0f 91       	pop	r16
     aba:	08 95       	ret

00000abc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     abc:	cf 93       	push	r28
     abe:	df 93       	push	r29
     ac0:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     ac2:	89 2b       	or	r24, r25
     ac4:	19 f4       	brne	.+6      	; 0xacc <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     ac6:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
     aca:	0a c0       	rjmp	.+20     	; 0xae0 <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     acc:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     ad0:	60 e0       	ldi	r22, 0x00	; 0
     ad2:	ce 01       	movw	r24, r28
     ad4:	0e 94 4d 01 	call	0x29a	; 0x29a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     ad8:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     adc:	88 23       	and	r24, r24
     ade:	99 f3       	breq	.-26     	; 0xac6 <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     ae0:	df 91       	pop	r29
     ae2:	cf 91       	pop	r28
     ae4:	08 95       	ret

00000ae6 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     ae6:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxSchedulerSuspended>
     aea:	88 23       	and	r24, r24
     aec:	21 f0       	breq	.+8      	; 0xaf6 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     aee:	81 e0       	ldi	r24, 0x01	; 1
     af0:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <xYieldPending>
     af4:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     af6:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     afa:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <uxTopReadyPriority>
     afe:	69 e0       	ldi	r22, 0x09	; 9
     b00:	48 2f       	mov	r20, r24
     b02:	50 e0       	ldi	r21, 0x00	; 0
     b04:	64 9f       	mul	r22, r20
     b06:	90 01       	movw	r18, r0
     b08:	65 9f       	mul	r22, r21
     b0a:	30 0d       	add	r19, r0
     b0c:	11 24       	eor	r1, r1
     b0e:	f9 01       	movw	r30, r18
     b10:	ec 58       	subi	r30, 0x8C	; 140
     b12:	fe 4f       	sbci	r31, 0xFE	; 254
     b14:	90 81       	ld	r25, Z
     b16:	91 11       	cpse	r25, r1
     b18:	02 c0       	rjmp	.+4      	; 0xb1e <vTaskSwitchContext+0x38>
     b1a:	81 50       	subi	r24, 0x01	; 1
     b1c:	f1 cf       	rjmp	.-30     	; 0xb00 <vTaskSwitchContext+0x1a>
     b1e:	a1 81       	ldd	r26, Z+1	; 0x01
     b20:	b2 81       	ldd	r27, Z+2	; 0x02
     b22:	12 96       	adiw	r26, 0x02	; 2
     b24:	0d 90       	ld	r0, X+
     b26:	bc 91       	ld	r27, X
     b28:	a0 2d       	mov	r26, r0
     b2a:	b2 83       	std	Z+2, r27	; 0x02
     b2c:	a1 83       	std	Z+1, r26	; 0x01
     b2e:	29 58       	subi	r18, 0x89	; 137
     b30:	3e 4f       	sbci	r19, 0xFE	; 254
     b32:	a2 17       	cp	r26, r18
     b34:	b3 07       	cpc	r27, r19
     b36:	31 f4       	brne	.+12     	; 0xb44 <vTaskSwitchContext+0x5e>
     b38:	12 96       	adiw	r26, 0x02	; 2
     b3a:	2d 91       	ld	r18, X+
     b3c:	3c 91       	ld	r19, X
     b3e:	13 97       	sbiw	r26, 0x03	; 3
     b40:	32 83       	std	Z+2, r19	; 0x02
     b42:	21 83       	std	Z+1, r18	; 0x01
     b44:	99 e0       	ldi	r25, 0x09	; 9
     b46:	94 9f       	mul	r25, r20
     b48:	f0 01       	movw	r30, r0
     b4a:	95 9f       	mul	r25, r21
     b4c:	f0 0d       	add	r31, r0
     b4e:	11 24       	eor	r1, r1
     b50:	ec 58       	subi	r30, 0x8C	; 140
     b52:	fe 4f       	sbci	r31, 0xFE	; 254
     b54:	01 80       	ldd	r0, Z+1	; 0x01
     b56:	f2 81       	ldd	r31, Z+2	; 0x02
     b58:	e0 2d       	mov	r30, r0
     b5a:	26 81       	ldd	r18, Z+6	; 0x06
     b5c:	37 81       	ldd	r19, Z+7	; 0x07
     b5e:	30 93 33 01 	sts	0x0133, r19	; 0x800133 <pxCurrentTCB+0x1>
     b62:	20 93 32 01 	sts	0x0132, r18	; 0x800132 <pxCurrentTCB>
     b66:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxTopReadyPriority>
     b6a:	08 95       	ret

00000b6c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     b6c:	0f 93       	push	r16
     b6e:	1f 93       	push	r17
     b70:	cf 93       	push	r28
     b72:	df 93       	push	r29
     b74:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     b76:	0f b6       	in	r0, 0x3f	; 63
     b78:	f8 94       	cli
     b7a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     b7c:	89 2b       	or	r24, r25
     b7e:	21 f4       	brne	.+8      	; 0xb88 <vTaskSuspend+0x1c>
     b80:	c0 91 32 01 	lds	r28, 0x0132	; 0x800132 <pxCurrentTCB>
     b84:	d0 91 33 01 	lds	r29, 0x0133	; 0x800133 <pxCurrentTCB+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     b88:	8e 01       	movw	r16, r28
     b8a:	0e 5f       	subi	r16, 0xFE	; 254
     b8c:	1f 4f       	sbci	r17, 0xFF	; 255
     b8e:	c8 01       	movw	r24, r16
     b90:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     b94:	8c 89       	ldd	r24, Y+20	; 0x14
     b96:	9d 89       	ldd	r25, Y+21	; 0x15
     b98:	89 2b       	or	r24, r25
     b9a:	21 f0       	breq	.+8      	; 0xba4 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     b9c:	ce 01       	movw	r24, r28
     b9e:	0c 96       	adiw	r24, 0x0c	; 12
     ba0:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     ba4:	b8 01       	movw	r22, r16
     ba6:	82 e4       	ldi	r24, 0x42	; 66
     ba8:	91 e0       	ldi	r25, 0x01	; 1
     baa:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     bae:	8d a1       	ldd	r24, Y+37	; 0x25
     bb0:	81 30       	cpi	r24, 0x01	; 1
     bb2:	09 f4       	brne	.+2      	; 0xbb6 <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     bb4:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     bb6:	0f 90       	pop	r0
     bb8:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     bba:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <xSchedulerRunning>
     bbe:	88 23       	and	r24, r24
     bc0:	39 f0       	breq	.+14     	; 0xbd0 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     bc2:	0f b6       	in	r0, 0x3f	; 63
     bc4:	f8 94       	cli
     bc6:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     bc8:	0e 94 32 01 	call	0x264	; 0x264 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     bcc:	0f 90       	pop	r0
     bce:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     bd0:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <pxCurrentTCB>
     bd4:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     bd8:	c8 17       	cp	r28, r24
     bda:	d9 07       	cpc	r29, r25
     bdc:	c1 f4       	brne	.+48     	; 0xc0e <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     bde:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <xSchedulerRunning>
     be2:	88 23       	and	r24, r24
     be4:	19 f0       	breq	.+6      	; 0xbec <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     be6:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
     bea:	11 c0       	rjmp	.+34     	; 0xc0e <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     bec:	90 91 42 01 	lds	r25, 0x0142	; 0x800142 <xSuspendedTaskList>
     bf0:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <uxCurrentNumberOfTasks>
     bf4:	98 13       	cpse	r25, r24
     bf6:	05 c0       	rjmp	.+10     	; 0xc02 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     bf8:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <pxCurrentTCB+0x1>
     bfc:	10 92 32 01 	sts	0x0132, r1	; 0x800132 <pxCurrentTCB>
     c00:	06 c0       	rjmp	.+12     	; 0xc0e <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     c02:	df 91       	pop	r29
     c04:	cf 91       	pop	r28
     c06:	1f 91       	pop	r17
     c08:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     c0a:	0c 94 73 05 	jmp	0xae6	; 0xae6 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     c0e:	df 91       	pop	r29
     c10:	cf 91       	pop	r28
     c12:	1f 91       	pop	r17
     c14:	0f 91       	pop	r16
     c16:	08 95       	ret

00000c18 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     c18:	cf 93       	push	r28
     c1a:	df 93       	push	r29
     c1c:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     c1e:	60 91 32 01 	lds	r22, 0x0132	; 0x800132 <pxCurrentTCB>
     c22:	70 91 33 01 	lds	r23, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     c26:	64 5f       	subi	r22, 0xF4	; 244
     c28:	7f 4f       	sbci	r23, 0xFF	; 255
     c2a:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c2e:	61 e0       	ldi	r22, 0x01	; 1
     c30:	ce 01       	movw	r24, r28
}
     c32:	df 91       	pop	r29
     c34:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c36:	0c 94 4d 01 	jmp	0x29a	; 0x29a <prvAddCurrentTaskToDelayedList>

00000c3a <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     c3a:	cf 93       	push	r28
     c3c:	df 93       	push	r29
     c3e:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c40:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     c44:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     c48:	70 68       	ori	r23, 0x80	; 128
     c4a:	75 87       	std	Z+13, r23	; 0x0d
     c4c:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     c4e:	60 91 32 01 	lds	r22, 0x0132	; 0x800132 <pxCurrentTCB>
     c52:	70 91 33 01 	lds	r23, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     c56:	64 5f       	subi	r22, 0xF4	; 244
     c58:	7f 4f       	sbci	r23, 0xFF	; 255
     c5a:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c5e:	61 e0       	ldi	r22, 0x01	; 1
     c60:	ce 01       	movw	r24, r28
}
     c62:	df 91       	pop	r29
     c64:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c66:	0c 94 4d 01 	jmp	0x29a	; 0x29a <prvAddCurrentTaskToDelayedList>

00000c6a <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     c6a:	0f 93       	push	r16
     c6c:	1f 93       	push	r17
     c6e:	cf 93       	push	r28
     c70:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     c72:	dc 01       	movw	r26, r24
     c74:	15 96       	adiw	r26, 0x05	; 5
     c76:	ed 91       	ld	r30, X+
     c78:	fc 91       	ld	r31, X
     c7a:	16 97       	sbiw	r26, 0x06	; 6
     c7c:	c6 81       	ldd	r28, Z+6	; 0x06
     c7e:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     c80:	8e 01       	movw	r16, r28
     c82:	04 5f       	subi	r16, 0xF4	; 244
     c84:	1f 4f       	sbci	r17, 0xFF	; 255
     c86:	c8 01       	movw	r24, r16
     c88:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c8c:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxSchedulerSuspended>
     c90:	81 11       	cpse	r24, r1
     c92:	14 c0       	rjmp	.+40     	; 0xcbc <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c94:	0a 50       	subi	r16, 0x0A	; 10
     c96:	11 09       	sbc	r17, r1
     c98:	c8 01       	movw	r24, r16
     c9a:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     c9e:	8e 89       	ldd	r24, Y+22	; 0x16
     ca0:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <uxTopReadyPriority>
     ca4:	98 17       	cp	r25, r24
     ca6:	10 f4       	brcc	.+4      	; 0xcac <xTaskRemoveFromEventList+0x42>
     ca8:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxTopReadyPriority>
     cac:	b9 e0       	ldi	r27, 0x09	; 9
     cae:	8b 9f       	mul	r24, r27
     cb0:	c0 01       	movw	r24, r0
     cb2:	11 24       	eor	r1, r1
     cb4:	b8 01       	movw	r22, r16
     cb6:	8c 58       	subi	r24, 0x8C	; 140
     cb8:	9e 4f       	sbci	r25, 0xFE	; 254
     cba:	03 c0       	rjmp	.+6      	; 0xcc2 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     cbc:	b8 01       	movw	r22, r16
     cbe:	85 e5       	ldi	r24, 0x55	; 85
     cc0:	91 e0       	ldi	r25, 0x01	; 1
     cc2:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     cc6:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     cca:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     cce:	9e 89       	ldd	r25, Y+22	; 0x16
     cd0:	86 89       	ldd	r24, Z+22	; 0x16
     cd2:	89 17       	cp	r24, r25
     cd4:	20 f4       	brcc	.+8      	; 0xcde <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     cd6:	81 e0       	ldi	r24, 0x01	; 1
     cd8:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <xYieldPending>
     cdc:	01 c0       	rjmp	.+2      	; 0xce0 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     cde:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     ce0:	df 91       	pop	r29
     ce2:	cf 91       	pop	r28
     ce4:	1f 91       	pop	r17
     ce6:	0f 91       	pop	r16
     ce8:	08 95       	ret

00000cea <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     cea:	0f 93       	push	r16
     cec:	1f 93       	push	r17
     cee:	cf 93       	push	r28
     cf0:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     cf2:	70 68       	ori	r23, 0x80	; 128
     cf4:	fc 01       	movw	r30, r24
     cf6:	71 83       	std	Z+1, r23	; 0x01
     cf8:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     cfa:	c6 81       	ldd	r28, Z+6	; 0x06
     cfc:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     cfe:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     d02:	8e 01       	movw	r16, r28
     d04:	0e 5f       	subi	r16, 0xFE	; 254
     d06:	1f 4f       	sbci	r17, 0xFF	; 255
     d08:	c8 01       	movw	r24, r16
     d0a:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     d0e:	8e 89       	ldd	r24, Y+22	; 0x16
     d10:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <uxTopReadyPriority>
     d14:	98 17       	cp	r25, r24
     d16:	10 f4       	brcc	.+4      	; 0xd1c <vTaskRemoveFromUnorderedEventList+0x32>
     d18:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxTopReadyPriority>
     d1c:	f9 e0       	ldi	r31, 0x09	; 9
     d1e:	8f 9f       	mul	r24, r31
     d20:	c0 01       	movw	r24, r0
     d22:	11 24       	eor	r1, r1
     d24:	b8 01       	movw	r22, r16
     d26:	8c 58       	subi	r24, 0x8C	; 140
     d28:	9e 4f       	sbci	r25, 0xFE	; 254
     d2a:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     d2e:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     d32:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     d36:	9e 89       	ldd	r25, Y+22	; 0x16
     d38:	86 89       	ldd	r24, Z+22	; 0x16
     d3a:	89 17       	cp	r24, r25
     d3c:	18 f4       	brcc	.+6      	; 0xd44 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     d3e:	81 e0       	ldi	r24, 0x01	; 1
     d40:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <xYieldPending>
	}
}
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	1f 91       	pop	r17
     d4a:	0f 91       	pop	r16
     d4c:	08 95       	ret

00000d4e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     d4e:	0f b6       	in	r0, 0x3f	; 63
     d50:	f8 94       	cli
     d52:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     d54:	20 91 3a 01 	lds	r18, 0x013A	; 0x80013a <xNumOfOverflows>
     d58:	fc 01       	movw	r30, r24
     d5a:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     d5c:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <xTickCount>
     d60:	30 91 40 01 	lds	r19, 0x0140	; 0x800140 <xTickCount+0x1>
     d64:	32 83       	std	Z+2, r19	; 0x02
     d66:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     d68:	0f 90       	pop	r0
     d6a:	0f be       	out	0x3f, r0	; 63
     d6c:	08 95       	ret

00000d6e <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     d6e:	20 91 3a 01 	lds	r18, 0x013A	; 0x80013a <xNumOfOverflows>
     d72:	fc 01       	movw	r30, r24
     d74:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     d76:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <xTickCount>
     d7a:	30 91 40 01 	lds	r19, 0x0140	; 0x800140 <xTickCount+0x1>
     d7e:	32 83       	std	Z+2, r19	; 0x02
     d80:	21 83       	std	Z+1, r18	; 0x01
     d82:	08 95       	ret

00000d84 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     d84:	cf 93       	push	r28
     d86:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     d88:	0f b6       	in	r0, 0x3f	; 63
     d8a:	f8 94       	cli
     d8c:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     d8e:	40 91 3f 01 	lds	r20, 0x013F	; 0x80013f <xTickCount>
     d92:	50 91 40 01 	lds	r21, 0x0140	; 0x800140 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     d96:	db 01       	movw	r26, r22
     d98:	2d 91       	ld	r18, X+
     d9a:	3c 91       	ld	r19, X
     d9c:	2f 3f       	cpi	r18, 0xFF	; 255
     d9e:	bf ef       	ldi	r27, 0xFF	; 255
     da0:	3b 07       	cpc	r19, r27
     da2:	d9 f0       	breq	.+54     	; 0xdda <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     da4:	ec 01       	movw	r28, r24
     da6:	e9 81       	ldd	r30, Y+1	; 0x01
     da8:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     daa:	a0 91 3a 01 	lds	r26, 0x013A	; 0x80013a <xNumOfOverflows>
     dae:	b8 81       	ld	r27, Y
     db0:	ba 17       	cp	r27, r26
     db2:	19 f0       	breq	.+6      	; 0xdba <xTaskCheckForTimeOut+0x36>
     db4:	4e 17       	cp	r20, r30
     db6:	5f 07       	cpc	r21, r31
     db8:	90 f4       	brcc	.+36     	; 0xdde <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     dba:	4e 1b       	sub	r20, r30
     dbc:	5f 0b       	sbc	r21, r31
     dbe:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     dc0:	42 17       	cp	r20, r18
     dc2:	53 07       	cpc	r21, r19
     dc4:	38 f4       	brcc	.+14     	; 0xdd4 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     dc6:	24 1b       	sub	r18, r20
     dc8:	35 0b       	sbc	r19, r21
     dca:	31 83       	std	Z+1, r19	; 0x01
     dcc:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     dce:	0e 94 b7 06 	call	0xd6e	; 0xd6e <vTaskInternalSetTimeOutState>
     dd2:	03 c0       	rjmp	.+6      	; 0xdda <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     dd4:	11 82       	std	Z+1, r1	; 0x01
     dd6:	10 82       	st	Z, r1
     dd8:	02 c0       	rjmp	.+4      	; 0xdde <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     dda:	80 e0       	ldi	r24, 0x00	; 0
     ddc:	01 c0       	rjmp	.+2      	; 0xde0 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     dde:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     de0:	0f 90       	pop	r0
     de2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     de4:	df 91       	pop	r29
     de6:	cf 91       	pop	r28
     de8:	08 95       	ret

00000dea <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     dea:	81 e0       	ldi	r24, 0x01	; 1
     dec:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <xYieldPending>
     df0:	08 95       	ret

00000df2 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     df2:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     df6:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     dfa:	84 85       	ldd	r24, Z+12	; 0x0c
     dfc:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     dfe:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     e02:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     e06:	a0 91 32 01 	lds	r26, 0x0132	; 0x800132 <pxCurrentTCB>
     e0a:	b0 91 33 01 	lds	r27, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     e0e:	56 96       	adiw	r26, 0x16	; 22
     e10:	4c 91       	ld	r20, X
     e12:	24 e0       	ldi	r18, 0x04	; 4
     e14:	30 e0       	ldi	r19, 0x00	; 0
     e16:	24 1b       	sub	r18, r20
     e18:	31 09       	sbc	r19, r1
     e1a:	35 87       	std	Z+13, r19	; 0x0d
     e1c:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     e1e:	08 95       	ret

00000e20 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     e20:	0f 93       	push	r16
     e22:	1f 93       	push	r17
     e24:	18 2f       	mov	r17, r24
     e26:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     e28:	0f b6       	in	r0, 0x3f	; 63
     e2a:	f8 94       	cli
     e2c:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     e2e:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     e32:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     e36:	41 a1       	ldd	r20, Z+33	; 0x21
     e38:	52 a1       	ldd	r21, Z+34	; 0x22
     e3a:	63 a1       	ldd	r22, Z+35	; 0x23
     e3c:	74 a1       	ldd	r23, Z+36	; 0x24
     e3e:	45 2b       	or	r20, r21
     e40:	46 2b       	or	r20, r22
     e42:	47 2b       	or	r20, r23
     e44:	69 f4       	brne	.+26     	; 0xe60 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     e46:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     e4a:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     e4e:	21 e0       	ldi	r18, 0x01	; 1
     e50:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     e52:	00 97       	sbiw	r24, 0x00	; 0
     e54:	29 f0       	breq	.+10     	; 0xe60 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     e56:	61 e0       	ldi	r22, 0x01	; 1
     e58:	0e 94 4d 01 	call	0x29a	; 0x29a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     e5c:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     e60:	0f 90       	pop	r0
     e62:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     e64:	0f b6       	in	r0, 0x3f	; 63
     e66:	f8 94       	cli
     e68:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
     e6a:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     e6e:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     e72:	61 a1       	ldd	r22, Z+33	; 0x21
     e74:	72 a1       	ldd	r23, Z+34	; 0x22
     e76:	83 a1       	ldd	r24, Z+35	; 0x23
     e78:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
     e7a:	61 15       	cp	r22, r1
     e7c:	71 05       	cpc	r23, r1
     e7e:	81 05       	cpc	r24, r1
     e80:	91 05       	cpc	r25, r1
     e82:	a9 f0       	breq	.+42     	; 0xeae <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     e84:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     e88:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
     e8c:	11 23       	and	r17, r17
     e8e:	29 f0       	breq	.+10     	; 0xe9a <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     e90:	11 a2       	std	Z+33, r1	; 0x21
     e92:	12 a2       	std	Z+34, r1	; 0x22
     e94:	13 a2       	std	Z+35, r1	; 0x23
     e96:	14 a2       	std	Z+36, r1	; 0x24
     e98:	0a c0       	rjmp	.+20     	; 0xeae <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
     e9a:	8b 01       	movw	r16, r22
     e9c:	9c 01       	movw	r18, r24
     e9e:	01 50       	subi	r16, 0x01	; 1
     ea0:	11 09       	sbc	r17, r1
     ea2:	21 09       	sbc	r18, r1
     ea4:	31 09       	sbc	r19, r1
     ea6:	01 a3       	std	Z+33, r16	; 0x21
     ea8:	12 a3       	std	Z+34, r17	; 0x22
     eaa:	23 a3       	std	Z+35, r18	; 0x23
     eac:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     eae:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     eb2:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     eb6:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     eb8:	0f 90       	pop	r0
     eba:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
     ebc:	1f 91       	pop	r17
     ebe:	0f 91       	pop	r16
     ec0:	08 95       	ret

00000ec2 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     ec2:	4f 92       	push	r4
     ec4:	5f 92       	push	r5
     ec6:	6f 92       	push	r6
     ec8:	7f 92       	push	r7
     eca:	8f 92       	push	r8
     ecc:	9f 92       	push	r9
     ece:	af 92       	push	r10
     ed0:	bf 92       	push	r11
     ed2:	ef 92       	push	r14
     ed4:	ff 92       	push	r15
     ed6:	0f 93       	push	r16
     ed8:	1f 93       	push	r17
     eda:	49 01       	movw	r8, r18
     edc:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     ede:	0f b6       	in	r0, 0x3f	; 63
     ee0:	f8 94       	cli
     ee2:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     ee4:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     ee8:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     eec:	25 a1       	ldd	r18, Z+37	; 0x25
     eee:	22 30       	cpi	r18, 0x02	; 2
     ef0:	39 f1       	breq	.+78     	; 0xf40 <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     ef2:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     ef6:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     efa:	21 a1       	ldd	r18, Z+33	; 0x21
     efc:	32 a1       	ldd	r19, Z+34	; 0x22
     efe:	43 a1       	ldd	r20, Z+35	; 0x23
     f00:	54 a1       	ldd	r21, Z+36	; 0x24
     f02:	2b 01       	movw	r4, r22
     f04:	3c 01       	movw	r6, r24
     f06:	40 94       	com	r4
     f08:	50 94       	com	r5
     f0a:	60 94       	com	r6
     f0c:	70 94       	com	r7
     f0e:	d3 01       	movw	r26, r6
     f10:	c2 01       	movw	r24, r4
     f12:	82 23       	and	r24, r18
     f14:	93 23       	and	r25, r19
     f16:	a4 23       	and	r26, r20
     f18:	b5 23       	and	r27, r21
     f1a:	81 a3       	std	Z+33, r24	; 0x21
     f1c:	92 a3       	std	Z+34, r25	; 0x22
     f1e:	a3 a3       	std	Z+35, r26	; 0x23
     f20:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     f22:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     f26:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     f2a:	81 e0       	ldi	r24, 0x01	; 1
     f2c:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     f2e:	e1 14       	cp	r14, r1
     f30:	f1 04       	cpc	r15, r1
     f32:	31 f0       	breq	.+12     	; 0xf40 <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     f34:	61 e0       	ldi	r22, 0x01	; 1
     f36:	c7 01       	movw	r24, r14
     f38:	0e 94 4d 01 	call	0x29a	; 0x29a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     f3c:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     f40:	0f 90       	pop	r0
     f42:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     f44:	0f b6       	in	r0, 0x3f	; 63
     f46:	f8 94       	cli
     f48:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
     f4a:	01 15       	cp	r16, r1
     f4c:	11 05       	cpc	r17, r1
     f4e:	69 f0       	breq	.+26     	; 0xf6a <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     f50:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     f54:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     f58:	81 a1       	ldd	r24, Z+33	; 0x21
     f5a:	92 a1       	ldd	r25, Z+34	; 0x22
     f5c:	a3 a1       	ldd	r26, Z+35	; 0x23
     f5e:	b4 a1       	ldd	r27, Z+36	; 0x24
     f60:	f8 01       	movw	r30, r16
     f62:	80 83       	st	Z, r24
     f64:	91 83       	std	Z+1, r25	; 0x01
     f66:	a2 83       	std	Z+2, r26	; 0x02
     f68:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     f6a:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     f6e:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     f72:	85 a1       	ldd	r24, Z+37	; 0x25
     f74:	82 30       	cpi	r24, 0x02	; 2
     f76:	c1 f4       	brne	.+48     	; 0xfa8 <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
     f78:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     f7c:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     f80:	41 a1       	ldd	r20, Z+33	; 0x21
     f82:	52 a1       	ldd	r21, Z+34	; 0x22
     f84:	63 a1       	ldd	r22, Z+35	; 0x23
     f86:	74 a1       	ldd	r23, Z+36	; 0x24
     f88:	d5 01       	movw	r26, r10
     f8a:	c4 01       	movw	r24, r8
     f8c:	80 95       	com	r24
     f8e:	90 95       	com	r25
     f90:	a0 95       	com	r26
     f92:	b0 95       	com	r27
     f94:	84 23       	and	r24, r20
     f96:	95 23       	and	r25, r21
     f98:	a6 23       	and	r26, r22
     f9a:	b7 23       	and	r27, r23
     f9c:	81 a3       	std	Z+33, r24	; 0x21
     f9e:	92 a3       	std	Z+34, r25	; 0x22
     fa0:	a3 a3       	std	Z+35, r26	; 0x23
     fa2:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
     fa4:	81 e0       	ldi	r24, 0x01	; 1
     fa6:	01 c0       	rjmp	.+2      	; 0xfaa <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
     fa8:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     faa:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
     fae:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
     fb2:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     fb4:	0f 90       	pop	r0
     fb6:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     fb8:	1f 91       	pop	r17
     fba:	0f 91       	pop	r16
     fbc:	ff 90       	pop	r15
     fbe:	ef 90       	pop	r14
     fc0:	bf 90       	pop	r11
     fc2:	af 90       	pop	r10
     fc4:	9f 90       	pop	r9
     fc6:	8f 90       	pop	r8
     fc8:	7f 90       	pop	r7
     fca:	6f 90       	pop	r6
     fcc:	5f 90       	pop	r5
     fce:	4f 90       	pop	r4
     fd0:	08 95       	ret

00000fd2 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
     fd2:	0f 93       	push	r16
     fd4:	1f 93       	push	r17
     fd6:	cf 93       	push	r28
     fd8:	df 93       	push	r29
     fda:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
     fdc:	0f b6       	in	r0, 0x3f	; 63
     fde:	f8 94       	cli
     fe0:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
     fe2:	01 15       	cp	r16, r1
     fe4:	11 05       	cpc	r17, r1
     fe6:	49 f0       	breq	.+18     	; 0xffa <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     fe8:	81 a1       	ldd	r24, Z+33	; 0x21
     fea:	92 a1       	ldd	r25, Z+34	; 0x22
     fec:	a3 a1       	ldd	r26, Z+35	; 0x23
     fee:	b4 a1       	ldd	r27, Z+36	; 0x24
     ff0:	e8 01       	movw	r28, r16
     ff2:	88 83       	st	Y, r24
     ff4:	99 83       	std	Y+1, r25	; 0x01
     ff6:	aa 83       	std	Y+2, r26	; 0x02
     ff8:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     ffa:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     ffc:	82 e0       	ldi	r24, 0x02	; 2
     ffe:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1000:	22 30       	cpi	r18, 0x02	; 2
    1002:	89 f0       	breq	.+34     	; 0x1026 <xTaskGenericNotify+0x54>
    1004:	58 f4       	brcc	.+22     	; 0x101c <xTaskGenericNotify+0x4a>
    1006:	21 30       	cpi	r18, 0x01	; 1
    1008:	01 f5       	brne	.+64     	; 0x104a <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    100a:	81 a1       	ldd	r24, Z+33	; 0x21
    100c:	92 a1       	ldd	r25, Z+34	; 0x22
    100e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1010:	b4 a1       	ldd	r27, Z+36	; 0x24
    1012:	48 2b       	or	r20, r24
    1014:	59 2b       	or	r21, r25
    1016:	6a 2b       	or	r22, r26
    1018:	7b 2b       	or	r23, r27
    101a:	13 c0       	rjmp	.+38     	; 0x1042 <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    101c:	23 30       	cpi	r18, 0x03	; 3
    101e:	89 f0       	breq	.+34     	; 0x1042 <xTaskGenericNotify+0x70>
    1020:	24 30       	cpi	r18, 0x04	; 4
    1022:	69 f0       	breq	.+26     	; 0x103e <xTaskGenericNotify+0x6c>
    1024:	12 c0       	rjmp	.+36     	; 0x104a <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1026:	81 a1       	ldd	r24, Z+33	; 0x21
    1028:	92 a1       	ldd	r25, Z+34	; 0x22
    102a:	a3 a1       	ldd	r26, Z+35	; 0x23
    102c:	b4 a1       	ldd	r27, Z+36	; 0x24
    102e:	01 96       	adiw	r24, 0x01	; 1
    1030:	a1 1d       	adc	r26, r1
    1032:	b1 1d       	adc	r27, r1
    1034:	81 a3       	std	Z+33, r24	; 0x21
    1036:	92 a3       	std	Z+34, r25	; 0x22
    1038:	a3 a3       	std	Z+35, r26	; 0x23
    103a:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    103c:	06 c0       	rjmp	.+12     	; 0x104a <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    103e:	32 30       	cpi	r19, 0x02	; 2
    1040:	49 f1       	breq	.+82     	; 0x1094 <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1042:	41 a3       	std	Z+33, r20	; 0x21
    1044:	52 a3       	std	Z+34, r21	; 0x22
    1046:	63 a3       	std	Z+35, r22	; 0x23
    1048:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    104a:	31 30       	cpi	r19, 0x01	; 1
    104c:	09 f5       	brne	.+66     	; 0x1090 <xTaskGenericNotify+0xbe>
    104e:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1050:	8f 01       	movw	r16, r30
    1052:	0e 5f       	subi	r16, 0xFE	; 254
    1054:	1f 4f       	sbci	r17, 0xFF	; 255
    1056:	c8 01       	movw	r24, r16
    1058:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    105c:	8e 89       	ldd	r24, Y+22	; 0x16
    105e:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <uxTopReadyPriority>
    1062:	98 17       	cp	r25, r24
    1064:	10 f4       	brcc	.+4      	; 0x106a <xTaskGenericNotify+0x98>
    1066:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxTopReadyPriority>
    106a:	29 e0       	ldi	r18, 0x09	; 9
    106c:	82 9f       	mul	r24, r18
    106e:	c0 01       	movw	r24, r0
    1070:	11 24       	eor	r1, r1
    1072:	b8 01       	movw	r22, r16
    1074:	8c 58       	subi	r24, 0x8C	; 140
    1076:	9e 4f       	sbci	r25, 0xFE	; 254
    1078:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    107c:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
    1080:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
    1084:	9e 89       	ldd	r25, Y+22	; 0x16
    1086:	86 89       	ldd	r24, Z+22	; 0x16
    1088:	89 17       	cp	r24, r25
    108a:	10 f4       	brcc	.+4      	; 0x1090 <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    108c:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
    1090:	81 e0       	ldi	r24, 0x01	; 1
    1092:	01 c0       	rjmp	.+2      	; 0x1096 <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1094:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1096:	0f 90       	pop	r0
    1098:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    109a:	df 91       	pop	r29
    109c:	cf 91       	pop	r28
    109e:	1f 91       	pop	r17
    10a0:	0f 91       	pop	r16
    10a2:	08 95       	ret

000010a4 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    10a4:	ef 92       	push	r14
    10a6:	ff 92       	push	r15
    10a8:	0f 93       	push	r16
    10aa:	1f 93       	push	r17
    10ac:	cf 93       	push	r28
    10ae:	df 93       	push	r29
    10b0:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    10b2:	01 15       	cp	r16, r1
    10b4:	11 05       	cpc	r17, r1
    10b6:	49 f0       	breq	.+18     	; 0x10ca <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    10b8:	81 a1       	ldd	r24, Z+33	; 0x21
    10ba:	92 a1       	ldd	r25, Z+34	; 0x22
    10bc:	a3 a1       	ldd	r26, Z+35	; 0x23
    10be:	b4 a1       	ldd	r27, Z+36	; 0x24
    10c0:	e8 01       	movw	r28, r16
    10c2:	88 83       	st	Y, r24
    10c4:	99 83       	std	Y+1, r25	; 0x01
    10c6:	aa 83       	std	Y+2, r26	; 0x02
    10c8:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    10ca:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    10cc:	82 e0       	ldi	r24, 0x02	; 2
    10ce:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    10d0:	22 30       	cpi	r18, 0x02	; 2
    10d2:	89 f0       	breq	.+34     	; 0x10f6 <xTaskGenericNotifyFromISR+0x52>
    10d4:	58 f4       	brcc	.+22     	; 0x10ec <xTaskGenericNotifyFromISR+0x48>
    10d6:	21 30       	cpi	r18, 0x01	; 1
    10d8:	01 f5       	brne	.+64     	; 0x111a <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    10da:	81 a1       	ldd	r24, Z+33	; 0x21
    10dc:	92 a1       	ldd	r25, Z+34	; 0x22
    10de:	a3 a1       	ldd	r26, Z+35	; 0x23
    10e0:	b4 a1       	ldd	r27, Z+36	; 0x24
    10e2:	48 2b       	or	r20, r24
    10e4:	59 2b       	or	r21, r25
    10e6:	6a 2b       	or	r22, r26
    10e8:	7b 2b       	or	r23, r27
    10ea:	13 c0       	rjmp	.+38     	; 0x1112 <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    10ec:	23 30       	cpi	r18, 0x03	; 3
    10ee:	89 f0       	breq	.+34     	; 0x1112 <xTaskGenericNotifyFromISR+0x6e>
    10f0:	24 30       	cpi	r18, 0x04	; 4
    10f2:	69 f0       	breq	.+26     	; 0x110e <xTaskGenericNotifyFromISR+0x6a>
    10f4:	12 c0       	rjmp	.+36     	; 0x111a <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    10f6:	81 a1       	ldd	r24, Z+33	; 0x21
    10f8:	92 a1       	ldd	r25, Z+34	; 0x22
    10fa:	a3 a1       	ldd	r26, Z+35	; 0x23
    10fc:	b4 a1       	ldd	r27, Z+36	; 0x24
    10fe:	01 96       	adiw	r24, 0x01	; 1
    1100:	a1 1d       	adc	r26, r1
    1102:	b1 1d       	adc	r27, r1
    1104:	81 a3       	std	Z+33, r24	; 0x21
    1106:	92 a3       	std	Z+34, r25	; 0x22
    1108:	a3 a3       	std	Z+35, r26	; 0x23
    110a:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    110c:	06 c0       	rjmp	.+12     	; 0x111a <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    110e:	32 30       	cpi	r19, 0x02	; 2
    1110:	d9 f1       	breq	.+118    	; 0x1188 <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1112:	41 a3       	std	Z+33, r20	; 0x21
    1114:	52 a3       	std	Z+34, r21	; 0x22
    1116:	63 a3       	std	Z+35, r22	; 0x23
    1118:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    111a:	31 30       	cpi	r19, 0x01	; 1
    111c:	11 f0       	breq	.+4      	; 0x1122 <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    111e:	81 e0       	ldi	r24, 0x01	; 1
    1120:	34 c0       	rjmp	.+104    	; 0x118a <xTaskGenericNotifyFromISR+0xe6>
    1122:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1124:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxSchedulerSuspended>
    1128:	81 11       	cpse	r24, r1
    112a:	15 c0       	rjmp	.+42     	; 0x1156 <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    112c:	8f 01       	movw	r16, r30
    112e:	0e 5f       	subi	r16, 0xFE	; 254
    1130:	1f 4f       	sbci	r17, 0xFF	; 255
    1132:	c8 01       	movw	r24, r16
    1134:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1138:	8e 89       	ldd	r24, Y+22	; 0x16
    113a:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <uxTopReadyPriority>
    113e:	98 17       	cp	r25, r24
    1140:	10 f4       	brcc	.+4      	; 0x1146 <xTaskGenericNotifyFromISR+0xa2>
    1142:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxTopReadyPriority>
    1146:	e9 e0       	ldi	r30, 0x09	; 9
    1148:	8e 9f       	mul	r24, r30
    114a:	c0 01       	movw	r24, r0
    114c:	11 24       	eor	r1, r1
    114e:	b8 01       	movw	r22, r16
    1150:	8c 58       	subi	r24, 0x8C	; 140
    1152:	9e 4f       	sbci	r25, 0xFE	; 254
    1154:	05 c0       	rjmp	.+10     	; 0x1160 <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1156:	bf 01       	movw	r22, r30
    1158:	64 5f       	subi	r22, 0xF4	; 244
    115a:	7f 4f       	sbci	r23, 0xFF	; 255
    115c:	85 e5       	ldi	r24, 0x55	; 85
    115e:	91 e0       	ldi	r25, 0x01	; 1
    1160:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1164:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
    1168:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
    116c:	9e 89       	ldd	r25, Y+22	; 0x16
    116e:	86 89       	ldd	r24, Z+22	; 0x16
    1170:	89 17       	cp	r24, r25
    1172:	a8 f6       	brcc	.-86     	; 0x111e <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1174:	e1 14       	cp	r14, r1
    1176:	f1 04       	cpc	r15, r1
    1178:	19 f0       	breq	.+6      	; 0x1180 <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    117a:	81 e0       	ldi	r24, 0x01	; 1
    117c:	e7 01       	movw	r28, r14
    117e:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1180:	81 e0       	ldi	r24, 0x01	; 1
    1182:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <xYieldPending>
    1186:	01 c0       	rjmp	.+2      	; 0x118a <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1188:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    118a:	df 91       	pop	r29
    118c:	cf 91       	pop	r28
    118e:	1f 91       	pop	r17
    1190:	0f 91       	pop	r16
    1192:	ff 90       	pop	r15
    1194:	ef 90       	pop	r14
    1196:	08 95       	ret

00001198 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1198:	ef 92       	push	r14
    119a:	ff 92       	push	r15
    119c:	0f 93       	push	r16
    119e:	1f 93       	push	r17
    11a0:	cf 93       	push	r28
    11a2:	df 93       	push	r29
    11a4:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    11a6:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    11a8:	82 e0       	ldi	r24, 0x02	; 2
    11aa:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    11ac:	81 a1       	ldd	r24, Z+33	; 0x21
    11ae:	92 a1       	ldd	r25, Z+34	; 0x22
    11b0:	a3 a1       	ldd	r26, Z+35	; 0x23
    11b2:	b4 a1       	ldd	r27, Z+36	; 0x24
    11b4:	01 96       	adiw	r24, 0x01	; 1
    11b6:	a1 1d       	adc	r26, r1
    11b8:	b1 1d       	adc	r27, r1
    11ba:	81 a3       	std	Z+33, r24	; 0x21
    11bc:	92 a3       	std	Z+34, r25	; 0x22
    11be:	a3 a3       	std	Z+35, r26	; 0x23
    11c0:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    11c2:	21 30       	cpi	r18, 0x01	; 1
    11c4:	a1 f5       	brne	.+104    	; 0x122e <vTaskNotifyGiveFromISR+0x96>
    11c6:	8b 01       	movw	r16, r22
    11c8:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    11ca:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <uxSchedulerSuspended>
    11ce:	81 11       	cpse	r24, r1
    11d0:	16 c0       	rjmp	.+44     	; 0x11fe <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    11d2:	7f 01       	movw	r14, r30
    11d4:	22 e0       	ldi	r18, 0x02	; 2
    11d6:	e2 0e       	add	r14, r18
    11d8:	f1 1c       	adc	r15, r1
    11da:	c7 01       	movw	r24, r14
    11dc:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    11e0:	8e 89       	ldd	r24, Y+22	; 0x16
    11e2:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <uxTopReadyPriority>
    11e6:	98 17       	cp	r25, r24
    11e8:	10 f4       	brcc	.+4      	; 0x11ee <vTaskNotifyGiveFromISR+0x56>
    11ea:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <uxTopReadyPriority>
    11ee:	e9 e0       	ldi	r30, 0x09	; 9
    11f0:	8e 9f       	mul	r24, r30
    11f2:	c0 01       	movw	r24, r0
    11f4:	11 24       	eor	r1, r1
    11f6:	b7 01       	movw	r22, r14
    11f8:	8c 58       	subi	r24, 0x8C	; 140
    11fa:	9e 4f       	sbci	r25, 0xFE	; 254
    11fc:	05 c0       	rjmp	.+10     	; 0x1208 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    11fe:	bf 01       	movw	r22, r30
    1200:	64 5f       	subi	r22, 0xF4	; 244
    1202:	7f 4f       	sbci	r23, 0xFF	; 255
    1204:	85 e5       	ldi	r24, 0x55	; 85
    1206:	91 e0       	ldi	r25, 0x01	; 1
    1208:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    120c:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxCurrentTCB>
    1210:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
    1214:	9e 89       	ldd	r25, Y+22	; 0x16
    1216:	86 89       	ldd	r24, Z+22	; 0x16
    1218:	89 17       	cp	r24, r25
    121a:	48 f4       	brcc	.+18     	; 0x122e <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    121c:	01 15       	cp	r16, r1
    121e:	11 05       	cpc	r17, r1
    1220:	19 f0       	breq	.+6      	; 0x1228 <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1222:	81 e0       	ldi	r24, 0x01	; 1
    1224:	f8 01       	movw	r30, r16
    1226:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1228:	81 e0       	ldi	r24, 0x01	; 1
    122a:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    122e:	df 91       	pop	r29
    1230:	cf 91       	pop	r28
    1232:	1f 91       	pop	r17
    1234:	0f 91       	pop	r16
    1236:	ff 90       	pop	r15
    1238:	ef 90       	pop	r14
    123a:	08 95       	ret

0000123c <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    123c:	00 97       	sbiw	r24, 0x00	; 0
    123e:	21 f4       	brne	.+8      	; 0x1248 <xTaskNotifyStateClear+0xc>
    1240:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <pxCurrentTCB>
    1244:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    1248:	0f b6       	in	r0, 0x3f	; 63
    124a:	f8 94       	cli
    124c:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    124e:	fc 01       	movw	r30, r24
    1250:	25 a1       	ldd	r18, Z+37	; 0x25
    1252:	22 30       	cpi	r18, 0x02	; 2
    1254:	19 f4       	brne	.+6      	; 0x125c <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1256:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    1258:	81 e0       	ldi	r24, 0x01	; 1
    125a:	01 c0       	rjmp	.+2      	; 0x125e <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    125c:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    125e:	0f 90       	pop	r0
    1260:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1262:	08 95       	ret

00001264 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1264:	0f b6       	in	r0, 0x3f	; 63
    1266:	f8 94       	cli
    1268:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    126a:	fc 01       	movw	r30, r24
    126c:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    126e:	0f 90       	pop	r0
    1270:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1272:	81 e0       	ldi	r24, 0x01	; 1
    1274:	91 11       	cpse	r25, r1
    1276:	80 e0       	ldi	r24, 0x00	; 0
}
    1278:	08 95       	ret

0000127a <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    127a:	0f 93       	push	r16
    127c:	1f 93       	push	r17
    127e:	cf 93       	push	r28
    1280:	df 93       	push	r29
    1282:	ec 01       	movw	r28, r24
    1284:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1286:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1288:	4c 8d       	ldd	r20, Y+28	; 0x1c
    128a:	44 23       	and	r20, r20
    128c:	b1 f1       	breq	.+108    	; 0x12fa <prvCopyDataToQueue+0x80>
    128e:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1290:	01 11       	cpse	r16, r1
    1292:	15 c0       	rjmp	.+42     	; 0x12be <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1294:	8a 81       	ldd	r24, Y+2	; 0x02
    1296:	9b 81       	ldd	r25, Y+3	; 0x03
    1298:	0e 94 4c 12 	call	0x2498	; 0x2498 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    129c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    129e:	8a 81       	ldd	r24, Y+2	; 0x02
    12a0:	9b 81       	ldd	r25, Y+3	; 0x03
    12a2:	82 0f       	add	r24, r18
    12a4:	91 1d       	adc	r25, r1
    12a6:	9b 83       	std	Y+3, r25	; 0x03
    12a8:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    12aa:	2c 81       	ldd	r18, Y+4	; 0x04
    12ac:	3d 81       	ldd	r19, Y+5	; 0x05
    12ae:	82 17       	cp	r24, r18
    12b0:	93 07       	cpc	r25, r19
    12b2:	18 f1       	brcs	.+70     	; 0x12fa <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    12b4:	88 81       	ld	r24, Y
    12b6:	99 81       	ldd	r25, Y+1	; 0x01
    12b8:	9b 83       	std	Y+3, r25	; 0x03
    12ba:	8a 83       	std	Y+2, r24	; 0x02
    12bc:	1e c0       	rjmp	.+60     	; 0x12fa <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    12be:	8e 81       	ldd	r24, Y+6	; 0x06
    12c0:	9f 81       	ldd	r25, Y+7	; 0x07
    12c2:	0e 94 4c 12 	call	0x2498	; 0x2498 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    12c6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	91 95       	neg	r25
    12cc:	81 95       	neg	r24
    12ce:	91 09       	sbc	r25, r1
    12d0:	2e 81       	ldd	r18, Y+6	; 0x06
    12d2:	3f 81       	ldd	r19, Y+7	; 0x07
    12d4:	28 0f       	add	r18, r24
    12d6:	39 1f       	adc	r19, r25
    12d8:	3f 83       	std	Y+7, r19	; 0x07
    12da:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    12dc:	48 81       	ld	r20, Y
    12de:	59 81       	ldd	r21, Y+1	; 0x01
    12e0:	24 17       	cp	r18, r20
    12e2:	35 07       	cpc	r19, r21
    12e4:	30 f4       	brcc	.+12     	; 0x12f2 <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    12e6:	2c 81       	ldd	r18, Y+4	; 0x04
    12e8:	3d 81       	ldd	r19, Y+5	; 0x05
    12ea:	82 0f       	add	r24, r18
    12ec:	93 1f       	adc	r25, r19
    12ee:	9f 83       	std	Y+7, r25	; 0x07
    12f0:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    12f2:	02 30       	cpi	r16, 0x02	; 2
    12f4:	11 f4       	brne	.+4      	; 0x12fa <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    12f6:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    12f8:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    12fa:	1f 5f       	subi	r17, 0xFF	; 255
    12fc:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    12fe:	80 e0       	ldi	r24, 0x00	; 0
    1300:	df 91       	pop	r29
    1302:	cf 91       	pop	r28
    1304:	1f 91       	pop	r17
    1306:	0f 91       	pop	r16
    1308:	08 95       	ret

0000130a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    130a:	fc 01       	movw	r30, r24
    130c:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    130e:	44 8d       	ldd	r20, Z+28	; 0x1c
    1310:	44 23       	and	r20, r20
    1312:	a1 f0       	breq	.+40     	; 0x133c <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1314:	50 e0       	ldi	r21, 0x00	; 0
    1316:	26 81       	ldd	r18, Z+6	; 0x06
    1318:	37 81       	ldd	r19, Z+7	; 0x07
    131a:	24 0f       	add	r18, r20
    131c:	35 1f       	adc	r19, r21
    131e:	37 83       	std	Z+7, r19	; 0x07
    1320:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1322:	64 81       	ldd	r22, Z+4	; 0x04
    1324:	75 81       	ldd	r23, Z+5	; 0x05
    1326:	26 17       	cp	r18, r22
    1328:	37 07       	cpc	r19, r23
    132a:	20 f0       	brcs	.+8      	; 0x1334 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    132c:	20 81       	ld	r18, Z
    132e:	31 81       	ldd	r19, Z+1	; 0x01
    1330:	37 83       	std	Z+7, r19	; 0x07
    1332:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1334:	66 81       	ldd	r22, Z+6	; 0x06
    1336:	77 81       	ldd	r23, Z+7	; 0x07
    1338:	0c 94 4c 12 	jmp	0x2498	; 0x2498 <memcpy>
    133c:	08 95       	ret

0000133e <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    133e:	ef 92       	push	r14
    1340:	ff 92       	push	r15
    1342:	1f 93       	push	r17
    1344:	cf 93       	push	r28
    1346:	df 93       	push	r29
    1348:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    134a:	0f b6       	in	r0, 0x3f	; 63
    134c:	f8 94       	cli
    134e:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1350:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1352:	7c 01       	movw	r14, r24
    1354:	81 e1       	ldi	r24, 0x11	; 17
    1356:	e8 0e       	add	r14, r24
    1358:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    135a:	11 16       	cp	r1, r17
    135c:	5c f4       	brge	.+22     	; 0x1374 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    135e:	89 89       	ldd	r24, Y+17	; 0x11
    1360:	88 23       	and	r24, r24
    1362:	41 f0       	breq	.+16     	; 0x1374 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1364:	c7 01       	movw	r24, r14
    1366:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
    136a:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    136c:	0e 94 f5 06 	call	0xdea	; 0xdea <vTaskMissedYield>
    1370:	11 50       	subi	r17, 0x01	; 1
    1372:	f3 cf       	rjmp	.-26     	; 0x135a <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1374:	8f ef       	ldi	r24, 0xFF	; 255
    1376:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1378:	0f 90       	pop	r0
    137a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    137c:	0f b6       	in	r0, 0x3f	; 63
    137e:	f8 94       	cli
    1380:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1382:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1384:	7e 01       	movw	r14, r28
    1386:	88 e0       	ldi	r24, 0x08	; 8
    1388:	e8 0e       	add	r14, r24
    138a:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    138c:	11 16       	cp	r1, r17
    138e:	5c f4       	brge	.+22     	; 0x13a6 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1390:	88 85       	ldd	r24, Y+8	; 0x08
    1392:	88 23       	and	r24, r24
    1394:	41 f0       	breq	.+16     	; 0x13a6 <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1396:	c7 01       	movw	r24, r14
    1398:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
    139c:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    139e:	0e 94 f5 06 	call	0xdea	; 0xdea <vTaskMissedYield>
    13a2:	11 50       	subi	r17, 0x01	; 1
    13a4:	f3 cf       	rjmp	.-26     	; 0x138c <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    13a6:	8f ef       	ldi	r24, 0xFF	; 255
    13a8:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    13aa:	0f 90       	pop	r0
    13ac:	0f be       	out	0x3f, r0	; 63
}
    13ae:	df 91       	pop	r29
    13b0:	cf 91       	pop	r28
    13b2:	1f 91       	pop	r17
    13b4:	ff 90       	pop	r15
    13b6:	ef 90       	pop	r14
    13b8:	08 95       	ret

000013ba <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    13ba:	cf 93       	push	r28
    13bc:	df 93       	push	r29
    13be:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    13c0:	0f b6       	in	r0, 0x3f	; 63
    13c2:	f8 94       	cli
    13c4:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    13c6:	48 81       	ld	r20, Y
    13c8:	59 81       	ldd	r21, Y+1	; 0x01
    13ca:	8b 8d       	ldd	r24, Y+27	; 0x1b
    13cc:	7c 8d       	ldd	r23, Y+28	; 0x1c
    13ce:	9a 01       	movw	r18, r20
    13d0:	87 9f       	mul	r24, r23
    13d2:	20 0d       	add	r18, r0
    13d4:	31 1d       	adc	r19, r1
    13d6:	11 24       	eor	r1, r1
    13d8:	3d 83       	std	Y+5, r19	; 0x05
    13da:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    13dc:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    13de:	5b 83       	std	Y+3, r21	; 0x03
    13e0:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    13e2:	90 e0       	ldi	r25, 0x00	; 0
    13e4:	01 97       	sbiw	r24, 0x01	; 1
    13e6:	78 9f       	mul	r23, r24
    13e8:	90 01       	movw	r18, r0
    13ea:	79 9f       	mul	r23, r25
    13ec:	30 0d       	add	r19, r0
    13ee:	11 24       	eor	r1, r1
    13f0:	ca 01       	movw	r24, r20
    13f2:	82 0f       	add	r24, r18
    13f4:	93 1f       	adc	r25, r19
    13f6:	9f 83       	std	Y+7, r25	; 0x07
    13f8:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    13fa:	8f ef       	ldi	r24, 0xFF	; 255
    13fc:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    13fe:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1400:	61 11       	cpse	r22, r1
    1402:	0c c0       	rjmp	.+24     	; 0x141c <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1404:	88 85       	ldd	r24, Y+8	; 0x08
    1406:	88 23       	and	r24, r24
    1408:	89 f0       	breq	.+34     	; 0x142c <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    140a:	ce 01       	movw	r24, r28
    140c:	08 96       	adiw	r24, 0x08	; 8
    140e:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
    1412:	88 23       	and	r24, r24
    1414:	59 f0       	breq	.+22     	; 0x142c <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1416:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
    141a:	08 c0       	rjmp	.+16     	; 0x142c <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    141c:	ce 01       	movw	r24, r28
    141e:	08 96       	adiw	r24, 0x08	; 8
    1420:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1424:	ce 01       	movw	r24, r28
    1426:	41 96       	adiw	r24, 0x11	; 17
    1428:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    142c:	0f 90       	pop	r0
    142e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1430:	81 e0       	ldi	r24, 0x01	; 1
    1432:	df 91       	pop	r29
    1434:	cf 91       	pop	r28
    1436:	08 95       	ret

00001438 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1438:	0f 93       	push	r16
    143a:	1f 93       	push	r17
    143c:	cf 93       	push	r28
    143e:	df 93       	push	r29
    1440:	08 2f       	mov	r16, r24
    1442:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1444:	66 23       	and	r22, r22
    1446:	21 f0       	breq	.+8      	; 0x1450 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1448:	86 9f       	mul	r24, r22
    144a:	c0 01       	movw	r24, r0
    144c:	11 24       	eor	r1, r1
    144e:	02 c0       	rjmp	.+4      	; 0x1454 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1450:	80 e0       	ldi	r24, 0x00	; 0
    1452:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1454:	4f 96       	adiw	r24, 0x1f	; 31
    1456:	0e 94 73 10 	call	0x20e6	; 0x20e6 <pvPortMalloc>
    145a:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    145c:	00 97       	sbiw	r24, 0x00	; 0
    145e:	71 f0       	breq	.+28     	; 0x147c <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1460:	11 11       	cpse	r17, r1
    1462:	03 c0       	rjmp	.+6      	; 0x146a <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1464:	99 83       	std	Y+1, r25	; 0x01
    1466:	88 83       	st	Y, r24
    1468:	03 c0       	rjmp	.+6      	; 0x1470 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    146a:	4f 96       	adiw	r24, 0x1f	; 31
    146c:	99 83       	std	Y+1, r25	; 0x01
    146e:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1470:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1472:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1474:	61 e0       	ldi	r22, 0x01	; 1
    1476:	ce 01       	movw	r24, r28
    1478:	0e 94 dd 09 	call	0x13ba	; 0x13ba <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    147c:	ce 01       	movw	r24, r28
    147e:	df 91       	pop	r29
    1480:	cf 91       	pop	r28
    1482:	1f 91       	pop	r17
    1484:	0f 91       	pop	r16
    1486:	08 95       	ret

00001488 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1488:	af 92       	push	r10
    148a:	bf 92       	push	r11
    148c:	cf 92       	push	r12
    148e:	df 92       	push	r13
    1490:	ff 92       	push	r15
    1492:	0f 93       	push	r16
    1494:	1f 93       	push	r17
    1496:	cf 93       	push	r28
    1498:	df 93       	push	r29
    149a:	00 d0       	rcall	.+0      	; 0x149c <xQueueGenericSend+0x14>
    149c:	00 d0       	rcall	.+0      	; 0x149e <xQueueGenericSend+0x16>
    149e:	1f 92       	push	r1
    14a0:	cd b7       	in	r28, 0x3d	; 61
    14a2:	de b7       	in	r29, 0x3e	; 62
    14a4:	8c 01       	movw	r16, r24
    14a6:	6b 01       	movw	r12, r22
    14a8:	5d 83       	std	Y+5, r21	; 0x05
    14aa:	4c 83       	std	Y+4, r20	; 0x04
    14ac:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    14ae:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    14b0:	58 01       	movw	r10, r16
    14b2:	98 e0       	ldi	r25, 0x08	; 8
    14b4:	a9 0e       	add	r10, r25
    14b6:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    14b8:	0f b6       	in	r0, 0x3f	; 63
    14ba:	f8 94       	cli
    14bc:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    14be:	f8 01       	movw	r30, r16
    14c0:	22 8d       	ldd	r18, Z+26	; 0x1a
    14c2:	93 8d       	ldd	r25, Z+27	; 0x1b
    14c4:	29 17       	cp	r18, r25
    14c6:	18 f0       	brcs	.+6      	; 0x14ce <xQueueGenericSend+0x46>
    14c8:	f2 e0       	ldi	r31, 0x02	; 2
    14ca:	ff 12       	cpse	r15, r31
    14cc:	14 c0       	rjmp	.+40     	; 0x14f6 <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    14ce:	4f 2d       	mov	r20, r15
    14d0:	b6 01       	movw	r22, r12
    14d2:	c8 01       	movw	r24, r16
    14d4:	0e 94 3d 09 	call	0x127a	; 0x127a <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14d8:	f8 01       	movw	r30, r16
    14da:	91 89       	ldd	r25, Z+17	; 0x11
    14dc:	99 23       	and	r25, r25
    14de:	21 f0       	breq	.+8      	; 0x14e8 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14e0:	c8 01       	movw	r24, r16
    14e2:	41 96       	adiw	r24, 0x11	; 17
    14e4:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
    14e8:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    14ea:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    14ee:	0f 90       	pop	r0
    14f0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    14f2:	81 e0       	ldi	r24, 0x01	; 1
    14f4:	50 c0       	rjmp	.+160    	; 0x1596 <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    14f6:	2c 81       	ldd	r18, Y+4	; 0x04
    14f8:	3d 81       	ldd	r19, Y+5	; 0x05
    14fa:	23 2b       	or	r18, r19
    14fc:	19 f4       	brne	.+6      	; 0x1504 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    14fe:	0f 90       	pop	r0
    1500:	0f be       	out	0x3f, r0	; 63
    1502:	48 c0       	rjmp	.+144    	; 0x1594 <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1504:	81 11       	cpse	r24, r1
    1506:	04 c0       	rjmp	.+8      	; 0x1510 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1508:	ce 01       	movw	r24, r28
    150a:	01 96       	adiw	r24, 0x01	; 1
    150c:	0e 94 b7 06 	call	0xd6e	; 0xd6e <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1510:	0f 90       	pop	r0
    1512:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1514:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1518:	0f b6       	in	r0, 0x3f	; 63
    151a:	f8 94       	cli
    151c:	0f 92       	push	r0
    151e:	f8 01       	movw	r30, r16
    1520:	85 8d       	ldd	r24, Z+29	; 0x1d
    1522:	8f 3f       	cpi	r24, 0xFF	; 255
    1524:	09 f4       	brne	.+2      	; 0x1528 <xQueueGenericSend+0xa0>
    1526:	15 8e       	std	Z+29, r1	; 0x1d
    1528:	f8 01       	movw	r30, r16
    152a:	86 8d       	ldd	r24, Z+30	; 0x1e
    152c:	8f 3f       	cpi	r24, 0xFF	; 255
    152e:	09 f4       	brne	.+2      	; 0x1532 <xQueueGenericSend+0xaa>
    1530:	16 8e       	std	Z+30, r1	; 0x1e
    1532:	0f 90       	pop	r0
    1534:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1536:	be 01       	movw	r22, r28
    1538:	6c 5f       	subi	r22, 0xFC	; 252
    153a:	7f 4f       	sbci	r23, 0xFF	; 255
    153c:	ce 01       	movw	r24, r28
    153e:	01 96       	adiw	r24, 0x01	; 1
    1540:	0e 94 c2 06 	call	0xd84	; 0xd84 <xTaskCheckForTimeOut>
    1544:	81 11       	cpse	r24, r1
    1546:	21 c0       	rjmp	.+66     	; 0x158a <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1548:	0f b6       	in	r0, 0x3f	; 63
    154a:	f8 94       	cli
    154c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    154e:	f8 01       	movw	r30, r16
    1550:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1552:	0f 90       	pop	r0
    1554:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1556:	83 8d       	ldd	r24, Z+27	; 0x1b
    1558:	98 13       	cpse	r25, r24
    155a:	11 c0       	rjmp	.+34     	; 0x157e <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    155c:	6c 81       	ldd	r22, Y+4	; 0x04
    155e:	7d 81       	ldd	r23, Y+5	; 0x05
    1560:	c5 01       	movw	r24, r10
    1562:	0e 94 0c 06 	call	0xc18	; 0xc18 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1566:	c8 01       	movw	r24, r16
    1568:	0e 94 9f 09 	call	0x133e	; 0x133e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    156c:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>
    1570:	88 23       	and	r24, r24
    1572:	11 f0       	breq	.+4      	; 0x1578 <xQueueGenericSend+0xf0>
    1574:	81 e0       	ldi	r24, 0x01	; 1
    1576:	a0 cf       	rjmp	.-192    	; 0x14b8 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    1578:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
    157c:	fb cf       	rjmp	.-10     	; 0x1574 <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    157e:	c8 01       	movw	r24, r16
    1580:	0e 94 9f 09 	call	0x133e	; 0x133e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1584:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>
    1588:	f5 cf       	rjmp	.-22     	; 0x1574 <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    158a:	c8 01       	movw	r24, r16
    158c:	0e 94 9f 09 	call	0x133e	; 0x133e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1590:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1594:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    1596:	0f 90       	pop	r0
    1598:	0f 90       	pop	r0
    159a:	0f 90       	pop	r0
    159c:	0f 90       	pop	r0
    159e:	0f 90       	pop	r0
    15a0:	df 91       	pop	r29
    15a2:	cf 91       	pop	r28
    15a4:	1f 91       	pop	r17
    15a6:	0f 91       	pop	r16
    15a8:	ff 90       	pop	r15
    15aa:	df 90       	pop	r13
    15ac:	cf 90       	pop	r12
    15ae:	bf 90       	pop	r11
    15b0:	af 90       	pop	r10
    15b2:	08 95       	ret

000015b4 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    15b4:	ef 92       	push	r14
    15b6:	ff 92       	push	r15
    15b8:	1f 93       	push	r17
    15ba:	cf 93       	push	r28
    15bc:	df 93       	push	r29
    15be:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    15c0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    15c2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    15c4:	98 17       	cp	r25, r24
    15c6:	10 f0       	brcs	.+4      	; 0x15cc <xQueueGenericSendFromISR+0x18>
    15c8:	22 30       	cpi	r18, 0x02	; 2
    15ca:	e1 f4       	brne	.+56     	; 0x1604 <xQueueGenericSendFromISR+0x50>
    15cc:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    15ce:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    15d0:	42 2f       	mov	r20, r18
    15d2:	ce 01       	movw	r24, r28
    15d4:	0e 94 3d 09 	call	0x127a	; 0x127a <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    15d8:	1f 3f       	cpi	r17, 0xFF	; 255
    15da:	81 f4       	brne	.+32     	; 0x15fc <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    15dc:	89 89       	ldd	r24, Y+17	; 0x11
    15de:	88 23       	and	r24, r24
    15e0:	79 f0       	breq	.+30     	; 0x1600 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15e2:	ce 01       	movw	r24, r28
    15e4:	41 96       	adiw	r24, 0x11	; 17
    15e6:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
    15ea:	88 23       	and	r24, r24
    15ec:	49 f0       	breq	.+18     	; 0x1600 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    15ee:	e1 14       	cp	r14, r1
    15f0:	f1 04       	cpc	r15, r1
    15f2:	31 f0       	breq	.+12     	; 0x1600 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    15f4:	81 e0       	ldi	r24, 0x01	; 1
    15f6:	f7 01       	movw	r30, r14
    15f8:	80 83       	st	Z, r24
    15fa:	05 c0       	rjmp	.+10     	; 0x1606 <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    15fc:	1f 5f       	subi	r17, 0xFF	; 255
    15fe:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    1600:	81 e0       	ldi	r24, 0x01	; 1
    1602:	01 c0       	rjmp	.+2      	; 0x1606 <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1604:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1606:	df 91       	pop	r29
    1608:	cf 91       	pop	r28
    160a:	1f 91       	pop	r17
    160c:	ff 90       	pop	r15
    160e:	ef 90       	pop	r14
    1610:	08 95       	ret

00001612 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1612:	cf 93       	push	r28
    1614:	df 93       	push	r29
    1616:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1618:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    161a:	83 8d       	ldd	r24, Z+27	; 0x1b
    161c:	98 17       	cp	r25, r24
    161e:	c0 f4       	brcc	.+48     	; 0x1650 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1620:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1622:	9f 5f       	subi	r25, 0xFF	; 255
    1624:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1626:	8f 3f       	cpi	r24, 0xFF	; 255
    1628:	79 f4       	brne	.+30     	; 0x1648 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    162a:	81 89       	ldd	r24, Z+17	; 0x11
    162c:	88 23       	and	r24, r24
    162e:	71 f0       	breq	.+28     	; 0x164c <xQueueGiveFromISR+0x3a>
    1630:	eb 01       	movw	r28, r22
    1632:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1634:	41 96       	adiw	r24, 0x11	; 17
    1636:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
    163a:	88 23       	and	r24, r24
    163c:	39 f0       	breq	.+14     	; 0x164c <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    163e:	20 97       	sbiw	r28, 0x00	; 0
    1640:	29 f0       	breq	.+10     	; 0x164c <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1642:	81 e0       	ldi	r24, 0x01	; 1
    1644:	88 83       	st	Y, r24
    1646:	05 c0       	rjmp	.+10     	; 0x1652 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1648:	8f 5f       	subi	r24, 0xFF	; 255
    164a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    164c:	81 e0       	ldi	r24, 0x01	; 1
    164e:	01 c0       	rjmp	.+2      	; 0x1652 <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1650:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1652:	df 91       	pop	r29
    1654:	cf 91       	pop	r28
    1656:	08 95       	ret

00001658 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1658:	af 92       	push	r10
    165a:	bf 92       	push	r11
    165c:	cf 92       	push	r12
    165e:	df 92       	push	r13
    1660:	ff 92       	push	r15
    1662:	0f 93       	push	r16
    1664:	1f 93       	push	r17
    1666:	cf 93       	push	r28
    1668:	df 93       	push	r29
    166a:	00 d0       	rcall	.+0      	; 0x166c <xQueueReceive+0x14>
    166c:	00 d0       	rcall	.+0      	; 0x166e <xQueueReceive+0x16>
    166e:	1f 92       	push	r1
    1670:	cd b7       	in	r28, 0x3d	; 61
    1672:	de b7       	in	r29, 0x3e	; 62
    1674:	8c 01       	movw	r16, r24
    1676:	6b 01       	movw	r12, r22
    1678:	5d 83       	std	Y+5, r21	; 0x05
    167a:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    167c:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    167e:	58 01       	movw	r10, r16
    1680:	91 e1       	ldi	r25, 0x11	; 17
    1682:	a9 0e       	add	r10, r25
    1684:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1686:	0f b6       	in	r0, 0x3f	; 63
    1688:	f8 94       	cli
    168a:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    168c:	f8 01       	movw	r30, r16
    168e:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1690:	ff 20       	and	r15, r15
    1692:	a9 f0       	breq	.+42     	; 0x16be <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1694:	b6 01       	movw	r22, r12
    1696:	c8 01       	movw	r24, r16
    1698:	0e 94 85 09 	call	0x130a	; 0x130a <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    169c:	fa 94       	dec	r15
    169e:	f8 01       	movw	r30, r16
    16a0:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16a2:	80 85       	ldd	r24, Z+8	; 0x08
    16a4:	88 23       	and	r24, r24
    16a6:	39 f0       	breq	.+14     	; 0x16b6 <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16a8:	c8 01       	movw	r24, r16
    16aa:	08 96       	adiw	r24, 0x08	; 8
    16ac:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
    16b0:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    16b2:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    16b6:	0f 90       	pop	r0
    16b8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    16ba:	81 e0       	ldi	r24, 0x01	; 1
    16bc:	50 c0       	rjmp	.+160    	; 0x175e <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    16be:	2c 81       	ldd	r18, Y+4	; 0x04
    16c0:	3d 81       	ldd	r19, Y+5	; 0x05
    16c2:	23 2b       	or	r18, r19
    16c4:	19 f4       	brne	.+6      	; 0x16cc <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    16c6:	0f 90       	pop	r0
    16c8:	0f be       	out	0x3f, r0	; 63
    16ca:	48 c0       	rjmp	.+144    	; 0x175c <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    16cc:	81 11       	cpse	r24, r1
    16ce:	04 c0       	rjmp	.+8      	; 0x16d8 <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    16d0:	ce 01       	movw	r24, r28
    16d2:	01 96       	adiw	r24, 0x01	; 1
    16d4:	0e 94 b7 06 	call	0xd6e	; 0xd6e <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    16d8:	0f 90       	pop	r0
    16da:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    16dc:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16e0:	0f b6       	in	r0, 0x3f	; 63
    16e2:	f8 94       	cli
    16e4:	0f 92       	push	r0
    16e6:	f8 01       	movw	r30, r16
    16e8:	85 8d       	ldd	r24, Z+29	; 0x1d
    16ea:	8f 3f       	cpi	r24, 0xFF	; 255
    16ec:	09 f4       	brne	.+2      	; 0x16f0 <xQueueReceive+0x98>
    16ee:	15 8e       	std	Z+29, r1	; 0x1d
    16f0:	f8 01       	movw	r30, r16
    16f2:	86 8d       	ldd	r24, Z+30	; 0x1e
    16f4:	8f 3f       	cpi	r24, 0xFF	; 255
    16f6:	09 f4       	brne	.+2      	; 0x16fa <xQueueReceive+0xa2>
    16f8:	16 8e       	std	Z+30, r1	; 0x1e
    16fa:	0f 90       	pop	r0
    16fc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16fe:	be 01       	movw	r22, r28
    1700:	6c 5f       	subi	r22, 0xFC	; 252
    1702:	7f 4f       	sbci	r23, 0xFF	; 255
    1704:	ce 01       	movw	r24, r28
    1706:	01 96       	adiw	r24, 0x01	; 1
    1708:	0e 94 c2 06 	call	0xd84	; 0xd84 <xTaskCheckForTimeOut>
    170c:	81 11       	cpse	r24, r1
    170e:	1c c0       	rjmp	.+56     	; 0x1748 <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1710:	c8 01       	movw	r24, r16
    1712:	0e 94 32 09 	call	0x1264	; 0x1264 <prvIsQueueEmpty>
    1716:	88 23       	and	r24, r24
    1718:	89 f0       	breq	.+34     	; 0x173c <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    171a:	6c 81       	ldd	r22, Y+4	; 0x04
    171c:	7d 81       	ldd	r23, Y+5	; 0x05
    171e:	c5 01       	movw	r24, r10
    1720:	0e 94 0c 06 	call	0xc18	; 0xc18 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1724:	c8 01       	movw	r24, r16
    1726:	0e 94 9f 09 	call	0x133e	; 0x133e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    172a:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>
    172e:	88 23       	and	r24, r24
    1730:	11 f0       	breq	.+4      	; 0x1736 <xQueueReceive+0xde>
    1732:	81 e0       	ldi	r24, 0x01	; 1
    1734:	a8 cf       	rjmp	.-176    	; 0x1686 <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    1736:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
    173a:	fb cf       	rjmp	.-10     	; 0x1732 <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    173c:	c8 01       	movw	r24, r16
    173e:	0e 94 9f 09 	call	0x133e	; 0x133e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1742:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>
    1746:	f5 cf       	rjmp	.-22     	; 0x1732 <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1748:	c8 01       	movw	r24, r16
    174a:	0e 94 9f 09 	call	0x133e	; 0x133e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    174e:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1752:	c8 01       	movw	r24, r16
    1754:	0e 94 32 09 	call	0x1264	; 0x1264 <prvIsQueueEmpty>
    1758:	88 23       	and	r24, r24
    175a:	59 f3       	breq	.-42     	; 0x1732 <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    175c:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    175e:	0f 90       	pop	r0
    1760:	0f 90       	pop	r0
    1762:	0f 90       	pop	r0
    1764:	0f 90       	pop	r0
    1766:	0f 90       	pop	r0
    1768:	df 91       	pop	r29
    176a:	cf 91       	pop	r28
    176c:	1f 91       	pop	r17
    176e:	0f 91       	pop	r16
    1770:	ff 90       	pop	r15
    1772:	df 90       	pop	r13
    1774:	cf 90       	pop	r12
    1776:	bf 90       	pop	r11
    1778:	af 90       	pop	r10
    177a:	08 95       	ret

0000177c <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    177c:	ef 92       	push	r14
    177e:	ff 92       	push	r15
    1780:	0f 93       	push	r16
    1782:	1f 93       	push	r17
    1784:	cf 93       	push	r28
    1786:	df 93       	push	r29
    1788:	00 d0       	rcall	.+0      	; 0x178a <xQueueSemaphoreTake+0xe>
    178a:	00 d0       	rcall	.+0      	; 0x178c <xQueueSemaphoreTake+0x10>
    178c:	1f 92       	push	r1
    178e:	cd b7       	in	r28, 0x3d	; 61
    1790:	de b7       	in	r29, 0x3e	; 62
    1792:	8c 01       	movw	r16, r24
    1794:	7d 83       	std	Y+5, r23	; 0x05
    1796:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1798:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    179a:	78 01       	movw	r14, r16
    179c:	81 e1       	ldi	r24, 0x11	; 17
    179e:	e8 0e       	add	r14, r24
    17a0:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    17a2:	0f b6       	in	r0, 0x3f	; 63
    17a4:	f8 94       	cli
    17a6:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    17a8:	f8 01       	movw	r30, r16
    17aa:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    17ac:	88 23       	and	r24, r24
    17ae:	81 f0       	breq	.+32     	; 0x17d0 <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    17b0:	81 50       	subi	r24, 0x01	; 1
    17b2:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17b4:	80 85       	ldd	r24, Z+8	; 0x08
    17b6:	88 23       	and	r24, r24
    17b8:	39 f0       	breq	.+14     	; 0x17c8 <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17ba:	c8 01       	movw	r24, r16
    17bc:	08 96       	adiw	r24, 0x08	; 8
    17be:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
    17c2:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    17c4:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    17c8:	0f 90       	pop	r0
    17ca:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    17cc:	81 e0       	ldi	r24, 0x01	; 1
    17ce:	50 c0       	rjmp	.+160    	; 0x1870 <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    17d0:	2c 81       	ldd	r18, Y+4	; 0x04
    17d2:	3d 81       	ldd	r19, Y+5	; 0x05
    17d4:	23 2b       	or	r18, r19
    17d6:	19 f4       	brne	.+6      	; 0x17de <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    17d8:	0f 90       	pop	r0
    17da:	0f be       	out	0x3f, r0	; 63
    17dc:	48 c0       	rjmp	.+144    	; 0x186e <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    17de:	91 11       	cpse	r25, r1
    17e0:	04 c0       	rjmp	.+8      	; 0x17ea <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    17e2:	ce 01       	movw	r24, r28
    17e4:	01 96       	adiw	r24, 0x01	; 1
    17e6:	0e 94 b7 06 	call	0xd6e	; 0xd6e <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    17ea:	0f 90       	pop	r0
    17ec:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    17ee:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    17f2:	0f b6       	in	r0, 0x3f	; 63
    17f4:	f8 94       	cli
    17f6:	0f 92       	push	r0
    17f8:	f8 01       	movw	r30, r16
    17fa:	85 8d       	ldd	r24, Z+29	; 0x1d
    17fc:	8f 3f       	cpi	r24, 0xFF	; 255
    17fe:	09 f4       	brne	.+2      	; 0x1802 <xQueueSemaphoreTake+0x86>
    1800:	15 8e       	std	Z+29, r1	; 0x1d
    1802:	f8 01       	movw	r30, r16
    1804:	86 8d       	ldd	r24, Z+30	; 0x1e
    1806:	8f 3f       	cpi	r24, 0xFF	; 255
    1808:	09 f4       	brne	.+2      	; 0x180c <xQueueSemaphoreTake+0x90>
    180a:	16 8e       	std	Z+30, r1	; 0x1e
    180c:	0f 90       	pop	r0
    180e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1810:	be 01       	movw	r22, r28
    1812:	6c 5f       	subi	r22, 0xFC	; 252
    1814:	7f 4f       	sbci	r23, 0xFF	; 255
    1816:	ce 01       	movw	r24, r28
    1818:	01 96       	adiw	r24, 0x01	; 1
    181a:	0e 94 c2 06 	call	0xd84	; 0xd84 <xTaskCheckForTimeOut>
    181e:	81 11       	cpse	r24, r1
    1820:	1c c0       	rjmp	.+56     	; 0x185a <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1822:	c8 01       	movw	r24, r16
    1824:	0e 94 32 09 	call	0x1264	; 0x1264 <prvIsQueueEmpty>
    1828:	88 23       	and	r24, r24
    182a:	89 f0       	breq	.+34     	; 0x184e <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    182c:	6c 81       	ldd	r22, Y+4	; 0x04
    182e:	7d 81       	ldd	r23, Y+5	; 0x05
    1830:	c7 01       	movw	r24, r14
    1832:	0e 94 0c 06 	call	0xc18	; 0xc18 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1836:	c8 01       	movw	r24, r16
    1838:	0e 94 9f 09 	call	0x133e	; 0x133e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    183c:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>
    1840:	88 23       	and	r24, r24
    1842:	11 f0       	breq	.+4      	; 0x1848 <xQueueSemaphoreTake+0xcc>
    1844:	91 e0       	ldi	r25, 0x01	; 1
    1846:	ad cf       	rjmp	.-166    	; 0x17a2 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    1848:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
    184c:	fb cf       	rjmp	.-10     	; 0x1844 <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    184e:	c8 01       	movw	r24, r16
    1850:	0e 94 9f 09 	call	0x133e	; 0x133e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1854:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>
    1858:	f5 cf       	rjmp	.-22     	; 0x1844 <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    185a:	c8 01       	movw	r24, r16
    185c:	0e 94 9f 09 	call	0x133e	; 0x133e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1860:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1864:	c8 01       	movw	r24, r16
    1866:	0e 94 32 09 	call	0x1264	; 0x1264 <prvIsQueueEmpty>
    186a:	88 23       	and	r24, r24
    186c:	59 f3       	breq	.-42     	; 0x1844 <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    186e:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1870:	0f 90       	pop	r0
    1872:	0f 90       	pop	r0
    1874:	0f 90       	pop	r0
    1876:	0f 90       	pop	r0
    1878:	0f 90       	pop	r0
    187a:	df 91       	pop	r29
    187c:	cf 91       	pop	r28
    187e:	1f 91       	pop	r17
    1880:	0f 91       	pop	r16
    1882:	ff 90       	pop	r15
    1884:	ef 90       	pop	r14
    1886:	08 95       	ret

00001888 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1888:	cf 92       	push	r12
    188a:	df 92       	push	r13
    188c:	ef 92       	push	r14
    188e:	ff 92       	push	r15
    1890:	0f 93       	push	r16
    1892:	1f 93       	push	r17
    1894:	cf 93       	push	r28
    1896:	df 93       	push	r29
    1898:	00 d0       	rcall	.+0      	; 0x189a <xQueuePeek+0x12>
    189a:	00 d0       	rcall	.+0      	; 0x189c <xQueuePeek+0x14>
    189c:	1f 92       	push	r1
    189e:	cd b7       	in	r28, 0x3d	; 61
    18a0:	de b7       	in	r29, 0x3e	; 62
    18a2:	8c 01       	movw	r16, r24
    18a4:	7b 01       	movw	r14, r22
    18a6:	5d 83       	std	Y+5, r21	; 0x05
    18a8:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    18aa:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18ac:	68 01       	movw	r12, r16
    18ae:	91 e1       	ldi	r25, 0x11	; 17
    18b0:	c9 0e       	add	r12, r25
    18b2:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    18b4:	0f b6       	in	r0, 0x3f	; 63
    18b6:	f8 94       	cli
    18b8:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    18ba:	f8 01       	movw	r30, r16
    18bc:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    18be:	99 23       	and	r25, r25
    18c0:	b9 f0       	breq	.+46     	; 0x18f0 <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    18c2:	c6 80       	ldd	r12, Z+6	; 0x06
    18c4:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    18c6:	b7 01       	movw	r22, r14
    18c8:	c8 01       	movw	r24, r16
    18ca:	0e 94 85 09 	call	0x130a	; 0x130a <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    18ce:	f8 01       	movw	r30, r16
    18d0:	d7 82       	std	Z+7, r13	; 0x07
    18d2:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18d4:	81 89       	ldd	r24, Z+17	; 0x11
    18d6:	88 23       	and	r24, r24
    18d8:	39 f0       	breq	.+14     	; 0x18e8 <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    18da:	c8 01       	movw	r24, r16
    18dc:	41 96       	adiw	r24, 0x11	; 17
    18de:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
    18e2:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    18e4:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    18e8:	0f 90       	pop	r0
    18ea:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    18ec:	81 e0       	ldi	r24, 0x01	; 1
    18ee:	50 c0       	rjmp	.+160    	; 0x1990 <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    18f0:	2c 81       	ldd	r18, Y+4	; 0x04
    18f2:	3d 81       	ldd	r19, Y+5	; 0x05
    18f4:	23 2b       	or	r18, r19
    18f6:	19 f4       	brne	.+6      	; 0x18fe <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    18f8:	0f 90       	pop	r0
    18fa:	0f be       	out	0x3f, r0	; 63
    18fc:	48 c0       	rjmp	.+144    	; 0x198e <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    18fe:	81 11       	cpse	r24, r1
    1900:	04 c0       	rjmp	.+8      	; 0x190a <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1902:	ce 01       	movw	r24, r28
    1904:	01 96       	adiw	r24, 0x01	; 1
    1906:	0e 94 b7 06 	call	0xd6e	; 0xd6e <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    190a:	0f 90       	pop	r0
    190c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    190e:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1912:	0f b6       	in	r0, 0x3f	; 63
    1914:	f8 94       	cli
    1916:	0f 92       	push	r0
    1918:	f8 01       	movw	r30, r16
    191a:	85 8d       	ldd	r24, Z+29	; 0x1d
    191c:	8f 3f       	cpi	r24, 0xFF	; 255
    191e:	09 f4       	brne	.+2      	; 0x1922 <xQueuePeek+0x9a>
    1920:	15 8e       	std	Z+29, r1	; 0x1d
    1922:	f8 01       	movw	r30, r16
    1924:	86 8d       	ldd	r24, Z+30	; 0x1e
    1926:	8f 3f       	cpi	r24, 0xFF	; 255
    1928:	09 f4       	brne	.+2      	; 0x192c <xQueuePeek+0xa4>
    192a:	16 8e       	std	Z+30, r1	; 0x1e
    192c:	0f 90       	pop	r0
    192e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1930:	be 01       	movw	r22, r28
    1932:	6c 5f       	subi	r22, 0xFC	; 252
    1934:	7f 4f       	sbci	r23, 0xFF	; 255
    1936:	ce 01       	movw	r24, r28
    1938:	01 96       	adiw	r24, 0x01	; 1
    193a:	0e 94 c2 06 	call	0xd84	; 0xd84 <xTaskCheckForTimeOut>
    193e:	81 11       	cpse	r24, r1
    1940:	1c c0       	rjmp	.+56     	; 0x197a <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1942:	c8 01       	movw	r24, r16
    1944:	0e 94 32 09 	call	0x1264	; 0x1264 <prvIsQueueEmpty>
    1948:	88 23       	and	r24, r24
    194a:	89 f0       	breq	.+34     	; 0x196e <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    194c:	6c 81       	ldd	r22, Y+4	; 0x04
    194e:	7d 81       	ldd	r23, Y+5	; 0x05
    1950:	c6 01       	movw	r24, r12
    1952:	0e 94 0c 06 	call	0xc18	; 0xc18 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1956:	c8 01       	movw	r24, r16
    1958:	0e 94 9f 09 	call	0x133e	; 0x133e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    195c:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>
    1960:	88 23       	and	r24, r24
    1962:	11 f0       	breq	.+4      	; 0x1968 <xQueuePeek+0xe0>
    1964:	81 e0       	ldi	r24, 0x01	; 1
    1966:	a6 cf       	rjmp	.-180    	; 0x18b4 <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    1968:	0e 94 61 11 	call	0x22c2	; 0x22c2 <vPortYield>
    196c:	fb cf       	rjmp	.-10     	; 0x1964 <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    196e:	c8 01       	movw	r24, r16
    1970:	0e 94 9f 09 	call	0x133e	; 0x133e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1974:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>
    1978:	f5 cf       	rjmp	.-22     	; 0x1964 <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    197a:	c8 01       	movw	r24, r16
    197c:	0e 94 9f 09 	call	0x133e	; 0x133e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1980:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1984:	c8 01       	movw	r24, r16
    1986:	0e 94 32 09 	call	0x1264	; 0x1264 <prvIsQueueEmpty>
    198a:	88 23       	and	r24, r24
    198c:	59 f3       	breq	.-42     	; 0x1964 <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    198e:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1990:	0f 90       	pop	r0
    1992:	0f 90       	pop	r0
    1994:	0f 90       	pop	r0
    1996:	0f 90       	pop	r0
    1998:	0f 90       	pop	r0
    199a:	df 91       	pop	r29
    199c:	cf 91       	pop	r28
    199e:	1f 91       	pop	r17
    19a0:	0f 91       	pop	r16
    19a2:	ff 90       	pop	r15
    19a4:	ef 90       	pop	r14
    19a6:	df 90       	pop	r13
    19a8:	cf 90       	pop	r12
    19aa:	08 95       	ret

000019ac <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    19ac:	ef 92       	push	r14
    19ae:	ff 92       	push	r15
    19b0:	0f 93       	push	r16
    19b2:	1f 93       	push	r17
    19b4:	cf 93       	push	r28
    19b6:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    19b8:	fc 01       	movw	r30, r24
    19ba:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    19bc:	00 23       	and	r16, r16
    19be:	e9 f0       	breq	.+58     	; 0x19fa <xQueueReceiveFromISR+0x4e>
    19c0:	7a 01       	movw	r14, r20
    19c2:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    19c4:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    19c6:	0e 94 85 09 	call	0x130a	; 0x130a <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    19ca:	01 50       	subi	r16, 0x01	; 1
    19cc:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    19ce:	1f 3f       	cpi	r17, 0xFF	; 255
    19d0:	81 f4       	brne	.+32     	; 0x19f2 <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    19d2:	88 85       	ldd	r24, Y+8	; 0x08
    19d4:	88 23       	and	r24, r24
    19d6:	79 f0       	breq	.+30     	; 0x19f6 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    19d8:	ce 01       	movw	r24, r28
    19da:	08 96       	adiw	r24, 0x08	; 8
    19dc:	0e 94 35 06 	call	0xc6a	; 0xc6a <xTaskRemoveFromEventList>
    19e0:	88 23       	and	r24, r24
    19e2:	49 f0       	breq	.+18     	; 0x19f6 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    19e4:	e1 14       	cp	r14, r1
    19e6:	f1 04       	cpc	r15, r1
    19e8:	31 f0       	breq	.+12     	; 0x19f6 <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    19ea:	81 e0       	ldi	r24, 0x01	; 1
    19ec:	f7 01       	movw	r30, r14
    19ee:	80 83       	st	Z, r24
    19f0:	05 c0       	rjmp	.+10     	; 0x19fc <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    19f2:	1f 5f       	subi	r17, 0xFF	; 255
    19f4:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    19f6:	81 e0       	ldi	r24, 0x01	; 1
    19f8:	01 c0       	rjmp	.+2      	; 0x19fc <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    19fa:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19fc:	df 91       	pop	r29
    19fe:	cf 91       	pop	r28
    1a00:	1f 91       	pop	r17
    1a02:	0f 91       	pop	r16
    1a04:	ff 90       	pop	r15
    1a06:	ef 90       	pop	r14
    1a08:	08 95       	ret

00001a0a <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1a0a:	0f 93       	push	r16
    1a0c:	1f 93       	push	r17
    1a0e:	cf 93       	push	r28
    1a10:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a12:	fc 01       	movw	r30, r24
    1a14:	22 8d       	ldd	r18, Z+26	; 0x1a
    1a16:	22 23       	and	r18, r18
    1a18:	49 f0       	breq	.+18     	; 0x1a2c <xQueuePeekFromISR+0x22>
    1a1a:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1a1c:	06 81       	ldd	r16, Z+6	; 0x06
    1a1e:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a20:	0e 94 85 09 	call	0x130a	; 0x130a <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1a24:	1f 83       	std	Y+7, r17	; 0x07
    1a26:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1a28:	81 e0       	ldi	r24, 0x01	; 1
    1a2a:	01 c0       	rjmp	.+2      	; 0x1a2e <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1a2c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a2e:	df 91       	pop	r29
    1a30:	cf 91       	pop	r28
    1a32:	1f 91       	pop	r17
    1a34:	0f 91       	pop	r16
    1a36:	08 95       	ret

00001a38 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1a38:	0f b6       	in	r0, 0x3f	; 63
    1a3a:	f8 94       	cli
    1a3c:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1a3e:	fc 01       	movw	r30, r24
    1a40:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1a42:	0f 90       	pop	r0
    1a44:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a46:	08 95       	ret

00001a48 <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1a48:	0f b6       	in	r0, 0x3f	; 63
    1a4a:	f8 94       	cli
    1a4c:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1a4e:	fc 01       	movw	r30, r24
    1a50:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1a52:	0f 90       	pop	r0
    1a54:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1a56:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a58:	82 1b       	sub	r24, r18
    1a5a:	08 95       	ret

00001a5c <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1a5c:	fc 01       	movw	r30, r24
    1a5e:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a60:	08 95       	ret

00001a62 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1a62:	0c 94 a5 10 	jmp	0x214a	; 0x214a <vPortFree>

00001a66 <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1a66:	fc 01       	movw	r30, r24
    1a68:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1a6a:	81 e0       	ldi	r24, 0x01	; 1
    1a6c:	91 11       	cpse	r25, r1
    1a6e:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1a70:	08 95       	ret

00001a72 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1a72:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1a74:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1a76:	81 e0       	ldi	r24, 0x01	; 1
    1a78:	23 8d       	ldd	r18, Z+27	; 0x1b
    1a7a:	29 13       	cpse	r18, r25
    1a7c:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1a7e:	08 95       	ret

00001a80 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1a80:	cf 93       	push	r28
    1a82:	df 93       	push	r29
    1a84:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1a86:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1a88:	0f b6       	in	r0, 0x3f	; 63
    1a8a:	f8 94       	cli
    1a8c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1a8e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a90:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1a92:	0f 90       	pop	r0
    1a94:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a96:	89 13       	cpse	r24, r25
    1a98:	0f c0       	rjmp	.+30     	; 0x1ab8 <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1a9a:	41 15       	cp	r20, r1
    1a9c:	51 05       	cpc	r21, r1
    1a9e:	49 f0       	breq	.+18     	; 0x1ab2 <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1aa0:	be 01       	movw	r22, r28
    1aa2:	68 5f       	subi	r22, 0xF8	; 248
    1aa4:	7f 4f       	sbci	r23, 0xFF	; 255
    1aa6:	ca 01       	movw	r24, r20
    1aa8:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1aac:	78 94       	sei
					return errQUEUE_BLOCKED;
    1aae:	8c ef       	ldi	r24, 0xFC	; 252
    1ab0:	1b c0       	rjmp	.+54     	; 0x1ae8 <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1ab2:	78 94       	sei
					return errQUEUE_FULL;
    1ab4:	80 e0       	ldi	r24, 0x00	; 0
    1ab6:	18 c0       	rjmp	.+48     	; 0x1ae8 <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1ab8:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1aba:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1abc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1abe:	89 17       	cp	r24, r25
    1ac0:	88 f4       	brcc	.+34     	; 0x1ae4 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1ac2:	40 e0       	ldi	r20, 0x00	; 0
    1ac4:	ce 01       	movw	r24, r28
    1ac6:	0e 94 3d 09 	call	0x127a	; 0x127a <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1aca:	89 89       	ldd	r24, Y+17	; 0x11
    1acc:	81 11       	cpse	r24, r1
    1ace:	02 c0       	rjmp	.+4      	; 0x1ad4 <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1ad0:	81 e0       	ldi	r24, 0x01	; 1
    1ad2:	09 c0       	rjmp	.+18     	; 0x1ae6 <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ad4:	ce 01       	movw	r24, r28
    1ad6:	41 96       	adiw	r24, 0x11	; 17
    1ad8:	0e 94 4e 10 	call	0x209c	; 0x209c <xCoRoutineRemoveFromEventList>
    1adc:	88 23       	and	r24, r24
    1ade:	c1 f3       	breq	.-16     	; 0x1ad0 <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1ae0:	8b ef       	ldi	r24, 0xFB	; 251
    1ae2:	01 c0       	rjmp	.+2      	; 0x1ae6 <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1ae4:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1ae6:	78 94       	sei

		return xReturn;
	}
    1ae8:	df 91       	pop	r29
    1aea:	cf 91       	pop	r28
    1aec:	08 95       	ret

00001aee <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1aee:	cf 93       	push	r28
    1af0:	df 93       	push	r29
    1af2:	ec 01       	movw	r28, r24
    1af4:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1af6:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1af8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1afa:	81 11       	cpse	r24, r1
    1afc:	0f c0       	rjmp	.+30     	; 0x1b1c <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1afe:	41 15       	cp	r20, r1
    1b00:	51 05       	cpc	r21, r1
    1b02:	49 f0       	breq	.+18     	; 0x1b16 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1b04:	be 01       	movw	r22, r28
    1b06:	6f 5e       	subi	r22, 0xEF	; 239
    1b08:	7f 4f       	sbci	r23, 0xFF	; 255
    1b0a:	ca 01       	movw	r24, r20
    1b0c:	0e 94 1f 0f 	call	0x1e3e	; 0x1e3e <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1b10:	78 94       	sei
					return errQUEUE_BLOCKED;
    1b12:	8c ef       	ldi	r24, 0xFC	; 252
    1b14:	30 c0       	rjmp	.+96     	; 0x1b76 <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1b16:	78 94       	sei
					return errQUEUE_FULL;
    1b18:	80 e0       	ldi	r24, 0x00	; 0
    1b1a:	2d c0       	rjmp	.+90     	; 0x1b76 <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1b1c:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1b1e:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b20:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b22:	88 23       	and	r24, r24
    1b24:	31 f1       	breq	.+76     	; 0x1b72 <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1b26:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1b28:	50 e0       	ldi	r21, 0x00	; 0
    1b2a:	2e 81       	ldd	r18, Y+6	; 0x06
    1b2c:	3f 81       	ldd	r19, Y+7	; 0x07
    1b2e:	24 0f       	add	r18, r20
    1b30:	35 1f       	adc	r19, r21
    1b32:	3f 83       	std	Y+7, r19	; 0x07
    1b34:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1b36:	8c 81       	ldd	r24, Y+4	; 0x04
    1b38:	9d 81       	ldd	r25, Y+5	; 0x05
    1b3a:	28 17       	cp	r18, r24
    1b3c:	39 07       	cpc	r19, r25
    1b3e:	20 f0       	brcs	.+8      	; 0x1b48 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1b40:	88 81       	ld	r24, Y
    1b42:	99 81       	ldd	r25, Y+1	; 0x01
    1b44:	9f 83       	std	Y+7, r25	; 0x07
    1b46:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1b48:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1b4a:	91 50       	subi	r25, 0x01	; 1
    1b4c:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1b4e:	6e 81       	ldd	r22, Y+6	; 0x06
    1b50:	7f 81       	ldd	r23, Y+7	; 0x07
    1b52:	cf 01       	movw	r24, r30
    1b54:	0e 94 4c 12 	call	0x2498	; 0x2498 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b58:	88 85       	ldd	r24, Y+8	; 0x08
    1b5a:	81 11       	cpse	r24, r1
    1b5c:	02 c0       	rjmp	.+4      	; 0x1b62 <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1b5e:	81 e0       	ldi	r24, 0x01	; 1
    1b60:	09 c0       	rjmp	.+18     	; 0x1b74 <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b62:	ce 01       	movw	r24, r28
    1b64:	08 96       	adiw	r24, 0x08	; 8
    1b66:	0e 94 4e 10 	call	0x209c	; 0x209c <xCoRoutineRemoveFromEventList>
    1b6a:	88 23       	and	r24, r24
    1b6c:	c1 f3       	breq	.-16     	; 0x1b5e <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1b6e:	8b ef       	ldi	r24, 0xFB	; 251
    1b70:	01 c0       	rjmp	.+2      	; 0x1b74 <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1b72:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1b74:	78 94       	sei

		return xReturn;
	}
    1b76:	df 91       	pop	r29
    1b78:	cf 91       	pop	r28
    1b7a:	08 95       	ret

00001b7c <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1b7c:	0f 93       	push	r16
    1b7e:	1f 93       	push	r17
    1b80:	cf 93       	push	r28
    1b82:	8c 01       	movw	r16, r24
    1b84:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1b86:	fc 01       	movw	r30, r24
    1b88:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b8a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b8c:	98 17       	cp	r25, r24
    1b8e:	10 f0       	brcs	.+4      	; 0x1b94 <xQueueCRSendFromISR+0x18>
    1b90:	4c 2f       	mov	r20, r28
    1b92:	12 c0       	rjmp	.+36     	; 0x1bb8 <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1b94:	40 e0       	ldi	r20, 0x00	; 0
    1b96:	c8 01       	movw	r24, r16
    1b98:	0e 94 3d 09 	call	0x127a	; 0x127a <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1b9c:	c1 11       	cpse	r28, r1
    1b9e:	f8 cf       	rjmp	.-16     	; 0x1b90 <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ba0:	f8 01       	movw	r30, r16
    1ba2:	81 89       	ldd	r24, Z+17	; 0x11
    1ba4:	88 23       	and	r24, r24
    1ba6:	39 f0       	breq	.+14     	; 0x1bb6 <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ba8:	c8 01       	movw	r24, r16
    1baa:	41 96       	adiw	r24, 0x11	; 17
    1bac:	0e 94 4e 10 	call	0x209c	; 0x209c <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1bb0:	41 e0       	ldi	r20, 0x01	; 1
    1bb2:	81 11       	cpse	r24, r1
    1bb4:	01 c0       	rjmp	.+2      	; 0x1bb8 <xQueueCRSendFromISR+0x3c>
    1bb6:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1bb8:	84 2f       	mov	r24, r20
    1bba:	cf 91       	pop	r28
    1bbc:	1f 91       	pop	r17
    1bbe:	0f 91       	pop	r16
    1bc0:	08 95       	ret

00001bc2 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1bc2:	0f 93       	push	r16
    1bc4:	1f 93       	push	r17
    1bc6:	cf 93       	push	r28
    1bc8:	df 93       	push	r29
    1bca:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1bcc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bce:	88 23       	and	r24, r24
    1bd0:	79 f1       	breq	.+94     	; 0x1c30 <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1bd2:	24 8d       	ldd	r18, Z+28	; 0x1c
    1bd4:	30 e0       	ldi	r19, 0x00	; 0
    1bd6:	a6 81       	ldd	r26, Z+6	; 0x06
    1bd8:	b7 81       	ldd	r27, Z+7	; 0x07
    1bda:	a2 0f       	add	r26, r18
    1bdc:	b3 1f       	adc	r27, r19
    1bde:	b7 83       	std	Z+7, r27	; 0x07
    1be0:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1be2:	84 81       	ldd	r24, Z+4	; 0x04
    1be4:	95 81       	ldd	r25, Z+5	; 0x05
    1be6:	a8 17       	cp	r26, r24
    1be8:	b9 07       	cpc	r27, r25
    1bea:	20 f0       	brcs	.+8      	; 0x1bf4 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1bec:	80 81       	ld	r24, Z
    1bee:	91 81       	ldd	r25, Z+1	; 0x01
    1bf0:	97 83       	std	Z+7, r25	; 0x07
    1bf2:	86 83       	std	Z+6, r24	; 0x06
    1bf4:	8a 01       	movw	r16, r20
    1bf6:	cb 01       	movw	r24, r22
    1bf8:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1bfa:	42 8d       	ldd	r20, Z+26	; 0x1a
    1bfc:	41 50       	subi	r20, 0x01	; 1
    1bfe:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1c00:	66 81       	ldd	r22, Z+6	; 0x06
    1c02:	77 81       	ldd	r23, Z+7	; 0x07
    1c04:	a9 01       	movw	r20, r18
    1c06:	0e 94 4c 12 	call	0x2498	; 0x2498 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1c0a:	f8 01       	movw	r30, r16
    1c0c:	80 81       	ld	r24, Z
    1c0e:	88 23       	and	r24, r24
    1c10:	11 f0       	breq	.+4      	; 0x1c16 <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1c12:	81 e0       	ldi	r24, 0x01	; 1
    1c14:	0e c0       	rjmp	.+28     	; 0x1c32 <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c16:	88 85       	ldd	r24, Y+8	; 0x08
    1c18:	88 23       	and	r24, r24
    1c1a:	d9 f3       	breq	.-10     	; 0x1c12 <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c1c:	ce 01       	movw	r24, r28
    1c1e:	08 96       	adiw	r24, 0x08	; 8
    1c20:	0e 94 4e 10 	call	0x209c	; 0x209c <xCoRoutineRemoveFromEventList>
    1c24:	88 23       	and	r24, r24
    1c26:	a9 f3       	breq	.-22     	; 0x1c12 <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1c28:	81 e0       	ldi	r24, 0x01	; 1
    1c2a:	f8 01       	movw	r30, r16
    1c2c:	80 83       	st	Z, r24
    1c2e:	01 c0       	rjmp	.+2      	; 0x1c32 <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1c30:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1c32:	df 91       	pop	r29
    1c34:	cf 91       	pop	r28
    1c36:	1f 91       	pop	r17
    1c38:	0f 91       	pop	r16
    1c3a:	08 95       	ret

00001c3c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1c3c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c3e:	03 96       	adiw	r24, 0x03	; 3
    1c40:	92 83       	std	Z+2, r25	; 0x02
    1c42:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1c44:	2f ef       	ldi	r18, 0xFF	; 255
    1c46:	3f ef       	ldi	r19, 0xFF	; 255
    1c48:	34 83       	std	Z+4, r19	; 0x04
    1c4a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c4c:	96 83       	std	Z+6, r25	; 0x06
    1c4e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c50:	90 87       	std	Z+8, r25	; 0x08
    1c52:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1c54:	10 82       	st	Z, r1
    1c56:	08 95       	ret

00001c58 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1c58:	fc 01       	movw	r30, r24
    1c5a:	11 86       	std	Z+9, r1	; 0x09
    1c5c:	10 86       	std	Z+8, r1	; 0x08
    1c5e:	08 95       	ret

00001c60 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c60:	cf 93       	push	r28
    1c62:	df 93       	push	r29
    1c64:	9c 01       	movw	r18, r24
    1c66:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1c68:	dc 01       	movw	r26, r24
    1c6a:	11 96       	adiw	r26, 0x01	; 1
    1c6c:	cd 91       	ld	r28, X+
    1c6e:	dc 91       	ld	r29, X
    1c70:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1c72:	d3 83       	std	Z+3, r29	; 0x03
    1c74:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1c76:	8c 81       	ldd	r24, Y+4	; 0x04
    1c78:	9d 81       	ldd	r25, Y+5	; 0x05
    1c7a:	95 83       	std	Z+5, r25	; 0x05
    1c7c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c7e:	8c 81       	ldd	r24, Y+4	; 0x04
    1c80:	9d 81       	ldd	r25, Y+5	; 0x05
    1c82:	dc 01       	movw	r26, r24
    1c84:	13 96       	adiw	r26, 0x03	; 3
    1c86:	7c 93       	st	X, r23
    1c88:	6e 93       	st	-X, r22
    1c8a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1c8c:	7d 83       	std	Y+5, r23	; 0x05
    1c8e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1c90:	31 87       	std	Z+9, r19	; 0x09
    1c92:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1c94:	f9 01       	movw	r30, r18
    1c96:	80 81       	ld	r24, Z
    1c98:	8f 5f       	subi	r24, 0xFF	; 255
    1c9a:	80 83       	st	Z, r24
}
    1c9c:	df 91       	pop	r29
    1c9e:	cf 91       	pop	r28
    1ca0:	08 95       	ret

00001ca2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1ca2:	0f 93       	push	r16
    1ca4:	1f 93       	push	r17
    1ca6:	cf 93       	push	r28
    1ca8:	df 93       	push	r29
    1caa:	8c 01       	movw	r16, r24
    1cac:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1cae:	80 81       	ld	r24, Z
    1cb0:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1cb2:	8f 3f       	cpi	r24, 0xFF	; 255
    1cb4:	2f ef       	ldi	r18, 0xFF	; 255
    1cb6:	92 07       	cpc	r25, r18
    1cb8:	21 f4       	brne	.+8      	; 0x1cc2 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1cba:	e8 01       	movw	r28, r16
    1cbc:	af 81       	ldd	r26, Y+7	; 0x07
    1cbe:	b8 85       	ldd	r27, Y+8	; 0x08
    1cc0:	0e c0       	rjmp	.+28     	; 0x1cde <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1cc2:	d8 01       	movw	r26, r16
    1cc4:	13 96       	adiw	r26, 0x03	; 3
    1cc6:	12 96       	adiw	r26, 0x02	; 2
    1cc8:	2d 91       	ld	r18, X+
    1cca:	3c 91       	ld	r19, X
    1ccc:	13 97       	sbiw	r26, 0x03	; 3
    1cce:	e9 01       	movw	r28, r18
    1cd0:	48 81       	ld	r20, Y
    1cd2:	59 81       	ldd	r21, Y+1	; 0x01
    1cd4:	84 17       	cp	r24, r20
    1cd6:	95 07       	cpc	r25, r21
    1cd8:	10 f0       	brcs	.+4      	; 0x1cde <vListInsert+0x3c>
    1cda:	d9 01       	movw	r26, r18
    1cdc:	f4 cf       	rjmp	.-24     	; 0x1cc6 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1cde:	12 96       	adiw	r26, 0x02	; 2
    1ce0:	8d 91       	ld	r24, X+
    1ce2:	9c 91       	ld	r25, X
    1ce4:	13 97       	sbiw	r26, 0x03	; 3
    1ce6:	93 83       	std	Z+3, r25	; 0x03
    1ce8:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1cea:	ec 01       	movw	r28, r24
    1cec:	fd 83       	std	Y+5, r31	; 0x05
    1cee:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1cf0:	b5 83       	std	Z+5, r27	; 0x05
    1cf2:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1cf4:	13 96       	adiw	r26, 0x03	; 3
    1cf6:	fc 93       	st	X, r31
    1cf8:	ee 93       	st	-X, r30
    1cfa:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1cfc:	11 87       	std	Z+9, r17	; 0x09
    1cfe:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1d00:	f8 01       	movw	r30, r16
    1d02:	80 81       	ld	r24, Z
    1d04:	8f 5f       	subi	r24, 0xFF	; 255
    1d06:	80 83       	st	Z, r24
}
    1d08:	df 91       	pop	r29
    1d0a:	cf 91       	pop	r28
    1d0c:	1f 91       	pop	r17
    1d0e:	0f 91       	pop	r16
    1d10:	08 95       	ret

00001d12 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1d12:	cf 93       	push	r28
    1d14:	df 93       	push	r29
    1d16:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1d18:	a0 85       	ldd	r26, Z+8	; 0x08
    1d1a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1d1c:	82 81       	ldd	r24, Z+2	; 0x02
    1d1e:	93 81       	ldd	r25, Z+3	; 0x03
    1d20:	24 81       	ldd	r18, Z+4	; 0x04
    1d22:	35 81       	ldd	r19, Z+5	; 0x05
    1d24:	ec 01       	movw	r28, r24
    1d26:	3d 83       	std	Y+5, r19	; 0x05
    1d28:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1d2a:	c4 81       	ldd	r28, Z+4	; 0x04
    1d2c:	d5 81       	ldd	r29, Z+5	; 0x05
    1d2e:	9b 83       	std	Y+3, r25	; 0x03
    1d30:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1d32:	11 96       	adiw	r26, 0x01	; 1
    1d34:	8d 91       	ld	r24, X+
    1d36:	9c 91       	ld	r25, X
    1d38:	12 97       	sbiw	r26, 0x02	; 2
    1d3a:	e8 17       	cp	r30, r24
    1d3c:	f9 07       	cpc	r31, r25
    1d3e:	21 f4       	brne	.+8      	; 0x1d48 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1d40:	12 96       	adiw	r26, 0x02	; 2
    1d42:	dc 93       	st	X, r29
    1d44:	ce 93       	st	-X, r28
    1d46:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1d48:	11 86       	std	Z+9, r1	; 0x09
    1d4a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1d4c:	8c 91       	ld	r24, X
    1d4e:	81 50       	subi	r24, 0x01	; 1
    1d50:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1d52:	8c 91       	ld	r24, X
}
    1d54:	df 91       	pop	r29
    1d56:	cf 91       	pop	r28
    1d58:	08 95       	ret

00001d5a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1d5a:	cf 92       	push	r12
    1d5c:	df 92       	push	r13
    1d5e:	ef 92       	push	r14
    1d60:	ff 92       	push	r15
    1d62:	1f 93       	push	r17
    1d64:	cf 93       	push	r28
    1d66:	df 93       	push	r29
    1d68:	6c 01       	movw	r12, r24
    1d6a:	16 2f       	mov	r17, r22
    1d6c:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1d6e:	8a e1       	ldi	r24, 0x1A	; 26
    1d70:	90 e0       	ldi	r25, 0x00	; 0
    1d72:	0e 94 73 10 	call	0x20e6	; 0x20e6 <pvPortMalloc>
    1d76:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1d78:	89 2b       	or	r24, r25
    1d7a:	09 f4       	brne	.+2      	; 0x1d7e <xCoRoutineCreate+0x24>
    1d7c:	57 c0       	rjmp	.+174    	; 0x1e2c <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1d7e:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <pxCurrentCoRoutine>
    1d82:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <pxCurrentCoRoutine+0x1>
    1d86:	89 2b       	or	r24, r25
    1d88:	21 f5       	brne	.+72     	; 0x1dd2 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1d8a:	d0 93 99 01 	sts	0x0199, r29	; 0x800199 <pxCurrentCoRoutine+0x1>
    1d8e:	c0 93 98 01 	sts	0x0198, r28	; 0x800198 <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1d92:	80 ec       	ldi	r24, 0xC0	; 192
    1d94:	91 e0       	ldi	r25, 0x01	; 1
    1d96:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
    1d9a:	89 ec       	ldi	r24, 0xC9	; 201
    1d9c:	91 e0       	ldi	r25, 0x01	; 1
    1d9e:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1da2:	87 eb       	ldi	r24, 0xB7	; 183
    1da4:	91 e0       	ldi	r25, 0x01	; 1
    1da6:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1daa:	8e ea       	ldi	r24, 0xAE	; 174
    1dac:	91 e0       	ldi	r25, 0x01	; 1
    1dae:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1db2:	81 ea       	ldi	r24, 0xA1	; 161
    1db4:	91 e0       	ldi	r25, 0x01	; 1
    1db6:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1dba:	87 eb       	ldi	r24, 0xB7	; 183
    1dbc:	91 e0       	ldi	r25, 0x01	; 1
    1dbe:	90 93 ad 01 	sts	0x01AD, r25	; 0x8001ad <pxDelayedCoRoutineList+0x1>
    1dc2:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1dc6:	8e ea       	ldi	r24, 0xAE	; 174
    1dc8:	91 e0       	ldi	r25, 0x01	; 1
    1dca:	90 93 ab 01 	sts	0x01AB, r25	; 0x8001ab <pxOverflowDelayedCoRoutineList+0x1>
    1dce:	80 93 aa 01 	sts	0x01AA, r24	; 0x8001aa <pxOverflowDelayedCoRoutineList>
    1dd2:	11 11       	cpse	r17, r1
    1dd4:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1dd6:	19 8e       	std	Y+25, r1	; 0x19
    1dd8:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1dda:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1ddc:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1dde:	fe 01       	movw	r30, r28
    1de0:	c1 92       	st	Z+, r12
    1de2:	d1 92       	st	Z+, r13
    1de4:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1de6:	cf 01       	movw	r24, r30
    1de8:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1dec:	ce 01       	movw	r24, r28
    1dee:	0c 96       	adiw	r24, 0x0c	; 12
    1df0:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1df4:	d9 87       	std	Y+9, r29	; 0x09
    1df6:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1df8:	db 8b       	std	Y+19, r29	; 0x13
    1dfa:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    1dfc:	82 e0       	ldi	r24, 0x02	; 2
    1dfe:	90 e0       	ldi	r25, 0x00	; 0
    1e00:	81 1b       	sub	r24, r17
    1e02:	91 09       	sbc	r25, r1
    1e04:	9d 87       	std	Y+13, r25	; 0x0d
    1e06:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1e08:	8e 89       	ldd	r24, Y+22	; 0x16
    1e0a:	90 91 a0 01 	lds	r25, 0x01A0	; 0x8001a0 <uxTopCoRoutineReadyPriority>
    1e0e:	98 17       	cp	r25, r24
    1e10:	10 f4       	brcc	.+4      	; 0x1e16 <xCoRoutineCreate+0xbc>
    1e12:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <uxTopCoRoutineReadyPriority>
    1e16:	f9 e0       	ldi	r31, 0x09	; 9
    1e18:	8f 9f       	mul	r24, r31
    1e1a:	c0 01       	movw	r24, r0
    1e1c:	11 24       	eor	r1, r1
    1e1e:	b7 01       	movw	r22, r14
    1e20:	80 54       	subi	r24, 0x40	; 64
    1e22:	9e 4f       	sbci	r25, 0xFE	; 254
    1e24:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>

		xReturn = pdPASS;
    1e28:	81 e0       	ldi	r24, 0x01	; 1
    1e2a:	01 c0       	rjmp	.+2      	; 0x1e2e <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1e2c:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    1e2e:	df 91       	pop	r29
    1e30:	cf 91       	pop	r28
    1e32:	1f 91       	pop	r17
    1e34:	ff 90       	pop	r15
    1e36:	ef 90       	pop	r14
    1e38:	df 90       	pop	r13
    1e3a:	cf 90       	pop	r12
    1e3c:	08 95       	ret

00001e3e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    1e3e:	0f 93       	push	r16
    1e40:	1f 93       	push	r17
    1e42:	cf 93       	push	r28
    1e44:	df 93       	push	r29
    1e46:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1e48:	c0 91 9e 01 	lds	r28, 0x019E	; 0x80019e <xCoRoutineTickCount>
    1e4c:	d0 91 9f 01 	lds	r29, 0x019F	; 0x80019f <xCoRoutineTickCount+0x1>
    1e50:	c8 0f       	add	r28, r24
    1e52:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1e54:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <pxCurrentCoRoutine>
    1e58:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <pxCurrentCoRoutine+0x1>
    1e5c:	02 96       	adiw	r24, 0x02	; 2
    1e5e:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1e62:	e0 91 98 01 	lds	r30, 0x0198	; 0x800198 <pxCurrentCoRoutine>
    1e66:	f0 91 99 01 	lds	r31, 0x0199	; 0x800199 <pxCurrentCoRoutine+0x1>
    1e6a:	d3 83       	std	Z+3, r29	; 0x03
    1e6c:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1e6e:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <xCoRoutineTickCount>
    1e72:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <xCoRoutineTickCount+0x1>
    1e76:	bf 01       	movw	r22, r30
    1e78:	6e 5f       	subi	r22, 0xFE	; 254
    1e7a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e7c:	c8 17       	cp	r28, r24
    1e7e:	d9 07       	cpc	r29, r25
    1e80:	28 f4       	brcc	.+10     	; 0x1e8c <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1e82:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <pxOverflowDelayedCoRoutineList>
    1e86:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <pxOverflowDelayedCoRoutineList+0x1>
    1e8a:	04 c0       	rjmp	.+8      	; 0x1e94 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1e8c:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <pxDelayedCoRoutineList>
    1e90:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <pxDelayedCoRoutineList+0x1>
    1e94:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <vListInsert>
	}

	if( pxEventList )
    1e98:	01 15       	cp	r16, r1
    1e9a:	11 05       	cpc	r17, r1
    1e9c:	69 f0       	breq	.+26     	; 0x1eb8 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1e9e:	60 91 98 01 	lds	r22, 0x0198	; 0x800198 <pxCurrentCoRoutine>
    1ea2:	70 91 99 01 	lds	r23, 0x0199	; 0x800199 <pxCurrentCoRoutine+0x1>
    1ea6:	64 5f       	subi	r22, 0xF4	; 244
    1ea8:	7f 4f       	sbci	r23, 0xFF	; 255
    1eaa:	c8 01       	movw	r24, r16
	}
}
    1eac:	df 91       	pop	r29
    1eae:	cf 91       	pop	r28
    1eb0:	1f 91       	pop	r17
    1eb2:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1eb4:	0c 94 51 0e 	jmp	0x1ca2	; 0x1ca2 <vListInsert>
	}
}
    1eb8:	df 91       	pop	r29
    1eba:	cf 91       	pop	r28
    1ebc:	1f 91       	pop	r17
    1ebe:	0f 91       	pop	r16
    1ec0:	08 95       	ret

00001ec2 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1ec2:	ff 92       	push	r15
    1ec4:	0f 93       	push	r16
    1ec6:	1f 93       	push	r17
    1ec8:	cf 93       	push	r28
    1eca:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1ecc:	99 e0       	ldi	r25, 0x09	; 9
    1ece:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1ed0:	80 91 a1 01 	lds	r24, 0x01A1	; 0x8001a1 <xPendingReadyCoRoutineList>
    1ed4:	88 23       	and	r24, r24
    1ed6:	11 f1       	breq	.+68     	; 0x1f1c <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1ed8:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1eda:	e0 91 a6 01 	lds	r30, 0x01A6	; 0x8001a6 <xPendingReadyCoRoutineList+0x5>
    1ede:	f0 91 a7 01 	lds	r31, 0x01A7	; 0x8001a7 <xPendingReadyCoRoutineList+0x6>
    1ee2:	c6 81       	ldd	r28, Z+6	; 0x06
    1ee4:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1ee6:	ce 01       	movw	r24, r28
    1ee8:	0c 96       	adiw	r24, 0x0c	; 12
    1eea:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1eee:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1ef0:	8e 01       	movw	r16, r28
    1ef2:	0e 5f       	subi	r16, 0xFE	; 254
    1ef4:	1f 4f       	sbci	r17, 0xFF	; 255
    1ef6:	c8 01       	movw	r24, r16
    1ef8:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1efc:	8e 89       	ldd	r24, Y+22	; 0x16
    1efe:	90 91 a0 01 	lds	r25, 0x01A0	; 0x8001a0 <uxTopCoRoutineReadyPriority>
    1f02:	98 17       	cp	r25, r24
    1f04:	10 f4       	brcc	.+4      	; 0x1f0a <vCoRoutineSchedule+0x48>
    1f06:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <uxTopCoRoutineReadyPriority>
    1f0a:	f8 9e       	mul	r15, r24
    1f0c:	c0 01       	movw	r24, r0
    1f0e:	11 24       	eor	r1, r1
    1f10:	b8 01       	movw	r22, r16
    1f12:	80 54       	subi	r24, 0x40	; 64
    1f14:	9e 4f       	sbci	r25, 0xFE	; 254
    1f16:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>
    1f1a:	da cf       	rjmp	.-76     	; 0x1ed0 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1f1c:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <xTaskGetTickCount>
    1f20:	20 91 9c 01 	lds	r18, 0x019C	; 0x80019c <xLastTickCount>
    1f24:	30 91 9d 01 	lds	r19, 0x019D	; 0x80019d <xLastTickCount+0x1>
    1f28:	82 1b       	sub	r24, r18
    1f2a:	93 0b       	sbc	r25, r19
    1f2c:	90 93 9b 01 	sts	0x019B, r25	; 0x80019b <xPassedTicks+0x1>
    1f30:	80 93 9a 01 	sts	0x019A, r24	; 0x80019a <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1f34:	89 e0       	ldi	r24, 0x09	; 9
    1f36:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1f38:	20 91 9a 01 	lds	r18, 0x019A	; 0x80019a <xPassedTicks>
    1f3c:	30 91 9b 01 	lds	r19, 0x019B	; 0x80019b <xPassedTicks+0x1>
    1f40:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <xCoRoutineTickCount>
    1f44:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <xCoRoutineTickCount+0x1>
    1f48:	21 15       	cp	r18, r1
    1f4a:	31 05       	cpc	r19, r1
    1f4c:	09 f4       	brne	.+2      	; 0x1f50 <vCoRoutineSchedule+0x8e>
    1f4e:	54 c0       	rjmp	.+168    	; 0x1ff8 <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    1f50:	01 96       	adiw	r24, 0x01	; 1
    1f52:	90 93 9f 01 	sts	0x019F, r25	; 0x80019f <xCoRoutineTickCount+0x1>
    1f56:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <xCoRoutineTickCount>
		xPassedTicks--;
    1f5a:	21 50       	subi	r18, 0x01	; 1
    1f5c:	31 09       	sbc	r19, r1
    1f5e:	30 93 9b 01 	sts	0x019B, r19	; 0x80019b <xPassedTicks+0x1>
    1f62:	20 93 9a 01 	sts	0x019A, r18	; 0x80019a <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1f66:	89 2b       	or	r24, r25
    1f68:	09 f0       	breq	.+2      	; 0x1f6c <vCoRoutineSchedule+0xaa>
    1f6a:	3e c0       	rjmp	.+124    	; 0x1fe8 <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1f6c:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <pxDelayedCoRoutineList>
    1f70:	90 91 ad 01 	lds	r25, 0x01AD	; 0x8001ad <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1f74:	20 91 aa 01 	lds	r18, 0x01AA	; 0x8001aa <pxOverflowDelayedCoRoutineList>
    1f78:	30 91 ab 01 	lds	r19, 0x01AB	; 0x8001ab <pxOverflowDelayedCoRoutineList+0x1>
    1f7c:	30 93 ad 01 	sts	0x01AD, r19	; 0x8001ad <pxDelayedCoRoutineList+0x1>
    1f80:	20 93 ac 01 	sts	0x01AC, r18	; 0x8001ac <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    1f84:	90 93 ab 01 	sts	0x01AB, r25	; 0x8001ab <pxOverflowDelayedCoRoutineList+0x1>
    1f88:	80 93 aa 01 	sts	0x01AA, r24	; 0x8001aa <pxOverflowDelayedCoRoutineList>
    1f8c:	2d c0       	rjmp	.+90     	; 0x1fe8 <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1f8e:	05 80       	ldd	r0, Z+5	; 0x05
    1f90:	f6 81       	ldd	r31, Z+6	; 0x06
    1f92:	e0 2d       	mov	r30, r0
    1f94:	c6 81       	ldd	r28, Z+6	; 0x06
    1f96:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1f98:	2a 81       	ldd	r18, Y+2	; 0x02
    1f9a:	3b 81       	ldd	r19, Y+3	; 0x03
    1f9c:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <xCoRoutineTickCount>
    1fa0:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <xCoRoutineTickCount+0x1>
    1fa4:	82 17       	cp	r24, r18
    1fa6:	93 07       	cpc	r25, r19
    1fa8:	38 f2       	brcs	.-114    	; 0x1f38 <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1faa:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1fac:	8e 01       	movw	r16, r28
    1fae:	0e 5f       	subi	r16, 0xFE	; 254
    1fb0:	1f 4f       	sbci	r17, 0xFF	; 255
    1fb2:	c8 01       	movw	r24, r16
    1fb4:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    1fb8:	8c 89       	ldd	r24, Y+20	; 0x14
    1fba:	9d 89       	ldd	r25, Y+21	; 0x15
    1fbc:	89 2b       	or	r24, r25
    1fbe:	21 f0       	breq	.+8      	; 0x1fc8 <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1fc0:	ce 01       	movw	r24, r28
    1fc2:	0c 96       	adiw	r24, 0x0c	; 12
    1fc4:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1fc8:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1fca:	8e 89       	ldd	r24, Y+22	; 0x16
    1fcc:	90 91 a0 01 	lds	r25, 0x01A0	; 0x8001a0 <uxTopCoRoutineReadyPriority>
    1fd0:	98 17       	cp	r25, r24
    1fd2:	10 f4       	brcc	.+4      	; 0x1fd8 <vCoRoutineSchedule+0x116>
    1fd4:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <uxTopCoRoutineReadyPriority>
    1fd8:	f8 9e       	mul	r15, r24
    1fda:	c0 01       	movw	r24, r0
    1fdc:	11 24       	eor	r1, r1
    1fde:	b8 01       	movw	r22, r16
    1fe0:	80 54       	subi	r24, 0x40	; 64
    1fe2:	9e 4f       	sbci	r25, 0xFE	; 254
    1fe4:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1fe8:	e0 91 ac 01 	lds	r30, 0x01AC	; 0x8001ac <pxDelayedCoRoutineList>
    1fec:	f0 91 ad 01 	lds	r31, 0x01AD	; 0x8001ad <pxDelayedCoRoutineList+0x1>
    1ff0:	80 81       	ld	r24, Z
    1ff2:	81 11       	cpse	r24, r1
    1ff4:	cc cf       	rjmp	.-104    	; 0x1f8e <vCoRoutineSchedule+0xcc>
    1ff6:	a0 cf       	rjmp	.-192    	; 0x1f38 <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    1ff8:	90 93 9d 01 	sts	0x019D, r25	; 0x80019d <xLastTickCount+0x1>
    1ffc:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <xLastTickCount>
    2000:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2004:	69 e0       	ldi	r22, 0x09	; 9
    2006:	48 2f       	mov	r20, r24
    2008:	50 e0       	ldi	r21, 0x00	; 0
    200a:	64 9f       	mul	r22, r20
    200c:	90 01       	movw	r18, r0
    200e:	65 9f       	mul	r22, r21
    2010:	30 0d       	add	r19, r0
    2012:	11 24       	eor	r1, r1
    2014:	f9 01       	movw	r30, r18
    2016:	e0 54       	subi	r30, 0x40	; 64
    2018:	fe 4f       	sbci	r31, 0xFE	; 254
    201a:	90 81       	ld	r25, Z
    201c:	91 11       	cpse	r25, r1
    201e:	0c c0       	rjmp	.+24     	; 0x2038 <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2020:	81 11       	cpse	r24, r1
    2022:	08 c0       	rjmp	.+16     	; 0x2034 <vCoRoutineSchedule+0x172>
    2024:	10 92 a0 01 	sts	0x01A0, r1	; 0x8001a0 <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    2028:	df 91       	pop	r29
    202a:	cf 91       	pop	r28
    202c:	1f 91       	pop	r17
    202e:	0f 91       	pop	r16
    2030:	ff 90       	pop	r15
    2032:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2034:	81 50       	subi	r24, 0x01	; 1
    2036:	e7 cf       	rjmp	.-50     	; 0x2006 <vCoRoutineSchedule+0x144>
    2038:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    203c:	a1 81       	ldd	r26, Z+1	; 0x01
    203e:	b2 81       	ldd	r27, Z+2	; 0x02
    2040:	12 96       	adiw	r26, 0x02	; 2
    2042:	0d 90       	ld	r0, X+
    2044:	bc 91       	ld	r27, X
    2046:	a0 2d       	mov	r26, r0
    2048:	b2 83       	std	Z+2, r27	; 0x02
    204a:	a1 83       	std	Z+1, r26	; 0x01
    204c:	2d 53       	subi	r18, 0x3D	; 61
    204e:	3e 4f       	sbci	r19, 0xFE	; 254
    2050:	a2 17       	cp	r26, r18
    2052:	b3 07       	cpc	r27, r19
    2054:	31 f4       	brne	.+12     	; 0x2062 <vCoRoutineSchedule+0x1a0>
    2056:	12 96       	adiw	r26, 0x02	; 2
    2058:	8d 91       	ld	r24, X+
    205a:	9c 91       	ld	r25, X
    205c:	13 97       	sbiw	r26, 0x03	; 3
    205e:	92 83       	std	Z+2, r25	; 0x02
    2060:	81 83       	std	Z+1, r24	; 0x01
    2062:	89 e0       	ldi	r24, 0x09	; 9
    2064:	84 9f       	mul	r24, r20
    2066:	f0 01       	movw	r30, r0
    2068:	85 9f       	mul	r24, r21
    206a:	f0 0d       	add	r31, r0
    206c:	11 24       	eor	r1, r1
    206e:	e0 54       	subi	r30, 0x40	; 64
    2070:	fe 4f       	sbci	r31, 0xFE	; 254
    2072:	01 80       	ldd	r0, Z+1	; 0x01
    2074:	f2 81       	ldd	r31, Z+2	; 0x02
    2076:	e0 2d       	mov	r30, r0
    2078:	86 81       	ldd	r24, Z+6	; 0x06
    207a:	97 81       	ldd	r25, Z+7	; 0x07
    207c:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <pxCurrentCoRoutine+0x1>
    2080:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2084:	dc 01       	movw	r26, r24
    2086:	ed 91       	ld	r30, X+
    2088:	fc 91       	ld	r31, X
    208a:	11 97       	sbiw	r26, 0x01	; 1
    208c:	57 96       	adiw	r26, 0x17	; 23
    208e:	6c 91       	ld	r22, X

	return;
}
    2090:	df 91       	pop	r29
    2092:	cf 91       	pop	r28
    2094:	1f 91       	pop	r17
    2096:	0f 91       	pop	r16
    2098:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    209a:	09 94       	ijmp

0000209c <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    209c:	0f 93       	push	r16
    209e:	1f 93       	push	r17
    20a0:	cf 93       	push	r28
    20a2:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    20a4:	dc 01       	movw	r26, r24
    20a6:	15 96       	adiw	r26, 0x05	; 5
    20a8:	ed 91       	ld	r30, X+
    20aa:	fc 91       	ld	r31, X
    20ac:	16 97       	sbiw	r26, 0x06	; 6
    20ae:	c6 81       	ldd	r28, Z+6	; 0x06
    20b0:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    20b2:	8e 01       	movw	r16, r28
    20b4:	04 5f       	subi	r16, 0xF4	; 244
    20b6:	1f 4f       	sbci	r17, 0xFF	; 255
    20b8:	c8 01       	movw	r24, r16
    20ba:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    20be:	b8 01       	movw	r22, r16
    20c0:	81 ea       	ldi	r24, 0xA1	; 161
    20c2:	91 e0       	ldi	r25, 0x01	; 1
    20c4:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    20c8:	e0 91 98 01 	lds	r30, 0x0198	; 0x800198 <pxCurrentCoRoutine>
    20cc:	f0 91 99 01 	lds	r31, 0x0199	; 0x800199 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    20d0:	81 e0       	ldi	r24, 0x01	; 1
    20d2:	2e 89       	ldd	r18, Y+22	; 0x16
    20d4:	96 89       	ldd	r25, Z+22	; 0x16
    20d6:	29 17       	cp	r18, r25
    20d8:	08 f4       	brcc	.+2      	; 0x20dc <xCoRoutineRemoveFromEventList+0x40>
    20da:	80 e0       	ldi	r24, 0x00	; 0
}
    20dc:	df 91       	pop	r29
    20de:	cf 91       	pop	r28
    20e0:	1f 91       	pop	r17
    20e2:	0f 91       	pop	r16
    20e4:	08 95       	ret

000020e6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    20e6:	cf 93       	push	r28
    20e8:	df 93       	push	r29
    20ea:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    20ec:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    20f0:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <pucAlignedHeap.2081>
    20f4:	90 91 d3 01 	lds	r25, 0x01D3	; 0x8001d3 <pucAlignedHeap.2081+0x1>
    20f8:	89 2b       	or	r24, r25
    20fa:	31 f4       	brne	.+12     	; 0x2108 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    20fc:	87 ed       	ldi	r24, 0xD7	; 215
    20fe:	91 e0       	ldi	r25, 0x01	; 1
    2100:	90 93 d3 01 	sts	0x01D3, r25	; 0x8001d3 <pucAlignedHeap.2081+0x1>
    2104:	80 93 d2 01 	sts	0x01D2, r24	; 0x8001d2 <pucAlignedHeap.2081>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2108:	20 91 d4 01 	lds	r18, 0x01D4	; 0x8001d4 <xNextFreeByte>
    210c:	30 91 d5 01 	lds	r19, 0x01D5	; 0x8001d5 <xNextFreeByte+0x1>
    2110:	c9 01       	movw	r24, r18
    2112:	8c 0f       	add	r24, r28
    2114:	9d 1f       	adc	r25, r29
    2116:	8b 3d       	cpi	r24, 0xDB	; 219
    2118:	45 e0       	ldi	r20, 0x05	; 5
    211a:	94 07       	cpc	r25, r20
    211c:	70 f4       	brcc	.+28     	; 0x213a <pvPortMalloc+0x54>
    211e:	28 17       	cp	r18, r24
    2120:	39 07       	cpc	r19, r25
    2122:	58 f4       	brcc	.+22     	; 0x213a <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2124:	c0 91 d2 01 	lds	r28, 0x01D2	; 0x8001d2 <pucAlignedHeap.2081>
    2128:	d0 91 d3 01 	lds	r29, 0x01D3	; 0x8001d3 <pucAlignedHeap.2081+0x1>
    212c:	c2 0f       	add	r28, r18
    212e:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2130:	90 93 d5 01 	sts	0x01D5, r25	; 0x8001d5 <xNextFreeByte+0x1>
    2134:	80 93 d4 01 	sts	0x01D4, r24	; 0x8001d4 <xNextFreeByte>
    2138:	02 c0       	rjmp	.+4      	; 0x213e <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    213a:	c0 e0       	ldi	r28, 0x00	; 0
    213c:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    213e:	0e 94 b7 04 	call	0x96e	; 0x96e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2142:	ce 01       	movw	r24, r28
    2144:	df 91       	pop	r29
    2146:	cf 91       	pop	r28
    2148:	08 95       	ret

0000214a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    214a:	08 95       	ret

0000214c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    214c:	10 92 d5 01 	sts	0x01D5, r1	; 0x8001d5 <xNextFreeByte+0x1>
    2150:	10 92 d4 01 	sts	0x01D4, r1	; 0x8001d4 <xNextFreeByte>
    2154:	08 95       	ret

00002156 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2156:	20 91 d4 01 	lds	r18, 0x01D4	; 0x8001d4 <xNextFreeByte>
    215a:	30 91 d5 01 	lds	r19, 0x01D5	; 0x8001d5 <xNextFreeByte+0x1>
}
    215e:	8b ed       	ldi	r24, 0xDB	; 219
    2160:	95 e0       	ldi	r25, 0x05	; 5
    2162:	82 1b       	sub	r24, r18
    2164:	93 0b       	sbc	r25, r19
    2166:	08 95       	ret

00002168 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2168:	31 e1       	ldi	r19, 0x11	; 17
    216a:	fc 01       	movw	r30, r24
    216c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    216e:	31 97       	sbiw	r30, 0x01	; 1
    2170:	22 e2       	ldi	r18, 0x22	; 34
    2172:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2174:	31 97       	sbiw	r30, 0x01	; 1
    2176:	a3 e3       	ldi	r26, 0x33	; 51
    2178:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    217a:	31 97       	sbiw	r30, 0x01	; 1
    217c:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    217e:	31 97       	sbiw	r30, 0x01	; 1
    2180:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2182:	31 97       	sbiw	r30, 0x01	; 1
    2184:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2186:	31 97       	sbiw	r30, 0x01	; 1
    2188:	60 e8       	ldi	r22, 0x80	; 128
    218a:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    218c:	31 97       	sbiw	r30, 0x01	; 1
    218e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2190:	31 97       	sbiw	r30, 0x01	; 1
    2192:	62 e0       	ldi	r22, 0x02	; 2
    2194:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2196:	31 97       	sbiw	r30, 0x01	; 1
    2198:	63 e0       	ldi	r22, 0x03	; 3
    219a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    219c:	31 97       	sbiw	r30, 0x01	; 1
    219e:	64 e0       	ldi	r22, 0x04	; 4
    21a0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    21a2:	31 97       	sbiw	r30, 0x01	; 1
    21a4:	65 e0       	ldi	r22, 0x05	; 5
    21a6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    21a8:	31 97       	sbiw	r30, 0x01	; 1
    21aa:	66 e0       	ldi	r22, 0x06	; 6
    21ac:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    21ae:	31 97       	sbiw	r30, 0x01	; 1
    21b0:	67 e0       	ldi	r22, 0x07	; 7
    21b2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    21b4:	31 97       	sbiw	r30, 0x01	; 1
    21b6:	68 e0       	ldi	r22, 0x08	; 8
    21b8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    21ba:	31 97       	sbiw	r30, 0x01	; 1
    21bc:	69 e0       	ldi	r22, 0x09	; 9
    21be:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    21c0:	31 97       	sbiw	r30, 0x01	; 1
    21c2:	60 e1       	ldi	r22, 0x10	; 16
    21c4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    21c6:	31 97       	sbiw	r30, 0x01	; 1
    21c8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    21ca:	31 97       	sbiw	r30, 0x01	; 1
    21cc:	32 e1       	ldi	r19, 0x12	; 18
    21ce:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    21d0:	31 97       	sbiw	r30, 0x01	; 1
    21d2:	33 e1       	ldi	r19, 0x13	; 19
    21d4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    21d6:	31 97       	sbiw	r30, 0x01	; 1
    21d8:	34 e1       	ldi	r19, 0x14	; 20
    21da:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    21dc:	31 97       	sbiw	r30, 0x01	; 1
    21de:	35 e1       	ldi	r19, 0x15	; 21
    21e0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    21e2:	31 97       	sbiw	r30, 0x01	; 1
    21e4:	36 e1       	ldi	r19, 0x16	; 22
    21e6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    21e8:	31 97       	sbiw	r30, 0x01	; 1
    21ea:	37 e1       	ldi	r19, 0x17	; 23
    21ec:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    21ee:	31 97       	sbiw	r30, 0x01	; 1
    21f0:	38 e1       	ldi	r19, 0x18	; 24
    21f2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    21f4:	31 97       	sbiw	r30, 0x01	; 1
    21f6:	39 e1       	ldi	r19, 0x19	; 25
    21f8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    21fa:	31 97       	sbiw	r30, 0x01	; 1
    21fc:	30 e2       	ldi	r19, 0x20	; 32
    21fe:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2200:	31 97       	sbiw	r30, 0x01	; 1
    2202:	31 e2       	ldi	r19, 0x21	; 33
    2204:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2206:	31 97       	sbiw	r30, 0x01	; 1
    2208:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    220a:	31 97       	sbiw	r30, 0x01	; 1
    220c:	23 e2       	ldi	r18, 0x23	; 35
    220e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2210:	31 97       	sbiw	r30, 0x01	; 1
    2212:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2214:	31 97       	sbiw	r30, 0x01	; 1
    2216:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2218:	31 97       	sbiw	r30, 0x01	; 1
    221a:	26 e2       	ldi	r18, 0x26	; 38
    221c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    221e:	31 97       	sbiw	r30, 0x01	; 1
    2220:	27 e2       	ldi	r18, 0x27	; 39
    2222:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2224:	31 97       	sbiw	r30, 0x01	; 1
    2226:	28 e2       	ldi	r18, 0x28	; 40
    2228:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    222a:	31 97       	sbiw	r30, 0x01	; 1
    222c:	29 e2       	ldi	r18, 0x29	; 41
    222e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2230:	31 97       	sbiw	r30, 0x01	; 1
    2232:	20 e3       	ldi	r18, 0x30	; 48
    2234:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2236:	31 97       	sbiw	r30, 0x01	; 1
    2238:	21 e3       	ldi	r18, 0x31	; 49
    223a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    223c:	86 97       	sbiw	r24, 0x26	; 38
    223e:	08 95       	ret

00002240 <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    2240:	89 ef       	ldi	r24, 0xF9	; 249
    2242:	90 e0       	ldi	r25, 0x00	; 0
    2244:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
    2248:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    224c:	e0 e8       	ldi	r30, 0x80	; 128
    224e:	f0 e0       	ldi	r31, 0x00	; 0
    2250:	80 81       	ld	r24, Z
    2252:	8c 7f       	andi	r24, 0xFC	; 252
    2254:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2256:	8b e0       	ldi	r24, 0x0B	; 11
    2258:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    225c:	ef e6       	ldi	r30, 0x6F	; 111
    225e:	f0 e0       	ldi	r31, 0x00	; 0
    2260:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2262:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    2264:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2266:	a0 91 32 01 	lds	r26, 0x0132	; 0x800132 <pxCurrentTCB>
    226a:	b0 91 33 01 	lds	r27, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
    226e:	cd 91       	ld	r28, X+
    2270:	cd bf       	out	0x3d, r28	; 61
    2272:	dd 91       	ld	r29, X+
    2274:	de bf       	out	0x3e, r29	; 62
    2276:	ff 91       	pop	r31
    2278:	ef 91       	pop	r30
    227a:	df 91       	pop	r29
    227c:	cf 91       	pop	r28
    227e:	bf 91       	pop	r27
    2280:	af 91       	pop	r26
    2282:	9f 91       	pop	r25
    2284:	8f 91       	pop	r24
    2286:	7f 91       	pop	r23
    2288:	6f 91       	pop	r22
    228a:	5f 91       	pop	r21
    228c:	4f 91       	pop	r20
    228e:	3f 91       	pop	r19
    2290:	2f 91       	pop	r18
    2292:	1f 91       	pop	r17
    2294:	0f 91       	pop	r16
    2296:	ff 90       	pop	r15
    2298:	ef 90       	pop	r14
    229a:	df 90       	pop	r13
    229c:	cf 90       	pop	r12
    229e:	bf 90       	pop	r11
    22a0:	af 90       	pop	r10
    22a2:	9f 90       	pop	r9
    22a4:	8f 90       	pop	r8
    22a6:	7f 90       	pop	r7
    22a8:	6f 90       	pop	r6
    22aa:	5f 90       	pop	r5
    22ac:	4f 90       	pop	r4
    22ae:	3f 90       	pop	r3
    22b0:	2f 90       	pop	r2
    22b2:	1f 90       	pop	r1
    22b4:	0f 90       	pop	r0
    22b6:	0f be       	out	0x3f, r0	; 63
    22b8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    22ba:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    22bc:	81 e0       	ldi	r24, 0x01	; 1
    22be:	08 95       	ret

000022c0 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    22c0:	08 95       	ret

000022c2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    22c2:	0f 92       	push	r0
    22c4:	0f b6       	in	r0, 0x3f	; 63
    22c6:	f8 94       	cli
    22c8:	0f 92       	push	r0
    22ca:	1f 92       	push	r1
    22cc:	11 24       	eor	r1, r1
    22ce:	2f 92       	push	r2
    22d0:	3f 92       	push	r3
    22d2:	4f 92       	push	r4
    22d4:	5f 92       	push	r5
    22d6:	6f 92       	push	r6
    22d8:	7f 92       	push	r7
    22da:	8f 92       	push	r8
    22dc:	9f 92       	push	r9
    22de:	af 92       	push	r10
    22e0:	bf 92       	push	r11
    22e2:	cf 92       	push	r12
    22e4:	df 92       	push	r13
    22e6:	ef 92       	push	r14
    22e8:	ff 92       	push	r15
    22ea:	0f 93       	push	r16
    22ec:	1f 93       	push	r17
    22ee:	2f 93       	push	r18
    22f0:	3f 93       	push	r19
    22f2:	4f 93       	push	r20
    22f4:	5f 93       	push	r21
    22f6:	6f 93       	push	r22
    22f8:	7f 93       	push	r23
    22fa:	8f 93       	push	r24
    22fc:	9f 93       	push	r25
    22fe:	af 93       	push	r26
    2300:	bf 93       	push	r27
    2302:	cf 93       	push	r28
    2304:	df 93       	push	r29
    2306:	ef 93       	push	r30
    2308:	ff 93       	push	r31
    230a:	a0 91 32 01 	lds	r26, 0x0132	; 0x800132 <pxCurrentTCB>
    230e:	b0 91 33 01 	lds	r27, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
    2312:	0d b6       	in	r0, 0x3d	; 61
    2314:	0d 92       	st	X+, r0
    2316:	0e b6       	in	r0, 0x3e	; 62
    2318:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    231a:	0e 94 73 05 	call	0xae6	; 0xae6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    231e:	a0 91 32 01 	lds	r26, 0x0132	; 0x800132 <pxCurrentTCB>
    2322:	b0 91 33 01 	lds	r27, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
    2326:	cd 91       	ld	r28, X+
    2328:	cd bf       	out	0x3d, r28	; 61
    232a:	dd 91       	ld	r29, X+
    232c:	de bf       	out	0x3e, r29	; 62
    232e:	ff 91       	pop	r31
    2330:	ef 91       	pop	r30
    2332:	df 91       	pop	r29
    2334:	cf 91       	pop	r28
    2336:	bf 91       	pop	r27
    2338:	af 91       	pop	r26
    233a:	9f 91       	pop	r25
    233c:	8f 91       	pop	r24
    233e:	7f 91       	pop	r23
    2340:	6f 91       	pop	r22
    2342:	5f 91       	pop	r21
    2344:	4f 91       	pop	r20
    2346:	3f 91       	pop	r19
    2348:	2f 91       	pop	r18
    234a:	1f 91       	pop	r17
    234c:	0f 91       	pop	r16
    234e:	ff 90       	pop	r15
    2350:	ef 90       	pop	r14
    2352:	df 90       	pop	r13
    2354:	cf 90       	pop	r12
    2356:	bf 90       	pop	r11
    2358:	af 90       	pop	r10
    235a:	9f 90       	pop	r9
    235c:	8f 90       	pop	r8
    235e:	7f 90       	pop	r7
    2360:	6f 90       	pop	r6
    2362:	5f 90       	pop	r5
    2364:	4f 90       	pop	r4
    2366:	3f 90       	pop	r3
    2368:	2f 90       	pop	r2
    236a:	1f 90       	pop	r1
    236c:	0f 90       	pop	r0
    236e:	0f be       	out	0x3f, r0	; 63
    2370:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2372:	08 95       	ret

00002374 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2374:	0f 92       	push	r0
    2376:	0f b6       	in	r0, 0x3f	; 63
    2378:	f8 94       	cli
    237a:	0f 92       	push	r0
    237c:	1f 92       	push	r1
    237e:	11 24       	eor	r1, r1
    2380:	2f 92       	push	r2
    2382:	3f 92       	push	r3
    2384:	4f 92       	push	r4
    2386:	5f 92       	push	r5
    2388:	6f 92       	push	r6
    238a:	7f 92       	push	r7
    238c:	8f 92       	push	r8
    238e:	9f 92       	push	r9
    2390:	af 92       	push	r10
    2392:	bf 92       	push	r11
    2394:	cf 92       	push	r12
    2396:	df 92       	push	r13
    2398:	ef 92       	push	r14
    239a:	ff 92       	push	r15
    239c:	0f 93       	push	r16
    239e:	1f 93       	push	r17
    23a0:	2f 93       	push	r18
    23a2:	3f 93       	push	r19
    23a4:	4f 93       	push	r20
    23a6:	5f 93       	push	r21
    23a8:	6f 93       	push	r22
    23aa:	7f 93       	push	r23
    23ac:	8f 93       	push	r24
    23ae:	9f 93       	push	r25
    23b0:	af 93       	push	r26
    23b2:	bf 93       	push	r27
    23b4:	cf 93       	push	r28
    23b6:	df 93       	push	r29
    23b8:	ef 93       	push	r30
    23ba:	ff 93       	push	r31
    23bc:	a0 91 32 01 	lds	r26, 0x0132	; 0x800132 <pxCurrentTCB>
    23c0:	b0 91 33 01 	lds	r27, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
    23c4:	0d b6       	in	r0, 0x3d	; 61
    23c6:	0d 92       	st	X+, r0
    23c8:	0e b6       	in	r0, 0x3e	; 62
    23ca:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    23cc:	0e 94 0b 04 	call	0x816	; 0x816 <xTaskIncrementTick>
    23d0:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    23d2:	0e 94 73 05 	call	0xae6	; 0xae6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    23d6:	a0 91 32 01 	lds	r26, 0x0132	; 0x800132 <pxCurrentTCB>
    23da:	b0 91 33 01 	lds	r27, 0x0133	; 0x800133 <pxCurrentTCB+0x1>
    23de:	cd 91       	ld	r28, X+
    23e0:	cd bf       	out	0x3d, r28	; 61
    23e2:	dd 91       	ld	r29, X+
    23e4:	de bf       	out	0x3e, r29	; 62
    23e6:	ff 91       	pop	r31
    23e8:	ef 91       	pop	r30
    23ea:	df 91       	pop	r29
    23ec:	cf 91       	pop	r28
    23ee:	bf 91       	pop	r27
    23f0:	af 91       	pop	r26
    23f2:	9f 91       	pop	r25
    23f4:	8f 91       	pop	r24
    23f6:	7f 91       	pop	r23
    23f8:	6f 91       	pop	r22
    23fa:	5f 91       	pop	r21
    23fc:	4f 91       	pop	r20
    23fe:	3f 91       	pop	r19
    2400:	2f 91       	pop	r18
    2402:	1f 91       	pop	r17
    2404:	0f 91       	pop	r16
    2406:	ff 90       	pop	r15
    2408:	ef 90       	pop	r14
    240a:	df 90       	pop	r13
    240c:	cf 90       	pop	r12
    240e:	bf 90       	pop	r11
    2410:	af 90       	pop	r10
    2412:	9f 90       	pop	r9
    2414:	8f 90       	pop	r8
    2416:	7f 90       	pop	r7
    2418:	6f 90       	pop	r6
    241a:	5f 90       	pop	r5
    241c:	4f 90       	pop	r4
    241e:	3f 90       	pop	r3
    2420:	2f 90       	pop	r2
    2422:	1f 90       	pop	r1
    2424:	0f 90       	pop	r0
    2426:	0f be       	out	0x3f, r0	; 63
    2428:	0f 90       	pop	r0

	asm volatile ( "ret" );
    242a:	08 95       	ret

0000242c <__vector_11>:
    242c:	0e 94 ba 11 	call	0x2374	; 0x2374 <vPortYieldFromTick>
    2430:	18 95       	reti

00002432 <main>:
 * \brief Main function.
 *
 * \return
 ******************************************************************************/
int main(void)
{
    2432:	ef 92       	push	r14
    2434:	ff 92       	push	r15
    2436:	0f 93       	push	r16
    2438:	cf 93       	push	r28
    243a:	df 93       	push	r29
    243c:	00 d0       	rcall	.+0      	; 0x243e <main+0xc>
    243e:	00 d0       	rcall	.+0      	; 0x2440 <main+0xe>
    2440:	cd b7       	in	r28, 0x3d	; 61
    2442:	de b7       	in	r29, 0x3e	; 62
    // Create task.
    xTaskHandle blink_handle;
    xTaskHandle serial_handle;

    xTaskCreate
    2444:	ce 01       	movw	r24, r28
    2446:	03 96       	adiw	r24, 0x03	; 3
    2448:	7c 01       	movw	r14, r24
    244a:	02 e0       	ldi	r16, 0x02	; 2
    244c:	20 e0       	ldi	r18, 0x00	; 0
    244e:	30 e0       	ldi	r19, 0x00	; 0
    2450:	45 e5       	ldi	r20, 0x55	; 85
    2452:	50 e0       	ldi	r21, 0x00	; 0
    2454:	60 e0       	ldi	r22, 0x00	; 0
    2456:	71 e0       	ldi	r23, 0x01	; 1
    2458:	85 ea       	ldi	r24, 0xA5	; 165
    245a:	90 e0       	ldi	r25, 0x00	; 0
    245c:	0e 94 d7 01 	call	0x3ae	; 0x3ae <xTaskCreate>
         NULL,
         mainLED_counter_TASK_PRIORITY,
         &blink_handle
        );

    xTaskCreate
    2460:	ce 01       	movw	r24, r28
    2462:	01 96       	adiw	r24, 0x01	; 1
    2464:	7c 01       	movw	r14, r24
    2466:	01 e0       	ldi	r16, 0x01	; 1
    2468:	20 e0       	ldi	r18, 0x00	; 0
    246a:	30 e0       	ldi	r19, 0x00	; 0
    246c:	45 e5       	ldi	r20, 0x55	; 85
    246e:	50 e0       	ldi	r21, 0x00	; 0
    2470:	66 e0       	ldi	r22, 0x06	; 6
    2472:	71 e0       	ldi	r23, 0x01	; 1
    2474:	83 e5       	ldi	r24, 0x53	; 83
    2476:	90 e0       	ldi	r25, 0x00	; 0
    2478:	0e 94 d7 01 	call	0x3ae	; 0x3ae <xTaskCreate>
         mainBUTTON_TASK_PRIORITY,
         &serial_handle
        );

    // Start scheduler.
    vTaskStartScheduler();
    247c:	0e 94 bc 03 	call	0x778	; 0x778 <vTaskStartScheduler>

    return 0;
}
    2480:	80 e0       	ldi	r24, 0x00	; 0
    2482:	90 e0       	ldi	r25, 0x00	; 0
    2484:	0f 90       	pop	r0
    2486:	0f 90       	pop	r0
    2488:	0f 90       	pop	r0
    248a:	0f 90       	pop	r0
    248c:	df 91       	pop	r29
    248e:	cf 91       	pop	r28
    2490:	0f 91       	pop	r16
    2492:	ff 90       	pop	r15
    2494:	ef 90       	pop	r14
    2496:	08 95       	ret

00002498 <memcpy>:
    2498:	fb 01       	movw	r30, r22
    249a:	dc 01       	movw	r26, r24
    249c:	02 c0       	rjmp	.+4      	; 0x24a2 <memcpy+0xa>
    249e:	01 90       	ld	r0, Z+
    24a0:	0d 92       	st	X+, r0
    24a2:	41 50       	subi	r20, 0x01	; 1
    24a4:	50 40       	sbci	r21, 0x00	; 0
    24a6:	d8 f7       	brcc	.-10     	; 0x249e <memcpy+0x6>
    24a8:	08 95       	ret

000024aa <_exit>:
    24aa:	f8 94       	cli

000024ac <__stop_program>:
    24ac:	ff cf       	rjmp	.-2      	; 0x24ac <__stop_program>

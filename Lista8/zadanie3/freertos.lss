
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800100  00002608  0000269c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002608  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000068a  00800120  00800120  000026bc  2**0
                  ALLOC
  3 .stab         000073a4  00000000  00000000  000026bc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000440a  00000000  00000000  00009a60  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000de6a  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000de7c  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000debc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000e4b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000ea52  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0000ea6c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 29 12 	jmp	0x2452	; 0x2452 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 0b 01 	jmp	0x216	; 0x216 <__vector_18>
      4c:	0c 94 d1 00 	jmp	0x1a2	; 0x1a2 <__vector_19>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e8 e0       	ldi	r30, 0x08	; 8
      7c:	f6 e2       	ldi	r31, 0x26	; 38
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a0 32       	cpi	r26, 0x20	; 32
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	a0 e2       	ldi	r26, 0x20	; 32
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	aa 3a       	cpi	r26, 0xAA	; 170
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 2c 12 	call	0x2458	; 0x2458 <main>
      9e:	0c 94 02 13 	jmp	0x2604	; 0x2604 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <uart_transmit>:
  // BaseType_t checkIfYieldRequired;
  // checkIfYieldRequired = xTaskResumeFromISR(mainECHO);
  // taskYIELD_FROM_ISR(checkIfYieldRequired);
}

int uart_transmit(char c, FILE *stream) {
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	1f 92       	push	r1
      ac:	cd b7       	in	r28, 0x3d	; 61
      ae:	de b7       	in	r29, 0x3e	; 62
      b0:	89 83       	std	Y+1, r24	; 0x01
  xQueueSend(tx_buffer, &c, portMAX_DELAY);
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	4f ef       	ldi	r20, 0xFF	; 255
      b6:	5f ef       	ldi	r21, 0xFF	; 255
      b8:	be 01       	movw	r22, r28
      ba:	6f 5f       	subi	r22, 0xFF	; 255
      bc:	7f 4f       	sbci	r23, 0xFF	; 255
      be:	80 91 a2 07 	lds	r24, 0x07A2	; 0x8007a2 <tx_buffer>
      c2:	90 91 a3 07 	lds	r25, 0x07A3	; 0x8007a3 <tx_buffer+0x1>
      c6:	0e 94 57 0a 	call	0x14ae	; 0x14ae <xQueueGenericSend>
  UCSR0B |= _BV(UDRIE0);
      ca:	e1 ec       	ldi	r30, 0xC1	; 193
      cc:	f0 e0       	ldi	r31, 0x00	; 0
      ce:	80 81       	ld	r24, Z
      d0:	80 62       	ori	r24, 0x20	; 32
      d2:	80 83       	st	Z, r24
  // vTaskSuspend(NULL);
  // while (!(UCSR0A & _BV(UDRE0))) taskYIELD();
  // UDR0 = c;
  return 0;
}
      d4:	80 e0       	ldi	r24, 0x00	; 0
      d6:	90 e0       	ldi	r25, 0x00	; 0
      d8:	0f 90       	pop	r0
      da:	df 91       	pop	r29
      dc:	cf 91       	pop	r28
      de:	08 95       	ret

000000e0 <uart_receive>:

int uart_receive(FILE *stream) {
      e0:	cf 93       	push	r28
      e2:	df 93       	push	r29
      e4:	1f 92       	push	r1
      e6:	cd b7       	in	r28, 0x3d	; 61
      e8:	de b7       	in	r29, 0x3e	; 62
  uint8_t data;
  xQueueReceive(rx_buffer,&data,portMAX_DELAY);
      ea:	4f ef       	ldi	r20, 0xFF	; 255
      ec:	5f ef       	ldi	r21, 0xFF	; 255
      ee:	be 01       	movw	r22, r28
      f0:	6f 5f       	subi	r22, 0xFF	; 255
      f2:	7f 4f       	sbci	r23, 0xFF	; 255
      f4:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <rx_buffer>
      f8:	90 91 a1 07 	lds	r25, 0x07A1	; 0x8007a1 <rx_buffer+0x1>
      fc:	0e 94 3f 0b 	call	0x167e	; 0x167e <xQueueReceive>
  return data;
     100:	89 81       	ldd	r24, Y+1	; 0x01
  // vTaskSuspend(NULL);
  // while (!(UCSR0A & _BV(RXC0))) taskYIELD();
  //return _FDEV_EOF;
}
     102:	90 e0       	ldi	r25, 0x00	; 0
     104:	0f 90       	pop	r0
     106:	df 91       	pop	r29
     108:	cf 91       	pop	r28
     10a:	08 95       	ret

0000010c <vBlinker>:

}

static void vBlinker(void* pvParameters)
{
    DDRB |= _BV(PB2);
     10c:	22 9a       	sbi	0x04, 2	; 4

while(1)    {
        PORTB |= _BV(PB2);
     10e:	2a 9a       	sbi	0x05, 2	; 5
        vTaskDelay(500 / portTICK_PERIOD_MS);
     110:	84 ef       	ldi	r24, 0xF4	; 244
     112:	91 e0       	ldi	r25, 0x01	; 1
     114:	0e 94 71 05 	call	0xae2	; 0xae2 <vTaskDelay>
        PORTB &= ~_BV(PB2);
     118:	2a 98       	cbi	0x05, 2	; 5
     11a:	f9 cf       	rjmp	.-14     	; 0x10e <vBlinker+0x2>

0000011c <uart_init>:

// inicjalizacja UART
void uart_init(void)
{
  // ustaw baudrate
  UBRR0 = UBRR_VALUE;
     11c:	87 e6       	ldi	r24, 0x67	; 103
     11e:	90 e0       	ldi	r25, 0x00	; 0
     120:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
     124:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
  // wyczyść rejestr UCSR0A
  UCSR0A = 0;
     128:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  // włącz odbiornik i nadajnik
  UCSR0B = _BV(RXEN0) | _BV(TXEN0) | _BV(UDRIE0);
     12c:	e1 ec       	ldi	r30, 0xC1	; 193
     12e:	f0 e0       	ldi	r31, 0x00	; 0
     130:	88 e3       	ldi	r24, 0x38	; 56
     132:	80 83       	st	Z, r24
  // ustaw format 8n1
  UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
     134:	86 e0       	ldi	r24, 0x06	; 6
     136:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
  //wlaczenie przerwan
  UCSR0B |= _BV(RXCIE0) | _BV(TXCIE0);
     13a:	80 81       	ld	r24, Z
     13c:	80 6c       	ori	r24, 0xC0	; 192
     13e:	80 83       	st	Z, r24
     140:	08 95       	ret

00000142 <vECHO>:
}


static void vECHO(void* pvParameters)
{
    uart_init();
     142:	0e 94 8e 00 	call	0x11c	; 0x11c <uart_init>
    stdin = stdout = stderr = &uart_file;
     146:	80 e0       	ldi	r24, 0x00	; 0
     148:	91 e0       	ldi	r25, 0x01	; 1
     14a:	90 93 a9 07 	sts	0x07A9, r25	; 0x8007a9 <__iob+0x5>
     14e:	80 93 a8 07 	sts	0x07A8, r24	; 0x8007a8 <__iob+0x4>
     152:	90 93 a7 07 	sts	0x07A7, r25	; 0x8007a7 <__iob+0x3>
     156:	80 93 a6 07 	sts	0x07A6, r24	; 0x8007a6 <__iob+0x2>
     15a:	90 93 a5 07 	sts	0x07A5, r25	; 0x8007a5 <__iob+0x1>
     15e:	80 93 a4 07 	sts	0x07A4, r24	; 0x8007a4 <__iob>
    char input;

    for ( ;; )
    {
        // puts("Hello World\r\n");
        input = getchar();
     162:	80 91 a4 07 	lds	r24, 0x07A4	; 0x8007a4 <__iob>
     166:	90 91 a5 07 	lds	r25, 0x07A5	; 0x8007a5 <__iob+0x1>
     16a:	0e 94 88 12 	call	0x2510	; 0x2510 <fgetc>
        putchar(input);
     16e:	60 91 a6 07 	lds	r22, 0x07A6	; 0x8007a6 <__iob+0x2>
     172:	70 91 a7 07 	lds	r23, 0x07A7	; 0x8007a7 <__iob+0x3>
     176:	08 2e       	mov	r0, r24
     178:	00 0c       	add	r0, r0
     17a:	99 0b       	sbc	r25, r25
     17c:	0e 94 c6 12 	call	0x258c	; 0x258c <fputc>
        putchar('\r');
     180:	60 91 a6 07 	lds	r22, 0x07A6	; 0x8007a6 <__iob+0x2>
     184:	70 91 a7 07 	lds	r23, 0x07A7	; 0x8007a7 <__iob+0x3>
     188:	8d e0       	ldi	r24, 0x0D	; 13
     18a:	90 e0       	ldi	r25, 0x00	; 0
     18c:	0e 94 c6 12 	call	0x258c	; 0x258c <fputc>
        putchar('\n');
     190:	60 91 a6 07 	lds	r22, 0x07A6	; 0x8007a6 <__iob+0x2>
     194:	70 91 a7 07 	lds	r23, 0x07A7	; 0x8007a7 <__iob+0x3>
     198:	8a e0       	ldi	r24, 0x0A	; 10
     19a:	90 e0       	ldi	r25, 0x00	; 0
     19c:	0e 94 c6 12 	call	0x258c	; 0x258c <fputc>
     1a0:	e0 cf       	rjmp	.-64     	; 0x162 <vECHO+0x20>

000001a2 <__vector_19>:

QueueHandle_t tx_buffer;
QueueHandle_t rx_buffer;


ISR(USART_UDRE_vect){
     1a2:	1f 92       	push	r1
     1a4:	0f 92       	push	r0
     1a6:	0f b6       	in	r0, 0x3f	; 63
     1a8:	0f 92       	push	r0
     1aa:	11 24       	eor	r1, r1
     1ac:	2f 93       	push	r18
     1ae:	3f 93       	push	r19
     1b0:	4f 93       	push	r20
     1b2:	5f 93       	push	r21
     1b4:	6f 93       	push	r22
     1b6:	7f 93       	push	r23
     1b8:	8f 93       	push	r24
     1ba:	9f 93       	push	r25
     1bc:	af 93       	push	r26
     1be:	bf 93       	push	r27
     1c0:	ef 93       	push	r30
     1c2:	ff 93       	push	r31
     1c4:	cf 93       	push	r28
     1c6:	df 93       	push	r29
     1c8:	1f 92       	push	r1
     1ca:	cd b7       	in	r28, 0x3d	; 61
     1cc:	de b7       	in	r29, 0x3e	; 62
  uint8_t value;
  if(xQueueReceiveFromISR(tx_buffer,&value,0) == pdPASS){
     1ce:	40 e0       	ldi	r20, 0x00	; 0
     1d0:	50 e0       	ldi	r21, 0x00	; 0
     1d2:	be 01       	movw	r22, r28
     1d4:	6f 5f       	subi	r22, 0xFF	; 255
     1d6:	7f 4f       	sbci	r23, 0xFF	; 255
     1d8:	80 91 a2 07 	lds	r24, 0x07A2	; 0x8007a2 <tx_buffer>
     1dc:	90 91 a3 07 	lds	r25, 0x07A3	; 0x8007a3 <tx_buffer+0x1>
     1e0:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <xQueueReceiveFromISR>
     1e4:	81 30       	cpi	r24, 0x01	; 1
     1e6:	19 f4       	brne	.+6      	; 0x1ee <__vector_19+0x4c>
    UDR0 = value;
     1e8:	89 81       	ldd	r24, Y+1	; 0x01
     1ea:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
  }
  // BaseType_t checkIfYieldRequired;
  // checkIfYieldRequired = xTaskResumeFromISR(mainECHO);
  // taskYIELD_FROM_ISR(checkIfYieldRequired);
}
     1ee:	0f 90       	pop	r0
     1f0:	df 91       	pop	r29
     1f2:	cf 91       	pop	r28
     1f4:	ff 91       	pop	r31
     1f6:	ef 91       	pop	r30
     1f8:	bf 91       	pop	r27
     1fa:	af 91       	pop	r26
     1fc:	9f 91       	pop	r25
     1fe:	8f 91       	pop	r24
     200:	7f 91       	pop	r23
     202:	6f 91       	pop	r22
     204:	5f 91       	pop	r21
     206:	4f 91       	pop	r20
     208:	3f 91       	pop	r19
     20a:	2f 91       	pop	r18
     20c:	0f 90       	pop	r0
     20e:	0f be       	out	0x3f, r0	; 63
     210:	0f 90       	pop	r0
     212:	1f 90       	pop	r1
     214:	18 95       	reti

00000216 <__vector_18>:

ISR(USART_RX_vect){
     216:	1f 92       	push	r1
     218:	0f 92       	push	r0
     21a:	0f b6       	in	r0, 0x3f	; 63
     21c:	0f 92       	push	r0
     21e:	11 24       	eor	r1, r1
     220:	2f 93       	push	r18
     222:	3f 93       	push	r19
     224:	4f 93       	push	r20
     226:	5f 93       	push	r21
     228:	6f 93       	push	r22
     22a:	7f 93       	push	r23
     22c:	8f 93       	push	r24
     22e:	9f 93       	push	r25
     230:	af 93       	push	r26
     232:	bf 93       	push	r27
     234:	ef 93       	push	r30
     236:	ff 93       	push	r31
     238:	cf 93       	push	r28
     23a:	df 93       	push	r29
     23c:	1f 92       	push	r1
     23e:	cd b7       	in	r28, 0x3d	; 61
     240:	de b7       	in	r29, 0x3e	; 62
  char received = UDR0;
     242:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     246:	89 83       	std	Y+1, r24	; 0x01
  //if(uxQueueMessagesWaitingFromISR(rx_buffer) < 29) 
  xQueueSendFromISR(rx_buffer,&received,0);
     248:	20 e0       	ldi	r18, 0x00	; 0
     24a:	40 e0       	ldi	r20, 0x00	; 0
     24c:	50 e0       	ldi	r21, 0x00	; 0
     24e:	be 01       	movw	r22, r28
     250:	6f 5f       	subi	r22, 0xFF	; 255
     252:	7f 4f       	sbci	r23, 0xFF	; 255
     254:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <rx_buffer>
     258:	90 91 a1 07 	lds	r25, 0x07A1	; 0x8007a1 <rx_buffer+0x1>
     25c:	0e 94 ed 0a 	call	0x15da	; 0x15da <xQueueGenericSendFromISR>
  // BaseType_t checkIfYieldRequired;
  // checkIfYieldRequired = xTaskResumeFromISR(mainECHO);
  // taskYIELD_FROM_ISR(checkIfYieldRequired);
}
     260:	0f 90       	pop	r0
     262:	df 91       	pop	r29
     264:	cf 91       	pop	r28
     266:	ff 91       	pop	r31
     268:	ef 91       	pop	r30
     26a:	bf 91       	pop	r27
     26c:	af 91       	pop	r26
     26e:	9f 91       	pop	r25
     270:	8f 91       	pop	r24
     272:	7f 91       	pop	r23
     274:	6f 91       	pop	r22
     276:	5f 91       	pop	r21
     278:	4f 91       	pop	r20
     27a:	3f 91       	pop	r19
     27c:	2f 91       	pop	r18
     27e:	0f 90       	pop	r0
     280:	0f be       	out	0x3f, r0	; 63
     282:	0f 90       	pop	r0
     284:	1f 90       	pop	r1
     286:	18 95       	reti

00000288 <vApplicationIdleHook>:
    return 0;
}


void vApplicationIdleHook(void)
{
     288:	08 95       	ret

0000028a <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     28a:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <pxDelayedTaskList>
     28e:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     292:	80 81       	ld	r24, Z
     294:	81 11       	cpse	r24, r1
     296:	03 c0       	rjmp	.+6      	; 0x29e <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     298:	8f ef       	ldi	r24, 0xFF	; 255
     29a:	9f ef       	ldi	r25, 0xFF	; 255
     29c:	0c c0       	rjmp	.+24     	; 0x2b6 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     29e:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <pxDelayedTaskList>
     2a2:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     2a6:	05 80       	ldd	r0, Z+5	; 0x05
     2a8:	f6 81       	ldd	r31, Z+6	; 0x06
     2aa:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     2ac:	06 80       	ldd	r0, Z+6	; 0x06
     2ae:	f7 81       	ldd	r31, Z+7	; 0x07
     2b0:	e0 2d       	mov	r30, r0
     2b2:	82 81       	ldd	r24, Z+2	; 0x02
     2b4:	93 81       	ldd	r25, Z+3	; 0x03
     2b6:	90 93 26 01 	sts	0x0126, r25	; 0x800126 <xNextTaskUnblockTime+0x1>
     2ba:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <xNextTaskUnblockTime>
     2be:	08 95       	ret

000002c0 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     2c0:	ff 92       	push	r15
     2c2:	0f 93       	push	r16
     2c4:	1f 93       	push	r17
     2c6:	cf 93       	push	r28
     2c8:	df 93       	push	r29
     2ca:	ec 01       	movw	r28, r24
     2cc:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     2ce:	00 91 2d 01 	lds	r16, 0x012D	; 0x80012d <xTickCount>
     2d2:	10 91 2e 01 	lds	r17, 0x012E	; 0x80012e <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     2d6:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     2da:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     2de:	02 96       	adiw	r24, 0x02	; 2
     2e0:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     2e4:	cf 3f       	cpi	r28, 0xFF	; 255
     2e6:	8f ef       	ldi	r24, 0xFF	; 255
     2e8:	d8 07       	cpc	r29, r24
     2ea:	89 f4       	brne	.+34     	; 0x30e <prvAddCurrentTaskToDelayedList+0x4e>
     2ec:	ff 20       	and	r15, r15
     2ee:	79 f0       	breq	.+30     	; 0x30e <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2f0:	60 91 20 01 	lds	r22, 0x0120	; 0x800120 <__data_end>
     2f4:	70 91 21 01 	lds	r23, 0x0121	; 0x800121 <__data_end+0x1>
     2f8:	6e 5f       	subi	r22, 0xFE	; 254
     2fa:	7f 4f       	sbci	r23, 0xFF	; 255
     2fc:	80 e3       	ldi	r24, 0x30	; 48
     2fe:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     300:	df 91       	pop	r29
     302:	cf 91       	pop	r28
     304:	1f 91       	pop	r17
     306:	0f 91       	pop	r16
     308:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     30a:	0c 94 43 0e 	jmp	0x1c86	; 0x1c86 <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     30e:	c0 0f       	add	r28, r16
     310:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     312:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     316:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     31a:	d3 83       	std	Z+3, r29	; 0x03
     31c:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     31e:	60 91 20 01 	lds	r22, 0x0120	; 0x800120 <__data_end>
     322:	70 91 21 01 	lds	r23, 0x0121	; 0x800121 <__data_end+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     326:	c0 17       	cp	r28, r16
     328:	d1 07       	cpc	r29, r17
     32a:	68 f4       	brcc	.+26     	; 0x346 <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     32c:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <pxOverflowDelayedTaskList>
     330:	90 91 4d 01 	lds	r25, 0x014D	; 0x80014d <pxOverflowDelayedTaskList+0x1>
     334:	6e 5f       	subi	r22, 0xFE	; 254
     336:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     338:	df 91       	pop	r29
     33a:	cf 91       	pop	r28
     33c:	1f 91       	pop	r17
     33e:	0f 91       	pop	r16
     340:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     342:	0c 94 64 0e 	jmp	0x1cc8	; 0x1cc8 <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     346:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <pxDelayedTaskList>
     34a:	90 91 4f 01 	lds	r25, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     34e:	6e 5f       	subi	r22, 0xFE	; 254
     350:	7f 4f       	sbci	r23, 0xFF	; 255
     352:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     356:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <xNextTaskUnblockTime>
     35a:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <xNextTaskUnblockTime+0x1>
     35e:	c8 17       	cp	r28, r24
     360:	d9 07       	cpc	r29, r25
     362:	20 f4       	brcc	.+8      	; 0x36c <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     364:	d0 93 26 01 	sts	0x0126, r29	; 0x800126 <xNextTaskUnblockTime+0x1>
     368:	c0 93 25 01 	sts	0x0125, r28	; 0x800125 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     36c:	df 91       	pop	r29
     36e:	cf 91       	pop	r28
     370:	1f 91       	pop	r17
     372:	0f 91       	pop	r16
     374:	ff 90       	pop	r15
     376:	08 95       	ret

00000378 <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     378:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <uxDeletedTasksWaitingCleanUp>
     37c:	88 23       	and	r24, r24
     37e:	09 f1       	breq	.+66     	; 0x3c2 <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     380:	0f b6       	in	r0, 0x3f	; 63
     382:	f8 94       	cli
     384:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     386:	e0 91 3f 01 	lds	r30, 0x013F	; 0x80013f <xTasksWaitingTermination+0x5>
     38a:	f0 91 40 01 	lds	r31, 0x0140	; 0x800140 <xTasksWaitingTermination+0x6>
     38e:	c6 81       	ldd	r28, Z+6	; 0x06
     390:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     392:	ce 01       	movw	r24, r28
     394:	02 96       	adiw	r24, 0x02	; 2
     396:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
				--uxCurrentNumberOfTasks;
     39a:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     39e:	81 50       	subi	r24, 0x01	; 1
     3a0:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     3a4:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <uxDeletedTasksWaitingCleanUp>
     3a8:	81 50       	subi	r24, 0x01	; 1
     3aa:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     3ae:	0f 90       	pop	r0
     3b0:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     3b2:	8f 89       	ldd	r24, Y+23	; 0x17
     3b4:	98 8d       	ldd	r25, Y+24	; 0x18
     3b6:	0e 94 b8 10 	call	0x2170	; 0x2170 <vPortFree>
			vPortFree( pxTCB );
     3ba:	ce 01       	movw	r24, r28
     3bc:	0e 94 b8 10 	call	0x2170	; 0x2170 <vPortFree>
     3c0:	db cf       	rjmp	.-74     	; 0x378 <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     3c2:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <pxReadyTasksLists>
     3c6:	82 30       	cpi	r24, 0x02	; 2
     3c8:	10 f0       	brcs	.+4      	; 0x3ce <prvIdleTask+0x56>
			{
				taskYIELD();
     3ca:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     3ce:	0e 94 44 01 	call	0x288	; 0x288 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     3d2:	d2 cf       	rjmp	.-92     	; 0x378 <prvIdleTask>

000003d4 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     3d4:	3f 92       	push	r3
     3d6:	4f 92       	push	r4
     3d8:	5f 92       	push	r5
     3da:	6f 92       	push	r6
     3dc:	7f 92       	push	r7
     3de:	8f 92       	push	r8
     3e0:	9f 92       	push	r9
     3e2:	af 92       	push	r10
     3e4:	bf 92       	push	r11
     3e6:	cf 92       	push	r12
     3e8:	df 92       	push	r13
     3ea:	ef 92       	push	r14
     3ec:	ff 92       	push	r15
     3ee:	0f 93       	push	r16
     3f0:	1f 93       	push	r17
     3f2:	cf 93       	push	r28
     3f4:	df 93       	push	r29
     3f6:	4c 01       	movw	r8, r24
     3f8:	16 2f       	mov	r17, r22
     3fa:	37 2e       	mov	r3, r23
     3fc:	6a 01       	movw	r12, r20
     3fe:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     400:	ca 01       	movw	r24, r20
     402:	0e 94 86 10 	call	0x210c	; 0x210c <pvPortMalloc>
     406:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     408:	89 2b       	or	r24, r25
     40a:	09 f4       	brne	.+2      	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
     40c:	d1 c0       	rjmp	.+418    	; 0x5b0 <__EEPROM_REGION_LENGTH__+0x1b0>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     40e:	86 e2       	ldi	r24, 0x26	; 38
     410:	90 e0       	ldi	r25, 0x00	; 0
     412:	0e 94 86 10 	call	0x210c	; 0x210c <pvPortMalloc>
     416:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     418:	89 2b       	or	r24, r25
     41a:	79 f0       	breq	.+30     	; 0x43a <__EEPROM_REGION_LENGTH__+0x3a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     41c:	58 8e       	std	Y+24, r5	; 0x18
     41e:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     420:	c6 01       	movw	r24, r12
     422:	01 97       	sbiw	r24, 0x01	; 1
     424:	32 01       	movw	r6, r4
     426:	68 0e       	add	r6, r24
     428:	79 1e       	adc	r7, r25
     42a:	be 01       	movw	r22, r28
     42c:	67 5e       	subi	r22, 0xE7	; 231
     42e:	7f 4f       	sbci	r23, 0xFF	; 255
     430:	e1 2f       	mov	r30, r17
     432:	f3 2d       	mov	r31, r3
     434:	cf 01       	movw	r24, r30
     436:	08 96       	adiw	r24, 0x08	; 8
     438:	07 c0       	rjmp	.+14     	; 0x448 <__EEPROM_REGION_LENGTH__+0x48>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     43a:	c2 01       	movw	r24, r4
     43c:	0e 94 b8 10 	call	0x2170	; 0x2170 <vPortFree>
     440:	b7 c0       	rjmp	.+366    	; 0x5b0 <__EEPROM_REGION_LENGTH__+0x1b0>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     442:	e8 17       	cp	r30, r24
     444:	f9 07       	cpc	r31, r25
     446:	49 f0       	breq	.+18     	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>
     448:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     44a:	41 91       	ld	r20, Z+
     44c:	db 01       	movw	r26, r22
     44e:	4d 93       	st	X+, r20
     450:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     452:	d9 01       	movw	r26, r18
     454:	2c 91       	ld	r18, X
     456:	21 11       	cpse	r18, r1
     458:	f4 cf       	rjmp	.-24     	; 0x442 <__EEPROM_REGION_LENGTH__+0x42>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     45a:	18 a2       	std	Y+32, r1	; 0x20
     45c:	04 30       	cpi	r16, 0x04	; 4
     45e:	08 f0       	brcs	.+2      	; 0x462 <__EEPROM_REGION_LENGTH__+0x62>
     460:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     462:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     464:	6e 01       	movw	r12, r28
     466:	b2 e0       	ldi	r27, 0x02	; 2
     468:	cb 0e       	add	r12, r27
     46a:	d1 1c       	adc	r13, r1
     46c:	c6 01       	movw	r24, r12
     46e:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     472:	ce 01       	movw	r24, r28
     474:	0c 96       	adiw	r24, 0x0c	; 12
     476:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     47a:	d9 87       	std	Y+9, r29	; 0x09
     47c:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     47e:	84 e0       	ldi	r24, 0x04	; 4
     480:	90 e0       	ldi	r25, 0x00	; 0
     482:	80 1b       	sub	r24, r16
     484:	91 09       	sbc	r25, r1
     486:	9d 87       	std	Y+13, r25	; 0x0d
     488:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     48a:	db 8b       	std	Y+19, r29	; 0x13
     48c:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     48e:	19 a2       	std	Y+33, r1	; 0x21
     490:	1a a2       	std	Y+34, r1	; 0x22
     492:	1b a2       	std	Y+35, r1	; 0x23
     494:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     496:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     498:	a5 01       	movw	r20, r10
     49a:	b4 01       	movw	r22, r8
     49c:	c3 01       	movw	r24, r6
     49e:	0e 94 c7 10 	call	0x218e	; 0x218e <pxPortInitialiseStack>
     4a2:	99 83       	std	Y+1, r25	; 0x01
     4a4:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     4a6:	e1 14       	cp	r14, r1
     4a8:	f1 04       	cpc	r15, r1
     4aa:	19 f0       	breq	.+6      	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     4ac:	f7 01       	movw	r30, r14
     4ae:	d1 83       	std	Z+1, r29	; 0x01
     4b0:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     4b2:	0f b6       	in	r0, 0x3f	; 63
     4b4:	f8 94       	cli
     4b6:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     4b8:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     4bc:	8f 5f       	subi	r24, 0xFF	; 255
     4be:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     4c2:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     4c6:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     4ca:	89 2b       	or	r24, r25
     4cc:	d1 f5       	brne	.+116    	; 0x542 <__EEPROM_REGION_LENGTH__+0x142>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     4ce:	d0 93 21 01 	sts	0x0121, r29	; 0x800121 <__data_end+0x1>
     4d2:	c0 93 20 01 	sts	0x0120, r28	; 0x800120 <__data_end>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     4d6:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     4da:	81 30       	cpi	r24, 0x01	; 1
     4dc:	09 f0       	breq	.+2      	; 0x4e0 <__EEPROM_REGION_LENGTH__+0xe0>
     4de:	41 c0       	rjmp	.+130    	; 0x562 <__EEPROM_REGION_LENGTH__+0x162>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     4e0:	82 e6       	ldi	r24, 0x62	; 98
     4e2:	91 e0       	ldi	r25, 0x01	; 1
     4e4:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
     4e8:	8b e6       	ldi	r24, 0x6B	; 107
     4ea:	91 e0       	ldi	r25, 0x01	; 1
     4ec:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
     4f0:	84 e7       	ldi	r24, 0x74	; 116
     4f2:	91 e0       	ldi	r25, 0x01	; 1
     4f4:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
     4f8:	8d e7       	ldi	r24, 0x7D	; 125
     4fa:	91 e0       	ldi	r25, 0x01	; 1
     4fc:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     500:	89 e5       	ldi	r24, 0x59	; 89
     502:	91 e0       	ldi	r25, 0x01	; 1
     504:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     508:	80 e5       	ldi	r24, 0x50	; 80
     50a:	91 e0       	ldi	r25, 0x01	; 1
     50c:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     510:	83 e4       	ldi	r24, 0x43	; 67
     512:	91 e0       	ldi	r25, 0x01	; 1
     514:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     518:	8a e3       	ldi	r24, 0x3A	; 58
     51a:	91 e0       	ldi	r25, 0x01	; 1
     51c:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     520:	80 e3       	ldi	r24, 0x30	; 48
     522:	91 e0       	ldi	r25, 0x01	; 1
     524:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     528:	89 e5       	ldi	r24, 0x59	; 89
     52a:	91 e0       	ldi	r25, 0x01	; 1
     52c:	90 93 4f 01 	sts	0x014F, r25	; 0x80014f <pxDelayedTaskList+0x1>
     530:	80 93 4e 01 	sts	0x014E, r24	; 0x80014e <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     534:	80 e5       	ldi	r24, 0x50	; 80
     536:	91 e0       	ldi	r25, 0x01	; 1
     538:	90 93 4d 01 	sts	0x014D, r25	; 0x80014d <pxOverflowDelayedTaskList+0x1>
     53c:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <pxOverflowDelayedTaskList>
     540:	10 c0       	rjmp	.+32     	; 0x562 <__EEPROM_REGION_LENGTH__+0x162>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     542:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     546:	81 11       	cpse	r24, r1
     548:	0c c0       	rjmp	.+24     	; 0x562 <__EEPROM_REGION_LENGTH__+0x162>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     54a:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     54e:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     552:	96 89       	ldd	r25, Z+22	; 0x16
     554:	8e 89       	ldd	r24, Y+22	; 0x16
     556:	89 17       	cp	r24, r25
     558:	20 f0       	brcs	.+8      	; 0x562 <__EEPROM_REGION_LENGTH__+0x162>
				{
					pxCurrentTCB = pxNewTCB;
     55a:	d0 93 21 01 	sts	0x0121, r29	; 0x800121 <__data_end+0x1>
     55e:	c0 93 20 01 	sts	0x0120, r28	; 0x800120 <__data_end>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     562:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxTaskNumber>
     566:	8f 5f       	subi	r24, 0xFF	; 255
     568:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     56c:	8e 89       	ldd	r24, Y+22	; 0x16
     56e:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     572:	98 17       	cp	r25, r24
     574:	10 f4       	brcc	.+4      	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
     576:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     57a:	f9 e0       	ldi	r31, 0x09	; 9
     57c:	8f 9f       	mul	r24, r31
     57e:	c0 01       	movw	r24, r0
     580:	11 24       	eor	r1, r1
     582:	b6 01       	movw	r22, r12
     584:	8e 59       	subi	r24, 0x9E	; 158
     586:	9e 4f       	sbci	r25, 0xFE	; 254
     588:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     58c:	0f 90       	pop	r0
     58e:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     590:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     594:	88 23       	and	r24, r24
     596:	51 f0       	breq	.+20     	; 0x5ac <__EEPROM_REGION_LENGTH__+0x1ac>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     598:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     59c:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     5a0:	96 89       	ldd	r25, Z+22	; 0x16
     5a2:	8e 89       	ldd	r24, Y+22	; 0x16
     5a4:	98 17       	cp	r25, r24
     5a6:	10 f4       	brcc	.+4      	; 0x5ac <__EEPROM_REGION_LENGTH__+0x1ac>
		{
			taskYIELD_IF_USING_PREEMPTION();
     5a8:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	01 c0       	rjmp	.+2      	; 0x5b2 <__EEPROM_REGION_LENGTH__+0x1b2>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     5b0:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     5b2:	df 91       	pop	r29
     5b4:	cf 91       	pop	r28
     5b6:	1f 91       	pop	r17
     5b8:	0f 91       	pop	r16
     5ba:	ff 90       	pop	r15
     5bc:	ef 90       	pop	r14
     5be:	df 90       	pop	r13
     5c0:	cf 90       	pop	r12
     5c2:	bf 90       	pop	r11
     5c4:	af 90       	pop	r10
     5c6:	9f 90       	pop	r9
     5c8:	8f 90       	pop	r8
     5ca:	7f 90       	pop	r7
     5cc:	6f 90       	pop	r6
     5ce:	5f 90       	pop	r5
     5d0:	4f 90       	pop	r4
     5d2:	3f 90       	pop	r3
     5d4:	08 95       	ret

000005d6 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     5d6:	0f 93       	push	r16
     5d8:	1f 93       	push	r17
     5da:	cf 93       	push	r28
     5dc:	df 93       	push	r29
     5de:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     5e0:	0f b6       	in	r0, 0x3f	; 63
     5e2:	f8 94       	cli
     5e4:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     5e6:	89 2b       	or	r24, r25
     5e8:	21 f4       	brne	.+8      	; 0x5f2 <vTaskDelete+0x1c>
     5ea:	c0 91 20 01 	lds	r28, 0x0120	; 0x800120 <__data_end>
     5ee:	d0 91 21 01 	lds	r29, 0x0121	; 0x800121 <__data_end+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     5f2:	8e 01       	movw	r16, r28
     5f4:	0e 5f       	subi	r16, 0xFE	; 254
     5f6:	1f 4f       	sbci	r17, 0xFF	; 255
     5f8:	c8 01       	movw	r24, r16
     5fa:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     5fe:	8c 89       	ldd	r24, Y+20	; 0x14
     600:	9d 89       	ldd	r25, Y+21	; 0x15
     602:	89 2b       	or	r24, r25
     604:	21 f0       	breq	.+8      	; 0x60e <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     606:	ce 01       	movw	r24, r28
     608:	0c 96       	adiw	r24, 0x0c	; 12
     60a:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     60e:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <uxTaskNumber>
     612:	8f 5f       	subi	r24, 0xFF	; 255
     614:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     618:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     61c:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     620:	c8 17       	cp	r28, r24
     622:	d9 07       	cpc	r29, r25
     624:	59 f4       	brne	.+22     	; 0x63c <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     626:	b8 01       	movw	r22, r16
     628:	8a e3       	ldi	r24, 0x3A	; 58
     62a:	91 e0       	ldi	r25, 0x01	; 1
     62c:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     630:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <uxDeletedTasksWaitingCleanUp>
     634:	8f 5f       	subi	r24, 0xFF	; 255
     636:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <uxDeletedTasksWaitingCleanUp>
     63a:	0e c0       	rjmp	.+28     	; 0x658 <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     63c:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     640:	81 50       	subi	r24, 0x01	; 1
     642:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     646:	8f 89       	ldd	r24, Y+23	; 0x17
     648:	98 8d       	ldd	r25, Y+24	; 0x18
     64a:	0e 94 b8 10 	call	0x2170	; 0x2170 <vPortFree>
			vPortFree( pxTCB );
     64e:	ce 01       	movw	r24, r28
     650:	0e 94 b8 10 	call	0x2170	; 0x2170 <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     654:	0e 94 45 01 	call	0x28a	; 0x28a <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     658:	0f 90       	pop	r0
     65a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     65c:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     660:	88 23       	and	r24, r24
     662:	49 f0       	breq	.+18     	; 0x676 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     664:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     668:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     66c:	c8 17       	cp	r28, r24
     66e:	d9 07       	cpc	r29, r25
     670:	11 f4       	brne	.+4      	; 0x676 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     672:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     676:	df 91       	pop	r29
     678:	cf 91       	pop	r28
     67a:	1f 91       	pop	r17
     67c:	0f 91       	pop	r16
     67e:	08 95       	ret

00000680 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     680:	0f 93       	push	r16
     682:	1f 93       	push	r17
     684:	cf 93       	push	r28
     686:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     688:	20 91 20 01 	lds	r18, 0x0120	; 0x800120 <__data_end>
     68c:	30 91 21 01 	lds	r19, 0x0121	; 0x800121 <__data_end+0x1>
     690:	82 17       	cp	r24, r18
     692:	93 07       	cpc	r25, r19
     694:	b9 f1       	breq	.+110    	; 0x704 <vTaskResume+0x84>
     696:	00 97       	sbiw	r24, 0x00	; 0
     698:	a9 f1       	breq	.+106    	; 0x704 <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     69a:	0f b6       	in	r0, 0x3f	; 63
     69c:	f8 94       	cli
     69e:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     6a0:	fc 01       	movw	r30, r24
     6a2:	22 85       	ldd	r18, Z+10	; 0x0a
     6a4:	33 85       	ldd	r19, Z+11	; 0x0b
     6a6:	20 53       	subi	r18, 0x30	; 48
     6a8:	31 40       	sbci	r19, 0x01	; 1
     6aa:	51 f5       	brne	.+84     	; 0x700 <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     6ac:	fc 01       	movw	r30, r24
     6ae:	24 89       	ldd	r18, Z+20	; 0x14
     6b0:	35 89       	ldd	r19, Z+21	; 0x15
     6b2:	f1 e0       	ldi	r31, 0x01	; 1
     6b4:	23 34       	cpi	r18, 0x43	; 67
     6b6:	3f 07       	cpc	r19, r31
     6b8:	19 f1       	breq	.+70     	; 0x700 <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     6ba:	23 2b       	or	r18, r19
     6bc:	09 f5       	brne	.+66     	; 0x700 <vTaskResume+0x80>
     6be:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     6c0:	8c 01       	movw	r16, r24
     6c2:	0e 5f       	subi	r16, 0xFE	; 254
     6c4:	1f 4f       	sbci	r17, 0xFF	; 255
     6c6:	c8 01       	movw	r24, r16
     6c8:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     6cc:	8e 89       	ldd	r24, Y+22	; 0x16
     6ce:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     6d2:	98 17       	cp	r25, r24
     6d4:	10 f4       	brcc	.+4      	; 0x6da <vTaskResume+0x5a>
     6d6:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     6da:	29 e0       	ldi	r18, 0x09	; 9
     6dc:	82 9f       	mul	r24, r18
     6de:	c0 01       	movw	r24, r0
     6e0:	11 24       	eor	r1, r1
     6e2:	b8 01       	movw	r22, r16
     6e4:	8e 59       	subi	r24, 0x9E	; 158
     6e6:	9e 4f       	sbci	r25, 0xFE	; 254
     6e8:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     6ec:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     6f0:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     6f4:	9e 89       	ldd	r25, Y+22	; 0x16
     6f6:	86 89       	ldd	r24, Z+22	; 0x16
     6f8:	98 17       	cp	r25, r24
     6fa:	10 f0       	brcs	.+4      	; 0x700 <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     6fc:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     700:	0f 90       	pop	r0
     702:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     704:	df 91       	pop	r29
     706:	cf 91       	pop	r28
     708:	1f 91       	pop	r17
     70a:	0f 91       	pop	r16
     70c:	08 95       	ret

0000070e <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     70e:	ef 92       	push	r14
     710:	ff 92       	push	r15
     712:	1f 93       	push	r17
     714:	cf 93       	push	r28
     716:	df 93       	push	r29
     718:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     71a:	8a 85       	ldd	r24, Y+10	; 0x0a
     71c:	9b 85       	ldd	r25, Y+11	; 0x0b
     71e:	80 53       	subi	r24, 0x30	; 48
     720:	91 40       	sbci	r25, 0x01	; 1
     722:	99 f4       	brne	.+38     	; 0x74a <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     724:	8c 89       	ldd	r24, Y+20	; 0x14
     726:	9d 89       	ldd	r25, Y+21	; 0x15
     728:	21 e0       	ldi	r18, 0x01	; 1
     72a:	83 34       	cpi	r24, 0x43	; 67
     72c:	92 07       	cpc	r25, r18
     72e:	69 f0       	breq	.+26     	; 0x74a <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     730:	89 2b       	or	r24, r25
     732:	59 f4       	brne	.+22     	; 0x74a <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     734:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     738:	88 23       	and	r24, r24
     73a:	49 f0       	breq	.+18     	; 0x74e <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     73c:	be 01       	movw	r22, r28
     73e:	64 5f       	subi	r22, 0xF4	; 244
     740:	7f 4f       	sbci	r23, 0xFF	; 255
     742:	83 e4       	ldi	r24, 0x43	; 67
     744:	91 e0       	ldi	r25, 0x01	; 1
     746:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     74a:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     74c:	21 c0       	rjmp	.+66     	; 0x790 <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     74e:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     752:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     756:	11 e0       	ldi	r17, 0x01	; 1
     758:	9e 89       	ldd	r25, Y+22	; 0x16
     75a:	86 89       	ldd	r24, Z+22	; 0x16
     75c:	98 17       	cp	r25, r24
     75e:	08 f4       	brcc	.+2      	; 0x762 <xTaskResumeFromISR+0x54>
     760:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     762:	7e 01       	movw	r14, r28
     764:	82 e0       	ldi	r24, 0x02	; 2
     766:	e8 0e       	add	r14, r24
     768:	f1 1c       	adc	r15, r1
     76a:	c7 01       	movw	r24, r14
     76c:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     770:	8e 89       	ldd	r24, Y+22	; 0x16
     772:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     776:	98 17       	cp	r25, r24
     778:	10 f4       	brcc	.+4      	; 0x77e <xTaskResumeFromISR+0x70>
     77a:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     77e:	29 e0       	ldi	r18, 0x09	; 9
     780:	82 9f       	mul	r24, r18
     782:	c0 01       	movw	r24, r0
     784:	11 24       	eor	r1, r1
     786:	b7 01       	movw	r22, r14
     788:	8e 59       	subi	r24, 0x9E	; 158
     78a:	9e 4f       	sbci	r25, 0xFE	; 254
     78c:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     790:	81 2f       	mov	r24, r17
     792:	df 91       	pop	r29
     794:	cf 91       	pop	r28
     796:	1f 91       	pop	r17
     798:	ff 90       	pop	r15
     79a:	ef 90       	pop	r14
     79c:	08 95       	ret

0000079e <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     79e:	ef 92       	push	r14
     7a0:	ff 92       	push	r15
     7a2:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     7a4:	83 e2       	ldi	r24, 0x23	; 35
     7a6:	e8 2e       	mov	r14, r24
     7a8:	81 e0       	ldi	r24, 0x01	; 1
     7aa:	f8 2e       	mov	r15, r24
     7ac:	00 e0       	ldi	r16, 0x00	; 0
     7ae:	20 e0       	ldi	r18, 0x00	; 0
     7b0:	30 e0       	ldi	r19, 0x00	; 0
     7b2:	45 e5       	ldi	r20, 0x55	; 85
     7b4:	50 e0       	ldi	r21, 0x00	; 0
     7b6:	6b e1       	ldi	r22, 0x1B	; 27
     7b8:	71 e0       	ldi	r23, 0x01	; 1
     7ba:	8c eb       	ldi	r24, 0xBC	; 188
     7bc:	91 e0       	ldi	r25, 0x01	; 1
     7be:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     7c2:	81 30       	cpi	r24, 0x01	; 1
     7c4:	91 f4       	brne	.+36     	; 0x7ea <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     7c6:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     7c8:	2f ef       	ldi	r18, 0xFF	; 255
     7ca:	3f ef       	ldi	r19, 0xFF	; 255
     7cc:	30 93 26 01 	sts	0x0126, r19	; 0x800126 <xNextTaskUnblockTime+0x1>
     7d0:	20 93 25 01 	sts	0x0125, r18	; 0x800125 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     7d4:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     7d8:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <xTickCount+0x1>
     7dc:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     7e0:	0f 91       	pop	r16
     7e2:	ff 90       	pop	r15
     7e4:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     7e6:	0c 94 33 11 	jmp	0x2266	; 0x2266 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     7ea:	0f 91       	pop	r16
     7ec:	ff 90       	pop	r15
     7ee:	ef 90       	pop	r14
     7f0:	08 95       	ret

000007f2 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     7f2:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     7f4:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <xSchedulerRunning>
	vPortEndScheduler();
     7f8:	0c 94 73 11 	jmp	0x22e6	; 0x22e6 <vPortEndScheduler>

000007fc <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     7fc:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     800:	8f 5f       	subi	r24, 0xFF	; 255
     802:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <uxSchedulerSuspended>
     806:	08 95       	ret

00000808 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     808:	0f b6       	in	r0, 0x3f	; 63
     80a:	f8 94       	cli
     80c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     80e:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <xTickCount>
     812:	90 91 2e 01 	lds	r25, 0x012E	; 0x80012e <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     816:	0f 90       	pop	r0
     818:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     81a:	08 95       	ret

0000081c <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     81c:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <xTickCount>
     820:	90 91 2e 01 	lds	r25, 0x012E	; 0x80012e <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     824:	08 95       	ret

00000826 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     826:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
}
     82a:	08 95       	ret

0000082c <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     82c:	00 97       	sbiw	r24, 0x00	; 0
     82e:	21 f4       	brne	.+8      	; 0x838 <pcTaskGetName+0xc>
     830:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     834:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     838:	49 96       	adiw	r24, 0x19	; 25
     83a:	08 95       	ret

0000083c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     83c:	cf 92       	push	r12
     83e:	df 92       	push	r13
     840:	ef 92       	push	r14
     842:	ff 92       	push	r15
     844:	0f 93       	push	r16
     846:	1f 93       	push	r17
     848:	cf 93       	push	r28
     84a:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     84c:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     850:	81 11       	cpse	r24, r1
     852:	8c c0       	rjmp	.+280    	; 0x96c <__stack+0x6d>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     854:	00 91 2d 01 	lds	r16, 0x012D	; 0x80012d <xTickCount>
     858:	10 91 2e 01 	lds	r17, 0x012E	; 0x80012e <xTickCount+0x1>
     85c:	0f 5f       	subi	r16, 0xFF	; 255
     85e:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     860:	10 93 2e 01 	sts	0x012E, r17	; 0x80012e <xTickCount+0x1>
     864:	00 93 2d 01 	sts	0x012D, r16	; 0x80012d <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     868:	01 15       	cp	r16, r1
     86a:	11 05       	cpc	r17, r1
     86c:	b9 f4       	brne	.+46     	; 0x89c <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     86e:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <pxDelayedTaskList>
     872:	90 91 4f 01 	lds	r25, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     876:	20 91 4c 01 	lds	r18, 0x014C	; 0x80014c <pxOverflowDelayedTaskList>
     87a:	30 91 4d 01 	lds	r19, 0x014D	; 0x80014d <pxOverflowDelayedTaskList+0x1>
     87e:	30 93 4f 01 	sts	0x014F, r19	; 0x80014f <pxDelayedTaskList+0x1>
     882:	20 93 4e 01 	sts	0x014E, r18	; 0x80014e <pxDelayedTaskList>
     886:	90 93 4d 01 	sts	0x014D, r25	; 0x80014d <pxOverflowDelayedTaskList+0x1>
     88a:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <pxOverflowDelayedTaskList>
     88e:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <xNumOfOverflows>
     892:	8f 5f       	subi	r24, 0xFF	; 255
     894:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <xNumOfOverflows>
     898:	0e 94 45 01 	call	0x28a	; 0x28a <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     89c:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <xNextTaskUnblockTime>
     8a0:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <xNextTaskUnblockTime+0x1>
     8a4:	c0 e0       	ldi	r28, 0x00	; 0
     8a6:	08 17       	cp	r16, r24
     8a8:	19 07       	cpc	r17, r25
     8aa:	08 f4       	brcc	.+2      	; 0x8ae <xTaskIncrementTick+0x72>
     8ac:	4f c0       	rjmp	.+158    	; 0x94c <__stack+0x4d>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     8ae:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     8b0:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <pxDelayedTaskList>
     8b4:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     8b8:	80 81       	ld	r24, Z
     8ba:	81 11       	cpse	r24, r1
     8bc:	03 c0       	rjmp	.+6      	; 0x8c4 <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     8be:	8f ef       	ldi	r24, 0xFF	; 255
     8c0:	9f ef       	ldi	r25, 0xFF	; 255
     8c2:	11 c0       	rjmp	.+34     	; 0x8e6 <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     8c4:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <pxDelayedTaskList>
     8c8:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <pxDelayedTaskList+0x1>
     8cc:	05 80       	ldd	r0, Z+5	; 0x05
     8ce:	f6 81       	ldd	r31, Z+6	; 0x06
     8d0:	e0 2d       	mov	r30, r0
     8d2:	e6 80       	ldd	r14, Z+6	; 0x06
     8d4:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     8d6:	d7 01       	movw	r26, r14
     8d8:	12 96       	adiw	r26, 0x02	; 2
     8da:	8d 91       	ld	r24, X+
     8dc:	9c 91       	ld	r25, X
     8de:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     8e0:	08 17       	cp	r16, r24
     8e2:	19 07       	cpc	r17, r25
     8e4:	28 f4       	brcc	.+10     	; 0x8f0 <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     8e6:	90 93 26 01 	sts	0x0126, r25	; 0x800126 <xNextTaskUnblockTime+0x1>
     8ea:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     8ee:	2e c0       	rjmp	.+92     	; 0x94c <__stack+0x4d>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     8f0:	67 01       	movw	r12, r14
     8f2:	b2 e0       	ldi	r27, 0x02	; 2
     8f4:	cb 0e       	add	r12, r27
     8f6:	d1 1c       	adc	r13, r1
     8f8:	c6 01       	movw	r24, r12
     8fa:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     8fe:	f7 01       	movw	r30, r14
     900:	84 89       	ldd	r24, Z+20	; 0x14
     902:	95 89       	ldd	r25, Z+21	; 0x15
     904:	89 2b       	or	r24, r25
     906:	21 f0       	breq	.+8      	; 0x910 <__stack+0x11>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     908:	c7 01       	movw	r24, r14
     90a:	0c 96       	adiw	r24, 0x0c	; 12
     90c:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     910:	d7 01       	movw	r26, r14
     912:	56 96       	adiw	r26, 0x16	; 22
     914:	8c 91       	ld	r24, X
     916:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     91a:	98 17       	cp	r25, r24
     91c:	10 f4       	brcc	.+4      	; 0x922 <__stack+0x23>
     91e:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     922:	d8 9f       	mul	r29, r24
     924:	c0 01       	movw	r24, r0
     926:	11 24       	eor	r1, r1
     928:	b6 01       	movw	r22, r12
     92a:	8e 59       	subi	r24, 0x9E	; 158
     92c:	9e 4f       	sbci	r25, 0xFE	; 254
     92e:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     932:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     936:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     93a:	d7 01       	movw	r26, r14
     93c:	56 96       	adiw	r26, 0x16	; 22
     93e:	9c 91       	ld	r25, X
     940:	86 89       	ldd	r24, Z+22	; 0x16
     942:	98 17       	cp	r25, r24
     944:	08 f4       	brcc	.+2      	; 0x948 <__stack+0x49>
     946:	b4 cf       	rjmp	.-152    	; 0x8b0 <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     948:	c1 e0       	ldi	r28, 0x01	; 1
     94a:	b2 cf       	rjmp	.-156    	; 0x8b0 <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     94c:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     950:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     954:	e6 89       	ldd	r30, Z+22	; 0x16
     956:	b9 e0       	ldi	r27, 0x09	; 9
     958:	eb 9f       	mul	r30, r27
     95a:	f0 01       	movw	r30, r0
     95c:	11 24       	eor	r1, r1
     95e:	ee 59       	subi	r30, 0x9E	; 158
     960:	fe 4f       	sbci	r31, 0xFE	; 254
     962:	80 81       	ld	r24, Z
     964:	82 30       	cpi	r24, 0x02	; 2
     966:	40 f0       	brcs	.+16     	; 0x978 <__stack+0x79>
			{
				xSwitchRequired = pdTRUE;
     968:	c1 e0       	ldi	r28, 0x01	; 1
     96a:	06 c0       	rjmp	.+12     	; 0x978 <__stack+0x79>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     96c:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <uxPendedTicks>
     970:	8f 5f       	subi	r24, 0xFF	; 255
     972:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     976:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     978:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <xYieldPending>
     97c:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     97e:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     980:	8c 2f       	mov	r24, r28
     982:	df 91       	pop	r29
     984:	cf 91       	pop	r28
     986:	1f 91       	pop	r17
     988:	0f 91       	pop	r16
     98a:	ff 90       	pop	r15
     98c:	ef 90       	pop	r14
     98e:	df 90       	pop	r13
     990:	cf 90       	pop	r12
     992:	08 95       	ret

00000994 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     994:	ef 92       	push	r14
     996:	ff 92       	push	r15
     998:	0f 93       	push	r16
     99a:	1f 93       	push	r17
     99c:	cf 93       	push	r28
     99e:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     9a0:	0f b6       	in	r0, 0x3f	; 63
     9a2:	f8 94       	cli
     9a4:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     9a6:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     9aa:	81 50       	subi	r24, 0x01	; 1
     9ac:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     9b0:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     9b4:	88 23       	and	r24, r24
     9b6:	11 f0       	breq	.+4      	; 0x9bc <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     9b8:	80 e0       	ldi	r24, 0x00	; 0
     9ba:	52 c0       	rjmp	.+164    	; 0xa60 <xTaskResumeAll+0xcc>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     9bc:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     9c0:	88 23       	and	r24, r24
     9c2:	d1 f3       	breq	.-12     	; 0x9b8 <xTaskResumeAll+0x24>
     9c4:	c0 e0       	ldi	r28, 0x00	; 0
     9c6:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     9c8:	89 e0       	ldi	r24, 0x09	; 9
     9ca:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     9cc:	ee 24       	eor	r14, r14
     9ce:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     9d0:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <xPendingReadyList>
     9d4:	88 23       	and	r24, r24
     9d6:	51 f1       	breq	.+84     	; 0xa2c <xTaskResumeAll+0x98>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     9d8:	e0 91 48 01 	lds	r30, 0x0148	; 0x800148 <xPendingReadyList+0x5>
     9dc:	f0 91 49 01 	lds	r31, 0x0149	; 0x800149 <xPendingReadyList+0x6>
     9e0:	c6 81       	ldd	r28, Z+6	; 0x06
     9e2:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     9e4:	ce 01       	movw	r24, r28
     9e6:	0c 96       	adiw	r24, 0x0c	; 12
     9e8:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     9ec:	8e 01       	movw	r16, r28
     9ee:	0e 5f       	subi	r16, 0xFE	; 254
     9f0:	1f 4f       	sbci	r17, 0xFF	; 255
     9f2:	c8 01       	movw	r24, r16
     9f4:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     9f8:	8e 89       	ldd	r24, Y+22	; 0x16
     9fa:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     9fe:	98 17       	cp	r25, r24
     a00:	10 f4       	brcc	.+4      	; 0xa06 <xTaskResumeAll+0x72>
     a02:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     a06:	f8 9e       	mul	r15, r24
     a08:	c0 01       	movw	r24, r0
     a0a:	11 24       	eor	r1, r1
     a0c:	b8 01       	movw	r22, r16
     a0e:	8e 59       	subi	r24, 0x9E	; 158
     a10:	9e 4f       	sbci	r25, 0xFE	; 254
     a12:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     a16:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     a1a:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     a1e:	9e 89       	ldd	r25, Y+22	; 0x16
     a20:	86 89       	ldd	r24, Z+22	; 0x16
     a22:	98 17       	cp	r25, r24
     a24:	a8 f2       	brcs	.-86     	; 0x9d0 <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     a26:	e0 92 29 01 	sts	0x0129, r14	; 0x800129 <xYieldPending>
     a2a:	d2 cf       	rjmp	.-92     	; 0x9d0 <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     a2c:	cd 2b       	or	r28, r29
     a2e:	11 f0       	breq	.+4      	; 0xa34 <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     a30:	0e 94 45 01 	call	0x28a	; 0x28a <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     a34:	c0 91 2a 01 	lds	r28, 0x012A	; 0x80012a <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     a38:	cc 23       	and	r28, r28
     a3a:	51 f0       	breq	.+20     	; 0xa50 <xTaskResumeAll+0xbc>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     a3c:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     a3e:	0e 94 1e 04 	call	0x83c	; 0x83c <xTaskIncrementTick>
     a42:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     a44:	d0 93 29 01 	sts	0x0129, r29	; 0x800129 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     a48:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     a4a:	c9 f7       	brne	.-14     	; 0xa3e <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     a4c:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     a50:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <xYieldPending>
     a54:	88 23       	and	r24, r24
     a56:	09 f4       	brne	.+2      	; 0xa5a <xTaskResumeAll+0xc6>
     a58:	af cf       	rjmp	.-162    	; 0x9b8 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     a5a:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     a5e:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     a60:	0f 90       	pop	r0
     a62:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     a64:	df 91       	pop	r29
     a66:	cf 91       	pop	r28
     a68:	1f 91       	pop	r17
     a6a:	0f 91       	pop	r16
     a6c:	ff 90       	pop	r15
     a6e:	ef 90       	pop	r14
     a70:	08 95       	ret

00000a72 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     a72:	0f 93       	push	r16
     a74:	1f 93       	push	r17
     a76:	cf 93       	push	r28
     a78:	df 93       	push	r29
     a7a:	8c 01       	movw	r16, r24
     a7c:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     a7e:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     a82:	40 91 2d 01 	lds	r20, 0x012D	; 0x80012d <xTickCount>
     a86:	50 91 2e 01 	lds	r21, 0x012E	; 0x80012e <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     a8a:	f8 01       	movw	r30, r16
     a8c:	20 81       	ld	r18, Z
     a8e:	31 81       	ldd	r19, Z+1	; 0x01
     a90:	c9 01       	movw	r24, r18
     a92:	8c 0f       	add	r24, r28
     a94:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     a96:	42 17       	cp	r20, r18
     a98:	53 07       	cpc	r21, r19
     a9a:	20 f4       	brcc	.+8      	; 0xaa4 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     a9c:	82 17       	cp	r24, r18
     a9e:	93 07       	cpc	r25, r19
     aa0:	40 f4       	brcc	.+16     	; 0xab2 <vTaskDelayUntil+0x40>
     aa2:	03 c0       	rjmp	.+6      	; 0xaaa <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     aa4:	82 17       	cp	r24, r18
     aa6:	93 07       	cpc	r25, r19
     aa8:	30 f0       	brcs	.+12     	; 0xab6 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     aaa:	21 e0       	ldi	r18, 0x01	; 1
     aac:	48 17       	cp	r20, r24
     aae:	59 07       	cpc	r21, r25
     ab0:	18 f0       	brcs	.+6      	; 0xab8 <vTaskDelayUntil+0x46>
     ab2:	20 e0       	ldi	r18, 0x00	; 0
     ab4:	01 c0       	rjmp	.+2      	; 0xab8 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     ab6:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     ab8:	f8 01       	movw	r30, r16
     aba:	91 83       	std	Z+1, r25	; 0x01
     abc:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     abe:	22 23       	and	r18, r18
     ac0:	29 f0       	breq	.+10     	; 0xacc <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     ac2:	60 e0       	ldi	r22, 0x00	; 0
     ac4:	84 1b       	sub	r24, r20
     ac6:	95 0b       	sbc	r25, r21
     ac8:	0e 94 60 01 	call	0x2c0	; 0x2c0 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     acc:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     ad0:	81 11       	cpse	r24, r1
     ad2:	02 c0       	rjmp	.+4      	; 0xad8 <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     ad4:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     ad8:	df 91       	pop	r29
     ada:	cf 91       	pop	r28
     adc:	1f 91       	pop	r17
     ade:	0f 91       	pop	r16
     ae0:	08 95       	ret

00000ae2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     ae2:	cf 93       	push	r28
     ae4:	df 93       	push	r29
     ae6:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     ae8:	89 2b       	or	r24, r25
     aea:	19 f4       	brne	.+6      	; 0xaf2 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     aec:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
     af0:	0a c0       	rjmp	.+20     	; 0xb06 <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     af2:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     af6:	60 e0       	ldi	r22, 0x00	; 0
     af8:	ce 01       	movw	r24, r28
     afa:	0e 94 60 01 	call	0x2c0	; 0x2c0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     afe:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     b02:	88 23       	and	r24, r24
     b04:	99 f3       	breq	.-26     	; 0xaec <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b06:	df 91       	pop	r29
     b08:	cf 91       	pop	r28
     b0a:	08 95       	ret

00000b0c <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     b0c:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     b10:	88 23       	and	r24, r24
     b12:	21 f0       	breq	.+8      	; 0xb1c <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     b14:	81 e0       	ldi	r24, 0x01	; 1
     b16:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
     b1a:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     b1c:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     b20:	80 91 2c 01 	lds	r24, 0x012C	; 0x80012c <uxTopReadyPriority>
     b24:	69 e0       	ldi	r22, 0x09	; 9
     b26:	48 2f       	mov	r20, r24
     b28:	50 e0       	ldi	r21, 0x00	; 0
     b2a:	64 9f       	mul	r22, r20
     b2c:	90 01       	movw	r18, r0
     b2e:	65 9f       	mul	r22, r21
     b30:	30 0d       	add	r19, r0
     b32:	11 24       	eor	r1, r1
     b34:	f9 01       	movw	r30, r18
     b36:	ee 59       	subi	r30, 0x9E	; 158
     b38:	fe 4f       	sbci	r31, 0xFE	; 254
     b3a:	90 81       	ld	r25, Z
     b3c:	91 11       	cpse	r25, r1
     b3e:	02 c0       	rjmp	.+4      	; 0xb44 <vTaskSwitchContext+0x38>
     b40:	81 50       	subi	r24, 0x01	; 1
     b42:	f1 cf       	rjmp	.-30     	; 0xb26 <vTaskSwitchContext+0x1a>
     b44:	a1 81       	ldd	r26, Z+1	; 0x01
     b46:	b2 81       	ldd	r27, Z+2	; 0x02
     b48:	12 96       	adiw	r26, 0x02	; 2
     b4a:	0d 90       	ld	r0, X+
     b4c:	bc 91       	ld	r27, X
     b4e:	a0 2d       	mov	r26, r0
     b50:	b2 83       	std	Z+2, r27	; 0x02
     b52:	a1 83       	std	Z+1, r26	; 0x01
     b54:	2b 59       	subi	r18, 0x9B	; 155
     b56:	3e 4f       	sbci	r19, 0xFE	; 254
     b58:	a2 17       	cp	r26, r18
     b5a:	b3 07       	cpc	r27, r19
     b5c:	31 f4       	brne	.+12     	; 0xb6a <vTaskSwitchContext+0x5e>
     b5e:	12 96       	adiw	r26, 0x02	; 2
     b60:	2d 91       	ld	r18, X+
     b62:	3c 91       	ld	r19, X
     b64:	13 97       	sbiw	r26, 0x03	; 3
     b66:	32 83       	std	Z+2, r19	; 0x02
     b68:	21 83       	std	Z+1, r18	; 0x01
     b6a:	99 e0       	ldi	r25, 0x09	; 9
     b6c:	94 9f       	mul	r25, r20
     b6e:	f0 01       	movw	r30, r0
     b70:	95 9f       	mul	r25, r21
     b72:	f0 0d       	add	r31, r0
     b74:	11 24       	eor	r1, r1
     b76:	ee 59       	subi	r30, 0x9E	; 158
     b78:	fe 4f       	sbci	r31, 0xFE	; 254
     b7a:	01 80       	ldd	r0, Z+1	; 0x01
     b7c:	f2 81       	ldd	r31, Z+2	; 0x02
     b7e:	e0 2d       	mov	r30, r0
     b80:	26 81       	ldd	r18, Z+6	; 0x06
     b82:	37 81       	ldd	r19, Z+7	; 0x07
     b84:	30 93 21 01 	sts	0x0121, r19	; 0x800121 <__data_end+0x1>
     b88:	20 93 20 01 	sts	0x0120, r18	; 0x800120 <__data_end>
     b8c:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     b90:	08 95       	ret

00000b92 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     b92:	0f 93       	push	r16
     b94:	1f 93       	push	r17
     b96:	cf 93       	push	r28
     b98:	df 93       	push	r29
     b9a:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     b9c:	0f b6       	in	r0, 0x3f	; 63
     b9e:	f8 94       	cli
     ba0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     ba2:	89 2b       	or	r24, r25
     ba4:	21 f4       	brne	.+8      	; 0xbae <vTaskSuspend+0x1c>
     ba6:	c0 91 20 01 	lds	r28, 0x0120	; 0x800120 <__data_end>
     baa:	d0 91 21 01 	lds	r29, 0x0121	; 0x800121 <__data_end+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     bae:	8e 01       	movw	r16, r28
     bb0:	0e 5f       	subi	r16, 0xFE	; 254
     bb2:	1f 4f       	sbci	r17, 0xFF	; 255
     bb4:	c8 01       	movw	r24, r16
     bb6:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     bba:	8c 89       	ldd	r24, Y+20	; 0x14
     bbc:	9d 89       	ldd	r25, Y+21	; 0x15
     bbe:	89 2b       	or	r24, r25
     bc0:	21 f0       	breq	.+8      	; 0xbca <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     bc2:	ce 01       	movw	r24, r28
     bc4:	0c 96       	adiw	r24, 0x0c	; 12
     bc6:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     bca:	b8 01       	movw	r22, r16
     bcc:	80 e3       	ldi	r24, 0x30	; 48
     bce:	91 e0       	ldi	r25, 0x01	; 1
     bd0:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     bd4:	8d a1       	ldd	r24, Y+37	; 0x25
     bd6:	81 30       	cpi	r24, 0x01	; 1
     bd8:	09 f4       	brne	.+2      	; 0xbdc <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     bda:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     bdc:	0f 90       	pop	r0
     bde:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     be0:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     be4:	88 23       	and	r24, r24
     be6:	39 f0       	breq	.+14     	; 0xbf6 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     be8:	0f b6       	in	r0, 0x3f	; 63
     bea:	f8 94       	cli
     bec:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     bee:	0e 94 45 01 	call	0x28a	; 0x28a <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     bf2:	0f 90       	pop	r0
     bf4:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     bf6:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
     bfa:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
     bfe:	c8 17       	cp	r28, r24
     c00:	d9 07       	cpc	r29, r25
     c02:	c1 f4       	brne	.+48     	; 0xc34 <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     c04:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xSchedulerRunning>
     c08:	88 23       	and	r24, r24
     c0a:	19 f0       	breq	.+6      	; 0xc12 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     c0c:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
     c10:	11 c0       	rjmp	.+34     	; 0xc34 <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     c12:	90 91 30 01 	lds	r25, 0x0130	; 0x800130 <xSuspendedTaskList>
     c16:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <uxCurrentNumberOfTasks>
     c1a:	98 13       	cpse	r25, r24
     c1c:	05 c0       	rjmp	.+10     	; 0xc28 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     c1e:	10 92 21 01 	sts	0x0121, r1	; 0x800121 <__data_end+0x1>
     c22:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__data_end>
     c26:	06 c0       	rjmp	.+12     	; 0xc34 <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     c28:	df 91       	pop	r29
     c2a:	cf 91       	pop	r28
     c2c:	1f 91       	pop	r17
     c2e:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     c30:	0c 94 86 05 	jmp	0xb0c	; 0xb0c <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     c34:	df 91       	pop	r29
     c36:	cf 91       	pop	r28
     c38:	1f 91       	pop	r17
     c3a:	0f 91       	pop	r16
     c3c:	08 95       	ret

00000c3e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     c3e:	cf 93       	push	r28
     c40:	df 93       	push	r29
     c42:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     c44:	60 91 20 01 	lds	r22, 0x0120	; 0x800120 <__data_end>
     c48:	70 91 21 01 	lds	r23, 0x0121	; 0x800121 <__data_end+0x1>
     c4c:	64 5f       	subi	r22, 0xF4	; 244
     c4e:	7f 4f       	sbci	r23, 0xFF	; 255
     c50:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c54:	61 e0       	ldi	r22, 0x01	; 1
     c56:	ce 01       	movw	r24, r28
}
     c58:	df 91       	pop	r29
     c5a:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c5c:	0c 94 60 01 	jmp	0x2c0	; 0x2c0 <prvAddCurrentTaskToDelayedList>

00000c60 <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     c60:	cf 93       	push	r28
     c62:	df 93       	push	r29
     c64:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c66:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     c6a:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     c6e:	70 68       	ori	r23, 0x80	; 128
     c70:	75 87       	std	Z+13, r23	; 0x0d
     c72:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     c74:	60 91 20 01 	lds	r22, 0x0120	; 0x800120 <__data_end>
     c78:	70 91 21 01 	lds	r23, 0x0121	; 0x800121 <__data_end+0x1>
     c7c:	64 5f       	subi	r22, 0xF4	; 244
     c7e:	7f 4f       	sbci	r23, 0xFF	; 255
     c80:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c84:	61 e0       	ldi	r22, 0x01	; 1
     c86:	ce 01       	movw	r24, r28
}
     c88:	df 91       	pop	r29
     c8a:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c8c:	0c 94 60 01 	jmp	0x2c0	; 0x2c0 <prvAddCurrentTaskToDelayedList>

00000c90 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     c90:	0f 93       	push	r16
     c92:	1f 93       	push	r17
     c94:	cf 93       	push	r28
     c96:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     c98:	dc 01       	movw	r26, r24
     c9a:	15 96       	adiw	r26, 0x05	; 5
     c9c:	ed 91       	ld	r30, X+
     c9e:	fc 91       	ld	r31, X
     ca0:	16 97       	sbiw	r26, 0x06	; 6
     ca2:	c6 81       	ldd	r28, Z+6	; 0x06
     ca4:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     ca6:	8e 01       	movw	r16, r28
     ca8:	04 5f       	subi	r16, 0xF4	; 244
     caa:	1f 4f       	sbci	r17, 0xFF	; 255
     cac:	c8 01       	movw	r24, r16
     cae:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     cb2:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
     cb6:	81 11       	cpse	r24, r1
     cb8:	14 c0       	rjmp	.+40     	; 0xce2 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     cba:	0a 50       	subi	r16, 0x0A	; 10
     cbc:	11 09       	sbc	r17, r1
     cbe:	c8 01       	movw	r24, r16
     cc0:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     cc4:	8e 89       	ldd	r24, Y+22	; 0x16
     cc6:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     cca:	98 17       	cp	r25, r24
     ccc:	10 f4       	brcc	.+4      	; 0xcd2 <xTaskRemoveFromEventList+0x42>
     cce:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     cd2:	b9 e0       	ldi	r27, 0x09	; 9
     cd4:	8b 9f       	mul	r24, r27
     cd6:	c0 01       	movw	r24, r0
     cd8:	11 24       	eor	r1, r1
     cda:	b8 01       	movw	r22, r16
     cdc:	8e 59       	subi	r24, 0x9E	; 158
     cde:	9e 4f       	sbci	r25, 0xFE	; 254
     ce0:	03 c0       	rjmp	.+6      	; 0xce8 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     ce2:	b8 01       	movw	r22, r16
     ce4:	83 e4       	ldi	r24, 0x43	; 67
     ce6:	91 e0       	ldi	r25, 0x01	; 1
     ce8:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     cec:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     cf0:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     cf4:	9e 89       	ldd	r25, Y+22	; 0x16
     cf6:	86 89       	ldd	r24, Z+22	; 0x16
     cf8:	89 17       	cp	r24, r25
     cfa:	20 f4       	brcc	.+8      	; 0xd04 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     cfc:	81 e0       	ldi	r24, 0x01	; 1
     cfe:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
     d02:	01 c0       	rjmp	.+2      	; 0xd06 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     d04:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     d06:	df 91       	pop	r29
     d08:	cf 91       	pop	r28
     d0a:	1f 91       	pop	r17
     d0c:	0f 91       	pop	r16
     d0e:	08 95       	ret

00000d10 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     d10:	0f 93       	push	r16
     d12:	1f 93       	push	r17
     d14:	cf 93       	push	r28
     d16:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     d18:	70 68       	ori	r23, 0x80	; 128
     d1a:	fc 01       	movw	r30, r24
     d1c:	71 83       	std	Z+1, r23	; 0x01
     d1e:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     d20:	c6 81       	ldd	r28, Z+6	; 0x06
     d22:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     d24:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     d28:	8e 01       	movw	r16, r28
     d2a:	0e 5f       	subi	r16, 0xFE	; 254
     d2c:	1f 4f       	sbci	r17, 0xFF	; 255
     d2e:	c8 01       	movw	r24, r16
     d30:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     d34:	8e 89       	ldd	r24, Y+22	; 0x16
     d36:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
     d3a:	98 17       	cp	r25, r24
     d3c:	10 f4       	brcc	.+4      	; 0xd42 <vTaskRemoveFromUnorderedEventList+0x32>
     d3e:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
     d42:	f9 e0       	ldi	r31, 0x09	; 9
     d44:	8f 9f       	mul	r24, r31
     d46:	c0 01       	movw	r24, r0
     d48:	11 24       	eor	r1, r1
     d4a:	b8 01       	movw	r22, r16
     d4c:	8e 59       	subi	r24, 0x9E	; 158
     d4e:	9e 4f       	sbci	r25, 0xFE	; 254
     d50:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     d54:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     d58:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     d5c:	9e 89       	ldd	r25, Y+22	; 0x16
     d5e:	86 89       	ldd	r24, Z+22	; 0x16
     d60:	89 17       	cp	r24, r25
     d62:	18 f4       	brcc	.+6      	; 0xd6a <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     d64:	81 e0       	ldi	r24, 0x01	; 1
     d66:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
	}
}
     d6a:	df 91       	pop	r29
     d6c:	cf 91       	pop	r28
     d6e:	1f 91       	pop	r17
     d70:	0f 91       	pop	r16
     d72:	08 95       	ret

00000d74 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     d74:	0f b6       	in	r0, 0x3f	; 63
     d76:	f8 94       	cli
     d78:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     d7a:	20 91 28 01 	lds	r18, 0x0128	; 0x800128 <xNumOfOverflows>
     d7e:	fc 01       	movw	r30, r24
     d80:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     d82:	20 91 2d 01 	lds	r18, 0x012D	; 0x80012d <xTickCount>
     d86:	30 91 2e 01 	lds	r19, 0x012E	; 0x80012e <xTickCount+0x1>
     d8a:	32 83       	std	Z+2, r19	; 0x02
     d8c:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     d8e:	0f 90       	pop	r0
     d90:	0f be       	out	0x3f, r0	; 63
     d92:	08 95       	ret

00000d94 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     d94:	20 91 28 01 	lds	r18, 0x0128	; 0x800128 <xNumOfOverflows>
     d98:	fc 01       	movw	r30, r24
     d9a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     d9c:	20 91 2d 01 	lds	r18, 0x012D	; 0x80012d <xTickCount>
     da0:	30 91 2e 01 	lds	r19, 0x012E	; 0x80012e <xTickCount+0x1>
     da4:	32 83       	std	Z+2, r19	; 0x02
     da6:	21 83       	std	Z+1, r18	; 0x01
     da8:	08 95       	ret

00000daa <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     daa:	cf 93       	push	r28
     dac:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     dae:	0f b6       	in	r0, 0x3f	; 63
     db0:	f8 94       	cli
     db2:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     db4:	40 91 2d 01 	lds	r20, 0x012D	; 0x80012d <xTickCount>
     db8:	50 91 2e 01 	lds	r21, 0x012E	; 0x80012e <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     dbc:	db 01       	movw	r26, r22
     dbe:	2d 91       	ld	r18, X+
     dc0:	3c 91       	ld	r19, X
     dc2:	2f 3f       	cpi	r18, 0xFF	; 255
     dc4:	bf ef       	ldi	r27, 0xFF	; 255
     dc6:	3b 07       	cpc	r19, r27
     dc8:	d9 f0       	breq	.+54     	; 0xe00 <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     dca:	ec 01       	movw	r28, r24
     dcc:	e9 81       	ldd	r30, Y+1	; 0x01
     dce:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     dd0:	a0 91 28 01 	lds	r26, 0x0128	; 0x800128 <xNumOfOverflows>
     dd4:	b8 81       	ld	r27, Y
     dd6:	ba 17       	cp	r27, r26
     dd8:	19 f0       	breq	.+6      	; 0xde0 <xTaskCheckForTimeOut+0x36>
     dda:	4e 17       	cp	r20, r30
     ddc:	5f 07       	cpc	r21, r31
     dde:	90 f4       	brcc	.+36     	; 0xe04 <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     de0:	4e 1b       	sub	r20, r30
     de2:	5f 0b       	sbc	r21, r31
     de4:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     de6:	42 17       	cp	r20, r18
     de8:	53 07       	cpc	r21, r19
     dea:	38 f4       	brcc	.+14     	; 0xdfa <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     dec:	24 1b       	sub	r18, r20
     dee:	35 0b       	sbc	r19, r21
     df0:	31 83       	std	Z+1, r19	; 0x01
     df2:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     df4:	0e 94 ca 06 	call	0xd94	; 0xd94 <vTaskInternalSetTimeOutState>
     df8:	03 c0       	rjmp	.+6      	; 0xe00 <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     dfa:	11 82       	std	Z+1, r1	; 0x01
     dfc:	10 82       	st	Z, r1
     dfe:	02 c0       	rjmp	.+4      	; 0xe04 <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     e00:	80 e0       	ldi	r24, 0x00	; 0
     e02:	01 c0       	rjmp	.+2      	; 0xe06 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     e04:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     e06:	0f 90       	pop	r0
     e08:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     e0a:	df 91       	pop	r29
     e0c:	cf 91       	pop	r28
     e0e:	08 95       	ret

00000e10 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     e10:	81 e0       	ldi	r24, 0x01	; 1
     e12:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
     e16:	08 95       	ret

00000e18 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     e18:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     e1c:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e20:	84 85       	ldd	r24, Z+12	; 0x0c
     e22:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     e24:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     e28:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e2c:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
     e30:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
     e34:	56 96       	adiw	r26, 0x16	; 22
     e36:	4c 91       	ld	r20, X
     e38:	24 e0       	ldi	r18, 0x04	; 4
     e3a:	30 e0       	ldi	r19, 0x00	; 0
     e3c:	24 1b       	sub	r18, r20
     e3e:	31 09       	sbc	r19, r1
     e40:	35 87       	std	Z+13, r19	; 0x0d
     e42:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     e44:	08 95       	ret

00000e46 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     e46:	0f 93       	push	r16
     e48:	1f 93       	push	r17
     e4a:	18 2f       	mov	r17, r24
     e4c:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     e4e:	0f b6       	in	r0, 0x3f	; 63
     e50:	f8 94       	cli
     e52:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     e54:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     e58:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e5c:	41 a1       	ldd	r20, Z+33	; 0x21
     e5e:	52 a1       	ldd	r21, Z+34	; 0x22
     e60:	63 a1       	ldd	r22, Z+35	; 0x23
     e62:	74 a1       	ldd	r23, Z+36	; 0x24
     e64:	45 2b       	or	r20, r21
     e66:	46 2b       	or	r20, r22
     e68:	47 2b       	or	r20, r23
     e6a:	69 f4       	brne	.+26     	; 0xe86 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     e6c:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     e70:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e74:	21 e0       	ldi	r18, 0x01	; 1
     e76:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     e78:	00 97       	sbiw	r24, 0x00	; 0
     e7a:	29 f0       	breq	.+10     	; 0xe86 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     e7c:	61 e0       	ldi	r22, 0x01	; 1
     e7e:	0e 94 60 01 	call	0x2c0	; 0x2c0 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     e82:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     e86:	0f 90       	pop	r0
     e88:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     e8a:	0f b6       	in	r0, 0x3f	; 63
     e8c:	f8 94       	cli
     e8e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
     e90:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     e94:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     e98:	61 a1       	ldd	r22, Z+33	; 0x21
     e9a:	72 a1       	ldd	r23, Z+34	; 0x22
     e9c:	83 a1       	ldd	r24, Z+35	; 0x23
     e9e:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
     ea0:	61 15       	cp	r22, r1
     ea2:	71 05       	cpc	r23, r1
     ea4:	81 05       	cpc	r24, r1
     ea6:	91 05       	cpc	r25, r1
     ea8:	a9 f0       	breq	.+42     	; 0xed4 <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     eaa:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     eae:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
     eb2:	11 23       	and	r17, r17
     eb4:	29 f0       	breq	.+10     	; 0xec0 <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     eb6:	11 a2       	std	Z+33, r1	; 0x21
     eb8:	12 a2       	std	Z+34, r1	; 0x22
     eba:	13 a2       	std	Z+35, r1	; 0x23
     ebc:	14 a2       	std	Z+36, r1	; 0x24
     ebe:	0a c0       	rjmp	.+20     	; 0xed4 <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
     ec0:	8b 01       	movw	r16, r22
     ec2:	9c 01       	movw	r18, r24
     ec4:	01 50       	subi	r16, 0x01	; 1
     ec6:	11 09       	sbc	r17, r1
     ec8:	21 09       	sbc	r18, r1
     eca:	31 09       	sbc	r19, r1
     ecc:	01 a3       	std	Z+33, r16	; 0x21
     ece:	12 a3       	std	Z+34, r17	; 0x22
     ed0:	23 a3       	std	Z+35, r18	; 0x23
     ed2:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     ed4:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     ed8:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     edc:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     ede:	0f 90       	pop	r0
     ee0:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
     ee2:	1f 91       	pop	r17
     ee4:	0f 91       	pop	r16
     ee6:	08 95       	ret

00000ee8 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     ee8:	4f 92       	push	r4
     eea:	5f 92       	push	r5
     eec:	6f 92       	push	r6
     eee:	7f 92       	push	r7
     ef0:	8f 92       	push	r8
     ef2:	9f 92       	push	r9
     ef4:	af 92       	push	r10
     ef6:	bf 92       	push	r11
     ef8:	ef 92       	push	r14
     efa:	ff 92       	push	r15
     efc:	0f 93       	push	r16
     efe:	1f 93       	push	r17
     f00:	49 01       	movw	r8, r18
     f02:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     f04:	0f b6       	in	r0, 0x3f	; 63
     f06:	f8 94       	cli
     f08:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     f0a:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     f0e:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     f12:	25 a1       	ldd	r18, Z+37	; 0x25
     f14:	22 30       	cpi	r18, 0x02	; 2
     f16:	39 f1       	breq	.+78     	; 0xf66 <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     f18:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     f1c:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     f20:	21 a1       	ldd	r18, Z+33	; 0x21
     f22:	32 a1       	ldd	r19, Z+34	; 0x22
     f24:	43 a1       	ldd	r20, Z+35	; 0x23
     f26:	54 a1       	ldd	r21, Z+36	; 0x24
     f28:	2b 01       	movw	r4, r22
     f2a:	3c 01       	movw	r6, r24
     f2c:	40 94       	com	r4
     f2e:	50 94       	com	r5
     f30:	60 94       	com	r6
     f32:	70 94       	com	r7
     f34:	d3 01       	movw	r26, r6
     f36:	c2 01       	movw	r24, r4
     f38:	82 23       	and	r24, r18
     f3a:	93 23       	and	r25, r19
     f3c:	a4 23       	and	r26, r20
     f3e:	b5 23       	and	r27, r21
     f40:	81 a3       	std	Z+33, r24	; 0x21
     f42:	92 a3       	std	Z+34, r25	; 0x22
     f44:	a3 a3       	std	Z+35, r26	; 0x23
     f46:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     f48:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     f4c:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     f50:	81 e0       	ldi	r24, 0x01	; 1
     f52:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     f54:	e1 14       	cp	r14, r1
     f56:	f1 04       	cpc	r15, r1
     f58:	31 f0       	breq	.+12     	; 0xf66 <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     f5a:	61 e0       	ldi	r22, 0x01	; 1
     f5c:	c7 01       	movw	r24, r14
     f5e:	0e 94 60 01 	call	0x2c0	; 0x2c0 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     f62:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     f66:	0f 90       	pop	r0
     f68:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     f6a:	0f b6       	in	r0, 0x3f	; 63
     f6c:	f8 94       	cli
     f6e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
     f70:	01 15       	cp	r16, r1
     f72:	11 05       	cpc	r17, r1
     f74:	69 f0       	breq	.+26     	; 0xf90 <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     f76:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     f7a:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     f7e:	81 a1       	ldd	r24, Z+33	; 0x21
     f80:	92 a1       	ldd	r25, Z+34	; 0x22
     f82:	a3 a1       	ldd	r26, Z+35	; 0x23
     f84:	b4 a1       	ldd	r27, Z+36	; 0x24
     f86:	f8 01       	movw	r30, r16
     f88:	80 83       	st	Z, r24
     f8a:	91 83       	std	Z+1, r25	; 0x01
     f8c:	a2 83       	std	Z+2, r26	; 0x02
     f8e:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     f90:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     f94:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     f98:	85 a1       	ldd	r24, Z+37	; 0x25
     f9a:	82 30       	cpi	r24, 0x02	; 2
     f9c:	c1 f4       	brne	.+48     	; 0xfce <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
     f9e:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     fa2:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     fa6:	41 a1       	ldd	r20, Z+33	; 0x21
     fa8:	52 a1       	ldd	r21, Z+34	; 0x22
     faa:	63 a1       	ldd	r22, Z+35	; 0x23
     fac:	74 a1       	ldd	r23, Z+36	; 0x24
     fae:	d5 01       	movw	r26, r10
     fb0:	c4 01       	movw	r24, r8
     fb2:	80 95       	com	r24
     fb4:	90 95       	com	r25
     fb6:	a0 95       	com	r26
     fb8:	b0 95       	com	r27
     fba:	84 23       	and	r24, r20
     fbc:	95 23       	and	r25, r21
     fbe:	a6 23       	and	r26, r22
     fc0:	b7 23       	and	r27, r23
     fc2:	81 a3       	std	Z+33, r24	; 0x21
     fc4:	92 a3       	std	Z+34, r25	; 0x22
     fc6:	a3 a3       	std	Z+35, r26	; 0x23
     fc8:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
     fca:	81 e0       	ldi	r24, 0x01	; 1
     fcc:	01 c0       	rjmp	.+2      	; 0xfd0 <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
     fce:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     fd0:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
     fd4:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
     fd8:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     fda:	0f 90       	pop	r0
     fdc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     fde:	1f 91       	pop	r17
     fe0:	0f 91       	pop	r16
     fe2:	ff 90       	pop	r15
     fe4:	ef 90       	pop	r14
     fe6:	bf 90       	pop	r11
     fe8:	af 90       	pop	r10
     fea:	9f 90       	pop	r9
     fec:	8f 90       	pop	r8
     fee:	7f 90       	pop	r7
     ff0:	6f 90       	pop	r6
     ff2:	5f 90       	pop	r5
     ff4:	4f 90       	pop	r4
     ff6:	08 95       	ret

00000ff8 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
     ff8:	0f 93       	push	r16
     ffa:	1f 93       	push	r17
     ffc:	cf 93       	push	r28
     ffe:	df 93       	push	r29
    1000:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
    1002:	0f b6       	in	r0, 0x3f	; 63
    1004:	f8 94       	cli
    1006:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    1008:	01 15       	cp	r16, r1
    100a:	11 05       	cpc	r17, r1
    100c:	49 f0       	breq	.+18     	; 0x1020 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    100e:	81 a1       	ldd	r24, Z+33	; 0x21
    1010:	92 a1       	ldd	r25, Z+34	; 0x22
    1012:	a3 a1       	ldd	r26, Z+35	; 0x23
    1014:	b4 a1       	ldd	r27, Z+36	; 0x24
    1016:	e8 01       	movw	r28, r16
    1018:	88 83       	st	Y, r24
    101a:	99 83       	std	Y+1, r25	; 0x01
    101c:	aa 83       	std	Y+2, r26	; 0x02
    101e:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1020:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1022:	82 e0       	ldi	r24, 0x02	; 2
    1024:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1026:	22 30       	cpi	r18, 0x02	; 2
    1028:	89 f0       	breq	.+34     	; 0x104c <xTaskGenericNotify+0x54>
    102a:	58 f4       	brcc	.+22     	; 0x1042 <xTaskGenericNotify+0x4a>
    102c:	21 30       	cpi	r18, 0x01	; 1
    102e:	01 f5       	brne	.+64     	; 0x1070 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1030:	81 a1       	ldd	r24, Z+33	; 0x21
    1032:	92 a1       	ldd	r25, Z+34	; 0x22
    1034:	a3 a1       	ldd	r26, Z+35	; 0x23
    1036:	b4 a1       	ldd	r27, Z+36	; 0x24
    1038:	48 2b       	or	r20, r24
    103a:	59 2b       	or	r21, r25
    103c:	6a 2b       	or	r22, r26
    103e:	7b 2b       	or	r23, r27
    1040:	13 c0       	rjmp	.+38     	; 0x1068 <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1042:	23 30       	cpi	r18, 0x03	; 3
    1044:	89 f0       	breq	.+34     	; 0x1068 <xTaskGenericNotify+0x70>
    1046:	24 30       	cpi	r18, 0x04	; 4
    1048:	69 f0       	breq	.+26     	; 0x1064 <xTaskGenericNotify+0x6c>
    104a:	12 c0       	rjmp	.+36     	; 0x1070 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    104c:	81 a1       	ldd	r24, Z+33	; 0x21
    104e:	92 a1       	ldd	r25, Z+34	; 0x22
    1050:	a3 a1       	ldd	r26, Z+35	; 0x23
    1052:	b4 a1       	ldd	r27, Z+36	; 0x24
    1054:	01 96       	adiw	r24, 0x01	; 1
    1056:	a1 1d       	adc	r26, r1
    1058:	b1 1d       	adc	r27, r1
    105a:	81 a3       	std	Z+33, r24	; 0x21
    105c:	92 a3       	std	Z+34, r25	; 0x22
    105e:	a3 a3       	std	Z+35, r26	; 0x23
    1060:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1062:	06 c0       	rjmp	.+12     	; 0x1070 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1064:	32 30       	cpi	r19, 0x02	; 2
    1066:	49 f1       	breq	.+82     	; 0x10ba <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1068:	41 a3       	std	Z+33, r20	; 0x21
    106a:	52 a3       	std	Z+34, r21	; 0x22
    106c:	63 a3       	std	Z+35, r22	; 0x23
    106e:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1070:	31 30       	cpi	r19, 0x01	; 1
    1072:	09 f5       	brne	.+66     	; 0x10b6 <xTaskGenericNotify+0xbe>
    1074:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1076:	8f 01       	movw	r16, r30
    1078:	0e 5f       	subi	r16, 0xFE	; 254
    107a:	1f 4f       	sbci	r17, 0xFF	; 255
    107c:	c8 01       	movw	r24, r16
    107e:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    1082:	8e 89       	ldd	r24, Y+22	; 0x16
    1084:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
    1088:	98 17       	cp	r25, r24
    108a:	10 f4       	brcc	.+4      	; 0x1090 <xTaskGenericNotify+0x98>
    108c:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
    1090:	29 e0       	ldi	r18, 0x09	; 9
    1092:	82 9f       	mul	r24, r18
    1094:	c0 01       	movw	r24, r0
    1096:	11 24       	eor	r1, r1
    1098:	b8 01       	movw	r22, r16
    109a:	8e 59       	subi	r24, 0x9E	; 158
    109c:	9e 4f       	sbci	r25, 0xFE	; 254
    109e:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    10a2:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
    10a6:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
    10aa:	9e 89       	ldd	r25, Y+22	; 0x16
    10ac:	86 89       	ldd	r24, Z+22	; 0x16
    10ae:	89 17       	cp	r24, r25
    10b0:	10 f4       	brcc	.+4      	; 0x10b6 <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    10b2:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
    10b6:	81 e0       	ldi	r24, 0x01	; 1
    10b8:	01 c0       	rjmp	.+2      	; 0x10bc <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    10ba:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    10bc:	0f 90       	pop	r0
    10be:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	1f 91       	pop	r17
    10c6:	0f 91       	pop	r16
    10c8:	08 95       	ret

000010ca <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    10ca:	ef 92       	push	r14
    10cc:	ff 92       	push	r15
    10ce:	0f 93       	push	r16
    10d0:	1f 93       	push	r17
    10d2:	cf 93       	push	r28
    10d4:	df 93       	push	r29
    10d6:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    10d8:	01 15       	cp	r16, r1
    10da:	11 05       	cpc	r17, r1
    10dc:	49 f0       	breq	.+18     	; 0x10f0 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    10de:	81 a1       	ldd	r24, Z+33	; 0x21
    10e0:	92 a1       	ldd	r25, Z+34	; 0x22
    10e2:	a3 a1       	ldd	r26, Z+35	; 0x23
    10e4:	b4 a1       	ldd	r27, Z+36	; 0x24
    10e6:	e8 01       	movw	r28, r16
    10e8:	88 83       	st	Y, r24
    10ea:	99 83       	std	Y+1, r25	; 0x01
    10ec:	aa 83       	std	Y+2, r26	; 0x02
    10ee:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    10f0:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    10f2:	82 e0       	ldi	r24, 0x02	; 2
    10f4:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    10f6:	22 30       	cpi	r18, 0x02	; 2
    10f8:	89 f0       	breq	.+34     	; 0x111c <xTaskGenericNotifyFromISR+0x52>
    10fa:	58 f4       	brcc	.+22     	; 0x1112 <xTaskGenericNotifyFromISR+0x48>
    10fc:	21 30       	cpi	r18, 0x01	; 1
    10fe:	01 f5       	brne	.+64     	; 0x1140 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1100:	81 a1       	ldd	r24, Z+33	; 0x21
    1102:	92 a1       	ldd	r25, Z+34	; 0x22
    1104:	a3 a1       	ldd	r26, Z+35	; 0x23
    1106:	b4 a1       	ldd	r27, Z+36	; 0x24
    1108:	48 2b       	or	r20, r24
    110a:	59 2b       	or	r21, r25
    110c:	6a 2b       	or	r22, r26
    110e:	7b 2b       	or	r23, r27
    1110:	13 c0       	rjmp	.+38     	; 0x1138 <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1112:	23 30       	cpi	r18, 0x03	; 3
    1114:	89 f0       	breq	.+34     	; 0x1138 <xTaskGenericNotifyFromISR+0x6e>
    1116:	24 30       	cpi	r18, 0x04	; 4
    1118:	69 f0       	breq	.+26     	; 0x1134 <xTaskGenericNotifyFromISR+0x6a>
    111a:	12 c0       	rjmp	.+36     	; 0x1140 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    111c:	81 a1       	ldd	r24, Z+33	; 0x21
    111e:	92 a1       	ldd	r25, Z+34	; 0x22
    1120:	a3 a1       	ldd	r26, Z+35	; 0x23
    1122:	b4 a1       	ldd	r27, Z+36	; 0x24
    1124:	01 96       	adiw	r24, 0x01	; 1
    1126:	a1 1d       	adc	r26, r1
    1128:	b1 1d       	adc	r27, r1
    112a:	81 a3       	std	Z+33, r24	; 0x21
    112c:	92 a3       	std	Z+34, r25	; 0x22
    112e:	a3 a3       	std	Z+35, r26	; 0x23
    1130:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1132:	06 c0       	rjmp	.+12     	; 0x1140 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1134:	32 30       	cpi	r19, 0x02	; 2
    1136:	d9 f1       	breq	.+118    	; 0x11ae <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1138:	41 a3       	std	Z+33, r20	; 0x21
    113a:	52 a3       	std	Z+34, r21	; 0x22
    113c:	63 a3       	std	Z+35, r22	; 0x23
    113e:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1140:	31 30       	cpi	r19, 0x01	; 1
    1142:	11 f0       	breq	.+4      	; 0x1148 <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1144:	81 e0       	ldi	r24, 0x01	; 1
    1146:	34 c0       	rjmp	.+104    	; 0x11b0 <xTaskGenericNotifyFromISR+0xe6>
    1148:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    114a:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
    114e:	81 11       	cpse	r24, r1
    1150:	15 c0       	rjmp	.+42     	; 0x117c <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1152:	8f 01       	movw	r16, r30
    1154:	0e 5f       	subi	r16, 0xFE	; 254
    1156:	1f 4f       	sbci	r17, 0xFF	; 255
    1158:	c8 01       	movw	r24, r16
    115a:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    115e:	8e 89       	ldd	r24, Y+22	; 0x16
    1160:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
    1164:	98 17       	cp	r25, r24
    1166:	10 f4       	brcc	.+4      	; 0x116c <xTaskGenericNotifyFromISR+0xa2>
    1168:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
    116c:	e9 e0       	ldi	r30, 0x09	; 9
    116e:	8e 9f       	mul	r24, r30
    1170:	c0 01       	movw	r24, r0
    1172:	11 24       	eor	r1, r1
    1174:	b8 01       	movw	r22, r16
    1176:	8e 59       	subi	r24, 0x9E	; 158
    1178:	9e 4f       	sbci	r25, 0xFE	; 254
    117a:	05 c0       	rjmp	.+10     	; 0x1186 <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    117c:	bf 01       	movw	r22, r30
    117e:	64 5f       	subi	r22, 0xF4	; 244
    1180:	7f 4f       	sbci	r23, 0xFF	; 255
    1182:	83 e4       	ldi	r24, 0x43	; 67
    1184:	91 e0       	ldi	r25, 0x01	; 1
    1186:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    118a:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
    118e:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
    1192:	9e 89       	ldd	r25, Y+22	; 0x16
    1194:	86 89       	ldd	r24, Z+22	; 0x16
    1196:	89 17       	cp	r24, r25
    1198:	a8 f6       	brcc	.-86     	; 0x1144 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    119a:	e1 14       	cp	r14, r1
    119c:	f1 04       	cpc	r15, r1
    119e:	19 f0       	breq	.+6      	; 0x11a6 <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	e7 01       	movw	r28, r14
    11a4:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    11a6:	81 e0       	ldi	r24, 0x01	; 1
    11a8:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
    11ac:	01 c0       	rjmp	.+2      	; 0x11b0 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    11ae:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    11b0:	df 91       	pop	r29
    11b2:	cf 91       	pop	r28
    11b4:	1f 91       	pop	r17
    11b6:	0f 91       	pop	r16
    11b8:	ff 90       	pop	r15
    11ba:	ef 90       	pop	r14
    11bc:	08 95       	ret

000011be <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    11be:	ef 92       	push	r14
    11c0:	ff 92       	push	r15
    11c2:	0f 93       	push	r16
    11c4:	1f 93       	push	r17
    11c6:	cf 93       	push	r28
    11c8:	df 93       	push	r29
    11ca:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    11cc:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    11ce:	82 e0       	ldi	r24, 0x02	; 2
    11d0:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    11d2:	81 a1       	ldd	r24, Z+33	; 0x21
    11d4:	92 a1       	ldd	r25, Z+34	; 0x22
    11d6:	a3 a1       	ldd	r26, Z+35	; 0x23
    11d8:	b4 a1       	ldd	r27, Z+36	; 0x24
    11da:	01 96       	adiw	r24, 0x01	; 1
    11dc:	a1 1d       	adc	r26, r1
    11de:	b1 1d       	adc	r27, r1
    11e0:	81 a3       	std	Z+33, r24	; 0x21
    11e2:	92 a3       	std	Z+34, r25	; 0x22
    11e4:	a3 a3       	std	Z+35, r26	; 0x23
    11e6:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    11e8:	21 30       	cpi	r18, 0x01	; 1
    11ea:	a1 f5       	brne	.+104    	; 0x1254 <vTaskNotifyGiveFromISR+0x96>
    11ec:	8b 01       	movw	r16, r22
    11ee:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    11f0:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <uxSchedulerSuspended>
    11f4:	81 11       	cpse	r24, r1
    11f6:	16 c0       	rjmp	.+44     	; 0x1224 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    11f8:	7f 01       	movw	r14, r30
    11fa:	22 e0       	ldi	r18, 0x02	; 2
    11fc:	e2 0e       	add	r14, r18
    11fe:	f1 1c       	adc	r15, r1
    1200:	c7 01       	movw	r24, r14
    1202:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1206:	8e 89       	ldd	r24, Y+22	; 0x16
    1208:	90 91 2c 01 	lds	r25, 0x012C	; 0x80012c <uxTopReadyPriority>
    120c:	98 17       	cp	r25, r24
    120e:	10 f4       	brcc	.+4      	; 0x1214 <vTaskNotifyGiveFromISR+0x56>
    1210:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <uxTopReadyPriority>
    1214:	e9 e0       	ldi	r30, 0x09	; 9
    1216:	8e 9f       	mul	r24, r30
    1218:	c0 01       	movw	r24, r0
    121a:	11 24       	eor	r1, r1
    121c:	b7 01       	movw	r22, r14
    121e:	8e 59       	subi	r24, 0x9E	; 158
    1220:	9e 4f       	sbci	r25, 0xFE	; 254
    1222:	05 c0       	rjmp	.+10     	; 0x122e <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1224:	bf 01       	movw	r22, r30
    1226:	64 5f       	subi	r22, 0xF4	; 244
    1228:	7f 4f       	sbci	r23, 0xFF	; 255
    122a:	83 e4       	ldi	r24, 0x43	; 67
    122c:	91 e0       	ldi	r25, 0x01	; 1
    122e:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1232:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
    1236:	f0 91 21 01 	lds	r31, 0x0121	; 0x800121 <__data_end+0x1>
    123a:	9e 89       	ldd	r25, Y+22	; 0x16
    123c:	86 89       	ldd	r24, Z+22	; 0x16
    123e:	89 17       	cp	r24, r25
    1240:	48 f4       	brcc	.+18     	; 0x1254 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1242:	01 15       	cp	r16, r1
    1244:	11 05       	cpc	r17, r1
    1246:	19 f0       	breq	.+6      	; 0x124e <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1248:	81 e0       	ldi	r24, 0x01	; 1
    124a:	f8 01       	movw	r30, r16
    124c:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    124e:	81 e0       	ldi	r24, 0x01	; 1
    1250:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    1254:	df 91       	pop	r29
    1256:	cf 91       	pop	r28
    1258:	1f 91       	pop	r17
    125a:	0f 91       	pop	r16
    125c:	ff 90       	pop	r15
    125e:	ef 90       	pop	r14
    1260:	08 95       	ret

00001262 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    1262:	00 97       	sbiw	r24, 0x00	; 0
    1264:	21 f4       	brne	.+8      	; 0x126e <xTaskNotifyStateClear+0xc>
    1266:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
    126a:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>

		taskENTER_CRITICAL();
    126e:	0f b6       	in	r0, 0x3f	; 63
    1270:	f8 94       	cli
    1272:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    1274:	fc 01       	movw	r30, r24
    1276:	25 a1       	ldd	r18, Z+37	; 0x25
    1278:	22 30       	cpi	r18, 0x02	; 2
    127a:	19 f4       	brne	.+6      	; 0x1282 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    127c:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	01 c0       	rjmp	.+2      	; 0x1284 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    1282:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    1284:	0f 90       	pop	r0
    1286:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1288:	08 95       	ret

0000128a <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    128a:	0f b6       	in	r0, 0x3f	; 63
    128c:	f8 94       	cli
    128e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1290:	fc 01       	movw	r30, r24
    1292:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1294:	0f 90       	pop	r0
    1296:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1298:	81 e0       	ldi	r24, 0x01	; 1
    129a:	91 11       	cpse	r25, r1
    129c:	80 e0       	ldi	r24, 0x00	; 0
}
    129e:	08 95       	ret

000012a0 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    12a0:	0f 93       	push	r16
    12a2:	1f 93       	push	r17
    12a4:	cf 93       	push	r28
    12a6:	df 93       	push	r29
    12a8:	ec 01       	movw	r28, r24
    12aa:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    12ac:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    12ae:	4c 8d       	ldd	r20, Y+28	; 0x1c
    12b0:	44 23       	and	r20, r20
    12b2:	b1 f1       	breq	.+108    	; 0x1320 <prvCopyDataToQueue+0x80>
    12b4:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    12b6:	01 11       	cpse	r16, r1
    12b8:	15 c0       	rjmp	.+42     	; 0x12e4 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    12ba:	8a 81       	ldd	r24, Y+2	; 0x02
    12bc:	9b 81       	ldd	r25, Y+3	; 0x03
    12be:	0e 94 7f 12 	call	0x24fe	; 0x24fe <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    12c2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    12c4:	8a 81       	ldd	r24, Y+2	; 0x02
    12c6:	9b 81       	ldd	r25, Y+3	; 0x03
    12c8:	82 0f       	add	r24, r18
    12ca:	91 1d       	adc	r25, r1
    12cc:	9b 83       	std	Y+3, r25	; 0x03
    12ce:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    12d0:	2c 81       	ldd	r18, Y+4	; 0x04
    12d2:	3d 81       	ldd	r19, Y+5	; 0x05
    12d4:	82 17       	cp	r24, r18
    12d6:	93 07       	cpc	r25, r19
    12d8:	18 f1       	brcs	.+70     	; 0x1320 <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    12da:	88 81       	ld	r24, Y
    12dc:	99 81       	ldd	r25, Y+1	; 0x01
    12de:	9b 83       	std	Y+3, r25	; 0x03
    12e0:	8a 83       	std	Y+2, r24	; 0x02
    12e2:	1e c0       	rjmp	.+60     	; 0x1320 <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    12e4:	8e 81       	ldd	r24, Y+6	; 0x06
    12e6:	9f 81       	ldd	r25, Y+7	; 0x07
    12e8:	0e 94 7f 12 	call	0x24fe	; 0x24fe <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    12ec:	8c 8d       	ldd	r24, Y+28	; 0x1c
    12ee:	90 e0       	ldi	r25, 0x00	; 0
    12f0:	91 95       	neg	r25
    12f2:	81 95       	neg	r24
    12f4:	91 09       	sbc	r25, r1
    12f6:	2e 81       	ldd	r18, Y+6	; 0x06
    12f8:	3f 81       	ldd	r19, Y+7	; 0x07
    12fa:	28 0f       	add	r18, r24
    12fc:	39 1f       	adc	r19, r25
    12fe:	3f 83       	std	Y+7, r19	; 0x07
    1300:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1302:	48 81       	ld	r20, Y
    1304:	59 81       	ldd	r21, Y+1	; 0x01
    1306:	24 17       	cp	r18, r20
    1308:	35 07       	cpc	r19, r21
    130a:	30 f4       	brcc	.+12     	; 0x1318 <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    130c:	2c 81       	ldd	r18, Y+4	; 0x04
    130e:	3d 81       	ldd	r19, Y+5	; 0x05
    1310:	82 0f       	add	r24, r18
    1312:	93 1f       	adc	r25, r19
    1314:	9f 83       	std	Y+7, r25	; 0x07
    1316:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1318:	02 30       	cpi	r16, 0x02	; 2
    131a:	11 f4       	brne	.+4      	; 0x1320 <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    131c:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    131e:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1320:	1f 5f       	subi	r17, 0xFF	; 255
    1322:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    1324:	80 e0       	ldi	r24, 0x00	; 0
    1326:	df 91       	pop	r29
    1328:	cf 91       	pop	r28
    132a:	1f 91       	pop	r17
    132c:	0f 91       	pop	r16
    132e:	08 95       	ret

00001330 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1330:	fc 01       	movw	r30, r24
    1332:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1334:	44 8d       	ldd	r20, Z+28	; 0x1c
    1336:	44 23       	and	r20, r20
    1338:	a1 f0       	breq	.+40     	; 0x1362 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    133a:	50 e0       	ldi	r21, 0x00	; 0
    133c:	26 81       	ldd	r18, Z+6	; 0x06
    133e:	37 81       	ldd	r19, Z+7	; 0x07
    1340:	24 0f       	add	r18, r20
    1342:	35 1f       	adc	r19, r21
    1344:	37 83       	std	Z+7, r19	; 0x07
    1346:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1348:	64 81       	ldd	r22, Z+4	; 0x04
    134a:	75 81       	ldd	r23, Z+5	; 0x05
    134c:	26 17       	cp	r18, r22
    134e:	37 07       	cpc	r19, r23
    1350:	20 f0       	brcs	.+8      	; 0x135a <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1352:	20 81       	ld	r18, Z
    1354:	31 81       	ldd	r19, Z+1	; 0x01
    1356:	37 83       	std	Z+7, r19	; 0x07
    1358:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    135a:	66 81       	ldd	r22, Z+6	; 0x06
    135c:	77 81       	ldd	r23, Z+7	; 0x07
    135e:	0c 94 7f 12 	jmp	0x24fe	; 0x24fe <memcpy>
    1362:	08 95       	ret

00001364 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1364:	ef 92       	push	r14
    1366:	ff 92       	push	r15
    1368:	1f 93       	push	r17
    136a:	cf 93       	push	r28
    136c:	df 93       	push	r29
    136e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1370:	0f b6       	in	r0, 0x3f	; 63
    1372:	f8 94       	cli
    1374:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1376:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1378:	7c 01       	movw	r14, r24
    137a:	81 e1       	ldi	r24, 0x11	; 17
    137c:	e8 0e       	add	r14, r24
    137e:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1380:	11 16       	cp	r1, r17
    1382:	5c f4       	brge	.+22     	; 0x139a <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1384:	89 89       	ldd	r24, Y+17	; 0x11
    1386:	88 23       	and	r24, r24
    1388:	41 f0       	breq	.+16     	; 0x139a <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    138a:	c7 01       	movw	r24, r14
    138c:	0e 94 48 06 	call	0xc90	; 0xc90 <xTaskRemoveFromEventList>
    1390:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1392:	0e 94 08 07 	call	0xe10	; 0xe10 <vTaskMissedYield>
    1396:	11 50       	subi	r17, 0x01	; 1
    1398:	f3 cf       	rjmp	.-26     	; 0x1380 <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    139a:	8f ef       	ldi	r24, 0xFF	; 255
    139c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    139e:	0f 90       	pop	r0
    13a0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    13a2:	0f b6       	in	r0, 0x3f	; 63
    13a4:	f8 94       	cli
    13a6:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    13a8:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    13aa:	7e 01       	movw	r14, r28
    13ac:	88 e0       	ldi	r24, 0x08	; 8
    13ae:	e8 0e       	add	r14, r24
    13b0:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    13b2:	11 16       	cp	r1, r17
    13b4:	5c f4       	brge	.+22     	; 0x13cc <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13b6:	88 85       	ldd	r24, Y+8	; 0x08
    13b8:	88 23       	and	r24, r24
    13ba:	41 f0       	breq	.+16     	; 0x13cc <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    13bc:	c7 01       	movw	r24, r14
    13be:	0e 94 48 06 	call	0xc90	; 0xc90 <xTaskRemoveFromEventList>
    13c2:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    13c4:	0e 94 08 07 	call	0xe10	; 0xe10 <vTaskMissedYield>
    13c8:	11 50       	subi	r17, 0x01	; 1
    13ca:	f3 cf       	rjmp	.-26     	; 0x13b2 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    13cc:	8f ef       	ldi	r24, 0xFF	; 255
    13ce:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    13d0:	0f 90       	pop	r0
    13d2:	0f be       	out	0x3f, r0	; 63
}
    13d4:	df 91       	pop	r29
    13d6:	cf 91       	pop	r28
    13d8:	1f 91       	pop	r17
    13da:	ff 90       	pop	r15
    13dc:	ef 90       	pop	r14
    13de:	08 95       	ret

000013e0 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    13e0:	cf 93       	push	r28
    13e2:	df 93       	push	r29
    13e4:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    13e6:	0f b6       	in	r0, 0x3f	; 63
    13e8:	f8 94       	cli
    13ea:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    13ec:	48 81       	ld	r20, Y
    13ee:	59 81       	ldd	r21, Y+1	; 0x01
    13f0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    13f2:	7c 8d       	ldd	r23, Y+28	; 0x1c
    13f4:	9a 01       	movw	r18, r20
    13f6:	87 9f       	mul	r24, r23
    13f8:	20 0d       	add	r18, r0
    13fa:	31 1d       	adc	r19, r1
    13fc:	11 24       	eor	r1, r1
    13fe:	3d 83       	std	Y+5, r19	; 0x05
    1400:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1402:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1404:	5b 83       	std	Y+3, r21	; 0x03
    1406:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1408:	90 e0       	ldi	r25, 0x00	; 0
    140a:	01 97       	sbiw	r24, 0x01	; 1
    140c:	78 9f       	mul	r23, r24
    140e:	90 01       	movw	r18, r0
    1410:	79 9f       	mul	r23, r25
    1412:	30 0d       	add	r19, r0
    1414:	11 24       	eor	r1, r1
    1416:	ca 01       	movw	r24, r20
    1418:	82 0f       	add	r24, r18
    141a:	93 1f       	adc	r25, r19
    141c:	9f 83       	std	Y+7, r25	; 0x07
    141e:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1420:	8f ef       	ldi	r24, 0xFF	; 255
    1422:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1424:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1426:	61 11       	cpse	r22, r1
    1428:	0c c0       	rjmp	.+24     	; 0x1442 <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    142a:	88 85       	ldd	r24, Y+8	; 0x08
    142c:	88 23       	and	r24, r24
    142e:	89 f0       	breq	.+34     	; 0x1452 <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1430:	ce 01       	movw	r24, r28
    1432:	08 96       	adiw	r24, 0x08	; 8
    1434:	0e 94 48 06 	call	0xc90	; 0xc90 <xTaskRemoveFromEventList>
    1438:	88 23       	and	r24, r24
    143a:	59 f0       	breq	.+22     	; 0x1452 <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    143c:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
    1440:	08 c0       	rjmp	.+16     	; 0x1452 <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1442:	ce 01       	movw	r24, r28
    1444:	08 96       	adiw	r24, 0x08	; 8
    1446:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    144a:	ce 01       	movw	r24, r28
    144c:	41 96       	adiw	r24, 0x11	; 17
    144e:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1452:	0f 90       	pop	r0
    1454:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1456:	81 e0       	ldi	r24, 0x01	; 1
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	08 95       	ret

0000145e <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    145e:	0f 93       	push	r16
    1460:	1f 93       	push	r17
    1462:	cf 93       	push	r28
    1464:	df 93       	push	r29
    1466:	08 2f       	mov	r16, r24
    1468:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    146a:	66 23       	and	r22, r22
    146c:	21 f0       	breq	.+8      	; 0x1476 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    146e:	86 9f       	mul	r24, r22
    1470:	c0 01       	movw	r24, r0
    1472:	11 24       	eor	r1, r1
    1474:	02 c0       	rjmp	.+4      	; 0x147a <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1476:	80 e0       	ldi	r24, 0x00	; 0
    1478:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    147a:	4f 96       	adiw	r24, 0x1f	; 31
    147c:	0e 94 86 10 	call	0x210c	; 0x210c <pvPortMalloc>
    1480:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    1482:	00 97       	sbiw	r24, 0x00	; 0
    1484:	71 f0       	breq	.+28     	; 0x14a2 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1486:	11 11       	cpse	r17, r1
    1488:	03 c0       	rjmp	.+6      	; 0x1490 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    148a:	99 83       	std	Y+1, r25	; 0x01
    148c:	88 83       	st	Y, r24
    148e:	03 c0       	rjmp	.+6      	; 0x1496 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1490:	4f 96       	adiw	r24, 0x1f	; 31
    1492:	99 83       	std	Y+1, r25	; 0x01
    1494:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1496:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1498:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    149a:	61 e0       	ldi	r22, 0x01	; 1
    149c:	ce 01       	movw	r24, r28
    149e:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    14a2:	ce 01       	movw	r24, r28
    14a4:	df 91       	pop	r29
    14a6:	cf 91       	pop	r28
    14a8:	1f 91       	pop	r17
    14aa:	0f 91       	pop	r16
    14ac:	08 95       	ret

000014ae <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    14ae:	af 92       	push	r10
    14b0:	bf 92       	push	r11
    14b2:	cf 92       	push	r12
    14b4:	df 92       	push	r13
    14b6:	ff 92       	push	r15
    14b8:	0f 93       	push	r16
    14ba:	1f 93       	push	r17
    14bc:	cf 93       	push	r28
    14be:	df 93       	push	r29
    14c0:	00 d0       	rcall	.+0      	; 0x14c2 <xQueueGenericSend+0x14>
    14c2:	00 d0       	rcall	.+0      	; 0x14c4 <xQueueGenericSend+0x16>
    14c4:	1f 92       	push	r1
    14c6:	cd b7       	in	r28, 0x3d	; 61
    14c8:	de b7       	in	r29, 0x3e	; 62
    14ca:	8c 01       	movw	r16, r24
    14cc:	6b 01       	movw	r12, r22
    14ce:	5d 83       	std	Y+5, r21	; 0x05
    14d0:	4c 83       	std	Y+4, r20	; 0x04
    14d2:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    14d4:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    14d6:	58 01       	movw	r10, r16
    14d8:	98 e0       	ldi	r25, 0x08	; 8
    14da:	a9 0e       	add	r10, r25
    14dc:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    14de:	0f b6       	in	r0, 0x3f	; 63
    14e0:	f8 94       	cli
    14e2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    14e4:	f8 01       	movw	r30, r16
    14e6:	22 8d       	ldd	r18, Z+26	; 0x1a
    14e8:	93 8d       	ldd	r25, Z+27	; 0x1b
    14ea:	29 17       	cp	r18, r25
    14ec:	18 f0       	brcs	.+6      	; 0x14f4 <xQueueGenericSend+0x46>
    14ee:	f2 e0       	ldi	r31, 0x02	; 2
    14f0:	ff 12       	cpse	r15, r31
    14f2:	14 c0       	rjmp	.+40     	; 0x151c <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    14f4:	4f 2d       	mov	r20, r15
    14f6:	b6 01       	movw	r22, r12
    14f8:	c8 01       	movw	r24, r16
    14fa:	0e 94 50 09 	call	0x12a0	; 0x12a0 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14fe:	f8 01       	movw	r30, r16
    1500:	91 89       	ldd	r25, Z+17	; 0x11
    1502:	99 23       	and	r25, r25
    1504:	21 f0       	breq	.+8      	; 0x150e <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1506:	c8 01       	movw	r24, r16
    1508:	41 96       	adiw	r24, 0x11	; 17
    150a:	0e 94 48 06 	call	0xc90	; 0xc90 <xTaskRemoveFromEventList>
    150e:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1510:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1514:	0f 90       	pop	r0
    1516:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1518:	81 e0       	ldi	r24, 0x01	; 1
    151a:	50 c0       	rjmp	.+160    	; 0x15bc <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    151c:	2c 81       	ldd	r18, Y+4	; 0x04
    151e:	3d 81       	ldd	r19, Y+5	; 0x05
    1520:	23 2b       	or	r18, r19
    1522:	19 f4       	brne	.+6      	; 0x152a <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1524:	0f 90       	pop	r0
    1526:	0f be       	out	0x3f, r0	; 63
    1528:	48 c0       	rjmp	.+144    	; 0x15ba <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    152a:	81 11       	cpse	r24, r1
    152c:	04 c0       	rjmp	.+8      	; 0x1536 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    152e:	ce 01       	movw	r24, r28
    1530:	01 96       	adiw	r24, 0x01	; 1
    1532:	0e 94 ca 06 	call	0xd94	; 0xd94 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1536:	0f 90       	pop	r0
    1538:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    153a:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    153e:	0f b6       	in	r0, 0x3f	; 63
    1540:	f8 94       	cli
    1542:	0f 92       	push	r0
    1544:	f8 01       	movw	r30, r16
    1546:	85 8d       	ldd	r24, Z+29	; 0x1d
    1548:	8f 3f       	cpi	r24, 0xFF	; 255
    154a:	09 f4       	brne	.+2      	; 0x154e <xQueueGenericSend+0xa0>
    154c:	15 8e       	std	Z+29, r1	; 0x1d
    154e:	f8 01       	movw	r30, r16
    1550:	86 8d       	ldd	r24, Z+30	; 0x1e
    1552:	8f 3f       	cpi	r24, 0xFF	; 255
    1554:	09 f4       	brne	.+2      	; 0x1558 <xQueueGenericSend+0xaa>
    1556:	16 8e       	std	Z+30, r1	; 0x1e
    1558:	0f 90       	pop	r0
    155a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    155c:	be 01       	movw	r22, r28
    155e:	6c 5f       	subi	r22, 0xFC	; 252
    1560:	7f 4f       	sbci	r23, 0xFF	; 255
    1562:	ce 01       	movw	r24, r28
    1564:	01 96       	adiw	r24, 0x01	; 1
    1566:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskCheckForTimeOut>
    156a:	81 11       	cpse	r24, r1
    156c:	21 c0       	rjmp	.+66     	; 0x15b0 <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    156e:	0f b6       	in	r0, 0x3f	; 63
    1570:	f8 94       	cli
    1572:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1574:	f8 01       	movw	r30, r16
    1576:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1578:	0f 90       	pop	r0
    157a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    157c:	83 8d       	ldd	r24, Z+27	; 0x1b
    157e:	98 13       	cpse	r25, r24
    1580:	11 c0       	rjmp	.+34     	; 0x15a4 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1582:	6c 81       	ldd	r22, Y+4	; 0x04
    1584:	7d 81       	ldd	r23, Y+5	; 0x05
    1586:	c5 01       	movw	r24, r10
    1588:	0e 94 1f 06 	call	0xc3e	; 0xc3e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    158c:	c8 01       	movw	r24, r16
    158e:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1592:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>
    1596:	88 23       	and	r24, r24
    1598:	11 f0       	breq	.+4      	; 0x159e <xQueueGenericSend+0xf0>
    159a:	81 e0       	ldi	r24, 0x01	; 1
    159c:	a0 cf       	rjmp	.-192    	; 0x14de <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    159e:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
    15a2:	fb cf       	rjmp	.-10     	; 0x159a <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    15a4:	c8 01       	movw	r24, r16
    15a6:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    15aa:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>
    15ae:	f5 cf       	rjmp	.-22     	; 0x159a <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    15b0:	c8 01       	movw	r24, r16
    15b2:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    15b6:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    15ba:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    15bc:	0f 90       	pop	r0
    15be:	0f 90       	pop	r0
    15c0:	0f 90       	pop	r0
    15c2:	0f 90       	pop	r0
    15c4:	0f 90       	pop	r0
    15c6:	df 91       	pop	r29
    15c8:	cf 91       	pop	r28
    15ca:	1f 91       	pop	r17
    15cc:	0f 91       	pop	r16
    15ce:	ff 90       	pop	r15
    15d0:	df 90       	pop	r13
    15d2:	cf 90       	pop	r12
    15d4:	bf 90       	pop	r11
    15d6:	af 90       	pop	r10
    15d8:	08 95       	ret

000015da <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    15da:	ef 92       	push	r14
    15dc:	ff 92       	push	r15
    15de:	1f 93       	push	r17
    15e0:	cf 93       	push	r28
    15e2:	df 93       	push	r29
    15e4:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    15e6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    15e8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    15ea:	98 17       	cp	r25, r24
    15ec:	10 f0       	brcs	.+4      	; 0x15f2 <xQueueGenericSendFromISR+0x18>
    15ee:	22 30       	cpi	r18, 0x02	; 2
    15f0:	e1 f4       	brne	.+56     	; 0x162a <xQueueGenericSendFromISR+0x50>
    15f2:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    15f4:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    15f6:	42 2f       	mov	r20, r18
    15f8:	ce 01       	movw	r24, r28
    15fa:	0e 94 50 09 	call	0x12a0	; 0x12a0 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    15fe:	1f 3f       	cpi	r17, 0xFF	; 255
    1600:	81 f4       	brne	.+32     	; 0x1622 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1602:	89 89       	ldd	r24, Y+17	; 0x11
    1604:	88 23       	and	r24, r24
    1606:	79 f0       	breq	.+30     	; 0x1626 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1608:	ce 01       	movw	r24, r28
    160a:	41 96       	adiw	r24, 0x11	; 17
    160c:	0e 94 48 06 	call	0xc90	; 0xc90 <xTaskRemoveFromEventList>
    1610:	88 23       	and	r24, r24
    1612:	49 f0       	breq	.+18     	; 0x1626 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1614:	e1 14       	cp	r14, r1
    1616:	f1 04       	cpc	r15, r1
    1618:	31 f0       	breq	.+12     	; 0x1626 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    161a:	81 e0       	ldi	r24, 0x01	; 1
    161c:	f7 01       	movw	r30, r14
    161e:	80 83       	st	Z, r24
    1620:	05 c0       	rjmp	.+10     	; 0x162c <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1622:	1f 5f       	subi	r17, 0xFF	; 255
    1624:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    1626:	81 e0       	ldi	r24, 0x01	; 1
    1628:	01 c0       	rjmp	.+2      	; 0x162c <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    162a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    162c:	df 91       	pop	r29
    162e:	cf 91       	pop	r28
    1630:	1f 91       	pop	r17
    1632:	ff 90       	pop	r15
    1634:	ef 90       	pop	r14
    1636:	08 95       	ret

00001638 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1638:	cf 93       	push	r28
    163a:	df 93       	push	r29
    163c:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    163e:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1640:	83 8d       	ldd	r24, Z+27	; 0x1b
    1642:	98 17       	cp	r25, r24
    1644:	c0 f4       	brcc	.+48     	; 0x1676 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1646:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1648:	9f 5f       	subi	r25, 0xFF	; 255
    164a:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    164c:	8f 3f       	cpi	r24, 0xFF	; 255
    164e:	79 f4       	brne	.+30     	; 0x166e <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1650:	81 89       	ldd	r24, Z+17	; 0x11
    1652:	88 23       	and	r24, r24
    1654:	71 f0       	breq	.+28     	; 0x1672 <xQueueGiveFromISR+0x3a>
    1656:	eb 01       	movw	r28, r22
    1658:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    165a:	41 96       	adiw	r24, 0x11	; 17
    165c:	0e 94 48 06 	call	0xc90	; 0xc90 <xTaskRemoveFromEventList>
    1660:	88 23       	and	r24, r24
    1662:	39 f0       	breq	.+14     	; 0x1672 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1664:	20 97       	sbiw	r28, 0x00	; 0
    1666:	29 f0       	breq	.+10     	; 0x1672 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1668:	81 e0       	ldi	r24, 0x01	; 1
    166a:	88 83       	st	Y, r24
    166c:	05 c0       	rjmp	.+10     	; 0x1678 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    166e:	8f 5f       	subi	r24, 0xFF	; 255
    1670:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1672:	81 e0       	ldi	r24, 0x01	; 1
    1674:	01 c0       	rjmp	.+2      	; 0x1678 <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1676:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1678:	df 91       	pop	r29
    167a:	cf 91       	pop	r28
    167c:	08 95       	ret

0000167e <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    167e:	af 92       	push	r10
    1680:	bf 92       	push	r11
    1682:	cf 92       	push	r12
    1684:	df 92       	push	r13
    1686:	ff 92       	push	r15
    1688:	0f 93       	push	r16
    168a:	1f 93       	push	r17
    168c:	cf 93       	push	r28
    168e:	df 93       	push	r29
    1690:	00 d0       	rcall	.+0      	; 0x1692 <xQueueReceive+0x14>
    1692:	00 d0       	rcall	.+0      	; 0x1694 <xQueueReceive+0x16>
    1694:	1f 92       	push	r1
    1696:	cd b7       	in	r28, 0x3d	; 61
    1698:	de b7       	in	r29, 0x3e	; 62
    169a:	8c 01       	movw	r16, r24
    169c:	6b 01       	movw	r12, r22
    169e:	5d 83       	std	Y+5, r21	; 0x05
    16a0:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    16a2:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16a4:	58 01       	movw	r10, r16
    16a6:	91 e1       	ldi	r25, 0x11	; 17
    16a8:	a9 0e       	add	r10, r25
    16aa:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    16ac:	0f b6       	in	r0, 0x3f	; 63
    16ae:	f8 94       	cli
    16b0:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    16b2:	f8 01       	movw	r30, r16
    16b4:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    16b6:	ff 20       	and	r15, r15
    16b8:	a9 f0       	breq	.+42     	; 0x16e4 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    16ba:	b6 01       	movw	r22, r12
    16bc:	c8 01       	movw	r24, r16
    16be:	0e 94 98 09 	call	0x1330	; 0x1330 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    16c2:	fa 94       	dec	r15
    16c4:	f8 01       	movw	r30, r16
    16c6:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16c8:	80 85       	ldd	r24, Z+8	; 0x08
    16ca:	88 23       	and	r24, r24
    16cc:	39 f0       	breq	.+14     	; 0x16dc <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16ce:	c8 01       	movw	r24, r16
    16d0:	08 96       	adiw	r24, 0x08	; 8
    16d2:	0e 94 48 06 	call	0xc90	; 0xc90 <xTaskRemoveFromEventList>
    16d6:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    16d8:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    16dc:	0f 90       	pop	r0
    16de:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    16e0:	81 e0       	ldi	r24, 0x01	; 1
    16e2:	50 c0       	rjmp	.+160    	; 0x1784 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    16e4:	2c 81       	ldd	r18, Y+4	; 0x04
    16e6:	3d 81       	ldd	r19, Y+5	; 0x05
    16e8:	23 2b       	or	r18, r19
    16ea:	19 f4       	brne	.+6      	; 0x16f2 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    16ec:	0f 90       	pop	r0
    16ee:	0f be       	out	0x3f, r0	; 63
    16f0:	48 c0       	rjmp	.+144    	; 0x1782 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    16f2:	81 11       	cpse	r24, r1
    16f4:	04 c0       	rjmp	.+8      	; 0x16fe <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    16f6:	ce 01       	movw	r24, r28
    16f8:	01 96       	adiw	r24, 0x01	; 1
    16fa:	0e 94 ca 06 	call	0xd94	; 0xd94 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    16fe:	0f 90       	pop	r0
    1700:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1702:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1706:	0f b6       	in	r0, 0x3f	; 63
    1708:	f8 94       	cli
    170a:	0f 92       	push	r0
    170c:	f8 01       	movw	r30, r16
    170e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1710:	8f 3f       	cpi	r24, 0xFF	; 255
    1712:	09 f4       	brne	.+2      	; 0x1716 <xQueueReceive+0x98>
    1714:	15 8e       	std	Z+29, r1	; 0x1d
    1716:	f8 01       	movw	r30, r16
    1718:	86 8d       	ldd	r24, Z+30	; 0x1e
    171a:	8f 3f       	cpi	r24, 0xFF	; 255
    171c:	09 f4       	brne	.+2      	; 0x1720 <xQueueReceive+0xa2>
    171e:	16 8e       	std	Z+30, r1	; 0x1e
    1720:	0f 90       	pop	r0
    1722:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1724:	be 01       	movw	r22, r28
    1726:	6c 5f       	subi	r22, 0xFC	; 252
    1728:	7f 4f       	sbci	r23, 0xFF	; 255
    172a:	ce 01       	movw	r24, r28
    172c:	01 96       	adiw	r24, 0x01	; 1
    172e:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskCheckForTimeOut>
    1732:	81 11       	cpse	r24, r1
    1734:	1c c0       	rjmp	.+56     	; 0x176e <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1736:	c8 01       	movw	r24, r16
    1738:	0e 94 45 09 	call	0x128a	; 0x128a <prvIsQueueEmpty>
    173c:	88 23       	and	r24, r24
    173e:	89 f0       	breq	.+34     	; 0x1762 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1740:	6c 81       	ldd	r22, Y+4	; 0x04
    1742:	7d 81       	ldd	r23, Y+5	; 0x05
    1744:	c5 01       	movw	r24, r10
    1746:	0e 94 1f 06 	call	0xc3e	; 0xc3e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    174a:	c8 01       	movw	r24, r16
    174c:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1750:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>
    1754:	88 23       	and	r24, r24
    1756:	11 f0       	breq	.+4      	; 0x175c <xQueueReceive+0xde>
    1758:	81 e0       	ldi	r24, 0x01	; 1
    175a:	a8 cf       	rjmp	.-176    	; 0x16ac <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    175c:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
    1760:	fb cf       	rjmp	.-10     	; 0x1758 <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1762:	c8 01       	movw	r24, r16
    1764:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1768:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>
    176c:	f5 cf       	rjmp	.-22     	; 0x1758 <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    176e:	c8 01       	movw	r24, r16
    1770:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1774:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1778:	c8 01       	movw	r24, r16
    177a:	0e 94 45 09 	call	0x128a	; 0x128a <prvIsQueueEmpty>
    177e:	88 23       	and	r24, r24
    1780:	59 f3       	breq	.-42     	; 0x1758 <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1782:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1784:	0f 90       	pop	r0
    1786:	0f 90       	pop	r0
    1788:	0f 90       	pop	r0
    178a:	0f 90       	pop	r0
    178c:	0f 90       	pop	r0
    178e:	df 91       	pop	r29
    1790:	cf 91       	pop	r28
    1792:	1f 91       	pop	r17
    1794:	0f 91       	pop	r16
    1796:	ff 90       	pop	r15
    1798:	df 90       	pop	r13
    179a:	cf 90       	pop	r12
    179c:	bf 90       	pop	r11
    179e:	af 90       	pop	r10
    17a0:	08 95       	ret

000017a2 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    17a2:	ef 92       	push	r14
    17a4:	ff 92       	push	r15
    17a6:	0f 93       	push	r16
    17a8:	1f 93       	push	r17
    17aa:	cf 93       	push	r28
    17ac:	df 93       	push	r29
    17ae:	00 d0       	rcall	.+0      	; 0x17b0 <xQueueSemaphoreTake+0xe>
    17b0:	00 d0       	rcall	.+0      	; 0x17b2 <xQueueSemaphoreTake+0x10>
    17b2:	1f 92       	push	r1
    17b4:	cd b7       	in	r28, 0x3d	; 61
    17b6:	de b7       	in	r29, 0x3e	; 62
    17b8:	8c 01       	movw	r16, r24
    17ba:	7d 83       	std	Y+5, r23	; 0x05
    17bc:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    17be:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17c0:	78 01       	movw	r14, r16
    17c2:	81 e1       	ldi	r24, 0x11	; 17
    17c4:	e8 0e       	add	r14, r24
    17c6:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    17c8:	0f b6       	in	r0, 0x3f	; 63
    17ca:	f8 94       	cli
    17cc:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    17ce:	f8 01       	movw	r30, r16
    17d0:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    17d2:	88 23       	and	r24, r24
    17d4:	81 f0       	breq	.+32     	; 0x17f6 <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    17d6:	81 50       	subi	r24, 0x01	; 1
    17d8:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17da:	80 85       	ldd	r24, Z+8	; 0x08
    17dc:	88 23       	and	r24, r24
    17de:	39 f0       	breq	.+14     	; 0x17ee <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17e0:	c8 01       	movw	r24, r16
    17e2:	08 96       	adiw	r24, 0x08	; 8
    17e4:	0e 94 48 06 	call	0xc90	; 0xc90 <xTaskRemoveFromEventList>
    17e8:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    17ea:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    17ee:	0f 90       	pop	r0
    17f0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    17f2:	81 e0       	ldi	r24, 0x01	; 1
    17f4:	50 c0       	rjmp	.+160    	; 0x1896 <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    17f6:	2c 81       	ldd	r18, Y+4	; 0x04
    17f8:	3d 81       	ldd	r19, Y+5	; 0x05
    17fa:	23 2b       	or	r18, r19
    17fc:	19 f4       	brne	.+6      	; 0x1804 <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    17fe:	0f 90       	pop	r0
    1800:	0f be       	out	0x3f, r0	; 63
    1802:	48 c0       	rjmp	.+144    	; 0x1894 <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1804:	91 11       	cpse	r25, r1
    1806:	04 c0       	rjmp	.+8      	; 0x1810 <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1808:	ce 01       	movw	r24, r28
    180a:	01 96       	adiw	r24, 0x01	; 1
    180c:	0e 94 ca 06 	call	0xd94	; 0xd94 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1810:	0f 90       	pop	r0
    1812:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1814:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1818:	0f b6       	in	r0, 0x3f	; 63
    181a:	f8 94       	cli
    181c:	0f 92       	push	r0
    181e:	f8 01       	movw	r30, r16
    1820:	85 8d       	ldd	r24, Z+29	; 0x1d
    1822:	8f 3f       	cpi	r24, 0xFF	; 255
    1824:	09 f4       	brne	.+2      	; 0x1828 <xQueueSemaphoreTake+0x86>
    1826:	15 8e       	std	Z+29, r1	; 0x1d
    1828:	f8 01       	movw	r30, r16
    182a:	86 8d       	ldd	r24, Z+30	; 0x1e
    182c:	8f 3f       	cpi	r24, 0xFF	; 255
    182e:	09 f4       	brne	.+2      	; 0x1832 <xQueueSemaphoreTake+0x90>
    1830:	16 8e       	std	Z+30, r1	; 0x1e
    1832:	0f 90       	pop	r0
    1834:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1836:	be 01       	movw	r22, r28
    1838:	6c 5f       	subi	r22, 0xFC	; 252
    183a:	7f 4f       	sbci	r23, 0xFF	; 255
    183c:	ce 01       	movw	r24, r28
    183e:	01 96       	adiw	r24, 0x01	; 1
    1840:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskCheckForTimeOut>
    1844:	81 11       	cpse	r24, r1
    1846:	1c c0       	rjmp	.+56     	; 0x1880 <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1848:	c8 01       	movw	r24, r16
    184a:	0e 94 45 09 	call	0x128a	; 0x128a <prvIsQueueEmpty>
    184e:	88 23       	and	r24, r24
    1850:	89 f0       	breq	.+34     	; 0x1874 <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1852:	6c 81       	ldd	r22, Y+4	; 0x04
    1854:	7d 81       	ldd	r23, Y+5	; 0x05
    1856:	c7 01       	movw	r24, r14
    1858:	0e 94 1f 06 	call	0xc3e	; 0xc3e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    185c:	c8 01       	movw	r24, r16
    185e:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1862:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>
    1866:	88 23       	and	r24, r24
    1868:	11 f0       	breq	.+4      	; 0x186e <xQueueSemaphoreTake+0xcc>
    186a:	91 e0       	ldi	r25, 0x01	; 1
    186c:	ad cf       	rjmp	.-166    	; 0x17c8 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    186e:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
    1872:	fb cf       	rjmp	.-10     	; 0x186a <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1874:	c8 01       	movw	r24, r16
    1876:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    187a:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>
    187e:	f5 cf       	rjmp	.-22     	; 0x186a <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1880:	c8 01       	movw	r24, r16
    1882:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1886:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    188a:	c8 01       	movw	r24, r16
    188c:	0e 94 45 09 	call	0x128a	; 0x128a <prvIsQueueEmpty>
    1890:	88 23       	and	r24, r24
    1892:	59 f3       	breq	.-42     	; 0x186a <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1894:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1896:	0f 90       	pop	r0
    1898:	0f 90       	pop	r0
    189a:	0f 90       	pop	r0
    189c:	0f 90       	pop	r0
    189e:	0f 90       	pop	r0
    18a0:	df 91       	pop	r29
    18a2:	cf 91       	pop	r28
    18a4:	1f 91       	pop	r17
    18a6:	0f 91       	pop	r16
    18a8:	ff 90       	pop	r15
    18aa:	ef 90       	pop	r14
    18ac:	08 95       	ret

000018ae <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    18ae:	cf 92       	push	r12
    18b0:	df 92       	push	r13
    18b2:	ef 92       	push	r14
    18b4:	ff 92       	push	r15
    18b6:	0f 93       	push	r16
    18b8:	1f 93       	push	r17
    18ba:	cf 93       	push	r28
    18bc:	df 93       	push	r29
    18be:	00 d0       	rcall	.+0      	; 0x18c0 <xQueuePeek+0x12>
    18c0:	00 d0       	rcall	.+0      	; 0x18c2 <xQueuePeek+0x14>
    18c2:	1f 92       	push	r1
    18c4:	cd b7       	in	r28, 0x3d	; 61
    18c6:	de b7       	in	r29, 0x3e	; 62
    18c8:	8c 01       	movw	r16, r24
    18ca:	7b 01       	movw	r14, r22
    18cc:	5d 83       	std	Y+5, r21	; 0x05
    18ce:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    18d0:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18d2:	68 01       	movw	r12, r16
    18d4:	91 e1       	ldi	r25, 0x11	; 17
    18d6:	c9 0e       	add	r12, r25
    18d8:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    18da:	0f b6       	in	r0, 0x3f	; 63
    18dc:	f8 94       	cli
    18de:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    18e0:	f8 01       	movw	r30, r16
    18e2:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    18e4:	99 23       	and	r25, r25
    18e6:	b9 f0       	breq	.+46     	; 0x1916 <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    18e8:	c6 80       	ldd	r12, Z+6	; 0x06
    18ea:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    18ec:	b7 01       	movw	r22, r14
    18ee:	c8 01       	movw	r24, r16
    18f0:	0e 94 98 09 	call	0x1330	; 0x1330 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    18f4:	f8 01       	movw	r30, r16
    18f6:	d7 82       	std	Z+7, r13	; 0x07
    18f8:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18fa:	81 89       	ldd	r24, Z+17	; 0x11
    18fc:	88 23       	and	r24, r24
    18fe:	39 f0       	breq	.+14     	; 0x190e <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1900:	c8 01       	movw	r24, r16
    1902:	41 96       	adiw	r24, 0x11	; 17
    1904:	0e 94 48 06 	call	0xc90	; 0xc90 <xTaskRemoveFromEventList>
    1908:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    190a:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    190e:	0f 90       	pop	r0
    1910:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1912:	81 e0       	ldi	r24, 0x01	; 1
    1914:	50 c0       	rjmp	.+160    	; 0x19b6 <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1916:	2c 81       	ldd	r18, Y+4	; 0x04
    1918:	3d 81       	ldd	r19, Y+5	; 0x05
    191a:	23 2b       	or	r18, r19
    191c:	19 f4       	brne	.+6      	; 0x1924 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    191e:	0f 90       	pop	r0
    1920:	0f be       	out	0x3f, r0	; 63
    1922:	48 c0       	rjmp	.+144    	; 0x19b4 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1924:	81 11       	cpse	r24, r1
    1926:	04 c0       	rjmp	.+8      	; 0x1930 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1928:	ce 01       	movw	r24, r28
    192a:	01 96       	adiw	r24, 0x01	; 1
    192c:	0e 94 ca 06 	call	0xd94	; 0xd94 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1930:	0f 90       	pop	r0
    1932:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1934:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1938:	0f b6       	in	r0, 0x3f	; 63
    193a:	f8 94       	cli
    193c:	0f 92       	push	r0
    193e:	f8 01       	movw	r30, r16
    1940:	85 8d       	ldd	r24, Z+29	; 0x1d
    1942:	8f 3f       	cpi	r24, 0xFF	; 255
    1944:	09 f4       	brne	.+2      	; 0x1948 <xQueuePeek+0x9a>
    1946:	15 8e       	std	Z+29, r1	; 0x1d
    1948:	f8 01       	movw	r30, r16
    194a:	86 8d       	ldd	r24, Z+30	; 0x1e
    194c:	8f 3f       	cpi	r24, 0xFF	; 255
    194e:	09 f4       	brne	.+2      	; 0x1952 <xQueuePeek+0xa4>
    1950:	16 8e       	std	Z+30, r1	; 0x1e
    1952:	0f 90       	pop	r0
    1954:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1956:	be 01       	movw	r22, r28
    1958:	6c 5f       	subi	r22, 0xFC	; 252
    195a:	7f 4f       	sbci	r23, 0xFF	; 255
    195c:	ce 01       	movw	r24, r28
    195e:	01 96       	adiw	r24, 0x01	; 1
    1960:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskCheckForTimeOut>
    1964:	81 11       	cpse	r24, r1
    1966:	1c c0       	rjmp	.+56     	; 0x19a0 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1968:	c8 01       	movw	r24, r16
    196a:	0e 94 45 09 	call	0x128a	; 0x128a <prvIsQueueEmpty>
    196e:	88 23       	and	r24, r24
    1970:	89 f0       	breq	.+34     	; 0x1994 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1972:	6c 81       	ldd	r22, Y+4	; 0x04
    1974:	7d 81       	ldd	r23, Y+5	; 0x05
    1976:	c6 01       	movw	r24, r12
    1978:	0e 94 1f 06 	call	0xc3e	; 0xc3e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    197c:	c8 01       	movw	r24, r16
    197e:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1982:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>
    1986:	88 23       	and	r24, r24
    1988:	11 f0       	breq	.+4      	; 0x198e <xQueuePeek+0xe0>
    198a:	81 e0       	ldi	r24, 0x01	; 1
    198c:	a6 cf       	rjmp	.-180    	; 0x18da <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    198e:	0e 94 74 11 	call	0x22e8	; 0x22e8 <vPortYield>
    1992:	fb cf       	rjmp	.-10     	; 0x198a <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1994:	c8 01       	movw	r24, r16
    1996:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    199a:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>
    199e:	f5 cf       	rjmp	.-22     	; 0x198a <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    19a0:	c8 01       	movw	r24, r16
    19a2:	0e 94 b2 09 	call	0x1364	; 0x1364 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19a6:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    19aa:	c8 01       	movw	r24, r16
    19ac:	0e 94 45 09 	call	0x128a	; 0x128a <prvIsQueueEmpty>
    19b0:	88 23       	and	r24, r24
    19b2:	59 f3       	breq	.-42     	; 0x198a <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    19b4:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    19b6:	0f 90       	pop	r0
    19b8:	0f 90       	pop	r0
    19ba:	0f 90       	pop	r0
    19bc:	0f 90       	pop	r0
    19be:	0f 90       	pop	r0
    19c0:	df 91       	pop	r29
    19c2:	cf 91       	pop	r28
    19c4:	1f 91       	pop	r17
    19c6:	0f 91       	pop	r16
    19c8:	ff 90       	pop	r15
    19ca:	ef 90       	pop	r14
    19cc:	df 90       	pop	r13
    19ce:	cf 90       	pop	r12
    19d0:	08 95       	ret

000019d2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    19d2:	ef 92       	push	r14
    19d4:	ff 92       	push	r15
    19d6:	0f 93       	push	r16
    19d8:	1f 93       	push	r17
    19da:	cf 93       	push	r28
    19dc:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    19de:	fc 01       	movw	r30, r24
    19e0:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    19e2:	00 23       	and	r16, r16
    19e4:	e9 f0       	breq	.+58     	; 0x1a20 <xQueueReceiveFromISR+0x4e>
    19e6:	7a 01       	movw	r14, r20
    19e8:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    19ea:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    19ec:	0e 94 98 09 	call	0x1330	; 0x1330 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    19f0:	01 50       	subi	r16, 0x01	; 1
    19f2:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    19f4:	1f 3f       	cpi	r17, 0xFF	; 255
    19f6:	81 f4       	brne	.+32     	; 0x1a18 <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    19f8:	88 85       	ldd	r24, Y+8	; 0x08
    19fa:	88 23       	and	r24, r24
    19fc:	79 f0       	breq	.+30     	; 0x1a1c <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    19fe:	ce 01       	movw	r24, r28
    1a00:	08 96       	adiw	r24, 0x08	; 8
    1a02:	0e 94 48 06 	call	0xc90	; 0xc90 <xTaskRemoveFromEventList>
    1a06:	88 23       	and	r24, r24
    1a08:	49 f0       	breq	.+18     	; 0x1a1c <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1a0a:	e1 14       	cp	r14, r1
    1a0c:	f1 04       	cpc	r15, r1
    1a0e:	31 f0       	breq	.+12     	; 0x1a1c <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1a10:	81 e0       	ldi	r24, 0x01	; 1
    1a12:	f7 01       	movw	r30, r14
    1a14:	80 83       	st	Z, r24
    1a16:	05 c0       	rjmp	.+10     	; 0x1a22 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1a18:	1f 5f       	subi	r17, 0xFF	; 255
    1a1a:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1a1c:	81 e0       	ldi	r24, 0x01	; 1
    1a1e:	01 c0       	rjmp	.+2      	; 0x1a22 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1a20:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a22:	df 91       	pop	r29
    1a24:	cf 91       	pop	r28
    1a26:	1f 91       	pop	r17
    1a28:	0f 91       	pop	r16
    1a2a:	ff 90       	pop	r15
    1a2c:	ef 90       	pop	r14
    1a2e:	08 95       	ret

00001a30 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1a30:	0f 93       	push	r16
    1a32:	1f 93       	push	r17
    1a34:	cf 93       	push	r28
    1a36:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a38:	fc 01       	movw	r30, r24
    1a3a:	22 8d       	ldd	r18, Z+26	; 0x1a
    1a3c:	22 23       	and	r18, r18
    1a3e:	49 f0       	breq	.+18     	; 0x1a52 <xQueuePeekFromISR+0x22>
    1a40:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1a42:	06 81       	ldd	r16, Z+6	; 0x06
    1a44:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a46:	0e 94 98 09 	call	0x1330	; 0x1330 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1a4a:	1f 83       	std	Y+7, r17	; 0x07
    1a4c:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1a4e:	81 e0       	ldi	r24, 0x01	; 1
    1a50:	01 c0       	rjmp	.+2      	; 0x1a54 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1a52:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a54:	df 91       	pop	r29
    1a56:	cf 91       	pop	r28
    1a58:	1f 91       	pop	r17
    1a5a:	0f 91       	pop	r16
    1a5c:	08 95       	ret

00001a5e <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1a5e:	0f b6       	in	r0, 0x3f	; 63
    1a60:	f8 94       	cli
    1a62:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1a64:	fc 01       	movw	r30, r24
    1a66:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1a68:	0f 90       	pop	r0
    1a6a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a6c:	08 95       	ret

00001a6e <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1a6e:	0f b6       	in	r0, 0x3f	; 63
    1a70:	f8 94       	cli
    1a72:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1a74:	fc 01       	movw	r30, r24
    1a76:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1a78:	0f 90       	pop	r0
    1a7a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1a7c:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a7e:	82 1b       	sub	r24, r18
    1a80:	08 95       	ret

00001a82 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1a82:	fc 01       	movw	r30, r24
    1a84:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a86:	08 95       	ret

00001a88 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1a88:	0c 94 b8 10 	jmp	0x2170	; 0x2170 <vPortFree>

00001a8c <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1a8c:	fc 01       	movw	r30, r24
    1a8e:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1a90:	81 e0       	ldi	r24, 0x01	; 1
    1a92:	91 11       	cpse	r25, r1
    1a94:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1a96:	08 95       	ret

00001a98 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1a98:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1a9a:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1a9c:	81 e0       	ldi	r24, 0x01	; 1
    1a9e:	23 8d       	ldd	r18, Z+27	; 0x1b
    1aa0:	29 13       	cpse	r18, r25
    1aa2:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1aa4:	08 95       	ret

00001aa6 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1aa6:	cf 93       	push	r28
    1aa8:	df 93       	push	r29
    1aaa:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1aac:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1aae:	0f b6       	in	r0, 0x3f	; 63
    1ab0:	f8 94       	cli
    1ab2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1ab4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ab6:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1ab8:	0f 90       	pop	r0
    1aba:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1abc:	89 13       	cpse	r24, r25
    1abe:	0f c0       	rjmp	.+30     	; 0x1ade <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1ac0:	41 15       	cp	r20, r1
    1ac2:	51 05       	cpc	r21, r1
    1ac4:	49 f0       	breq	.+18     	; 0x1ad8 <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1ac6:	be 01       	movw	r22, r28
    1ac8:	68 5f       	subi	r22, 0xF8	; 248
    1aca:	7f 4f       	sbci	r23, 0xFF	; 255
    1acc:	ca 01       	movw	r24, r20
    1ace:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1ad2:	78 94       	sei
					return errQUEUE_BLOCKED;
    1ad4:	8c ef       	ldi	r24, 0xFC	; 252
    1ad6:	1b c0       	rjmp	.+54     	; 0x1b0e <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1ad8:	78 94       	sei
					return errQUEUE_FULL;
    1ada:	80 e0       	ldi	r24, 0x00	; 0
    1adc:	18 c0       	rjmp	.+48     	; 0x1b0e <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1ade:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1ae0:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1ae2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ae4:	89 17       	cp	r24, r25
    1ae6:	88 f4       	brcc	.+34     	; 0x1b0a <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1ae8:	40 e0       	ldi	r20, 0x00	; 0
    1aea:	ce 01       	movw	r24, r28
    1aec:	0e 94 50 09 	call	0x12a0	; 0x12a0 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1af0:	89 89       	ldd	r24, Y+17	; 0x11
    1af2:	81 11       	cpse	r24, r1
    1af4:	02 c0       	rjmp	.+4      	; 0x1afa <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1af6:	81 e0       	ldi	r24, 0x01	; 1
    1af8:	09 c0       	rjmp	.+18     	; 0x1b0c <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1afa:	ce 01       	movw	r24, r28
    1afc:	41 96       	adiw	r24, 0x11	; 17
    1afe:	0e 94 61 10 	call	0x20c2	; 0x20c2 <xCoRoutineRemoveFromEventList>
    1b02:	88 23       	and	r24, r24
    1b04:	c1 f3       	breq	.-16     	; 0x1af6 <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1b06:	8b ef       	ldi	r24, 0xFB	; 251
    1b08:	01 c0       	rjmp	.+2      	; 0x1b0c <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1b0a:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1b0c:	78 94       	sei

		return xReturn;
	}
    1b0e:	df 91       	pop	r29
    1b10:	cf 91       	pop	r28
    1b12:	08 95       	ret

00001b14 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1b14:	cf 93       	push	r28
    1b16:	df 93       	push	r29
    1b18:	ec 01       	movw	r28, r24
    1b1a:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1b1c:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1b1e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b20:	81 11       	cpse	r24, r1
    1b22:	0f c0       	rjmp	.+30     	; 0x1b42 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1b24:	41 15       	cp	r20, r1
    1b26:	51 05       	cpc	r21, r1
    1b28:	49 f0       	breq	.+18     	; 0x1b3c <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1b2a:	be 01       	movw	r22, r28
    1b2c:	6f 5e       	subi	r22, 0xEF	; 239
    1b2e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b30:	ca 01       	movw	r24, r20
    1b32:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1b36:	78 94       	sei
					return errQUEUE_BLOCKED;
    1b38:	8c ef       	ldi	r24, 0xFC	; 252
    1b3a:	30 c0       	rjmp	.+96     	; 0x1b9c <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1b3c:	78 94       	sei
					return errQUEUE_FULL;
    1b3e:	80 e0       	ldi	r24, 0x00	; 0
    1b40:	2d c0       	rjmp	.+90     	; 0x1b9c <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1b42:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1b44:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b46:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b48:	88 23       	and	r24, r24
    1b4a:	31 f1       	breq	.+76     	; 0x1b98 <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1b4c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1b4e:	50 e0       	ldi	r21, 0x00	; 0
    1b50:	2e 81       	ldd	r18, Y+6	; 0x06
    1b52:	3f 81       	ldd	r19, Y+7	; 0x07
    1b54:	24 0f       	add	r18, r20
    1b56:	35 1f       	adc	r19, r21
    1b58:	3f 83       	std	Y+7, r19	; 0x07
    1b5a:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1b5c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b5e:	9d 81       	ldd	r25, Y+5	; 0x05
    1b60:	28 17       	cp	r18, r24
    1b62:	39 07       	cpc	r19, r25
    1b64:	20 f0       	brcs	.+8      	; 0x1b6e <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1b66:	88 81       	ld	r24, Y
    1b68:	99 81       	ldd	r25, Y+1	; 0x01
    1b6a:	9f 83       	std	Y+7, r25	; 0x07
    1b6c:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1b6e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1b70:	91 50       	subi	r25, 0x01	; 1
    1b72:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1b74:	6e 81       	ldd	r22, Y+6	; 0x06
    1b76:	7f 81       	ldd	r23, Y+7	; 0x07
    1b78:	cf 01       	movw	r24, r30
    1b7a:	0e 94 7f 12 	call	0x24fe	; 0x24fe <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b7e:	88 85       	ldd	r24, Y+8	; 0x08
    1b80:	81 11       	cpse	r24, r1
    1b82:	02 c0       	rjmp	.+4      	; 0x1b88 <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1b84:	81 e0       	ldi	r24, 0x01	; 1
    1b86:	09 c0       	rjmp	.+18     	; 0x1b9a <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b88:	ce 01       	movw	r24, r28
    1b8a:	08 96       	adiw	r24, 0x08	; 8
    1b8c:	0e 94 61 10 	call	0x20c2	; 0x20c2 <xCoRoutineRemoveFromEventList>
    1b90:	88 23       	and	r24, r24
    1b92:	c1 f3       	breq	.-16     	; 0x1b84 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1b94:	8b ef       	ldi	r24, 0xFB	; 251
    1b96:	01 c0       	rjmp	.+2      	; 0x1b9a <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1b98:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1b9a:	78 94       	sei

		return xReturn;
	}
    1b9c:	df 91       	pop	r29
    1b9e:	cf 91       	pop	r28
    1ba0:	08 95       	ret

00001ba2 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1ba2:	0f 93       	push	r16
    1ba4:	1f 93       	push	r17
    1ba6:	cf 93       	push	r28
    1ba8:	8c 01       	movw	r16, r24
    1baa:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1bac:	fc 01       	movw	r30, r24
    1bae:	92 8d       	ldd	r25, Z+26	; 0x1a
    1bb0:	83 8d       	ldd	r24, Z+27	; 0x1b
    1bb2:	98 17       	cp	r25, r24
    1bb4:	10 f0       	brcs	.+4      	; 0x1bba <xQueueCRSendFromISR+0x18>
    1bb6:	4c 2f       	mov	r20, r28
    1bb8:	12 c0       	rjmp	.+36     	; 0x1bde <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1bba:	40 e0       	ldi	r20, 0x00	; 0
    1bbc:	c8 01       	movw	r24, r16
    1bbe:	0e 94 50 09 	call	0x12a0	; 0x12a0 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1bc2:	c1 11       	cpse	r28, r1
    1bc4:	f8 cf       	rjmp	.-16     	; 0x1bb6 <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1bc6:	f8 01       	movw	r30, r16
    1bc8:	81 89       	ldd	r24, Z+17	; 0x11
    1bca:	88 23       	and	r24, r24
    1bcc:	39 f0       	breq	.+14     	; 0x1bdc <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1bce:	c8 01       	movw	r24, r16
    1bd0:	41 96       	adiw	r24, 0x11	; 17
    1bd2:	0e 94 61 10 	call	0x20c2	; 0x20c2 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1bd6:	41 e0       	ldi	r20, 0x01	; 1
    1bd8:	81 11       	cpse	r24, r1
    1bda:	01 c0       	rjmp	.+2      	; 0x1bde <xQueueCRSendFromISR+0x3c>
    1bdc:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1bde:	84 2f       	mov	r24, r20
    1be0:	cf 91       	pop	r28
    1be2:	1f 91       	pop	r17
    1be4:	0f 91       	pop	r16
    1be6:	08 95       	ret

00001be8 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1be8:	0f 93       	push	r16
    1bea:	1f 93       	push	r17
    1bec:	cf 93       	push	r28
    1bee:	df 93       	push	r29
    1bf0:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1bf2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bf4:	88 23       	and	r24, r24
    1bf6:	79 f1       	breq	.+94     	; 0x1c56 <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1bf8:	24 8d       	ldd	r18, Z+28	; 0x1c
    1bfa:	30 e0       	ldi	r19, 0x00	; 0
    1bfc:	a6 81       	ldd	r26, Z+6	; 0x06
    1bfe:	b7 81       	ldd	r27, Z+7	; 0x07
    1c00:	a2 0f       	add	r26, r18
    1c02:	b3 1f       	adc	r27, r19
    1c04:	b7 83       	std	Z+7, r27	; 0x07
    1c06:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1c08:	84 81       	ldd	r24, Z+4	; 0x04
    1c0a:	95 81       	ldd	r25, Z+5	; 0x05
    1c0c:	a8 17       	cp	r26, r24
    1c0e:	b9 07       	cpc	r27, r25
    1c10:	20 f0       	brcs	.+8      	; 0x1c1a <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1c12:	80 81       	ld	r24, Z
    1c14:	91 81       	ldd	r25, Z+1	; 0x01
    1c16:	97 83       	std	Z+7, r25	; 0x07
    1c18:	86 83       	std	Z+6, r24	; 0x06
    1c1a:	8a 01       	movw	r16, r20
    1c1c:	cb 01       	movw	r24, r22
    1c1e:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1c20:	42 8d       	ldd	r20, Z+26	; 0x1a
    1c22:	41 50       	subi	r20, 0x01	; 1
    1c24:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1c26:	66 81       	ldd	r22, Z+6	; 0x06
    1c28:	77 81       	ldd	r23, Z+7	; 0x07
    1c2a:	a9 01       	movw	r20, r18
    1c2c:	0e 94 7f 12 	call	0x24fe	; 0x24fe <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1c30:	f8 01       	movw	r30, r16
    1c32:	80 81       	ld	r24, Z
    1c34:	88 23       	and	r24, r24
    1c36:	11 f0       	breq	.+4      	; 0x1c3c <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1c38:	81 e0       	ldi	r24, 0x01	; 1
    1c3a:	0e c0       	rjmp	.+28     	; 0x1c58 <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c3c:	88 85       	ldd	r24, Y+8	; 0x08
    1c3e:	88 23       	and	r24, r24
    1c40:	d9 f3       	breq	.-10     	; 0x1c38 <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c42:	ce 01       	movw	r24, r28
    1c44:	08 96       	adiw	r24, 0x08	; 8
    1c46:	0e 94 61 10 	call	0x20c2	; 0x20c2 <xCoRoutineRemoveFromEventList>
    1c4a:	88 23       	and	r24, r24
    1c4c:	a9 f3       	breq	.-22     	; 0x1c38 <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1c4e:	81 e0       	ldi	r24, 0x01	; 1
    1c50:	f8 01       	movw	r30, r16
    1c52:	80 83       	st	Z, r24
    1c54:	01 c0       	rjmp	.+2      	; 0x1c58 <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1c56:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1c58:	df 91       	pop	r29
    1c5a:	cf 91       	pop	r28
    1c5c:	1f 91       	pop	r17
    1c5e:	0f 91       	pop	r16
    1c60:	08 95       	ret

00001c62 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1c62:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c64:	03 96       	adiw	r24, 0x03	; 3
    1c66:	92 83       	std	Z+2, r25	; 0x02
    1c68:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1c6a:	2f ef       	ldi	r18, 0xFF	; 255
    1c6c:	3f ef       	ldi	r19, 0xFF	; 255
    1c6e:	34 83       	std	Z+4, r19	; 0x04
    1c70:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c72:	96 83       	std	Z+6, r25	; 0x06
    1c74:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c76:	90 87       	std	Z+8, r25	; 0x08
    1c78:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1c7a:	10 82       	st	Z, r1
    1c7c:	08 95       	ret

00001c7e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1c7e:	fc 01       	movw	r30, r24
    1c80:	11 86       	std	Z+9, r1	; 0x09
    1c82:	10 86       	std	Z+8, r1	; 0x08
    1c84:	08 95       	ret

00001c86 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c86:	cf 93       	push	r28
    1c88:	df 93       	push	r29
    1c8a:	9c 01       	movw	r18, r24
    1c8c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1c8e:	dc 01       	movw	r26, r24
    1c90:	11 96       	adiw	r26, 0x01	; 1
    1c92:	cd 91       	ld	r28, X+
    1c94:	dc 91       	ld	r29, X
    1c96:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1c98:	d3 83       	std	Z+3, r29	; 0x03
    1c9a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1c9c:	8c 81       	ldd	r24, Y+4	; 0x04
    1c9e:	9d 81       	ldd	r25, Y+5	; 0x05
    1ca0:	95 83       	std	Z+5, r25	; 0x05
    1ca2:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1ca4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ca6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ca8:	dc 01       	movw	r26, r24
    1caa:	13 96       	adiw	r26, 0x03	; 3
    1cac:	7c 93       	st	X, r23
    1cae:	6e 93       	st	-X, r22
    1cb0:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1cb2:	7d 83       	std	Y+5, r23	; 0x05
    1cb4:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1cb6:	31 87       	std	Z+9, r19	; 0x09
    1cb8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1cba:	f9 01       	movw	r30, r18
    1cbc:	80 81       	ld	r24, Z
    1cbe:	8f 5f       	subi	r24, 0xFF	; 255
    1cc0:	80 83       	st	Z, r24
}
    1cc2:	df 91       	pop	r29
    1cc4:	cf 91       	pop	r28
    1cc6:	08 95       	ret

00001cc8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1cc8:	0f 93       	push	r16
    1cca:	1f 93       	push	r17
    1ccc:	cf 93       	push	r28
    1cce:	df 93       	push	r29
    1cd0:	8c 01       	movw	r16, r24
    1cd2:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1cd4:	80 81       	ld	r24, Z
    1cd6:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1cd8:	8f 3f       	cpi	r24, 0xFF	; 255
    1cda:	2f ef       	ldi	r18, 0xFF	; 255
    1cdc:	92 07       	cpc	r25, r18
    1cde:	21 f4       	brne	.+8      	; 0x1ce8 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1ce0:	e8 01       	movw	r28, r16
    1ce2:	af 81       	ldd	r26, Y+7	; 0x07
    1ce4:	b8 85       	ldd	r27, Y+8	; 0x08
    1ce6:	0e c0       	rjmp	.+28     	; 0x1d04 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1ce8:	d8 01       	movw	r26, r16
    1cea:	13 96       	adiw	r26, 0x03	; 3
    1cec:	12 96       	adiw	r26, 0x02	; 2
    1cee:	2d 91       	ld	r18, X+
    1cf0:	3c 91       	ld	r19, X
    1cf2:	13 97       	sbiw	r26, 0x03	; 3
    1cf4:	e9 01       	movw	r28, r18
    1cf6:	48 81       	ld	r20, Y
    1cf8:	59 81       	ldd	r21, Y+1	; 0x01
    1cfa:	84 17       	cp	r24, r20
    1cfc:	95 07       	cpc	r25, r21
    1cfe:	10 f0       	brcs	.+4      	; 0x1d04 <vListInsert+0x3c>
    1d00:	d9 01       	movw	r26, r18
    1d02:	f4 cf       	rjmp	.-24     	; 0x1cec <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1d04:	12 96       	adiw	r26, 0x02	; 2
    1d06:	8d 91       	ld	r24, X+
    1d08:	9c 91       	ld	r25, X
    1d0a:	13 97       	sbiw	r26, 0x03	; 3
    1d0c:	93 83       	std	Z+3, r25	; 0x03
    1d0e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1d10:	ec 01       	movw	r28, r24
    1d12:	fd 83       	std	Y+5, r31	; 0x05
    1d14:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1d16:	b5 83       	std	Z+5, r27	; 0x05
    1d18:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1d1a:	13 96       	adiw	r26, 0x03	; 3
    1d1c:	fc 93       	st	X, r31
    1d1e:	ee 93       	st	-X, r30
    1d20:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1d22:	11 87       	std	Z+9, r17	; 0x09
    1d24:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1d26:	f8 01       	movw	r30, r16
    1d28:	80 81       	ld	r24, Z
    1d2a:	8f 5f       	subi	r24, 0xFF	; 255
    1d2c:	80 83       	st	Z, r24
}
    1d2e:	df 91       	pop	r29
    1d30:	cf 91       	pop	r28
    1d32:	1f 91       	pop	r17
    1d34:	0f 91       	pop	r16
    1d36:	08 95       	ret

00001d38 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1d38:	cf 93       	push	r28
    1d3a:	df 93       	push	r29
    1d3c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1d3e:	a0 85       	ldd	r26, Z+8	; 0x08
    1d40:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1d42:	82 81       	ldd	r24, Z+2	; 0x02
    1d44:	93 81       	ldd	r25, Z+3	; 0x03
    1d46:	24 81       	ldd	r18, Z+4	; 0x04
    1d48:	35 81       	ldd	r19, Z+5	; 0x05
    1d4a:	ec 01       	movw	r28, r24
    1d4c:	3d 83       	std	Y+5, r19	; 0x05
    1d4e:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1d50:	c4 81       	ldd	r28, Z+4	; 0x04
    1d52:	d5 81       	ldd	r29, Z+5	; 0x05
    1d54:	9b 83       	std	Y+3, r25	; 0x03
    1d56:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1d58:	11 96       	adiw	r26, 0x01	; 1
    1d5a:	8d 91       	ld	r24, X+
    1d5c:	9c 91       	ld	r25, X
    1d5e:	12 97       	sbiw	r26, 0x02	; 2
    1d60:	e8 17       	cp	r30, r24
    1d62:	f9 07       	cpc	r31, r25
    1d64:	21 f4       	brne	.+8      	; 0x1d6e <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1d66:	12 96       	adiw	r26, 0x02	; 2
    1d68:	dc 93       	st	X, r29
    1d6a:	ce 93       	st	-X, r28
    1d6c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1d6e:	11 86       	std	Z+9, r1	; 0x09
    1d70:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1d72:	8c 91       	ld	r24, X
    1d74:	81 50       	subi	r24, 0x01	; 1
    1d76:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1d78:	8c 91       	ld	r24, X
}
    1d7a:	df 91       	pop	r29
    1d7c:	cf 91       	pop	r28
    1d7e:	08 95       	ret

00001d80 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1d80:	cf 92       	push	r12
    1d82:	df 92       	push	r13
    1d84:	ef 92       	push	r14
    1d86:	ff 92       	push	r15
    1d88:	1f 93       	push	r17
    1d8a:	cf 93       	push	r28
    1d8c:	df 93       	push	r29
    1d8e:	6c 01       	movw	r12, r24
    1d90:	16 2f       	mov	r17, r22
    1d92:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1d94:	8a e1       	ldi	r24, 0x1A	; 26
    1d96:	90 e0       	ldi	r25, 0x00	; 0
    1d98:	0e 94 86 10 	call	0x210c	; 0x210c <pvPortMalloc>
    1d9c:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1d9e:	89 2b       	or	r24, r25
    1da0:	09 f4       	brne	.+2      	; 0x1da4 <xCoRoutineCreate+0x24>
    1da2:	57 c0       	rjmp	.+174    	; 0x1e52 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1da4:	80 91 86 01 	lds	r24, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    1da8:	90 91 87 01 	lds	r25, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
    1dac:	89 2b       	or	r24, r25
    1dae:	21 f5       	brne	.+72     	; 0x1df8 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1db0:	d0 93 87 01 	sts	0x0187, r29	; 0x800187 <pxCurrentCoRoutine+0x1>
    1db4:	c0 93 86 01 	sts	0x0186, r28	; 0x800186 <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1db8:	8e ea       	ldi	r24, 0xAE	; 174
    1dba:	91 e0       	ldi	r25, 0x01	; 1
    1dbc:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
    1dc0:	87 eb       	ldi	r24, 0xB7	; 183
    1dc2:	91 e0       	ldi	r25, 0x01	; 1
    1dc4:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1dc8:	85 ea       	ldi	r24, 0xA5	; 165
    1dca:	91 e0       	ldi	r25, 0x01	; 1
    1dcc:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1dd0:	8c e9       	ldi	r24, 0x9C	; 156
    1dd2:	91 e0       	ldi	r25, 0x01	; 1
    1dd4:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1dd8:	8f e8       	ldi	r24, 0x8F	; 143
    1dda:	91 e0       	ldi	r25, 0x01	; 1
    1ddc:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1de0:	85 ea       	ldi	r24, 0xA5	; 165
    1de2:	91 e0       	ldi	r25, 0x01	; 1
    1de4:	90 93 9b 01 	sts	0x019B, r25	; 0x80019b <pxDelayedCoRoutineList+0x1>
    1de8:	80 93 9a 01 	sts	0x019A, r24	; 0x80019a <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1dec:	8c e9       	ldi	r24, 0x9C	; 156
    1dee:	91 e0       	ldi	r25, 0x01	; 1
    1df0:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <pxOverflowDelayedCoRoutineList+0x1>
    1df4:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <pxOverflowDelayedCoRoutineList>
    1df8:	11 11       	cpse	r17, r1
    1dfa:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1dfc:	19 8e       	std	Y+25, r1	; 0x19
    1dfe:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1e00:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1e02:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1e04:	fe 01       	movw	r30, r28
    1e06:	c1 92       	st	Z+, r12
    1e08:	d1 92       	st	Z+, r13
    1e0a:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1e0c:	cf 01       	movw	r24, r30
    1e0e:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1e12:	ce 01       	movw	r24, r28
    1e14:	0c 96       	adiw	r24, 0x0c	; 12
    1e16:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1e1a:	d9 87       	std	Y+9, r29	; 0x09
    1e1c:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1e1e:	db 8b       	std	Y+19, r29	; 0x13
    1e20:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    1e22:	82 e0       	ldi	r24, 0x02	; 2
    1e24:	90 e0       	ldi	r25, 0x00	; 0
    1e26:	81 1b       	sub	r24, r17
    1e28:	91 09       	sbc	r25, r1
    1e2a:	9d 87       	std	Y+13, r25	; 0x0d
    1e2c:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1e2e:	8e 89       	ldd	r24, Y+22	; 0x16
    1e30:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <uxTopCoRoutineReadyPriority>
    1e34:	98 17       	cp	r25, r24
    1e36:	10 f4       	brcc	.+4      	; 0x1e3c <xCoRoutineCreate+0xbc>
    1e38:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxTopCoRoutineReadyPriority>
    1e3c:	f9 e0       	ldi	r31, 0x09	; 9
    1e3e:	8f 9f       	mul	r24, r31
    1e40:	c0 01       	movw	r24, r0
    1e42:	11 24       	eor	r1, r1
    1e44:	b7 01       	movw	r22, r14
    1e46:	82 55       	subi	r24, 0x52	; 82
    1e48:	9e 4f       	sbci	r25, 0xFE	; 254
    1e4a:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>

		xReturn = pdPASS;
    1e4e:	81 e0       	ldi	r24, 0x01	; 1
    1e50:	01 c0       	rjmp	.+2      	; 0x1e54 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1e52:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    1e54:	df 91       	pop	r29
    1e56:	cf 91       	pop	r28
    1e58:	1f 91       	pop	r17
    1e5a:	ff 90       	pop	r15
    1e5c:	ef 90       	pop	r14
    1e5e:	df 90       	pop	r13
    1e60:	cf 90       	pop	r12
    1e62:	08 95       	ret

00001e64 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    1e64:	0f 93       	push	r16
    1e66:	1f 93       	push	r17
    1e68:	cf 93       	push	r28
    1e6a:	df 93       	push	r29
    1e6c:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1e6e:	c0 91 8c 01 	lds	r28, 0x018C	; 0x80018c <xCoRoutineTickCount>
    1e72:	d0 91 8d 01 	lds	r29, 0x018D	; 0x80018d <xCoRoutineTickCount+0x1>
    1e76:	c8 0f       	add	r28, r24
    1e78:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1e7a:	80 91 86 01 	lds	r24, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    1e7e:	90 91 87 01 	lds	r25, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
    1e82:	02 96       	adiw	r24, 0x02	; 2
    1e84:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1e88:	e0 91 86 01 	lds	r30, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    1e8c:	f0 91 87 01 	lds	r31, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
    1e90:	d3 83       	std	Z+3, r29	; 0x03
    1e92:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1e94:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <xCoRoutineTickCount>
    1e98:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <xCoRoutineTickCount+0x1>
    1e9c:	bf 01       	movw	r22, r30
    1e9e:	6e 5f       	subi	r22, 0xFE	; 254
    1ea0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ea2:	c8 17       	cp	r28, r24
    1ea4:	d9 07       	cpc	r29, r25
    1ea6:	28 f4       	brcc	.+10     	; 0x1eb2 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1ea8:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <pxOverflowDelayedCoRoutineList>
    1eac:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <pxOverflowDelayedCoRoutineList+0x1>
    1eb0:	04 c0       	rjmp	.+8      	; 0x1eba <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1eb2:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <pxDelayedCoRoutineList>
    1eb6:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <pxDelayedCoRoutineList+0x1>
    1eba:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <vListInsert>
	}

	if( pxEventList )
    1ebe:	01 15       	cp	r16, r1
    1ec0:	11 05       	cpc	r17, r1
    1ec2:	69 f0       	breq	.+26     	; 0x1ede <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1ec4:	60 91 86 01 	lds	r22, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    1ec8:	70 91 87 01 	lds	r23, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
    1ecc:	64 5f       	subi	r22, 0xF4	; 244
    1ece:	7f 4f       	sbci	r23, 0xFF	; 255
    1ed0:	c8 01       	movw	r24, r16
	}
}
    1ed2:	df 91       	pop	r29
    1ed4:	cf 91       	pop	r28
    1ed6:	1f 91       	pop	r17
    1ed8:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1eda:	0c 94 64 0e 	jmp	0x1cc8	; 0x1cc8 <vListInsert>
	}
}
    1ede:	df 91       	pop	r29
    1ee0:	cf 91       	pop	r28
    1ee2:	1f 91       	pop	r17
    1ee4:	0f 91       	pop	r16
    1ee6:	08 95       	ret

00001ee8 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1ee8:	ff 92       	push	r15
    1eea:	0f 93       	push	r16
    1eec:	1f 93       	push	r17
    1eee:	cf 93       	push	r28
    1ef0:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1ef2:	99 e0       	ldi	r25, 0x09	; 9
    1ef4:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1ef6:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <xPendingReadyCoRoutineList>
    1efa:	88 23       	and	r24, r24
    1efc:	11 f1       	breq	.+68     	; 0x1f42 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1efe:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1f00:	e0 91 94 01 	lds	r30, 0x0194	; 0x800194 <xPendingReadyCoRoutineList+0x5>
    1f04:	f0 91 95 01 	lds	r31, 0x0195	; 0x800195 <xPendingReadyCoRoutineList+0x6>
    1f08:	c6 81       	ldd	r28, Z+6	; 0x06
    1f0a:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1f0c:	ce 01       	movw	r24, r28
    1f0e:	0c 96       	adiw	r24, 0x0c	; 12
    1f10:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1f14:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1f16:	8e 01       	movw	r16, r28
    1f18:	0e 5f       	subi	r16, 0xFE	; 254
    1f1a:	1f 4f       	sbci	r17, 0xFF	; 255
    1f1c:	c8 01       	movw	r24, r16
    1f1e:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1f22:	8e 89       	ldd	r24, Y+22	; 0x16
    1f24:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <uxTopCoRoutineReadyPriority>
    1f28:	98 17       	cp	r25, r24
    1f2a:	10 f4       	brcc	.+4      	; 0x1f30 <vCoRoutineSchedule+0x48>
    1f2c:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxTopCoRoutineReadyPriority>
    1f30:	f8 9e       	mul	r15, r24
    1f32:	c0 01       	movw	r24, r0
    1f34:	11 24       	eor	r1, r1
    1f36:	b8 01       	movw	r22, r16
    1f38:	82 55       	subi	r24, 0x52	; 82
    1f3a:	9e 4f       	sbci	r25, 0xFE	; 254
    1f3c:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>
    1f40:	da cf       	rjmp	.-76     	; 0x1ef6 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1f42:	0e 94 04 04 	call	0x808	; 0x808 <xTaskGetTickCount>
    1f46:	20 91 8a 01 	lds	r18, 0x018A	; 0x80018a <xLastTickCount>
    1f4a:	30 91 8b 01 	lds	r19, 0x018B	; 0x80018b <xLastTickCount+0x1>
    1f4e:	82 1b       	sub	r24, r18
    1f50:	93 0b       	sbc	r25, r19
    1f52:	90 93 89 01 	sts	0x0189, r25	; 0x800189 <xPassedTicks+0x1>
    1f56:	80 93 88 01 	sts	0x0188, r24	; 0x800188 <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1f5a:	89 e0       	ldi	r24, 0x09	; 9
    1f5c:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1f5e:	20 91 88 01 	lds	r18, 0x0188	; 0x800188 <xPassedTicks>
    1f62:	30 91 89 01 	lds	r19, 0x0189	; 0x800189 <xPassedTicks+0x1>
    1f66:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <xCoRoutineTickCount>
    1f6a:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <xCoRoutineTickCount+0x1>
    1f6e:	21 15       	cp	r18, r1
    1f70:	31 05       	cpc	r19, r1
    1f72:	09 f4       	brne	.+2      	; 0x1f76 <vCoRoutineSchedule+0x8e>
    1f74:	54 c0       	rjmp	.+168    	; 0x201e <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    1f76:	01 96       	adiw	r24, 0x01	; 1
    1f78:	90 93 8d 01 	sts	0x018D, r25	; 0x80018d <xCoRoutineTickCount+0x1>
    1f7c:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <xCoRoutineTickCount>
		xPassedTicks--;
    1f80:	21 50       	subi	r18, 0x01	; 1
    1f82:	31 09       	sbc	r19, r1
    1f84:	30 93 89 01 	sts	0x0189, r19	; 0x800189 <xPassedTicks+0x1>
    1f88:	20 93 88 01 	sts	0x0188, r18	; 0x800188 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1f8c:	89 2b       	or	r24, r25
    1f8e:	09 f0       	breq	.+2      	; 0x1f92 <vCoRoutineSchedule+0xaa>
    1f90:	3e c0       	rjmp	.+124    	; 0x200e <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1f92:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <pxDelayedCoRoutineList>
    1f96:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1f9a:	20 91 98 01 	lds	r18, 0x0198	; 0x800198 <pxOverflowDelayedCoRoutineList>
    1f9e:	30 91 99 01 	lds	r19, 0x0199	; 0x800199 <pxOverflowDelayedCoRoutineList+0x1>
    1fa2:	30 93 9b 01 	sts	0x019B, r19	; 0x80019b <pxDelayedCoRoutineList+0x1>
    1fa6:	20 93 9a 01 	sts	0x019A, r18	; 0x80019a <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    1faa:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <pxOverflowDelayedCoRoutineList+0x1>
    1fae:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <pxOverflowDelayedCoRoutineList>
    1fb2:	2d c0       	rjmp	.+90     	; 0x200e <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1fb4:	05 80       	ldd	r0, Z+5	; 0x05
    1fb6:	f6 81       	ldd	r31, Z+6	; 0x06
    1fb8:	e0 2d       	mov	r30, r0
    1fba:	c6 81       	ldd	r28, Z+6	; 0x06
    1fbc:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1fbe:	2a 81       	ldd	r18, Y+2	; 0x02
    1fc0:	3b 81       	ldd	r19, Y+3	; 0x03
    1fc2:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <xCoRoutineTickCount>
    1fc6:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <xCoRoutineTickCount+0x1>
    1fca:	82 17       	cp	r24, r18
    1fcc:	93 07       	cpc	r25, r19
    1fce:	38 f2       	brcs	.-114    	; 0x1f5e <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1fd0:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1fd2:	8e 01       	movw	r16, r28
    1fd4:	0e 5f       	subi	r16, 0xFE	; 254
    1fd6:	1f 4f       	sbci	r17, 0xFF	; 255
    1fd8:	c8 01       	movw	r24, r16
    1fda:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    1fde:	8c 89       	ldd	r24, Y+20	; 0x14
    1fe0:	9d 89       	ldd	r25, Y+21	; 0x15
    1fe2:	89 2b       	or	r24, r25
    1fe4:	21 f0       	breq	.+8      	; 0x1fee <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1fe6:	ce 01       	movw	r24, r28
    1fe8:	0c 96       	adiw	r24, 0x0c	; 12
    1fea:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1fee:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1ff0:	8e 89       	ldd	r24, Y+22	; 0x16
    1ff2:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <uxTopCoRoutineReadyPriority>
    1ff6:	98 17       	cp	r25, r24
    1ff8:	10 f4       	brcc	.+4      	; 0x1ffe <vCoRoutineSchedule+0x116>
    1ffa:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxTopCoRoutineReadyPriority>
    1ffe:	f8 9e       	mul	r15, r24
    2000:	c0 01       	movw	r24, r0
    2002:	11 24       	eor	r1, r1
    2004:	b8 01       	movw	r22, r16
    2006:	82 55       	subi	r24, 0x52	; 82
    2008:	9e 4f       	sbci	r25, 0xFE	; 254
    200a:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    200e:	e0 91 9a 01 	lds	r30, 0x019A	; 0x80019a <pxDelayedCoRoutineList>
    2012:	f0 91 9b 01 	lds	r31, 0x019B	; 0x80019b <pxDelayedCoRoutineList+0x1>
    2016:	80 81       	ld	r24, Z
    2018:	81 11       	cpse	r24, r1
    201a:	cc cf       	rjmp	.-104    	; 0x1fb4 <vCoRoutineSchedule+0xcc>
    201c:	a0 cf       	rjmp	.-192    	; 0x1f5e <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    201e:	90 93 8b 01 	sts	0x018B, r25	; 0x80018b <xLastTickCount+0x1>
    2022:	80 93 8a 01 	sts	0x018A, r24	; 0x80018a <xLastTickCount>
    2026:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    202a:	69 e0       	ldi	r22, 0x09	; 9
    202c:	48 2f       	mov	r20, r24
    202e:	50 e0       	ldi	r21, 0x00	; 0
    2030:	64 9f       	mul	r22, r20
    2032:	90 01       	movw	r18, r0
    2034:	65 9f       	mul	r22, r21
    2036:	30 0d       	add	r19, r0
    2038:	11 24       	eor	r1, r1
    203a:	f9 01       	movw	r30, r18
    203c:	e2 55       	subi	r30, 0x52	; 82
    203e:	fe 4f       	sbci	r31, 0xFE	; 254
    2040:	90 81       	ld	r25, Z
    2042:	91 11       	cpse	r25, r1
    2044:	0c c0       	rjmp	.+24     	; 0x205e <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2046:	81 11       	cpse	r24, r1
    2048:	08 c0       	rjmp	.+16     	; 0x205a <vCoRoutineSchedule+0x172>
    204a:	10 92 8e 01 	sts	0x018E, r1	; 0x80018e <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    204e:	df 91       	pop	r29
    2050:	cf 91       	pop	r28
    2052:	1f 91       	pop	r17
    2054:	0f 91       	pop	r16
    2056:	ff 90       	pop	r15
    2058:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    205a:	81 50       	subi	r24, 0x01	; 1
    205c:	e7 cf       	rjmp	.-50     	; 0x202c <vCoRoutineSchedule+0x144>
    205e:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2062:	a1 81       	ldd	r26, Z+1	; 0x01
    2064:	b2 81       	ldd	r27, Z+2	; 0x02
    2066:	12 96       	adiw	r26, 0x02	; 2
    2068:	0d 90       	ld	r0, X+
    206a:	bc 91       	ld	r27, X
    206c:	a0 2d       	mov	r26, r0
    206e:	b2 83       	std	Z+2, r27	; 0x02
    2070:	a1 83       	std	Z+1, r26	; 0x01
    2072:	2f 54       	subi	r18, 0x4F	; 79
    2074:	3e 4f       	sbci	r19, 0xFE	; 254
    2076:	a2 17       	cp	r26, r18
    2078:	b3 07       	cpc	r27, r19
    207a:	31 f4       	brne	.+12     	; 0x2088 <vCoRoutineSchedule+0x1a0>
    207c:	12 96       	adiw	r26, 0x02	; 2
    207e:	8d 91       	ld	r24, X+
    2080:	9c 91       	ld	r25, X
    2082:	13 97       	sbiw	r26, 0x03	; 3
    2084:	92 83       	std	Z+2, r25	; 0x02
    2086:	81 83       	std	Z+1, r24	; 0x01
    2088:	89 e0       	ldi	r24, 0x09	; 9
    208a:	84 9f       	mul	r24, r20
    208c:	f0 01       	movw	r30, r0
    208e:	85 9f       	mul	r24, r21
    2090:	f0 0d       	add	r31, r0
    2092:	11 24       	eor	r1, r1
    2094:	e2 55       	subi	r30, 0x52	; 82
    2096:	fe 4f       	sbci	r31, 0xFE	; 254
    2098:	01 80       	ldd	r0, Z+1	; 0x01
    209a:	f2 81       	ldd	r31, Z+2	; 0x02
    209c:	e0 2d       	mov	r30, r0
    209e:	86 81       	ldd	r24, Z+6	; 0x06
    20a0:	97 81       	ldd	r25, Z+7	; 0x07
    20a2:	90 93 87 01 	sts	0x0187, r25	; 0x800187 <pxCurrentCoRoutine+0x1>
    20a6:	80 93 86 01 	sts	0x0186, r24	; 0x800186 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    20aa:	dc 01       	movw	r26, r24
    20ac:	ed 91       	ld	r30, X+
    20ae:	fc 91       	ld	r31, X
    20b0:	11 97       	sbiw	r26, 0x01	; 1
    20b2:	57 96       	adiw	r26, 0x17	; 23
    20b4:	6c 91       	ld	r22, X

	return;
}
    20b6:	df 91       	pop	r29
    20b8:	cf 91       	pop	r28
    20ba:	1f 91       	pop	r17
    20bc:	0f 91       	pop	r16
    20be:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    20c0:	09 94       	ijmp

000020c2 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    20c2:	0f 93       	push	r16
    20c4:	1f 93       	push	r17
    20c6:	cf 93       	push	r28
    20c8:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    20ca:	dc 01       	movw	r26, r24
    20cc:	15 96       	adiw	r26, 0x05	; 5
    20ce:	ed 91       	ld	r30, X+
    20d0:	fc 91       	ld	r31, X
    20d2:	16 97       	sbiw	r26, 0x06	; 6
    20d4:	c6 81       	ldd	r28, Z+6	; 0x06
    20d6:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    20d8:	8e 01       	movw	r16, r28
    20da:	04 5f       	subi	r16, 0xF4	; 244
    20dc:	1f 4f       	sbci	r17, 0xFF	; 255
    20de:	c8 01       	movw	r24, r16
    20e0:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    20e4:	b8 01       	movw	r22, r16
    20e6:	8f e8       	ldi	r24, 0x8F	; 143
    20e8:	91 e0       	ldi	r25, 0x01	; 1
    20ea:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    20ee:	e0 91 86 01 	lds	r30, 0x0186	; 0x800186 <pxCurrentCoRoutine>
    20f2:	f0 91 87 01 	lds	r31, 0x0187	; 0x800187 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    20f6:	81 e0       	ldi	r24, 0x01	; 1
    20f8:	2e 89       	ldd	r18, Y+22	; 0x16
    20fa:	96 89       	ldd	r25, Z+22	; 0x16
    20fc:	29 17       	cp	r18, r25
    20fe:	08 f4       	brcc	.+2      	; 0x2102 <xCoRoutineRemoveFromEventList+0x40>
    2100:	80 e0       	ldi	r24, 0x00	; 0
}
    2102:	df 91       	pop	r29
    2104:	cf 91       	pop	r28
    2106:	1f 91       	pop	r17
    2108:	0f 91       	pop	r16
    210a:	08 95       	ret

0000210c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    210c:	cf 93       	push	r28
    210e:	df 93       	push	r29
    2110:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2112:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2116:	80 91 c0 01 	lds	r24, 0x01C0	; 0x8001c0 <pucAlignedHeap.2081>
    211a:	90 91 c1 01 	lds	r25, 0x01C1	; 0x8001c1 <pucAlignedHeap.2081+0x1>
    211e:	89 2b       	or	r24, r25
    2120:	31 f4       	brne	.+12     	; 0x212e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2122:	85 ec       	ldi	r24, 0xC5	; 197
    2124:	91 e0       	ldi	r25, 0x01	; 1
    2126:	90 93 c1 01 	sts	0x01C1, r25	; 0x8001c1 <pucAlignedHeap.2081+0x1>
    212a:	80 93 c0 01 	sts	0x01C0, r24	; 0x8001c0 <pucAlignedHeap.2081>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    212e:	20 91 c2 01 	lds	r18, 0x01C2	; 0x8001c2 <xNextFreeByte>
    2132:	30 91 c3 01 	lds	r19, 0x01C3	; 0x8001c3 <xNextFreeByte+0x1>
    2136:	c9 01       	movw	r24, r18
    2138:	8c 0f       	add	r24, r28
    213a:	9d 1f       	adc	r25, r29
    213c:	8b 3d       	cpi	r24, 0xDB	; 219
    213e:	45 e0       	ldi	r20, 0x05	; 5
    2140:	94 07       	cpc	r25, r20
    2142:	70 f4       	brcc	.+28     	; 0x2160 <pvPortMalloc+0x54>
    2144:	28 17       	cp	r18, r24
    2146:	39 07       	cpc	r19, r25
    2148:	58 f4       	brcc	.+22     	; 0x2160 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    214a:	c0 91 c0 01 	lds	r28, 0x01C0	; 0x8001c0 <pucAlignedHeap.2081>
    214e:	d0 91 c1 01 	lds	r29, 0x01C1	; 0x8001c1 <pucAlignedHeap.2081+0x1>
    2152:	c2 0f       	add	r28, r18
    2154:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2156:	90 93 c3 01 	sts	0x01C3, r25	; 0x8001c3 <xNextFreeByte+0x1>
    215a:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <xNextFreeByte>
    215e:	02 c0       	rjmp	.+4      	; 0x2164 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    2160:	c0 e0       	ldi	r28, 0x00	; 0
    2162:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2164:	0e 94 ca 04 	call	0x994	; 0x994 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2168:	ce 01       	movw	r24, r28
    216a:	df 91       	pop	r29
    216c:	cf 91       	pop	r28
    216e:	08 95       	ret

00002170 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2170:	08 95       	ret

00002172 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2172:	10 92 c3 01 	sts	0x01C3, r1	; 0x8001c3 <xNextFreeByte+0x1>
    2176:	10 92 c2 01 	sts	0x01C2, r1	; 0x8001c2 <xNextFreeByte>
    217a:	08 95       	ret

0000217c <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    217c:	20 91 c2 01 	lds	r18, 0x01C2	; 0x8001c2 <xNextFreeByte>
    2180:	30 91 c3 01 	lds	r19, 0x01C3	; 0x8001c3 <xNextFreeByte+0x1>
}
    2184:	8b ed       	ldi	r24, 0xDB	; 219
    2186:	95 e0       	ldi	r25, 0x05	; 5
    2188:	82 1b       	sub	r24, r18
    218a:	93 0b       	sbc	r25, r19
    218c:	08 95       	ret

0000218e <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    218e:	31 e1       	ldi	r19, 0x11	; 17
    2190:	fc 01       	movw	r30, r24
    2192:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2194:	31 97       	sbiw	r30, 0x01	; 1
    2196:	22 e2       	ldi	r18, 0x22	; 34
    2198:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    219a:	31 97       	sbiw	r30, 0x01	; 1
    219c:	a3 e3       	ldi	r26, 0x33	; 51
    219e:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    21a0:	31 97       	sbiw	r30, 0x01	; 1
    21a2:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    21a4:	31 97       	sbiw	r30, 0x01	; 1
    21a6:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    21a8:	31 97       	sbiw	r30, 0x01	; 1
    21aa:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    21ac:	31 97       	sbiw	r30, 0x01	; 1
    21ae:	60 e8       	ldi	r22, 0x80	; 128
    21b0:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    21b2:	31 97       	sbiw	r30, 0x01	; 1
    21b4:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    21b6:	31 97       	sbiw	r30, 0x01	; 1
    21b8:	62 e0       	ldi	r22, 0x02	; 2
    21ba:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    21bc:	31 97       	sbiw	r30, 0x01	; 1
    21be:	63 e0       	ldi	r22, 0x03	; 3
    21c0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    21c2:	31 97       	sbiw	r30, 0x01	; 1
    21c4:	64 e0       	ldi	r22, 0x04	; 4
    21c6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    21c8:	31 97       	sbiw	r30, 0x01	; 1
    21ca:	65 e0       	ldi	r22, 0x05	; 5
    21cc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    21ce:	31 97       	sbiw	r30, 0x01	; 1
    21d0:	66 e0       	ldi	r22, 0x06	; 6
    21d2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    21d4:	31 97       	sbiw	r30, 0x01	; 1
    21d6:	67 e0       	ldi	r22, 0x07	; 7
    21d8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    21da:	31 97       	sbiw	r30, 0x01	; 1
    21dc:	68 e0       	ldi	r22, 0x08	; 8
    21de:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    21e0:	31 97       	sbiw	r30, 0x01	; 1
    21e2:	69 e0       	ldi	r22, 0x09	; 9
    21e4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    21e6:	31 97       	sbiw	r30, 0x01	; 1
    21e8:	60 e1       	ldi	r22, 0x10	; 16
    21ea:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    21ec:	31 97       	sbiw	r30, 0x01	; 1
    21ee:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    21f0:	31 97       	sbiw	r30, 0x01	; 1
    21f2:	32 e1       	ldi	r19, 0x12	; 18
    21f4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    21f6:	31 97       	sbiw	r30, 0x01	; 1
    21f8:	33 e1       	ldi	r19, 0x13	; 19
    21fa:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    21fc:	31 97       	sbiw	r30, 0x01	; 1
    21fe:	34 e1       	ldi	r19, 0x14	; 20
    2200:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2202:	31 97       	sbiw	r30, 0x01	; 1
    2204:	35 e1       	ldi	r19, 0x15	; 21
    2206:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2208:	31 97       	sbiw	r30, 0x01	; 1
    220a:	36 e1       	ldi	r19, 0x16	; 22
    220c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    220e:	31 97       	sbiw	r30, 0x01	; 1
    2210:	37 e1       	ldi	r19, 0x17	; 23
    2212:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2214:	31 97       	sbiw	r30, 0x01	; 1
    2216:	38 e1       	ldi	r19, 0x18	; 24
    2218:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    221a:	31 97       	sbiw	r30, 0x01	; 1
    221c:	39 e1       	ldi	r19, 0x19	; 25
    221e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2220:	31 97       	sbiw	r30, 0x01	; 1
    2222:	30 e2       	ldi	r19, 0x20	; 32
    2224:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2226:	31 97       	sbiw	r30, 0x01	; 1
    2228:	31 e2       	ldi	r19, 0x21	; 33
    222a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    222c:	31 97       	sbiw	r30, 0x01	; 1
    222e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2230:	31 97       	sbiw	r30, 0x01	; 1
    2232:	23 e2       	ldi	r18, 0x23	; 35
    2234:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2236:	31 97       	sbiw	r30, 0x01	; 1
    2238:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    223a:	31 97       	sbiw	r30, 0x01	; 1
    223c:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    223e:	31 97       	sbiw	r30, 0x01	; 1
    2240:	26 e2       	ldi	r18, 0x26	; 38
    2242:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2244:	31 97       	sbiw	r30, 0x01	; 1
    2246:	27 e2       	ldi	r18, 0x27	; 39
    2248:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    224a:	31 97       	sbiw	r30, 0x01	; 1
    224c:	28 e2       	ldi	r18, 0x28	; 40
    224e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2250:	31 97       	sbiw	r30, 0x01	; 1
    2252:	29 e2       	ldi	r18, 0x29	; 41
    2254:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2256:	31 97       	sbiw	r30, 0x01	; 1
    2258:	20 e3       	ldi	r18, 0x30	; 48
    225a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    225c:	31 97       	sbiw	r30, 0x01	; 1
    225e:	21 e3       	ldi	r18, 0x31	; 49
    2260:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2262:	86 97       	sbiw	r24, 0x26	; 38
    2264:	08 95       	ret

00002266 <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    2266:	89 ef       	ldi	r24, 0xF9	; 249
    2268:	90 e0       	ldi	r25, 0x00	; 0
    226a:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
    226e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    2272:	e0 e8       	ldi	r30, 0x80	; 128
    2274:	f0 e0       	ldi	r31, 0x00	; 0
    2276:	80 81       	ld	r24, Z
    2278:	8c 7f       	andi	r24, 0xFC	; 252
    227a:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    227c:	8b e0       	ldi	r24, 0x0B	; 11
    227e:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2282:	ef e6       	ldi	r30, 0x6F	; 111
    2284:	f0 e0       	ldi	r31, 0x00	; 0
    2286:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2288:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    228a:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    228c:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    2290:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    2294:	cd 91       	ld	r28, X+
    2296:	cd bf       	out	0x3d, r28	; 61
    2298:	dd 91       	ld	r29, X+
    229a:	de bf       	out	0x3e, r29	; 62
    229c:	ff 91       	pop	r31
    229e:	ef 91       	pop	r30
    22a0:	df 91       	pop	r29
    22a2:	cf 91       	pop	r28
    22a4:	bf 91       	pop	r27
    22a6:	af 91       	pop	r26
    22a8:	9f 91       	pop	r25
    22aa:	8f 91       	pop	r24
    22ac:	7f 91       	pop	r23
    22ae:	6f 91       	pop	r22
    22b0:	5f 91       	pop	r21
    22b2:	4f 91       	pop	r20
    22b4:	3f 91       	pop	r19
    22b6:	2f 91       	pop	r18
    22b8:	1f 91       	pop	r17
    22ba:	0f 91       	pop	r16
    22bc:	ff 90       	pop	r15
    22be:	ef 90       	pop	r14
    22c0:	df 90       	pop	r13
    22c2:	cf 90       	pop	r12
    22c4:	bf 90       	pop	r11
    22c6:	af 90       	pop	r10
    22c8:	9f 90       	pop	r9
    22ca:	8f 90       	pop	r8
    22cc:	7f 90       	pop	r7
    22ce:	6f 90       	pop	r6
    22d0:	5f 90       	pop	r5
    22d2:	4f 90       	pop	r4
    22d4:	3f 90       	pop	r3
    22d6:	2f 90       	pop	r2
    22d8:	1f 90       	pop	r1
    22da:	0f 90       	pop	r0
    22dc:	0f be       	out	0x3f, r0	; 63
    22de:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    22e0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    22e2:	81 e0       	ldi	r24, 0x01	; 1
    22e4:	08 95       	ret

000022e6 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    22e6:	08 95       	ret

000022e8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    22e8:	0f 92       	push	r0
    22ea:	0f b6       	in	r0, 0x3f	; 63
    22ec:	f8 94       	cli
    22ee:	0f 92       	push	r0
    22f0:	1f 92       	push	r1
    22f2:	11 24       	eor	r1, r1
    22f4:	2f 92       	push	r2
    22f6:	3f 92       	push	r3
    22f8:	4f 92       	push	r4
    22fa:	5f 92       	push	r5
    22fc:	6f 92       	push	r6
    22fe:	7f 92       	push	r7
    2300:	8f 92       	push	r8
    2302:	9f 92       	push	r9
    2304:	af 92       	push	r10
    2306:	bf 92       	push	r11
    2308:	cf 92       	push	r12
    230a:	df 92       	push	r13
    230c:	ef 92       	push	r14
    230e:	ff 92       	push	r15
    2310:	0f 93       	push	r16
    2312:	1f 93       	push	r17
    2314:	2f 93       	push	r18
    2316:	3f 93       	push	r19
    2318:	4f 93       	push	r20
    231a:	5f 93       	push	r21
    231c:	6f 93       	push	r22
    231e:	7f 93       	push	r23
    2320:	8f 93       	push	r24
    2322:	9f 93       	push	r25
    2324:	af 93       	push	r26
    2326:	bf 93       	push	r27
    2328:	cf 93       	push	r28
    232a:	df 93       	push	r29
    232c:	ef 93       	push	r30
    232e:	ff 93       	push	r31
    2330:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    2334:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    2338:	0d b6       	in	r0, 0x3d	; 61
    233a:	0d 92       	st	X+, r0
    233c:	0e b6       	in	r0, 0x3e	; 62
    233e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2340:	0e 94 86 05 	call	0xb0c	; 0xb0c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2344:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    2348:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    234c:	cd 91       	ld	r28, X+
    234e:	cd bf       	out	0x3d, r28	; 61
    2350:	dd 91       	ld	r29, X+
    2352:	de bf       	out	0x3e, r29	; 62
    2354:	ff 91       	pop	r31
    2356:	ef 91       	pop	r30
    2358:	df 91       	pop	r29
    235a:	cf 91       	pop	r28
    235c:	bf 91       	pop	r27
    235e:	af 91       	pop	r26
    2360:	9f 91       	pop	r25
    2362:	8f 91       	pop	r24
    2364:	7f 91       	pop	r23
    2366:	6f 91       	pop	r22
    2368:	5f 91       	pop	r21
    236a:	4f 91       	pop	r20
    236c:	3f 91       	pop	r19
    236e:	2f 91       	pop	r18
    2370:	1f 91       	pop	r17
    2372:	0f 91       	pop	r16
    2374:	ff 90       	pop	r15
    2376:	ef 90       	pop	r14
    2378:	df 90       	pop	r13
    237a:	cf 90       	pop	r12
    237c:	bf 90       	pop	r11
    237e:	af 90       	pop	r10
    2380:	9f 90       	pop	r9
    2382:	8f 90       	pop	r8
    2384:	7f 90       	pop	r7
    2386:	6f 90       	pop	r6
    2388:	5f 90       	pop	r5
    238a:	4f 90       	pop	r4
    238c:	3f 90       	pop	r3
    238e:	2f 90       	pop	r2
    2390:	1f 90       	pop	r1
    2392:	0f 90       	pop	r0
    2394:	0f be       	out	0x3f, r0	; 63
    2396:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2398:	08 95       	ret

0000239a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    239a:	0f 92       	push	r0
    239c:	0f b6       	in	r0, 0x3f	; 63
    239e:	f8 94       	cli
    23a0:	0f 92       	push	r0
    23a2:	1f 92       	push	r1
    23a4:	11 24       	eor	r1, r1
    23a6:	2f 92       	push	r2
    23a8:	3f 92       	push	r3
    23aa:	4f 92       	push	r4
    23ac:	5f 92       	push	r5
    23ae:	6f 92       	push	r6
    23b0:	7f 92       	push	r7
    23b2:	8f 92       	push	r8
    23b4:	9f 92       	push	r9
    23b6:	af 92       	push	r10
    23b8:	bf 92       	push	r11
    23ba:	cf 92       	push	r12
    23bc:	df 92       	push	r13
    23be:	ef 92       	push	r14
    23c0:	ff 92       	push	r15
    23c2:	0f 93       	push	r16
    23c4:	1f 93       	push	r17
    23c6:	2f 93       	push	r18
    23c8:	3f 93       	push	r19
    23ca:	4f 93       	push	r20
    23cc:	5f 93       	push	r21
    23ce:	6f 93       	push	r22
    23d0:	7f 93       	push	r23
    23d2:	8f 93       	push	r24
    23d4:	9f 93       	push	r25
    23d6:	af 93       	push	r26
    23d8:	bf 93       	push	r27
    23da:	cf 93       	push	r28
    23dc:	df 93       	push	r29
    23de:	ef 93       	push	r30
    23e0:	ff 93       	push	r31
    23e2:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    23e6:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    23ea:	0d b6       	in	r0, 0x3d	; 61
    23ec:	0d 92       	st	X+, r0
    23ee:	0e b6       	in	r0, 0x3e	; 62
    23f0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    23f2:	0e 94 1e 04 	call	0x83c	; 0x83c <xTaskIncrementTick>
    23f6:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    23f8:	0e 94 86 05 	call	0xb0c	; 0xb0c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    23fc:	a0 91 20 01 	lds	r26, 0x0120	; 0x800120 <__data_end>
    2400:	b0 91 21 01 	lds	r27, 0x0121	; 0x800121 <__data_end+0x1>
    2404:	cd 91       	ld	r28, X+
    2406:	cd bf       	out	0x3d, r28	; 61
    2408:	dd 91       	ld	r29, X+
    240a:	de bf       	out	0x3e, r29	; 62
    240c:	ff 91       	pop	r31
    240e:	ef 91       	pop	r30
    2410:	df 91       	pop	r29
    2412:	cf 91       	pop	r28
    2414:	bf 91       	pop	r27
    2416:	af 91       	pop	r26
    2418:	9f 91       	pop	r25
    241a:	8f 91       	pop	r24
    241c:	7f 91       	pop	r23
    241e:	6f 91       	pop	r22
    2420:	5f 91       	pop	r21
    2422:	4f 91       	pop	r20
    2424:	3f 91       	pop	r19
    2426:	2f 91       	pop	r18
    2428:	1f 91       	pop	r17
    242a:	0f 91       	pop	r16
    242c:	ff 90       	pop	r15
    242e:	ef 90       	pop	r14
    2430:	df 90       	pop	r13
    2432:	cf 90       	pop	r12
    2434:	bf 90       	pop	r11
    2436:	af 90       	pop	r10
    2438:	9f 90       	pop	r9
    243a:	8f 90       	pop	r8
    243c:	7f 90       	pop	r7
    243e:	6f 90       	pop	r6
    2440:	5f 90       	pop	r5
    2442:	4f 90       	pop	r4
    2444:	3f 90       	pop	r3
    2446:	2f 90       	pop	r2
    2448:	1f 90       	pop	r1
    244a:	0f 90       	pop	r0
    244c:	0f be       	out	0x3f, r0	; 63
    244e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2450:	08 95       	ret

00002452 <__vector_11>:
    2452:	0e 94 cd 11 	call	0x239a	; 0x239a <vPortYieldFromTick>
    2456:	18 95       	reti

00002458 <main>:
  //return _FDEV_EOF;
}


int main(void)
{
    2458:	ef 92       	push	r14
    245a:	ff 92       	push	r15
    245c:	0f 93       	push	r16
    245e:	cf 93       	push	r28
    2460:	df 93       	push	r29
    2462:	00 d0       	rcall	.+0      	; 0x2464 <main+0xc>
    2464:	00 d0       	rcall	.+0      	; 0x2466 <main+0xe>
    2466:	cd b7       	in	r28, 0x3d	; 61
    2468:	de b7       	in	r29, 0x3e	; 62
    tx_buffer = xQueueCreate(100,sizeof(uint8_t));
    246a:	40 e0       	ldi	r20, 0x00	; 0
    246c:	61 e0       	ldi	r22, 0x01	; 1
    246e:	84 e6       	ldi	r24, 0x64	; 100
    2470:	0e 94 2f 0a 	call	0x145e	; 0x145e <xQueueGenericCreate>
    2474:	90 93 a3 07 	sts	0x07A3, r25	; 0x8007a3 <tx_buffer+0x1>
    2478:	80 93 a2 07 	sts	0x07A2, r24	; 0x8007a2 <tx_buffer>
    rx_buffer = xQueueCreate(100,sizeof(uint8_t));
    247c:	40 e0       	ldi	r20, 0x00	; 0
    247e:	61 e0       	ldi	r22, 0x01	; 1
    2480:	84 e6       	ldi	r24, 0x64	; 100
    2482:	0e 94 2f 0a 	call	0x145e	; 0x145e <xQueueGenericCreate>
    2486:	90 93 a1 07 	sts	0x07A1, r25	; 0x8007a1 <rx_buffer+0x1>
    248a:	80 93 a0 07 	sts	0x07A0, r24	; 0x8007a0 <rx_buffer>

    // Create task.
    xTaskHandle blinker_handle;
    xTaskHandle echo_handle;
    fdev_setup_stream(&uart_file,uart_transmit,uart_receive,_FDEV_SETUP_RW);
    248e:	e0 e0       	ldi	r30, 0x00	; 0
    2490:	f1 e0       	ldi	r31, 0x01	; 1
    2492:	83 e5       	ldi	r24, 0x53	; 83
    2494:	90 e0       	ldi	r25, 0x00	; 0
    2496:	91 87       	std	Z+9, r25	; 0x09
    2498:	80 87       	std	Z+8, r24	; 0x08
    249a:	80 e7       	ldi	r24, 0x70	; 112
    249c:	90 e0       	ldi	r25, 0x00	; 0
    249e:	93 87       	std	Z+11, r25	; 0x0b
    24a0:	82 87       	std	Z+10, r24	; 0x0a
    24a2:	83 e0       	ldi	r24, 0x03	; 3
    24a4:	83 83       	std	Z+3, r24	; 0x03
    24a6:	15 86       	std	Z+13, r1	; 0x0d
    24a8:	14 86       	std	Z+12, r1	; 0x0c
    xTaskCreate
    24aa:	ce 01       	movw	r24, r28
    24ac:	03 96       	adiw	r24, 0x03	; 3
    24ae:	7c 01       	movw	r14, r24
    24b0:	01 e0       	ldi	r16, 0x01	; 1
    24b2:	20 e0       	ldi	r18, 0x00	; 0
    24b4:	30 e0       	ldi	r19, 0x00	; 0
    24b6:	48 e5       	ldi	r20, 0x58	; 88
    24b8:	52 e0       	ldi	r21, 0x02	; 2
    24ba:	6e e0       	ldi	r22, 0x0E	; 14
    24bc:	71 e0       	ldi	r23, 0x01	; 1
    24be:	86 e8       	ldi	r24, 0x86	; 134
    24c0:	90 e0       	ldi	r25, 0x00	; 0
    24c2:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <xTaskCreate>
         NULL,
         mainBLINKER,
         &blinker_handle
        );

    xTaskCreate
    24c6:	ce 01       	movw	r24, r28
    24c8:	01 96       	adiw	r24, 0x01	; 1
    24ca:	7c 01       	movw	r14, r24
    24cc:	02 e0       	ldi	r16, 0x02	; 2
    24ce:	20 e0       	ldi	r18, 0x00	; 0
    24d0:	30 e0       	ldi	r19, 0x00	; 0
    24d2:	48 e5       	ldi	r20, 0x58	; 88
    24d4:	52 e0       	ldi	r21, 0x02	; 2
    24d6:	64 e1       	ldi	r22, 0x14	; 20
    24d8:	71 e0       	ldi	r23, 0x01	; 1
    24da:	81 ea       	ldi	r24, 0xA1	; 161
    24dc:	90 e0       	ldi	r25, 0x00	; 0
    24de:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <xTaskCreate>
         mainECHO,
         &echo_handle
        );

    // Start scheduler.
    vTaskStartScheduler();
    24e2:	0e 94 cf 03 	call	0x79e	; 0x79e <vTaskStartScheduler>

    return 0;
}
    24e6:	80 e0       	ldi	r24, 0x00	; 0
    24e8:	90 e0       	ldi	r25, 0x00	; 0
    24ea:	0f 90       	pop	r0
    24ec:	0f 90       	pop	r0
    24ee:	0f 90       	pop	r0
    24f0:	0f 90       	pop	r0
    24f2:	df 91       	pop	r29
    24f4:	cf 91       	pop	r28
    24f6:	0f 91       	pop	r16
    24f8:	ff 90       	pop	r15
    24fa:	ef 90       	pop	r14
    24fc:	08 95       	ret

000024fe <memcpy>:
    24fe:	fb 01       	movw	r30, r22
    2500:	dc 01       	movw	r26, r24
    2502:	02 c0       	rjmp	.+4      	; 0x2508 <memcpy+0xa>
    2504:	01 90       	ld	r0, Z+
    2506:	0d 92       	st	X+, r0
    2508:	41 50       	subi	r20, 0x01	; 1
    250a:	50 40       	sbci	r21, 0x00	; 0
    250c:	d8 f7       	brcc	.-10     	; 0x2504 <memcpy+0x6>
    250e:	08 95       	ret

00002510 <fgetc>:
    2510:	cf 93       	push	r28
    2512:	df 93       	push	r29
    2514:	ec 01       	movw	r28, r24
    2516:	2b 81       	ldd	r18, Y+3	; 0x03
    2518:	20 ff       	sbrs	r18, 0
    251a:	33 c0       	rjmp	.+102    	; 0x2582 <fgetc+0x72>
    251c:	26 ff       	sbrs	r18, 6
    251e:	0a c0       	rjmp	.+20     	; 0x2534 <fgetc+0x24>
    2520:	2f 7b       	andi	r18, 0xBF	; 191
    2522:	2b 83       	std	Y+3, r18	; 0x03
    2524:	8e 81       	ldd	r24, Y+6	; 0x06
    2526:	9f 81       	ldd	r25, Y+7	; 0x07
    2528:	01 96       	adiw	r24, 0x01	; 1
    252a:	9f 83       	std	Y+7, r25	; 0x07
    252c:	8e 83       	std	Y+6, r24	; 0x06
    252e:	8a 81       	ldd	r24, Y+2	; 0x02
    2530:	90 e0       	ldi	r25, 0x00	; 0
    2532:	29 c0       	rjmp	.+82     	; 0x2586 <fgetc+0x76>
    2534:	22 ff       	sbrs	r18, 2
    2536:	0f c0       	rjmp	.+30     	; 0x2556 <fgetc+0x46>
    2538:	e8 81       	ld	r30, Y
    253a:	f9 81       	ldd	r31, Y+1	; 0x01
    253c:	80 81       	ld	r24, Z
    253e:	08 2e       	mov	r0, r24
    2540:	00 0c       	add	r0, r0
    2542:	99 0b       	sbc	r25, r25
    2544:	00 97       	sbiw	r24, 0x00	; 0
    2546:	19 f4       	brne	.+6      	; 0x254e <fgetc+0x3e>
    2548:	20 62       	ori	r18, 0x20	; 32
    254a:	2b 83       	std	Y+3, r18	; 0x03
    254c:	1a c0       	rjmp	.+52     	; 0x2582 <fgetc+0x72>
    254e:	31 96       	adiw	r30, 0x01	; 1
    2550:	f9 83       	std	Y+1, r31	; 0x01
    2552:	e8 83       	st	Y, r30
    2554:	0e c0       	rjmp	.+28     	; 0x2572 <fgetc+0x62>
    2556:	ea 85       	ldd	r30, Y+10	; 0x0a
    2558:	fb 85       	ldd	r31, Y+11	; 0x0b
    255a:	09 95       	icall
    255c:	97 ff       	sbrs	r25, 7
    255e:	09 c0       	rjmp	.+18     	; 0x2572 <fgetc+0x62>
    2560:	2b 81       	ldd	r18, Y+3	; 0x03
    2562:	01 96       	adiw	r24, 0x01	; 1
    2564:	11 f0       	breq	.+4      	; 0x256a <fgetc+0x5a>
    2566:	80 e2       	ldi	r24, 0x20	; 32
    2568:	01 c0       	rjmp	.+2      	; 0x256c <fgetc+0x5c>
    256a:	80 e1       	ldi	r24, 0x10	; 16
    256c:	82 2b       	or	r24, r18
    256e:	8b 83       	std	Y+3, r24	; 0x03
    2570:	08 c0       	rjmp	.+16     	; 0x2582 <fgetc+0x72>
    2572:	2e 81       	ldd	r18, Y+6	; 0x06
    2574:	3f 81       	ldd	r19, Y+7	; 0x07
    2576:	2f 5f       	subi	r18, 0xFF	; 255
    2578:	3f 4f       	sbci	r19, 0xFF	; 255
    257a:	3f 83       	std	Y+7, r19	; 0x07
    257c:	2e 83       	std	Y+6, r18	; 0x06
    257e:	99 27       	eor	r25, r25
    2580:	02 c0       	rjmp	.+4      	; 0x2586 <fgetc+0x76>
    2582:	8f ef       	ldi	r24, 0xFF	; 255
    2584:	9f ef       	ldi	r25, 0xFF	; 255
    2586:	df 91       	pop	r29
    2588:	cf 91       	pop	r28
    258a:	08 95       	ret

0000258c <fputc>:
    258c:	0f 93       	push	r16
    258e:	1f 93       	push	r17
    2590:	cf 93       	push	r28
    2592:	df 93       	push	r29
    2594:	fb 01       	movw	r30, r22
    2596:	23 81       	ldd	r18, Z+3	; 0x03
    2598:	21 fd       	sbrc	r18, 1
    259a:	03 c0       	rjmp	.+6      	; 0x25a2 <fputc+0x16>
    259c:	8f ef       	ldi	r24, 0xFF	; 255
    259e:	9f ef       	ldi	r25, 0xFF	; 255
    25a0:	2c c0       	rjmp	.+88     	; 0x25fa <fputc+0x6e>
    25a2:	22 ff       	sbrs	r18, 2
    25a4:	16 c0       	rjmp	.+44     	; 0x25d2 <fputc+0x46>
    25a6:	46 81       	ldd	r20, Z+6	; 0x06
    25a8:	57 81       	ldd	r21, Z+7	; 0x07
    25aa:	24 81       	ldd	r18, Z+4	; 0x04
    25ac:	35 81       	ldd	r19, Z+5	; 0x05
    25ae:	42 17       	cp	r20, r18
    25b0:	53 07       	cpc	r21, r19
    25b2:	44 f4       	brge	.+16     	; 0x25c4 <fputc+0x38>
    25b4:	a0 81       	ld	r26, Z
    25b6:	b1 81       	ldd	r27, Z+1	; 0x01
    25b8:	9d 01       	movw	r18, r26
    25ba:	2f 5f       	subi	r18, 0xFF	; 255
    25bc:	3f 4f       	sbci	r19, 0xFF	; 255
    25be:	31 83       	std	Z+1, r19	; 0x01
    25c0:	20 83       	st	Z, r18
    25c2:	8c 93       	st	X, r24
    25c4:	26 81       	ldd	r18, Z+6	; 0x06
    25c6:	37 81       	ldd	r19, Z+7	; 0x07
    25c8:	2f 5f       	subi	r18, 0xFF	; 255
    25ca:	3f 4f       	sbci	r19, 0xFF	; 255
    25cc:	37 83       	std	Z+7, r19	; 0x07
    25ce:	26 83       	std	Z+6, r18	; 0x06
    25d0:	14 c0       	rjmp	.+40     	; 0x25fa <fputc+0x6e>
    25d2:	8b 01       	movw	r16, r22
    25d4:	ec 01       	movw	r28, r24
    25d6:	fb 01       	movw	r30, r22
    25d8:	00 84       	ldd	r0, Z+8	; 0x08
    25da:	f1 85       	ldd	r31, Z+9	; 0x09
    25dc:	e0 2d       	mov	r30, r0
    25de:	09 95       	icall
    25e0:	89 2b       	or	r24, r25
    25e2:	e1 f6       	brne	.-72     	; 0x259c <fputc+0x10>
    25e4:	d8 01       	movw	r26, r16
    25e6:	16 96       	adiw	r26, 0x06	; 6
    25e8:	8d 91       	ld	r24, X+
    25ea:	9c 91       	ld	r25, X
    25ec:	17 97       	sbiw	r26, 0x07	; 7
    25ee:	01 96       	adiw	r24, 0x01	; 1
    25f0:	17 96       	adiw	r26, 0x07	; 7
    25f2:	9c 93       	st	X, r25
    25f4:	8e 93       	st	-X, r24
    25f6:	16 97       	sbiw	r26, 0x06	; 6
    25f8:	ce 01       	movw	r24, r28
    25fa:	df 91       	pop	r29
    25fc:	cf 91       	pop	r28
    25fe:	1f 91       	pop	r17
    2600:	0f 91       	pop	r16
    2602:	08 95       	ret

00002604 <_exit>:
    2604:	f8 94       	cli

00002606 <__stop_program>:
    2606:	ff cf       	rjmp	.-2      	; 0x2606 <__stop_program>

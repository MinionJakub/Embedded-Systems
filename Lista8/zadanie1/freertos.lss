
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  000023e8  0000247c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000023e8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006a1  00800126  00800126  000024a2  2**0
                  ALLOC
  3 .stab         00007248  00000000  00000000  000024a4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004373  00000000  00000000  000096ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000da5f  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000da70  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000dab0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000e0a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000e646  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0000e660  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 a7 11 	jmp	0x234e	; 0x234e <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e8 ee       	ldi	r30, 0xE8	; 232
      7c:	f3 e2       	ldi	r31, 0x23	; 35
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a6 32       	cpi	r26, 0x26	; 38
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	a6 e2       	ldi	r26, 0x26	; 38
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a7 3c       	cpi	r26, 0xC7	; 199
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 aa 11 	call	0x2354	; 0x2354 <main>
      9e:	0c 94 f2 11 	jmp	0x23e4	; 0x23e4 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vButton>:
}


static void vButton(void* pvParameters)
{
    BUTTON_DDR &= ~_BV(BUTTON);
      a6:	3c 98       	cbi	0x07, 4	; 7
    BUTTON_PORT |= _BV(BUTTON);
      a8:	44 9a       	sbi	0x08, 4	; 8

    LED_DDR2  |= _BV(LED);
      aa:	21 9a       	sbi	0x04, 1	; 4
    uint8_t crossed_100 = 0;
    uint8_t place;
    uint8_t bit;
    uint8_t writer = 0;
      ac:	c0 e0       	ldi	r28, 0x00	; 0
{
    BUTTON_DDR &= ~_BV(BUTTON);
    BUTTON_PORT |= _BV(BUTTON);

    LED_DDR2  |= _BV(LED);
    uint8_t crossed_100 = 0;
      ae:	f1 2c       	mov	r15, r1
    uint8_t place;
    uint8_t bit;
    uint8_t writer = 0;
    uint8_t reader = 0;
      b0:	d0 e0       	ldi	r29, 0x00	; 0
        bit = get_bit(writer);
        if(!(PINC&_BV(BUTTON))){
            cirular_buffer[place] |= _BV(bit);
        }
        else{
            cirular_buffer[place] &= ~_BV(bit);
      b2:	01 e0       	ldi	r16, 0x01	; 1
      b4:	10 e0       	ldi	r17, 0x00	; 0
    uint8_t reader = 0;
    // while(1) LED_PORT2 |= _BV(LED);
    while(1){
        if(reader == 255)
            reader = 0;
        if(writer == 255)
      b6:	cf 3f       	cpi	r28, 0xFF	; 255
      b8:	29 f0       	breq	.+10     	; 0xc4 <vButton+0x1e>
            writer = 0;
        if(!crossed_100 && writer == 100)
      ba:	f1 10       	cpse	r15, r1
      bc:	0a c0       	rjmp	.+20     	; 0xd2 <vButton+0x2c>
      be:	c4 36       	cpi	r28, 0x64	; 100
      c0:	21 f4       	brne	.+8      	; 0xca <vButton+0x24>
      c2:	05 c0       	rjmp	.+10     	; 0xce <vButton+0x28>
    // while(1) LED_PORT2 |= _BV(LED);
    while(1){
        if(reader == 255)
            reader = 0;
        if(writer == 255)
            writer = 0;
      c4:	c0 e0       	ldi	r28, 0x00	; 0
        if(!crossed_100 && writer == 100)
      c6:	f1 10       	cpse	r15, r1
      c8:	04 c0       	rjmp	.+8      	; 0xd2 <vButton+0x2c>
    // while(1) LED_PORT2 |= _BV(LED);
    while(1){
        if(reader == 255)
            reader = 0;
        if(writer == 255)
            writer = 0;
      ca:	f1 2c       	mov	r15, r1
      cc:	02 c0       	rjmp	.+4      	; 0xd2 <vButton+0x2c>
        if(!crossed_100 && writer == 100)
            crossed_100 = 1;
      ce:	ff 24       	eor	r15, r15
      d0:	f3 94       	inc	r15
static inline uint8_t get_place(uint8_t value){
    return (value >> 3);
}

static inline uint8_t get_bit(uint8_t value){
    return (value&7);
      d2:	8c 2f       	mov	r24, r28
      d4:	87 70       	andi	r24, 0x07	; 7
      d6:	ec 2f       	mov	r30, r28
      d8:	e6 95       	lsr	r30
      da:	e6 95       	lsr	r30
      dc:	e6 95       	lsr	r30
      de:	f0 e0       	ldi	r31, 0x00	; 0
        if(!crossed_100 && writer == 100)
            crossed_100 = 1;
        place = get_place(writer);
        bit = get_bit(writer);
        if(!(PINC&_BV(BUTTON))){
            cirular_buffer[place] |= _BV(bit);
      e0:	e9 5d       	subi	r30, 0xD9	; 217
      e2:	fe 4f       	sbci	r31, 0xFE	; 254
      e4:	98 01       	movw	r18, r16
      e6:	02 c0       	rjmp	.+4      	; 0xec <vButton+0x46>
      e8:	22 0f       	add	r18, r18
      ea:	33 1f       	adc	r19, r19
      ec:	8a 95       	dec	r24
      ee:	e2 f7       	brpl	.-8      	; 0xe8 <vButton+0x42>
      f0:	c9 01       	movw	r24, r18
            writer = 0;
        if(!crossed_100 && writer == 100)
            crossed_100 = 1;
        place = get_place(writer);
        bit = get_bit(writer);
        if(!(PINC&_BV(BUTTON))){
      f2:	34 99       	sbic	0x06, 4	; 6
      f4:	03 c0       	rjmp	.+6      	; 0xfc <vButton+0x56>
            cirular_buffer[place] |= _BV(bit);
      f6:	90 81       	ld	r25, Z
      f8:	89 2b       	or	r24, r25
      fa:	03 c0       	rjmp	.+6      	; 0x102 <vButton+0x5c>
        }
        else{
            cirular_buffer[place] &= ~_BV(bit);
      fc:	80 95       	com	r24
      fe:	90 81       	ld	r25, Z
     100:	89 23       	and	r24, r25
     102:	80 83       	st	Z, r24
        }
        writer++;
     104:	cf 5f       	subi	r28, 0xFF	; 255
        if(crossed_100){
     106:	ff 20       	and	r15, r15
     108:	b9 f0       	breq	.+46     	; 0x138 <vButton+0x92>
            place = get_place(reader);
            bit = get_bit(reader);
            light(cirular_buffer[place]&_BV(bit));
     10a:	ed 2f       	mov	r30, r29
     10c:	e6 95       	lsr	r30
     10e:	e6 95       	lsr	r30
     110:	e6 95       	lsr	r30
     112:	f0 e0       	ldi	r31, 0x00	; 0
     114:	e9 5d       	subi	r30, 0xD9	; 217
     116:	fe 4f       	sbci	r31, 0xFE	; 254
static inline uint8_t get_bit(uint8_t value){
    return (value&7);
}

static inline void light(uint8_t value){
    if(value)
     118:	8d 2f       	mov	r24, r29
     11a:	87 70       	andi	r24, 0x07	; 7
     11c:	98 01       	movw	r18, r16
     11e:	02 c0       	rjmp	.+4      	; 0x124 <vButton+0x7e>
     120:	22 0f       	add	r18, r18
     122:	33 1f       	adc	r19, r19
     124:	8a 95       	dec	r24
     126:	e2 f7       	brpl	.-8      	; 0x120 <vButton+0x7a>
     128:	c9 01       	movw	r24, r18
     12a:	90 81       	ld	r25, Z
     12c:	89 23       	and	r24, r25
     12e:	11 f0       	breq	.+4      	; 0x134 <vButton+0x8e>
        LED_PORT2 |= _BV(LED);
     130:	29 9a       	sbi	0x05, 1	; 5
     132:	01 c0       	rjmp	.+2      	; 0x136 <vButton+0x90>
    else
        LED_PORT2 &= ~_BV(LED);
     134:	29 98       	cbi	0x05, 1	; 5
        writer++;
        if(crossed_100){
            place = get_place(reader);
            bit = get_bit(reader);
            light(cirular_buffer[place]&_BV(bit));
            reader++;
     136:	df 5f       	subi	r29, 0xFF	; 255
        }
        vTaskDelay(10/portTICK_PERIOD_MS);
     138:	8a e0       	ldi	r24, 0x0A	; 10
     13a:	90 e0       	ldi	r25, 0x00	; 0
     13c:	0e 94 ef 04 	call	0x9de	; 0x9de <vTaskDelay>
    uint8_t bit;
    uint8_t writer = 0;
    uint8_t reader = 0;
    // while(1) LED_PORT2 |= _BV(LED);
    while(1){
        if(reader == 255)
     140:	df 3f       	cpi	r29, 0xFF	; 255
     142:	09 f0       	breq	.+2      	; 0x146 <vButton+0xa0>
     144:	b8 cf       	rjmp	.-144    	; 0xb6 <vButton+0x10>
            reader = 0;
     146:	d0 e0       	ldi	r29, 0x00	; 0
     148:	b6 cf       	rjmp	.-148    	; 0xb6 <vButton+0x10>

0000014a <vLED_counter>:
};

static void vLED_counter(void* pvParameters)
{
    static uint8_t counter = 0;
    LED_DDR = 0xff;
     14a:	8f ef       	ldi	r24, 0xFF	; 255
     14c:	8a b9       	out	0x0a, r24	; 10
    LED_PORT = 0xff;
     14e:	8b b9       	out	0x0b, r24	; 11
    while(1){
        LED_PORT = LED_DIGITS[counter++];
        counter %= 10;
     150:	ca e0       	ldi	r28, 0x0A	; 10
{
    static uint8_t counter = 0;
    LED_DDR = 0xff;
    LED_PORT = 0xff;
    while(1){
        LED_PORT = LED_DIGITS[counter++];
     152:	e0 91 26 01 	lds	r30, 0x0126	; 0x800126 <__data_end>
     156:	81 e0       	ldi	r24, 0x01	; 1
     158:	8e 0f       	add	r24, r30
     15a:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__data_end>
     15e:	f0 e0       	ldi	r31, 0x00	; 0
     160:	ee 0f       	add	r30, r30
     162:	ff 1f       	adc	r31, r31
     164:	e0 50       	subi	r30, 0x00	; 0
     166:	ff 4f       	sbci	r31, 0xFF	; 255
     168:	80 81       	ld	r24, Z
     16a:	8b b9       	out	0x0b, r24	; 11
        counter %= 10;
     16c:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <__data_end>
     170:	6c 2f       	mov	r22, r28
     172:	0e 94 dd 11 	call	0x23ba	; 0x23ba <__udivmodqi4>
     176:	90 93 26 01 	sts	0x0126, r25	; 0x800126 <__data_end>
        vTaskDelay(1000/portTICK_PERIOD_MS);
     17a:	88 ee       	ldi	r24, 0xE8	; 232
     17c:	93 e0       	ldi	r25, 0x03	; 3
     17e:	0e 94 ef 04 	call	0x9de	; 0x9de <vTaskDelay>
     182:	e7 cf       	rjmp	.-50     	; 0x152 <vLED_counter+0x8>

00000184 <vApplicationIdleHook>:
 * \fn static vApplicationIdleHook(void)
 *
 * \brief
 ******************************************************************************/
void vApplicationIdleHook(void)
{
     184:	08 95       	ret

00000186 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     186:	e0 91 75 01 	lds	r30, 0x0175	; 0x800175 <pxDelayedTaskList>
     18a:	f0 91 76 01 	lds	r31, 0x0176	; 0x800176 <pxDelayedTaskList+0x1>
     18e:	80 81       	ld	r24, Z
     190:	81 11       	cpse	r24, r1
     192:	03 c0       	rjmp	.+6      	; 0x19a <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     194:	8f ef       	ldi	r24, 0xFF	; 255
     196:	9f ef       	ldi	r25, 0xFF	; 255
     198:	0c c0       	rjmp	.+24     	; 0x1b2 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     19a:	e0 91 75 01 	lds	r30, 0x0175	; 0x800175 <pxDelayedTaskList>
     19e:	f0 91 76 01 	lds	r31, 0x0176	; 0x800176 <pxDelayedTaskList+0x1>
     1a2:	05 80       	ldd	r0, Z+5	; 0x05
     1a4:	f6 81       	ldd	r31, Z+6	; 0x06
     1a6:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     1a8:	06 80       	ldd	r0, Z+6	; 0x06
     1aa:	f7 81       	ldd	r31, Z+7	; 0x07
     1ac:	e0 2d       	mov	r30, r0
     1ae:	82 81       	ldd	r24, Z+2	; 0x02
     1b0:	93 81       	ldd	r25, Z+3	; 0x03
     1b2:	90 93 4d 01 	sts	0x014D, r25	; 0x80014d <xNextTaskUnblockTime+0x1>
     1b6:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <xNextTaskUnblockTime>
     1ba:	08 95       	ret

000001bc <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     1bc:	ff 92       	push	r15
     1be:	0f 93       	push	r16
     1c0:	1f 93       	push	r17
     1c2:	cf 93       	push	r28
     1c4:	df 93       	push	r29
     1c6:	ec 01       	movw	r28, r24
     1c8:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     1ca:	00 91 54 01 	lds	r16, 0x0154	; 0x800154 <xTickCount>
     1ce:	10 91 55 01 	lds	r17, 0x0155	; 0x800155 <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     1d2:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <pxCurrentTCB>
     1d6:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     1da:	02 96       	adiw	r24, 0x02	; 2
     1dc:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     1e0:	cf 3f       	cpi	r28, 0xFF	; 255
     1e2:	8f ef       	ldi	r24, 0xFF	; 255
     1e4:	d8 07       	cpc	r29, r24
     1e6:	89 f4       	brne	.+34     	; 0x20a <prvAddCurrentTaskToDelayedList+0x4e>
     1e8:	ff 20       	and	r15, r15
     1ea:	79 f0       	breq	.+30     	; 0x20a <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     1ec:	60 91 47 01 	lds	r22, 0x0147	; 0x800147 <pxCurrentTCB>
     1f0:	70 91 48 01 	lds	r23, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     1f4:	6e 5f       	subi	r22, 0xFE	; 254
     1f6:	7f 4f       	sbci	r23, 0xFF	; 255
     1f8:	87 e5       	ldi	r24, 0x57	; 87
     1fa:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     1fc:	df 91       	pop	r29
     1fe:	cf 91       	pop	r28
     200:	1f 91       	pop	r17
     202:	0f 91       	pop	r16
     204:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     206:	0c 94 c1 0d 	jmp	0x1b82	; 0x1b82 <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     20a:	c0 0f       	add	r28, r16
     20c:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     20e:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     212:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     216:	d3 83       	std	Z+3, r29	; 0x03
     218:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     21a:	60 91 47 01 	lds	r22, 0x0147	; 0x800147 <pxCurrentTCB>
     21e:	70 91 48 01 	lds	r23, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     222:	c0 17       	cp	r28, r16
     224:	d1 07       	cpc	r29, r17
     226:	68 f4       	brcc	.+26     	; 0x242 <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     228:	80 91 73 01 	lds	r24, 0x0173	; 0x800173 <pxOverflowDelayedTaskList>
     22c:	90 91 74 01 	lds	r25, 0x0174	; 0x800174 <pxOverflowDelayedTaskList+0x1>
     230:	6e 5f       	subi	r22, 0xFE	; 254
     232:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     234:	df 91       	pop	r29
     236:	cf 91       	pop	r28
     238:	1f 91       	pop	r17
     23a:	0f 91       	pop	r16
     23c:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     23e:	0c 94 e2 0d 	jmp	0x1bc4	; 0x1bc4 <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     242:	80 91 75 01 	lds	r24, 0x0175	; 0x800175 <pxDelayedTaskList>
     246:	90 91 76 01 	lds	r25, 0x0176	; 0x800176 <pxDelayedTaskList+0x1>
     24a:	6e 5f       	subi	r22, 0xFE	; 254
     24c:	7f 4f       	sbci	r23, 0xFF	; 255
     24e:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     252:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <xNextTaskUnblockTime>
     256:	90 91 4d 01 	lds	r25, 0x014D	; 0x80014d <xNextTaskUnblockTime+0x1>
     25a:	c8 17       	cp	r28, r24
     25c:	d9 07       	cpc	r29, r25
     25e:	20 f4       	brcc	.+8      	; 0x268 <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     260:	d0 93 4d 01 	sts	0x014D, r29	; 0x80014d <xNextTaskUnblockTime+0x1>
     264:	c0 93 4c 01 	sts	0x014C, r28	; 0x80014c <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     268:	df 91       	pop	r29
     26a:	cf 91       	pop	r28
     26c:	1f 91       	pop	r17
     26e:	0f 91       	pop	r16
     270:	ff 90       	pop	r15
     272:	08 95       	ret

00000274 <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     274:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <uxDeletedTasksWaitingCleanUp>
     278:	88 23       	and	r24, r24
     27a:	09 f1       	breq	.+66     	; 0x2be <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     27c:	0f b6       	in	r0, 0x3f	; 63
     27e:	f8 94       	cli
     280:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     282:	e0 91 66 01 	lds	r30, 0x0166	; 0x800166 <xTasksWaitingTermination+0x5>
     286:	f0 91 67 01 	lds	r31, 0x0167	; 0x800167 <xTasksWaitingTermination+0x6>
     28a:	c6 81       	ldd	r28, Z+6	; 0x06
     28c:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     28e:	ce 01       	movw	r24, r28
     290:	02 96       	adiw	r24, 0x02	; 2
     292:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
				--uxCurrentNumberOfTasks;
     296:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <uxCurrentNumberOfTasks>
     29a:	81 50       	subi	r24, 0x01	; 1
     29c:	80 93 56 01 	sts	0x0156, r24	; 0x800156 <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     2a0:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <uxDeletedTasksWaitingCleanUp>
     2a4:	81 50       	subi	r24, 0x01	; 1
     2a6:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     2aa:	0f 90       	pop	r0
     2ac:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     2ae:	8f 89       	ldd	r24, Y+23	; 0x17
     2b0:	98 8d       	ldd	r25, Y+24	; 0x18
     2b2:	0e 94 36 10 	call	0x206c	; 0x206c <vPortFree>
			vPortFree( pxTCB );
     2b6:	ce 01       	movw	r24, r28
     2b8:	0e 94 36 10 	call	0x206c	; 0x206c <vPortFree>
     2bc:	db cf       	rjmp	.-74     	; 0x274 <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     2be:	80 91 89 01 	lds	r24, 0x0189	; 0x800189 <pxReadyTasksLists>
     2c2:	82 30       	cpi	r24, 0x02	; 2
     2c4:	10 f0       	brcs	.+4      	; 0x2ca <prvIdleTask+0x56>
			{
				taskYIELD();
     2c6:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     2ca:	0e 94 c2 00 	call	0x184	; 0x184 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     2ce:	d2 cf       	rjmp	.-92     	; 0x274 <prvIdleTask>

000002d0 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     2d0:	3f 92       	push	r3
     2d2:	4f 92       	push	r4
     2d4:	5f 92       	push	r5
     2d6:	6f 92       	push	r6
     2d8:	7f 92       	push	r7
     2da:	8f 92       	push	r8
     2dc:	9f 92       	push	r9
     2de:	af 92       	push	r10
     2e0:	bf 92       	push	r11
     2e2:	cf 92       	push	r12
     2e4:	df 92       	push	r13
     2e6:	ef 92       	push	r14
     2e8:	ff 92       	push	r15
     2ea:	0f 93       	push	r16
     2ec:	1f 93       	push	r17
     2ee:	cf 93       	push	r28
     2f0:	df 93       	push	r29
     2f2:	4c 01       	movw	r8, r24
     2f4:	16 2f       	mov	r17, r22
     2f6:	37 2e       	mov	r3, r23
     2f8:	6a 01       	movw	r12, r20
     2fa:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     2fc:	ca 01       	movw	r24, r20
     2fe:	0e 94 04 10 	call	0x2008	; 0x2008 <pvPortMalloc>
     302:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     304:	89 2b       	or	r24, r25
     306:	09 f4       	brne	.+2      	; 0x30a <xTaskCreate+0x3a>
     308:	d1 c0       	rjmp	.+418    	; 0x4ac <__EEPROM_REGION_LENGTH__+0xac>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     30a:	86 e2       	ldi	r24, 0x26	; 38
     30c:	90 e0       	ldi	r25, 0x00	; 0
     30e:	0e 94 04 10 	call	0x2008	; 0x2008 <pvPortMalloc>
     312:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     314:	89 2b       	or	r24, r25
     316:	79 f0       	breq	.+30     	; 0x336 <xTaskCreate+0x66>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     318:	58 8e       	std	Y+24, r5	; 0x18
     31a:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     31c:	c6 01       	movw	r24, r12
     31e:	01 97       	sbiw	r24, 0x01	; 1
     320:	32 01       	movw	r6, r4
     322:	68 0e       	add	r6, r24
     324:	79 1e       	adc	r7, r25
     326:	be 01       	movw	r22, r28
     328:	67 5e       	subi	r22, 0xE7	; 231
     32a:	7f 4f       	sbci	r23, 0xFF	; 255
     32c:	e1 2f       	mov	r30, r17
     32e:	f3 2d       	mov	r31, r3
     330:	cf 01       	movw	r24, r30
     332:	08 96       	adiw	r24, 0x08	; 8
     334:	07 c0       	rjmp	.+14     	; 0x344 <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     336:	c2 01       	movw	r24, r4
     338:	0e 94 36 10 	call	0x206c	; 0x206c <vPortFree>
     33c:	b7 c0       	rjmp	.+366    	; 0x4ac <__EEPROM_REGION_LENGTH__+0xac>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     33e:	e8 17       	cp	r30, r24
     340:	f9 07       	cpc	r31, r25
     342:	49 f0       	breq	.+18     	; 0x356 <xTaskCreate+0x86>
     344:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     346:	41 91       	ld	r20, Z+
     348:	db 01       	movw	r26, r22
     34a:	4d 93       	st	X+, r20
     34c:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     34e:	d9 01       	movw	r26, r18
     350:	2c 91       	ld	r18, X
     352:	21 11       	cpse	r18, r1
     354:	f4 cf       	rjmp	.-24     	; 0x33e <xTaskCreate+0x6e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     356:	18 a2       	std	Y+32, r1	; 0x20
     358:	04 30       	cpi	r16, 0x04	; 4
     35a:	08 f0       	brcs	.+2      	; 0x35e <xTaskCreate+0x8e>
     35c:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     35e:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     360:	6e 01       	movw	r12, r28
     362:	b2 e0       	ldi	r27, 0x02	; 2
     364:	cb 0e       	add	r12, r27
     366:	d1 1c       	adc	r13, r1
     368:	c6 01       	movw	r24, r12
     36a:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     36e:	ce 01       	movw	r24, r28
     370:	0c 96       	adiw	r24, 0x0c	; 12
     372:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     376:	d9 87       	std	Y+9, r29	; 0x09
     378:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     37a:	84 e0       	ldi	r24, 0x04	; 4
     37c:	90 e0       	ldi	r25, 0x00	; 0
     37e:	80 1b       	sub	r24, r16
     380:	91 09       	sbc	r25, r1
     382:	9d 87       	std	Y+13, r25	; 0x0d
     384:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     386:	db 8b       	std	Y+19, r29	; 0x13
     388:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     38a:	19 a2       	std	Y+33, r1	; 0x21
     38c:	1a a2       	std	Y+34, r1	; 0x22
     38e:	1b a2       	std	Y+35, r1	; 0x23
     390:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     392:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     394:	a5 01       	movw	r20, r10
     396:	b4 01       	movw	r22, r8
     398:	c3 01       	movw	r24, r6
     39a:	0e 94 45 10 	call	0x208a	; 0x208a <pxPortInitialiseStack>
     39e:	99 83       	std	Y+1, r25	; 0x01
     3a0:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     3a2:	e1 14       	cp	r14, r1
     3a4:	f1 04       	cpc	r15, r1
     3a6:	19 f0       	breq	.+6      	; 0x3ae <xTaskCreate+0xde>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     3a8:	f7 01       	movw	r30, r14
     3aa:	d1 83       	std	Z+1, r29	; 0x01
     3ac:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     3ae:	0f b6       	in	r0, 0x3f	; 63
     3b0:	f8 94       	cli
     3b2:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     3b4:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <uxCurrentNumberOfTasks>
     3b8:	8f 5f       	subi	r24, 0xFF	; 255
     3ba:	80 93 56 01 	sts	0x0156, r24	; 0x800156 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     3be:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <pxCurrentTCB>
     3c2:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     3c6:	89 2b       	or	r24, r25
     3c8:	d1 f5       	brne	.+116    	; 0x43e <__EEPROM_REGION_LENGTH__+0x3e>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     3ca:	d0 93 48 01 	sts	0x0148, r29	; 0x800148 <pxCurrentTCB+0x1>
     3ce:	c0 93 47 01 	sts	0x0147, r28	; 0x800147 <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     3d2:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <uxCurrentNumberOfTasks>
     3d6:	81 30       	cpi	r24, 0x01	; 1
     3d8:	09 f0       	breq	.+2      	; 0x3dc <xTaskCreate+0x10c>
     3da:	41 c0       	rjmp	.+130    	; 0x45e <__EEPROM_REGION_LENGTH__+0x5e>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     3dc:	89 e8       	ldi	r24, 0x89	; 137
     3de:	91 e0       	ldi	r25, 0x01	; 1
     3e0:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
     3e4:	82 e9       	ldi	r24, 0x92	; 146
     3e6:	91 e0       	ldi	r25, 0x01	; 1
     3e8:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
     3ec:	8b e9       	ldi	r24, 0x9B	; 155
     3ee:	91 e0       	ldi	r25, 0x01	; 1
     3f0:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
     3f4:	84 ea       	ldi	r24, 0xA4	; 164
     3f6:	91 e0       	ldi	r25, 0x01	; 1
     3f8:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     3fc:	80 e8       	ldi	r24, 0x80	; 128
     3fe:	91 e0       	ldi	r25, 0x01	; 1
     400:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     404:	87 e7       	ldi	r24, 0x77	; 119
     406:	91 e0       	ldi	r25, 0x01	; 1
     408:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
	vListInitialise( &xPendingReadyList );
     40c:	8a e6       	ldi	r24, 0x6A	; 106
     40e:	91 e0       	ldi	r25, 0x01	; 1
     410:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     414:	81 e6       	ldi	r24, 0x61	; 97
     416:	91 e0       	ldi	r25, 0x01	; 1
     418:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     41c:	87 e5       	ldi	r24, 0x57	; 87
     41e:	91 e0       	ldi	r25, 0x01	; 1
     420:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     424:	80 e8       	ldi	r24, 0x80	; 128
     426:	91 e0       	ldi	r25, 0x01	; 1
     428:	90 93 76 01 	sts	0x0176, r25	; 0x800176 <pxDelayedTaskList+0x1>
     42c:	80 93 75 01 	sts	0x0175, r24	; 0x800175 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     430:	87 e7       	ldi	r24, 0x77	; 119
     432:	91 e0       	ldi	r25, 0x01	; 1
     434:	90 93 74 01 	sts	0x0174, r25	; 0x800174 <pxOverflowDelayedTaskList+0x1>
     438:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <pxOverflowDelayedTaskList>
     43c:	10 c0       	rjmp	.+32     	; 0x45e <__EEPROM_REGION_LENGTH__+0x5e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     43e:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <xSchedulerRunning>
     442:	81 11       	cpse	r24, r1
     444:	0c c0       	rjmp	.+24     	; 0x45e <__EEPROM_REGION_LENGTH__+0x5e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     446:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     44a:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     44e:	96 89       	ldd	r25, Z+22	; 0x16
     450:	8e 89       	ldd	r24, Y+22	; 0x16
     452:	89 17       	cp	r24, r25
     454:	20 f0       	brcs	.+8      	; 0x45e <__EEPROM_REGION_LENGTH__+0x5e>
				{
					pxCurrentTCB = pxNewTCB;
     456:	d0 93 48 01 	sts	0x0148, r29	; 0x800148 <pxCurrentTCB+0x1>
     45a:	c0 93 47 01 	sts	0x0147, r28	; 0x800147 <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     45e:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <uxTaskNumber>
     462:	8f 5f       	subi	r24, 0xFF	; 255
     464:	80 93 4e 01 	sts	0x014E, r24	; 0x80014e <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     468:	8e 89       	ldd	r24, Y+22	; 0x16
     46a:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <uxTopReadyPriority>
     46e:	98 17       	cp	r25, r24
     470:	10 f4       	brcc	.+4      	; 0x476 <__EEPROM_REGION_LENGTH__+0x76>
     472:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxTopReadyPriority>
     476:	f9 e0       	ldi	r31, 0x09	; 9
     478:	8f 9f       	mul	r24, r31
     47a:	c0 01       	movw	r24, r0
     47c:	11 24       	eor	r1, r1
     47e:	b6 01       	movw	r22, r12
     480:	87 57       	subi	r24, 0x77	; 119
     482:	9e 4f       	sbci	r25, 0xFE	; 254
     484:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     488:	0f 90       	pop	r0
     48a:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     48c:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <xSchedulerRunning>
     490:	88 23       	and	r24, r24
     492:	51 f0       	breq	.+20     	; 0x4a8 <__EEPROM_REGION_LENGTH__+0xa8>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     494:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     498:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     49c:	96 89       	ldd	r25, Z+22	; 0x16
     49e:	8e 89       	ldd	r24, Y+22	; 0x16
     4a0:	98 17       	cp	r25, r24
     4a2:	10 f4       	brcc	.+4      	; 0x4a8 <__EEPROM_REGION_LENGTH__+0xa8>
		{
			taskYIELD_IF_USING_PREEMPTION();
     4a4:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     4a8:	81 e0       	ldi	r24, 0x01	; 1
     4aa:	01 c0       	rjmp	.+2      	; 0x4ae <__EEPROM_REGION_LENGTH__+0xae>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     4ac:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     4ae:	df 91       	pop	r29
     4b0:	cf 91       	pop	r28
     4b2:	1f 91       	pop	r17
     4b4:	0f 91       	pop	r16
     4b6:	ff 90       	pop	r15
     4b8:	ef 90       	pop	r14
     4ba:	df 90       	pop	r13
     4bc:	cf 90       	pop	r12
     4be:	bf 90       	pop	r11
     4c0:	af 90       	pop	r10
     4c2:	9f 90       	pop	r9
     4c4:	8f 90       	pop	r8
     4c6:	7f 90       	pop	r7
     4c8:	6f 90       	pop	r6
     4ca:	5f 90       	pop	r5
     4cc:	4f 90       	pop	r4
     4ce:	3f 90       	pop	r3
     4d0:	08 95       	ret

000004d2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     4d2:	0f 93       	push	r16
     4d4:	1f 93       	push	r17
     4d6:	cf 93       	push	r28
     4d8:	df 93       	push	r29
     4da:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     4dc:	0f b6       	in	r0, 0x3f	; 63
     4de:	f8 94       	cli
     4e0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     4e2:	89 2b       	or	r24, r25
     4e4:	21 f4       	brne	.+8      	; 0x4ee <vTaskDelete+0x1c>
     4e6:	c0 91 47 01 	lds	r28, 0x0147	; 0x800147 <pxCurrentTCB>
     4ea:	d0 91 48 01 	lds	r29, 0x0148	; 0x800148 <pxCurrentTCB+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     4ee:	8e 01       	movw	r16, r28
     4f0:	0e 5f       	subi	r16, 0xFE	; 254
     4f2:	1f 4f       	sbci	r17, 0xFF	; 255
     4f4:	c8 01       	movw	r24, r16
     4f6:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     4fa:	8c 89       	ldd	r24, Y+20	; 0x14
     4fc:	9d 89       	ldd	r25, Y+21	; 0x15
     4fe:	89 2b       	or	r24, r25
     500:	21 f0       	breq	.+8      	; 0x50a <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     502:	ce 01       	movw	r24, r28
     504:	0c 96       	adiw	r24, 0x0c	; 12
     506:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     50a:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <uxTaskNumber>
     50e:	8f 5f       	subi	r24, 0xFF	; 255
     510:	80 93 4e 01 	sts	0x014E, r24	; 0x80014e <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     514:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <pxCurrentTCB>
     518:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     51c:	c8 17       	cp	r28, r24
     51e:	d9 07       	cpc	r29, r25
     520:	59 f4       	brne	.+22     	; 0x538 <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     522:	b8 01       	movw	r22, r16
     524:	81 e6       	ldi	r24, 0x61	; 97
     526:	91 e0       	ldi	r25, 0x01	; 1
     528:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     52c:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <uxDeletedTasksWaitingCleanUp>
     530:	8f 5f       	subi	r24, 0xFF	; 255
     532:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <uxDeletedTasksWaitingCleanUp>
     536:	0e c0       	rjmp	.+28     	; 0x554 <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     538:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <uxCurrentNumberOfTasks>
     53c:	81 50       	subi	r24, 0x01	; 1
     53e:	80 93 56 01 	sts	0x0156, r24	; 0x800156 <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     542:	8f 89       	ldd	r24, Y+23	; 0x17
     544:	98 8d       	ldd	r25, Y+24	; 0x18
     546:	0e 94 36 10 	call	0x206c	; 0x206c <vPortFree>
			vPortFree( pxTCB );
     54a:	ce 01       	movw	r24, r28
     54c:	0e 94 36 10 	call	0x206c	; 0x206c <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     550:	0e 94 c3 00 	call	0x186	; 0x186 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     554:	0f 90       	pop	r0
     556:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     558:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <xSchedulerRunning>
     55c:	88 23       	and	r24, r24
     55e:	49 f0       	breq	.+18     	; 0x572 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     560:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <pxCurrentTCB>
     564:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     568:	c8 17       	cp	r28, r24
     56a:	d9 07       	cpc	r29, r25
     56c:	11 f4       	brne	.+4      	; 0x572 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     56e:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     572:	df 91       	pop	r29
     574:	cf 91       	pop	r28
     576:	1f 91       	pop	r17
     578:	0f 91       	pop	r16
     57a:	08 95       	ret

0000057c <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     57c:	0f 93       	push	r16
     57e:	1f 93       	push	r17
     580:	cf 93       	push	r28
     582:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     584:	20 91 47 01 	lds	r18, 0x0147	; 0x800147 <pxCurrentTCB>
     588:	30 91 48 01 	lds	r19, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     58c:	82 17       	cp	r24, r18
     58e:	93 07       	cpc	r25, r19
     590:	b9 f1       	breq	.+110    	; 0x600 <vTaskResume+0x84>
     592:	00 97       	sbiw	r24, 0x00	; 0
     594:	a9 f1       	breq	.+106    	; 0x600 <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     596:	0f b6       	in	r0, 0x3f	; 63
     598:	f8 94       	cli
     59a:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     59c:	fc 01       	movw	r30, r24
     59e:	22 85       	ldd	r18, Z+10	; 0x0a
     5a0:	33 85       	ldd	r19, Z+11	; 0x0b
     5a2:	27 55       	subi	r18, 0x57	; 87
     5a4:	31 40       	sbci	r19, 0x01	; 1
     5a6:	51 f5       	brne	.+84     	; 0x5fc <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     5a8:	fc 01       	movw	r30, r24
     5aa:	24 89       	ldd	r18, Z+20	; 0x14
     5ac:	35 89       	ldd	r19, Z+21	; 0x15
     5ae:	f1 e0       	ldi	r31, 0x01	; 1
     5b0:	2a 36       	cpi	r18, 0x6A	; 106
     5b2:	3f 07       	cpc	r19, r31
     5b4:	19 f1       	breq	.+70     	; 0x5fc <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     5b6:	23 2b       	or	r18, r19
     5b8:	09 f5       	brne	.+66     	; 0x5fc <vTaskResume+0x80>
     5ba:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     5bc:	8c 01       	movw	r16, r24
     5be:	0e 5f       	subi	r16, 0xFE	; 254
     5c0:	1f 4f       	sbci	r17, 0xFF	; 255
     5c2:	c8 01       	movw	r24, r16
     5c4:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     5c8:	8e 89       	ldd	r24, Y+22	; 0x16
     5ca:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <uxTopReadyPriority>
     5ce:	98 17       	cp	r25, r24
     5d0:	10 f4       	brcc	.+4      	; 0x5d6 <vTaskResume+0x5a>
     5d2:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxTopReadyPriority>
     5d6:	29 e0       	ldi	r18, 0x09	; 9
     5d8:	82 9f       	mul	r24, r18
     5da:	c0 01       	movw	r24, r0
     5dc:	11 24       	eor	r1, r1
     5de:	b8 01       	movw	r22, r16
     5e0:	87 57       	subi	r24, 0x77	; 119
     5e2:	9e 4f       	sbci	r25, 0xFE	; 254
     5e4:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     5e8:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     5ec:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     5f0:	9e 89       	ldd	r25, Y+22	; 0x16
     5f2:	86 89       	ldd	r24, Z+22	; 0x16
     5f4:	98 17       	cp	r25, r24
     5f6:	10 f0       	brcs	.+4      	; 0x5fc <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     5f8:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     5fc:	0f 90       	pop	r0
     5fe:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     600:	df 91       	pop	r29
     602:	cf 91       	pop	r28
     604:	1f 91       	pop	r17
     606:	0f 91       	pop	r16
     608:	08 95       	ret

0000060a <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     60a:	ef 92       	push	r14
     60c:	ff 92       	push	r15
     60e:	1f 93       	push	r17
     610:	cf 93       	push	r28
     612:	df 93       	push	r29
     614:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     616:	8a 85       	ldd	r24, Y+10	; 0x0a
     618:	9b 85       	ldd	r25, Y+11	; 0x0b
     61a:	87 55       	subi	r24, 0x57	; 87
     61c:	91 40       	sbci	r25, 0x01	; 1
     61e:	99 f4       	brne	.+38     	; 0x646 <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     620:	8c 89       	ldd	r24, Y+20	; 0x14
     622:	9d 89       	ldd	r25, Y+21	; 0x15
     624:	21 e0       	ldi	r18, 0x01	; 1
     626:	8a 36       	cpi	r24, 0x6A	; 106
     628:	92 07       	cpc	r25, r18
     62a:	69 f0       	breq	.+26     	; 0x646 <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     62c:	89 2b       	or	r24, r25
     62e:	59 f4       	brne	.+22     	; 0x646 <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     630:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <uxSchedulerSuspended>
     634:	88 23       	and	r24, r24
     636:	49 f0       	breq	.+18     	; 0x64a <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     638:	be 01       	movw	r22, r28
     63a:	64 5f       	subi	r22, 0xF4	; 244
     63c:	7f 4f       	sbci	r23, 0xFF	; 255
     63e:	8a e6       	ldi	r24, 0x6A	; 106
     640:	91 e0       	ldi	r25, 0x01	; 1
     642:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     646:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     648:	21 c0       	rjmp	.+66     	; 0x68c <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     64a:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     64e:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     652:	11 e0       	ldi	r17, 0x01	; 1
     654:	9e 89       	ldd	r25, Y+22	; 0x16
     656:	86 89       	ldd	r24, Z+22	; 0x16
     658:	98 17       	cp	r25, r24
     65a:	08 f4       	brcc	.+2      	; 0x65e <xTaskResumeFromISR+0x54>
     65c:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     65e:	7e 01       	movw	r14, r28
     660:	82 e0       	ldi	r24, 0x02	; 2
     662:	e8 0e       	add	r14, r24
     664:	f1 1c       	adc	r15, r1
     666:	c7 01       	movw	r24, r14
     668:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     66c:	8e 89       	ldd	r24, Y+22	; 0x16
     66e:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <uxTopReadyPriority>
     672:	98 17       	cp	r25, r24
     674:	10 f4       	brcc	.+4      	; 0x67a <xTaskResumeFromISR+0x70>
     676:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxTopReadyPriority>
     67a:	29 e0       	ldi	r18, 0x09	; 9
     67c:	82 9f       	mul	r24, r18
     67e:	c0 01       	movw	r24, r0
     680:	11 24       	eor	r1, r1
     682:	b7 01       	movw	r22, r14
     684:	87 57       	subi	r24, 0x77	; 119
     686:	9e 4f       	sbci	r25, 0xFE	; 254
     688:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     68c:	81 2f       	mov	r24, r17
     68e:	df 91       	pop	r29
     690:	cf 91       	pop	r28
     692:	1f 91       	pop	r17
     694:	ff 90       	pop	r15
     696:	ef 90       	pop	r14
     698:	08 95       	ret

0000069a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     69a:	ef 92       	push	r14
     69c:	ff 92       	push	r15
     69e:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     6a0:	8a e4       	ldi	r24, 0x4A	; 74
     6a2:	e8 2e       	mov	r14, r24
     6a4:	81 e0       	ldi	r24, 0x01	; 1
     6a6:	f8 2e       	mov	r15, r24
     6a8:	00 e0       	ldi	r16, 0x00	; 0
     6aa:	20 e0       	ldi	r18, 0x00	; 0
     6ac:	30 e0       	ldi	r19, 0x00	; 0
     6ae:	45 e5       	ldi	r20, 0x55	; 85
     6b0:	50 e0       	ldi	r21, 0x00	; 0
     6b2:	61 e2       	ldi	r22, 0x21	; 33
     6b4:	71 e0       	ldi	r23, 0x01	; 1
     6b6:	8a e3       	ldi	r24, 0x3A	; 58
     6b8:	91 e0       	ldi	r25, 0x01	; 1
     6ba:	0e 94 68 01 	call	0x2d0	; 0x2d0 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     6be:	81 30       	cpi	r24, 0x01	; 1
     6c0:	91 f4       	brne	.+36     	; 0x6e6 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     6c2:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     6c4:	2f ef       	ldi	r18, 0xFF	; 255
     6c6:	3f ef       	ldi	r19, 0xFF	; 255
     6c8:	30 93 4d 01 	sts	0x014D, r19	; 0x80014d <xNextTaskUnblockTime+0x1>
     6cc:	20 93 4c 01 	sts	0x014C, r18	; 0x80014c <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     6d0:	80 93 52 01 	sts	0x0152, r24	; 0x800152 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     6d4:	10 92 55 01 	sts	0x0155, r1	; 0x800155 <xTickCount+0x1>
     6d8:	10 92 54 01 	sts	0x0154, r1	; 0x800154 <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     6dc:	0f 91       	pop	r16
     6de:	ff 90       	pop	r15
     6e0:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     6e2:	0c 94 b1 10 	jmp	0x2162	; 0x2162 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     6e6:	0f 91       	pop	r16
     6e8:	ff 90       	pop	r15
     6ea:	ef 90       	pop	r14
     6ec:	08 95       	ret

000006ee <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     6ee:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     6f0:	10 92 52 01 	sts	0x0152, r1	; 0x800152 <xSchedulerRunning>
	vPortEndScheduler();
     6f4:	0c 94 f1 10 	jmp	0x21e2	; 0x21e2 <vPortEndScheduler>

000006f8 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     6f8:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <uxSchedulerSuspended>
     6fc:	8f 5f       	subi	r24, 0xFF	; 255
     6fe:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <uxSchedulerSuspended>
     702:	08 95       	ret

00000704 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     704:	0f b6       	in	r0, 0x3f	; 63
     706:	f8 94       	cli
     708:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     70a:	80 91 54 01 	lds	r24, 0x0154	; 0x800154 <xTickCount>
     70e:	90 91 55 01 	lds	r25, 0x0155	; 0x800155 <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     712:	0f 90       	pop	r0
     714:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     716:	08 95       	ret

00000718 <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     718:	80 91 54 01 	lds	r24, 0x0154	; 0x800154 <xTickCount>
     71c:	90 91 55 01 	lds	r25, 0x0155	; 0x800155 <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     720:	08 95       	ret

00000722 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     722:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <uxCurrentNumberOfTasks>
}
     726:	08 95       	ret

00000728 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     728:	00 97       	sbiw	r24, 0x00	; 0
     72a:	21 f4       	brne	.+8      	; 0x734 <pcTaskGetName+0xc>
     72c:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <pxCurrentTCB>
     730:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     734:	49 96       	adiw	r24, 0x19	; 25
     736:	08 95       	ret

00000738 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     738:	cf 92       	push	r12
     73a:	df 92       	push	r13
     73c:	ef 92       	push	r14
     73e:	ff 92       	push	r15
     740:	0f 93       	push	r16
     742:	1f 93       	push	r17
     744:	cf 93       	push	r28
     746:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     748:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <uxSchedulerSuspended>
     74c:	81 11       	cpse	r24, r1
     74e:	8c c0       	rjmp	.+280    	; 0x868 <__DATA_REGION_LENGTH__+0x68>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     750:	00 91 54 01 	lds	r16, 0x0154	; 0x800154 <xTickCount>
     754:	10 91 55 01 	lds	r17, 0x0155	; 0x800155 <xTickCount+0x1>
     758:	0f 5f       	subi	r16, 0xFF	; 255
     75a:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     75c:	10 93 55 01 	sts	0x0155, r17	; 0x800155 <xTickCount+0x1>
     760:	00 93 54 01 	sts	0x0154, r16	; 0x800154 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     764:	01 15       	cp	r16, r1
     766:	11 05       	cpc	r17, r1
     768:	b9 f4       	brne	.+46     	; 0x798 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     76a:	80 91 75 01 	lds	r24, 0x0175	; 0x800175 <pxDelayedTaskList>
     76e:	90 91 76 01 	lds	r25, 0x0176	; 0x800176 <pxDelayedTaskList+0x1>
     772:	20 91 73 01 	lds	r18, 0x0173	; 0x800173 <pxOverflowDelayedTaskList>
     776:	30 91 74 01 	lds	r19, 0x0174	; 0x800174 <pxOverflowDelayedTaskList+0x1>
     77a:	30 93 76 01 	sts	0x0176, r19	; 0x800176 <pxDelayedTaskList+0x1>
     77e:	20 93 75 01 	sts	0x0175, r18	; 0x800175 <pxDelayedTaskList>
     782:	90 93 74 01 	sts	0x0174, r25	; 0x800174 <pxOverflowDelayedTaskList+0x1>
     786:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <pxOverflowDelayedTaskList>
     78a:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <xNumOfOverflows>
     78e:	8f 5f       	subi	r24, 0xFF	; 255
     790:	80 93 4f 01 	sts	0x014F, r24	; 0x80014f <xNumOfOverflows>
     794:	0e 94 c3 00 	call	0x186	; 0x186 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     798:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <xNextTaskUnblockTime>
     79c:	90 91 4d 01 	lds	r25, 0x014D	; 0x80014d <xNextTaskUnblockTime+0x1>
     7a0:	c0 e0       	ldi	r28, 0x00	; 0
     7a2:	08 17       	cp	r16, r24
     7a4:	19 07       	cpc	r17, r25
     7a6:	08 f4       	brcc	.+2      	; 0x7aa <xTaskIncrementTick+0x72>
     7a8:	4f c0       	rjmp	.+158    	; 0x848 <__DATA_REGION_LENGTH__+0x48>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     7aa:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     7ac:	e0 91 75 01 	lds	r30, 0x0175	; 0x800175 <pxDelayedTaskList>
     7b0:	f0 91 76 01 	lds	r31, 0x0176	; 0x800176 <pxDelayedTaskList+0x1>
     7b4:	80 81       	ld	r24, Z
     7b6:	81 11       	cpse	r24, r1
     7b8:	03 c0       	rjmp	.+6      	; 0x7c0 <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     7ba:	8f ef       	ldi	r24, 0xFF	; 255
     7bc:	9f ef       	ldi	r25, 0xFF	; 255
     7be:	11 c0       	rjmp	.+34     	; 0x7e2 <xTaskIncrementTick+0xaa>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     7c0:	e0 91 75 01 	lds	r30, 0x0175	; 0x800175 <pxDelayedTaskList>
     7c4:	f0 91 76 01 	lds	r31, 0x0176	; 0x800176 <pxDelayedTaskList+0x1>
     7c8:	05 80       	ldd	r0, Z+5	; 0x05
     7ca:	f6 81       	ldd	r31, Z+6	; 0x06
     7cc:	e0 2d       	mov	r30, r0
     7ce:	e6 80       	ldd	r14, Z+6	; 0x06
     7d0:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     7d2:	d7 01       	movw	r26, r14
     7d4:	12 96       	adiw	r26, 0x02	; 2
     7d6:	8d 91       	ld	r24, X+
     7d8:	9c 91       	ld	r25, X
     7da:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     7dc:	08 17       	cp	r16, r24
     7de:	19 07       	cpc	r17, r25
     7e0:	28 f4       	brcc	.+10     	; 0x7ec <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     7e2:	90 93 4d 01 	sts	0x014D, r25	; 0x80014d <xNextTaskUnblockTime+0x1>
     7e6:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     7ea:	2e c0       	rjmp	.+92     	; 0x848 <__DATA_REGION_LENGTH__+0x48>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     7ec:	67 01       	movw	r12, r14
     7ee:	b2 e0       	ldi	r27, 0x02	; 2
     7f0:	cb 0e       	add	r12, r27
     7f2:	d1 1c       	adc	r13, r1
     7f4:	c6 01       	movw	r24, r12
     7f6:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     7fa:	f7 01       	movw	r30, r14
     7fc:	84 89       	ldd	r24, Z+20	; 0x14
     7fe:	95 89       	ldd	r25, Z+21	; 0x15
     800:	89 2b       	or	r24, r25
     802:	21 f0       	breq	.+8      	; 0x80c <__DATA_REGION_LENGTH__+0xc>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     804:	c7 01       	movw	r24, r14
     806:	0c 96       	adiw	r24, 0x0c	; 12
     808:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     80c:	d7 01       	movw	r26, r14
     80e:	56 96       	adiw	r26, 0x16	; 22
     810:	8c 91       	ld	r24, X
     812:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <uxTopReadyPriority>
     816:	98 17       	cp	r25, r24
     818:	10 f4       	brcc	.+4      	; 0x81e <__DATA_REGION_LENGTH__+0x1e>
     81a:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxTopReadyPriority>
     81e:	d8 9f       	mul	r29, r24
     820:	c0 01       	movw	r24, r0
     822:	11 24       	eor	r1, r1
     824:	b6 01       	movw	r22, r12
     826:	87 57       	subi	r24, 0x77	; 119
     828:	9e 4f       	sbci	r25, 0xFE	; 254
     82a:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     82e:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     832:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     836:	d7 01       	movw	r26, r14
     838:	56 96       	adiw	r26, 0x16	; 22
     83a:	9c 91       	ld	r25, X
     83c:	86 89       	ldd	r24, Z+22	; 0x16
     83e:	98 17       	cp	r25, r24
     840:	08 f4       	brcc	.+2      	; 0x844 <__DATA_REGION_LENGTH__+0x44>
     842:	b4 cf       	rjmp	.-152    	; 0x7ac <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     844:	c1 e0       	ldi	r28, 0x01	; 1
     846:	b2 cf       	rjmp	.-156    	; 0x7ac <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     848:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     84c:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     850:	e6 89       	ldd	r30, Z+22	; 0x16
     852:	b9 e0       	ldi	r27, 0x09	; 9
     854:	eb 9f       	mul	r30, r27
     856:	f0 01       	movw	r30, r0
     858:	11 24       	eor	r1, r1
     85a:	e7 57       	subi	r30, 0x77	; 119
     85c:	fe 4f       	sbci	r31, 0xFE	; 254
     85e:	80 81       	ld	r24, Z
     860:	82 30       	cpi	r24, 0x02	; 2
     862:	40 f0       	brcs	.+16     	; 0x874 <__DATA_REGION_LENGTH__+0x74>
			{
				xSwitchRequired = pdTRUE;
     864:	c1 e0       	ldi	r28, 0x01	; 1
     866:	06 c0       	rjmp	.+12     	; 0x874 <__DATA_REGION_LENGTH__+0x74>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     868:	80 91 51 01 	lds	r24, 0x0151	; 0x800151 <uxPendedTicks>
     86c:	8f 5f       	subi	r24, 0xFF	; 255
     86e:	80 93 51 01 	sts	0x0151, r24	; 0x800151 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     872:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     874:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <xYieldPending>
     878:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     87a:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     87c:	8c 2f       	mov	r24, r28
     87e:	df 91       	pop	r29
     880:	cf 91       	pop	r28
     882:	1f 91       	pop	r17
     884:	0f 91       	pop	r16
     886:	ff 90       	pop	r15
     888:	ef 90       	pop	r14
     88a:	df 90       	pop	r13
     88c:	cf 90       	pop	r12
     88e:	08 95       	ret

00000890 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     890:	ef 92       	push	r14
     892:	ff 92       	push	r15
     894:	0f 93       	push	r16
     896:	1f 93       	push	r17
     898:	cf 93       	push	r28
     89a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     89c:	0f b6       	in	r0, 0x3f	; 63
     89e:	f8 94       	cli
     8a0:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     8a2:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <uxSchedulerSuspended>
     8a6:	81 50       	subi	r24, 0x01	; 1
     8a8:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     8ac:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <uxSchedulerSuspended>
     8b0:	88 23       	and	r24, r24
     8b2:	11 f0       	breq	.+4      	; 0x8b8 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     8b4:	80 e0       	ldi	r24, 0x00	; 0
     8b6:	52 c0       	rjmp	.+164    	; 0x95c <__stack+0x5d>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     8b8:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <uxCurrentNumberOfTasks>
     8bc:	88 23       	and	r24, r24
     8be:	d1 f3       	breq	.-12     	; 0x8b4 <xTaskResumeAll+0x24>
     8c0:	c0 e0       	ldi	r28, 0x00	; 0
     8c2:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     8c4:	89 e0       	ldi	r24, 0x09	; 9
     8c6:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     8c8:	ee 24       	eor	r14, r14
     8ca:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     8cc:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <xPendingReadyList>
     8d0:	88 23       	and	r24, r24
     8d2:	51 f1       	breq	.+84     	; 0x928 <__stack+0x29>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     8d4:	e0 91 6f 01 	lds	r30, 0x016F	; 0x80016f <xPendingReadyList+0x5>
     8d8:	f0 91 70 01 	lds	r31, 0x0170	; 0x800170 <xPendingReadyList+0x6>
     8dc:	c6 81       	ldd	r28, Z+6	; 0x06
     8de:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     8e0:	ce 01       	movw	r24, r28
     8e2:	0c 96       	adiw	r24, 0x0c	; 12
     8e4:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     8e8:	8e 01       	movw	r16, r28
     8ea:	0e 5f       	subi	r16, 0xFE	; 254
     8ec:	1f 4f       	sbci	r17, 0xFF	; 255
     8ee:	c8 01       	movw	r24, r16
     8f0:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     8f4:	8e 89       	ldd	r24, Y+22	; 0x16
     8f6:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <uxTopReadyPriority>
     8fa:	98 17       	cp	r25, r24
     8fc:	10 f4       	brcc	.+4      	; 0x902 <__stack+0x3>
     8fe:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxTopReadyPriority>
     902:	f8 9e       	mul	r15, r24
     904:	c0 01       	movw	r24, r0
     906:	11 24       	eor	r1, r1
     908:	b8 01       	movw	r22, r16
     90a:	87 57       	subi	r24, 0x77	; 119
     90c:	9e 4f       	sbci	r25, 0xFE	; 254
     90e:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     912:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     916:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     91a:	9e 89       	ldd	r25, Y+22	; 0x16
     91c:	86 89       	ldd	r24, Z+22	; 0x16
     91e:	98 17       	cp	r25, r24
     920:	a8 f2       	brcs	.-86     	; 0x8cc <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     922:	e0 92 50 01 	sts	0x0150, r14	; 0x800150 <xYieldPending>
     926:	d2 cf       	rjmp	.-92     	; 0x8cc <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     928:	cd 2b       	or	r28, r29
     92a:	11 f0       	breq	.+4      	; 0x930 <__stack+0x31>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     92c:	0e 94 c3 00 	call	0x186	; 0x186 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     930:	c0 91 51 01 	lds	r28, 0x0151	; 0x800151 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     934:	cc 23       	and	r28, r28
     936:	51 f0       	breq	.+20     	; 0x94c <__stack+0x4d>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     938:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     93a:	0e 94 9c 03 	call	0x738	; 0x738 <xTaskIncrementTick>
     93e:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     940:	d0 93 50 01 	sts	0x0150, r29	; 0x800150 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     944:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     946:	c9 f7       	brne	.-14     	; 0x93a <__stack+0x3b>

						uxPendedTicks = 0;
     948:	10 92 51 01 	sts	0x0151, r1	; 0x800151 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     94c:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <xYieldPending>
     950:	88 23       	and	r24, r24
     952:	09 f4       	brne	.+2      	; 0x956 <__stack+0x57>
     954:	af cf       	rjmp	.-162    	; 0x8b4 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     956:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     95a:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     95c:	0f 90       	pop	r0
     95e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     960:	df 91       	pop	r29
     962:	cf 91       	pop	r28
     964:	1f 91       	pop	r17
     966:	0f 91       	pop	r16
     968:	ff 90       	pop	r15
     96a:	ef 90       	pop	r14
     96c:	08 95       	ret

0000096e <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     96e:	0f 93       	push	r16
     970:	1f 93       	push	r17
     972:	cf 93       	push	r28
     974:	df 93       	push	r29
     976:	8c 01       	movw	r16, r24
     978:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     97a:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     97e:	40 91 54 01 	lds	r20, 0x0154	; 0x800154 <xTickCount>
     982:	50 91 55 01 	lds	r21, 0x0155	; 0x800155 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     986:	f8 01       	movw	r30, r16
     988:	20 81       	ld	r18, Z
     98a:	31 81       	ldd	r19, Z+1	; 0x01
     98c:	c9 01       	movw	r24, r18
     98e:	8c 0f       	add	r24, r28
     990:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     992:	42 17       	cp	r20, r18
     994:	53 07       	cpc	r21, r19
     996:	20 f4       	brcc	.+8      	; 0x9a0 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     998:	82 17       	cp	r24, r18
     99a:	93 07       	cpc	r25, r19
     99c:	40 f4       	brcc	.+16     	; 0x9ae <vTaskDelayUntil+0x40>
     99e:	03 c0       	rjmp	.+6      	; 0x9a6 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     9a0:	82 17       	cp	r24, r18
     9a2:	93 07       	cpc	r25, r19
     9a4:	30 f0       	brcs	.+12     	; 0x9b2 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     9a6:	21 e0       	ldi	r18, 0x01	; 1
     9a8:	48 17       	cp	r20, r24
     9aa:	59 07       	cpc	r21, r25
     9ac:	18 f0       	brcs	.+6      	; 0x9b4 <vTaskDelayUntil+0x46>
     9ae:	20 e0       	ldi	r18, 0x00	; 0
     9b0:	01 c0       	rjmp	.+2      	; 0x9b4 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     9b2:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     9b4:	f8 01       	movw	r30, r16
     9b6:	91 83       	std	Z+1, r25	; 0x01
     9b8:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     9ba:	22 23       	and	r18, r18
     9bc:	29 f0       	breq	.+10     	; 0x9c8 <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     9be:	60 e0       	ldi	r22, 0x00	; 0
     9c0:	84 1b       	sub	r24, r20
     9c2:	95 0b       	sbc	r25, r21
     9c4:	0e 94 de 00 	call	0x1bc	; 0x1bc <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     9c8:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     9cc:	81 11       	cpse	r24, r1
     9ce:	02 c0       	rjmp	.+4      	; 0x9d4 <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     9d0:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     9d4:	df 91       	pop	r29
     9d6:	cf 91       	pop	r28
     9d8:	1f 91       	pop	r17
     9da:	0f 91       	pop	r16
     9dc:	08 95       	ret

000009de <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     9de:	cf 93       	push	r28
     9e0:	df 93       	push	r29
     9e2:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     9e4:	89 2b       	or	r24, r25
     9e6:	19 f4       	brne	.+6      	; 0x9ee <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     9e8:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
     9ec:	0a c0       	rjmp	.+20     	; 0xa02 <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     9ee:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     9f2:	60 e0       	ldi	r22, 0x00	; 0
     9f4:	ce 01       	movw	r24, r28
     9f6:	0e 94 de 00 	call	0x1bc	; 0x1bc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     9fa:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     9fe:	88 23       	and	r24, r24
     a00:	99 f3       	breq	.-26     	; 0x9e8 <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a02:	df 91       	pop	r29
     a04:	cf 91       	pop	r28
     a06:	08 95       	ret

00000a08 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     a08:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <uxSchedulerSuspended>
     a0c:	88 23       	and	r24, r24
     a0e:	21 f0       	breq	.+8      	; 0xa18 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     a10:	81 e0       	ldi	r24, 0x01	; 1
     a12:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <xYieldPending>
     a16:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     a18:	10 92 50 01 	sts	0x0150, r1	; 0x800150 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     a1c:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <uxTopReadyPriority>
     a20:	69 e0       	ldi	r22, 0x09	; 9
     a22:	48 2f       	mov	r20, r24
     a24:	50 e0       	ldi	r21, 0x00	; 0
     a26:	64 9f       	mul	r22, r20
     a28:	90 01       	movw	r18, r0
     a2a:	65 9f       	mul	r22, r21
     a2c:	30 0d       	add	r19, r0
     a2e:	11 24       	eor	r1, r1
     a30:	f9 01       	movw	r30, r18
     a32:	e7 57       	subi	r30, 0x77	; 119
     a34:	fe 4f       	sbci	r31, 0xFE	; 254
     a36:	90 81       	ld	r25, Z
     a38:	91 11       	cpse	r25, r1
     a3a:	02 c0       	rjmp	.+4      	; 0xa40 <vTaskSwitchContext+0x38>
     a3c:	81 50       	subi	r24, 0x01	; 1
     a3e:	f1 cf       	rjmp	.-30     	; 0xa22 <vTaskSwitchContext+0x1a>
     a40:	a1 81       	ldd	r26, Z+1	; 0x01
     a42:	b2 81       	ldd	r27, Z+2	; 0x02
     a44:	12 96       	adiw	r26, 0x02	; 2
     a46:	0d 90       	ld	r0, X+
     a48:	bc 91       	ld	r27, X
     a4a:	a0 2d       	mov	r26, r0
     a4c:	b2 83       	std	Z+2, r27	; 0x02
     a4e:	a1 83       	std	Z+1, r26	; 0x01
     a50:	24 57       	subi	r18, 0x74	; 116
     a52:	3e 4f       	sbci	r19, 0xFE	; 254
     a54:	a2 17       	cp	r26, r18
     a56:	b3 07       	cpc	r27, r19
     a58:	31 f4       	brne	.+12     	; 0xa66 <vTaskSwitchContext+0x5e>
     a5a:	12 96       	adiw	r26, 0x02	; 2
     a5c:	2d 91       	ld	r18, X+
     a5e:	3c 91       	ld	r19, X
     a60:	13 97       	sbiw	r26, 0x03	; 3
     a62:	32 83       	std	Z+2, r19	; 0x02
     a64:	21 83       	std	Z+1, r18	; 0x01
     a66:	99 e0       	ldi	r25, 0x09	; 9
     a68:	94 9f       	mul	r25, r20
     a6a:	f0 01       	movw	r30, r0
     a6c:	95 9f       	mul	r25, r21
     a6e:	f0 0d       	add	r31, r0
     a70:	11 24       	eor	r1, r1
     a72:	e7 57       	subi	r30, 0x77	; 119
     a74:	fe 4f       	sbci	r31, 0xFE	; 254
     a76:	01 80       	ldd	r0, Z+1	; 0x01
     a78:	f2 81       	ldd	r31, Z+2	; 0x02
     a7a:	e0 2d       	mov	r30, r0
     a7c:	26 81       	ldd	r18, Z+6	; 0x06
     a7e:	37 81       	ldd	r19, Z+7	; 0x07
     a80:	30 93 48 01 	sts	0x0148, r19	; 0x800148 <pxCurrentTCB+0x1>
     a84:	20 93 47 01 	sts	0x0147, r18	; 0x800147 <pxCurrentTCB>
     a88:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxTopReadyPriority>
     a8c:	08 95       	ret

00000a8e <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     a8e:	0f 93       	push	r16
     a90:	1f 93       	push	r17
     a92:	cf 93       	push	r28
     a94:	df 93       	push	r29
     a96:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     a98:	0f b6       	in	r0, 0x3f	; 63
     a9a:	f8 94       	cli
     a9c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     a9e:	89 2b       	or	r24, r25
     aa0:	21 f4       	brne	.+8      	; 0xaaa <vTaskSuspend+0x1c>
     aa2:	c0 91 47 01 	lds	r28, 0x0147	; 0x800147 <pxCurrentTCB>
     aa6:	d0 91 48 01 	lds	r29, 0x0148	; 0x800148 <pxCurrentTCB+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     aaa:	8e 01       	movw	r16, r28
     aac:	0e 5f       	subi	r16, 0xFE	; 254
     aae:	1f 4f       	sbci	r17, 0xFF	; 255
     ab0:	c8 01       	movw	r24, r16
     ab2:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     ab6:	8c 89       	ldd	r24, Y+20	; 0x14
     ab8:	9d 89       	ldd	r25, Y+21	; 0x15
     aba:	89 2b       	or	r24, r25
     abc:	21 f0       	breq	.+8      	; 0xac6 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     abe:	ce 01       	movw	r24, r28
     ac0:	0c 96       	adiw	r24, 0x0c	; 12
     ac2:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     ac6:	b8 01       	movw	r22, r16
     ac8:	87 e5       	ldi	r24, 0x57	; 87
     aca:	91 e0       	ldi	r25, 0x01	; 1
     acc:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     ad0:	8d a1       	ldd	r24, Y+37	; 0x25
     ad2:	81 30       	cpi	r24, 0x01	; 1
     ad4:	09 f4       	brne	.+2      	; 0xad8 <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     ad6:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     ad8:	0f 90       	pop	r0
     ada:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     adc:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <xSchedulerRunning>
     ae0:	88 23       	and	r24, r24
     ae2:	39 f0       	breq	.+14     	; 0xaf2 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     ae4:	0f b6       	in	r0, 0x3f	; 63
     ae6:	f8 94       	cli
     ae8:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     aea:	0e 94 c3 00 	call	0x186	; 0x186 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     aee:	0f 90       	pop	r0
     af0:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     af2:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <pxCurrentTCB>
     af6:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     afa:	c8 17       	cp	r28, r24
     afc:	d9 07       	cpc	r29, r25
     afe:	c1 f4       	brne	.+48     	; 0xb30 <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     b00:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <xSchedulerRunning>
     b04:	88 23       	and	r24, r24
     b06:	19 f0       	breq	.+6      	; 0xb0e <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     b08:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
     b0c:	11 c0       	rjmp	.+34     	; 0xb30 <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     b0e:	90 91 57 01 	lds	r25, 0x0157	; 0x800157 <xSuspendedTaskList>
     b12:	80 91 56 01 	lds	r24, 0x0156	; 0x800156 <uxCurrentNumberOfTasks>
     b16:	98 13       	cpse	r25, r24
     b18:	05 c0       	rjmp	.+10     	; 0xb24 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     b1a:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <pxCurrentTCB+0x1>
     b1e:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <pxCurrentTCB>
     b22:	06 c0       	rjmp	.+12     	; 0xb30 <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b24:	df 91       	pop	r29
     b26:	cf 91       	pop	r28
     b28:	1f 91       	pop	r17
     b2a:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     b2c:	0c 94 04 05 	jmp	0xa08	; 0xa08 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b30:	df 91       	pop	r29
     b32:	cf 91       	pop	r28
     b34:	1f 91       	pop	r17
     b36:	0f 91       	pop	r16
     b38:	08 95       	ret

00000b3a <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     b3a:	cf 93       	push	r28
     b3c:	df 93       	push	r29
     b3e:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b40:	60 91 47 01 	lds	r22, 0x0147	; 0x800147 <pxCurrentTCB>
     b44:	70 91 48 01 	lds	r23, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     b48:	64 5f       	subi	r22, 0xF4	; 244
     b4a:	7f 4f       	sbci	r23, 0xFF	; 255
     b4c:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b50:	61 e0       	ldi	r22, 0x01	; 1
     b52:	ce 01       	movw	r24, r28
}
     b54:	df 91       	pop	r29
     b56:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b58:	0c 94 de 00 	jmp	0x1bc	; 0x1bc <prvAddCurrentTaskToDelayedList>

00000b5c <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     b5c:	cf 93       	push	r28
     b5e:	df 93       	push	r29
     b60:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     b62:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     b66:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     b6a:	70 68       	ori	r23, 0x80	; 128
     b6c:	75 87       	std	Z+13, r23	; 0x0d
     b6e:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b70:	60 91 47 01 	lds	r22, 0x0147	; 0x800147 <pxCurrentTCB>
     b74:	70 91 48 01 	lds	r23, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     b78:	64 5f       	subi	r22, 0xF4	; 244
     b7a:	7f 4f       	sbci	r23, 0xFF	; 255
     b7c:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b80:	61 e0       	ldi	r22, 0x01	; 1
     b82:	ce 01       	movw	r24, r28
}
     b84:	df 91       	pop	r29
     b86:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b88:	0c 94 de 00 	jmp	0x1bc	; 0x1bc <prvAddCurrentTaskToDelayedList>

00000b8c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     b8c:	0f 93       	push	r16
     b8e:	1f 93       	push	r17
     b90:	cf 93       	push	r28
     b92:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     b94:	dc 01       	movw	r26, r24
     b96:	15 96       	adiw	r26, 0x05	; 5
     b98:	ed 91       	ld	r30, X+
     b9a:	fc 91       	ld	r31, X
     b9c:	16 97       	sbiw	r26, 0x06	; 6
     b9e:	c6 81       	ldd	r28, Z+6	; 0x06
     ba0:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     ba2:	8e 01       	movw	r16, r28
     ba4:	04 5f       	subi	r16, 0xF4	; 244
     ba6:	1f 4f       	sbci	r17, 0xFF	; 255
     ba8:	c8 01       	movw	r24, r16
     baa:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     bae:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <uxSchedulerSuspended>
     bb2:	81 11       	cpse	r24, r1
     bb4:	14 c0       	rjmp	.+40     	; 0xbde <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     bb6:	0a 50       	subi	r16, 0x0A	; 10
     bb8:	11 09       	sbc	r17, r1
     bba:	c8 01       	movw	r24, r16
     bbc:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     bc0:	8e 89       	ldd	r24, Y+22	; 0x16
     bc2:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <uxTopReadyPriority>
     bc6:	98 17       	cp	r25, r24
     bc8:	10 f4       	brcc	.+4      	; 0xbce <xTaskRemoveFromEventList+0x42>
     bca:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxTopReadyPriority>
     bce:	b9 e0       	ldi	r27, 0x09	; 9
     bd0:	8b 9f       	mul	r24, r27
     bd2:	c0 01       	movw	r24, r0
     bd4:	11 24       	eor	r1, r1
     bd6:	b8 01       	movw	r22, r16
     bd8:	87 57       	subi	r24, 0x77	; 119
     bda:	9e 4f       	sbci	r25, 0xFE	; 254
     bdc:	03 c0       	rjmp	.+6      	; 0xbe4 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     bde:	b8 01       	movw	r22, r16
     be0:	8a e6       	ldi	r24, 0x6A	; 106
     be2:	91 e0       	ldi	r25, 0x01	; 1
     be4:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     be8:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     bec:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     bf0:	9e 89       	ldd	r25, Y+22	; 0x16
     bf2:	86 89       	ldd	r24, Z+22	; 0x16
     bf4:	89 17       	cp	r24, r25
     bf6:	20 f4       	brcc	.+8      	; 0xc00 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     bf8:	81 e0       	ldi	r24, 0x01	; 1
     bfa:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <xYieldPending>
     bfe:	01 c0       	rjmp	.+2      	; 0xc02 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     c00:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     c02:	df 91       	pop	r29
     c04:	cf 91       	pop	r28
     c06:	1f 91       	pop	r17
     c08:	0f 91       	pop	r16
     c0a:	08 95       	ret

00000c0c <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     c0c:	0f 93       	push	r16
     c0e:	1f 93       	push	r17
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c14:	70 68       	ori	r23, 0x80	; 128
     c16:	fc 01       	movw	r30, r24
     c18:	71 83       	std	Z+1, r23	; 0x01
     c1a:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     c1c:	c6 81       	ldd	r28, Z+6	; 0x06
     c1e:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     c20:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c24:	8e 01       	movw	r16, r28
     c26:	0e 5f       	subi	r16, 0xFE	; 254
     c28:	1f 4f       	sbci	r17, 0xFF	; 255
     c2a:	c8 01       	movw	r24, r16
     c2c:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     c30:	8e 89       	ldd	r24, Y+22	; 0x16
     c32:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <uxTopReadyPriority>
     c36:	98 17       	cp	r25, r24
     c38:	10 f4       	brcc	.+4      	; 0xc3e <vTaskRemoveFromUnorderedEventList+0x32>
     c3a:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxTopReadyPriority>
     c3e:	f9 e0       	ldi	r31, 0x09	; 9
     c40:	8f 9f       	mul	r24, r31
     c42:	c0 01       	movw	r24, r0
     c44:	11 24       	eor	r1, r1
     c46:	b8 01       	movw	r22, r16
     c48:	87 57       	subi	r24, 0x77	; 119
     c4a:	9e 4f       	sbci	r25, 0xFE	; 254
     c4c:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     c50:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     c54:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     c58:	9e 89       	ldd	r25, Y+22	; 0x16
     c5a:	86 89       	ldd	r24, Z+22	; 0x16
     c5c:	89 17       	cp	r24, r25
     c5e:	18 f4       	brcc	.+6      	; 0xc66 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     c60:	81 e0       	ldi	r24, 0x01	; 1
     c62:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <xYieldPending>
	}
}
     c66:	df 91       	pop	r29
     c68:	cf 91       	pop	r28
     c6a:	1f 91       	pop	r17
     c6c:	0f 91       	pop	r16
     c6e:	08 95       	ret

00000c70 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     c70:	0f b6       	in	r0, 0x3f	; 63
     c72:	f8 94       	cli
     c74:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     c76:	20 91 4f 01 	lds	r18, 0x014F	; 0x80014f <xNumOfOverflows>
     c7a:	fc 01       	movw	r30, r24
     c7c:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     c7e:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <xTickCount>
     c82:	30 91 55 01 	lds	r19, 0x0155	; 0x800155 <xTickCount+0x1>
     c86:	32 83       	std	Z+2, r19	; 0x02
     c88:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     c8a:	0f 90       	pop	r0
     c8c:	0f be       	out	0x3f, r0	; 63
     c8e:	08 95       	ret

00000c90 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     c90:	20 91 4f 01 	lds	r18, 0x014F	; 0x80014f <xNumOfOverflows>
     c94:	fc 01       	movw	r30, r24
     c96:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     c98:	20 91 54 01 	lds	r18, 0x0154	; 0x800154 <xTickCount>
     c9c:	30 91 55 01 	lds	r19, 0x0155	; 0x800155 <xTickCount+0x1>
     ca0:	32 83       	std	Z+2, r19	; 0x02
     ca2:	21 83       	std	Z+1, r18	; 0x01
     ca4:	08 95       	ret

00000ca6 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     ca6:	cf 93       	push	r28
     ca8:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     caa:	0f b6       	in	r0, 0x3f	; 63
     cac:	f8 94       	cli
     cae:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     cb0:	40 91 54 01 	lds	r20, 0x0154	; 0x800154 <xTickCount>
     cb4:	50 91 55 01 	lds	r21, 0x0155	; 0x800155 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     cb8:	db 01       	movw	r26, r22
     cba:	2d 91       	ld	r18, X+
     cbc:	3c 91       	ld	r19, X
     cbe:	2f 3f       	cpi	r18, 0xFF	; 255
     cc0:	bf ef       	ldi	r27, 0xFF	; 255
     cc2:	3b 07       	cpc	r19, r27
     cc4:	d9 f0       	breq	.+54     	; 0xcfc <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     cc6:	ec 01       	movw	r28, r24
     cc8:	e9 81       	ldd	r30, Y+1	; 0x01
     cca:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     ccc:	a0 91 4f 01 	lds	r26, 0x014F	; 0x80014f <xNumOfOverflows>
     cd0:	b8 81       	ld	r27, Y
     cd2:	ba 17       	cp	r27, r26
     cd4:	19 f0       	breq	.+6      	; 0xcdc <xTaskCheckForTimeOut+0x36>
     cd6:	4e 17       	cp	r20, r30
     cd8:	5f 07       	cpc	r21, r31
     cda:	90 f4       	brcc	.+36     	; 0xd00 <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     cdc:	4e 1b       	sub	r20, r30
     cde:	5f 0b       	sbc	r21, r31
     ce0:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     ce2:	42 17       	cp	r20, r18
     ce4:	53 07       	cpc	r21, r19
     ce6:	38 f4       	brcc	.+14     	; 0xcf6 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     ce8:	24 1b       	sub	r18, r20
     cea:	35 0b       	sbc	r19, r21
     cec:	31 83       	std	Z+1, r19	; 0x01
     cee:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     cf0:	0e 94 48 06 	call	0xc90	; 0xc90 <vTaskInternalSetTimeOutState>
     cf4:	03 c0       	rjmp	.+6      	; 0xcfc <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     cf6:	11 82       	std	Z+1, r1	; 0x01
     cf8:	10 82       	st	Z, r1
     cfa:	02 c0       	rjmp	.+4      	; 0xd00 <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     cfc:	80 e0       	ldi	r24, 0x00	; 0
     cfe:	01 c0       	rjmp	.+2      	; 0xd02 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     d00:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     d02:	0f 90       	pop	r0
     d04:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     d06:	df 91       	pop	r29
     d08:	cf 91       	pop	r28
     d0a:	08 95       	ret

00000d0c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     d0c:	81 e0       	ldi	r24, 0x01	; 1
     d0e:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <xYieldPending>
     d12:	08 95       	ret

00000d14 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     d14:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     d18:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     d1c:	84 85       	ldd	r24, Z+12	; 0x0c
     d1e:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d20:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     d24:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     d28:	a0 91 47 01 	lds	r26, 0x0147	; 0x800147 <pxCurrentTCB>
     d2c:	b0 91 48 01 	lds	r27, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     d30:	56 96       	adiw	r26, 0x16	; 22
     d32:	4c 91       	ld	r20, X
     d34:	24 e0       	ldi	r18, 0x04	; 4
     d36:	30 e0       	ldi	r19, 0x00	; 0
     d38:	24 1b       	sub	r18, r20
     d3a:	31 09       	sbc	r19, r1
     d3c:	35 87       	std	Z+13, r19	; 0x0d
     d3e:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     d40:	08 95       	ret

00000d42 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     d42:	0f 93       	push	r16
     d44:	1f 93       	push	r17
     d46:	18 2f       	mov	r17, r24
     d48:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     d4a:	0f b6       	in	r0, 0x3f	; 63
     d4c:	f8 94       	cli
     d4e:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     d50:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     d54:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     d58:	41 a1       	ldd	r20, Z+33	; 0x21
     d5a:	52 a1       	ldd	r21, Z+34	; 0x22
     d5c:	63 a1       	ldd	r22, Z+35	; 0x23
     d5e:	74 a1       	ldd	r23, Z+36	; 0x24
     d60:	45 2b       	or	r20, r21
     d62:	46 2b       	or	r20, r22
     d64:	47 2b       	or	r20, r23
     d66:	69 f4       	brne	.+26     	; 0xd82 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     d68:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     d6c:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     d70:	21 e0       	ldi	r18, 0x01	; 1
     d72:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     d74:	00 97       	sbiw	r24, 0x00	; 0
     d76:	29 f0       	breq	.+10     	; 0xd82 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     d78:	61 e0       	ldi	r22, 0x01	; 1
     d7a:	0e 94 de 00 	call	0x1bc	; 0x1bc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     d7e:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     d82:	0f 90       	pop	r0
     d84:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     d86:	0f b6       	in	r0, 0x3f	; 63
     d88:	f8 94       	cli
     d8a:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
     d8c:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     d90:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     d94:	61 a1       	ldd	r22, Z+33	; 0x21
     d96:	72 a1       	ldd	r23, Z+34	; 0x22
     d98:	83 a1       	ldd	r24, Z+35	; 0x23
     d9a:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
     d9c:	61 15       	cp	r22, r1
     d9e:	71 05       	cpc	r23, r1
     da0:	81 05       	cpc	r24, r1
     da2:	91 05       	cpc	r25, r1
     da4:	a9 f0       	breq	.+42     	; 0xdd0 <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     da6:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     daa:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
     dae:	11 23       	and	r17, r17
     db0:	29 f0       	breq	.+10     	; 0xdbc <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     db2:	11 a2       	std	Z+33, r1	; 0x21
     db4:	12 a2       	std	Z+34, r1	; 0x22
     db6:	13 a2       	std	Z+35, r1	; 0x23
     db8:	14 a2       	std	Z+36, r1	; 0x24
     dba:	0a c0       	rjmp	.+20     	; 0xdd0 <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
     dbc:	8b 01       	movw	r16, r22
     dbe:	9c 01       	movw	r18, r24
     dc0:	01 50       	subi	r16, 0x01	; 1
     dc2:	11 09       	sbc	r17, r1
     dc4:	21 09       	sbc	r18, r1
     dc6:	31 09       	sbc	r19, r1
     dc8:	01 a3       	std	Z+33, r16	; 0x21
     dca:	12 a3       	std	Z+34, r17	; 0x22
     dcc:	23 a3       	std	Z+35, r18	; 0x23
     dce:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     dd0:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     dd4:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     dd8:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     dda:	0f 90       	pop	r0
     ddc:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
     dde:	1f 91       	pop	r17
     de0:	0f 91       	pop	r16
     de2:	08 95       	ret

00000de4 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     de4:	4f 92       	push	r4
     de6:	5f 92       	push	r5
     de8:	6f 92       	push	r6
     dea:	7f 92       	push	r7
     dec:	8f 92       	push	r8
     dee:	9f 92       	push	r9
     df0:	af 92       	push	r10
     df2:	bf 92       	push	r11
     df4:	ef 92       	push	r14
     df6:	ff 92       	push	r15
     df8:	0f 93       	push	r16
     dfa:	1f 93       	push	r17
     dfc:	49 01       	movw	r8, r18
     dfe:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     e00:	0f b6       	in	r0, 0x3f	; 63
     e02:	f8 94       	cli
     e04:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     e06:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     e0a:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     e0e:	25 a1       	ldd	r18, Z+37	; 0x25
     e10:	22 30       	cpi	r18, 0x02	; 2
     e12:	39 f1       	breq	.+78     	; 0xe62 <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     e14:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     e18:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     e1c:	21 a1       	ldd	r18, Z+33	; 0x21
     e1e:	32 a1       	ldd	r19, Z+34	; 0x22
     e20:	43 a1       	ldd	r20, Z+35	; 0x23
     e22:	54 a1       	ldd	r21, Z+36	; 0x24
     e24:	2b 01       	movw	r4, r22
     e26:	3c 01       	movw	r6, r24
     e28:	40 94       	com	r4
     e2a:	50 94       	com	r5
     e2c:	60 94       	com	r6
     e2e:	70 94       	com	r7
     e30:	d3 01       	movw	r26, r6
     e32:	c2 01       	movw	r24, r4
     e34:	82 23       	and	r24, r18
     e36:	93 23       	and	r25, r19
     e38:	a4 23       	and	r26, r20
     e3a:	b5 23       	and	r27, r21
     e3c:	81 a3       	std	Z+33, r24	; 0x21
     e3e:	92 a3       	std	Z+34, r25	; 0x22
     e40:	a3 a3       	std	Z+35, r26	; 0x23
     e42:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     e44:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     e48:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     e4c:	81 e0       	ldi	r24, 0x01	; 1
     e4e:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     e50:	e1 14       	cp	r14, r1
     e52:	f1 04       	cpc	r15, r1
     e54:	31 f0       	breq	.+12     	; 0xe62 <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     e56:	61 e0       	ldi	r22, 0x01	; 1
     e58:	c7 01       	movw	r24, r14
     e5a:	0e 94 de 00 	call	0x1bc	; 0x1bc <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     e5e:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     e62:	0f 90       	pop	r0
     e64:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     e66:	0f b6       	in	r0, 0x3f	; 63
     e68:	f8 94       	cli
     e6a:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
     e6c:	01 15       	cp	r16, r1
     e6e:	11 05       	cpc	r17, r1
     e70:	69 f0       	breq	.+26     	; 0xe8c <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     e72:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     e76:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     e7a:	81 a1       	ldd	r24, Z+33	; 0x21
     e7c:	92 a1       	ldd	r25, Z+34	; 0x22
     e7e:	a3 a1       	ldd	r26, Z+35	; 0x23
     e80:	b4 a1       	ldd	r27, Z+36	; 0x24
     e82:	f8 01       	movw	r30, r16
     e84:	80 83       	st	Z, r24
     e86:	91 83       	std	Z+1, r25	; 0x01
     e88:	a2 83       	std	Z+2, r26	; 0x02
     e8a:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     e8c:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     e90:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     e94:	85 a1       	ldd	r24, Z+37	; 0x25
     e96:	82 30       	cpi	r24, 0x02	; 2
     e98:	c1 f4       	brne	.+48     	; 0xeca <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
     e9a:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     e9e:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     ea2:	41 a1       	ldd	r20, Z+33	; 0x21
     ea4:	52 a1       	ldd	r21, Z+34	; 0x22
     ea6:	63 a1       	ldd	r22, Z+35	; 0x23
     ea8:	74 a1       	ldd	r23, Z+36	; 0x24
     eaa:	d5 01       	movw	r26, r10
     eac:	c4 01       	movw	r24, r8
     eae:	80 95       	com	r24
     eb0:	90 95       	com	r25
     eb2:	a0 95       	com	r26
     eb4:	b0 95       	com	r27
     eb6:	84 23       	and	r24, r20
     eb8:	95 23       	and	r25, r21
     eba:	a6 23       	and	r26, r22
     ebc:	b7 23       	and	r27, r23
     ebe:	81 a3       	std	Z+33, r24	; 0x21
     ec0:	92 a3       	std	Z+34, r25	; 0x22
     ec2:	a3 a3       	std	Z+35, r26	; 0x23
     ec4:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
     ec6:	81 e0       	ldi	r24, 0x01	; 1
     ec8:	01 c0       	rjmp	.+2      	; 0xecc <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
     eca:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     ecc:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     ed0:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     ed4:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     ed6:	0f 90       	pop	r0
     ed8:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     eda:	1f 91       	pop	r17
     edc:	0f 91       	pop	r16
     ede:	ff 90       	pop	r15
     ee0:	ef 90       	pop	r14
     ee2:	bf 90       	pop	r11
     ee4:	af 90       	pop	r10
     ee6:	9f 90       	pop	r9
     ee8:	8f 90       	pop	r8
     eea:	7f 90       	pop	r7
     eec:	6f 90       	pop	r6
     eee:	5f 90       	pop	r5
     ef0:	4f 90       	pop	r4
     ef2:	08 95       	ret

00000ef4 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
     ef4:	0f 93       	push	r16
     ef6:	1f 93       	push	r17
     ef8:	cf 93       	push	r28
     efa:	df 93       	push	r29
     efc:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
     efe:	0f b6       	in	r0, 0x3f	; 63
     f00:	f8 94       	cli
     f02:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
     f04:	01 15       	cp	r16, r1
     f06:	11 05       	cpc	r17, r1
     f08:	49 f0       	breq	.+18     	; 0xf1c <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     f0a:	81 a1       	ldd	r24, Z+33	; 0x21
     f0c:	92 a1       	ldd	r25, Z+34	; 0x22
     f0e:	a3 a1       	ldd	r26, Z+35	; 0x23
     f10:	b4 a1       	ldd	r27, Z+36	; 0x24
     f12:	e8 01       	movw	r28, r16
     f14:	88 83       	st	Y, r24
     f16:	99 83       	std	Y+1, r25	; 0x01
     f18:	aa 83       	std	Y+2, r26	; 0x02
     f1a:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     f1c:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     f1e:	82 e0       	ldi	r24, 0x02	; 2
     f20:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
     f22:	22 30       	cpi	r18, 0x02	; 2
     f24:	89 f0       	breq	.+34     	; 0xf48 <xTaskGenericNotify+0x54>
     f26:	58 f4       	brcc	.+22     	; 0xf3e <xTaskGenericNotify+0x4a>
     f28:	21 30       	cpi	r18, 0x01	; 1
     f2a:	01 f5       	brne	.+64     	; 0xf6c <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     f2c:	81 a1       	ldd	r24, Z+33	; 0x21
     f2e:	92 a1       	ldd	r25, Z+34	; 0x22
     f30:	a3 a1       	ldd	r26, Z+35	; 0x23
     f32:	b4 a1       	ldd	r27, Z+36	; 0x24
     f34:	48 2b       	or	r20, r24
     f36:	59 2b       	or	r21, r25
     f38:	6a 2b       	or	r22, r26
     f3a:	7b 2b       	or	r23, r27
     f3c:	13 c0       	rjmp	.+38     	; 0xf64 <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
     f3e:	23 30       	cpi	r18, 0x03	; 3
     f40:	89 f0       	breq	.+34     	; 0xf64 <xTaskGenericNotify+0x70>
     f42:	24 30       	cpi	r18, 0x04	; 4
     f44:	69 f0       	breq	.+26     	; 0xf60 <xTaskGenericNotify+0x6c>
     f46:	12 c0       	rjmp	.+36     	; 0xf6c <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     f48:	81 a1       	ldd	r24, Z+33	; 0x21
     f4a:	92 a1       	ldd	r25, Z+34	; 0x22
     f4c:	a3 a1       	ldd	r26, Z+35	; 0x23
     f4e:	b4 a1       	ldd	r27, Z+36	; 0x24
     f50:	01 96       	adiw	r24, 0x01	; 1
     f52:	a1 1d       	adc	r26, r1
     f54:	b1 1d       	adc	r27, r1
     f56:	81 a3       	std	Z+33, r24	; 0x21
     f58:	92 a3       	std	Z+34, r25	; 0x22
     f5a:	a3 a3       	std	Z+35, r26	; 0x23
     f5c:	b4 a3       	std	Z+36, r27	; 0x24
					break;
     f5e:	06 c0       	rjmp	.+12     	; 0xf6c <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     f60:	32 30       	cpi	r19, 0x02	; 2
     f62:	49 f1       	breq	.+82     	; 0xfb6 <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
     f64:	41 a3       	std	Z+33, r20	; 0x21
     f66:	52 a3       	std	Z+34, r21	; 0x22
     f68:	63 a3       	std	Z+35, r22	; 0x23
     f6a:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     f6c:	31 30       	cpi	r19, 0x01	; 1
     f6e:	09 f5       	brne	.+66     	; 0xfb2 <xTaskGenericNotify+0xbe>
     f70:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     f72:	8f 01       	movw	r16, r30
     f74:	0e 5f       	subi	r16, 0xFE	; 254
     f76:	1f 4f       	sbci	r17, 0xFF	; 255
     f78:	c8 01       	movw	r24, r16
     f7a:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
     f7e:	8e 89       	ldd	r24, Y+22	; 0x16
     f80:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <uxTopReadyPriority>
     f84:	98 17       	cp	r25, r24
     f86:	10 f4       	brcc	.+4      	; 0xf8c <xTaskGenericNotify+0x98>
     f88:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxTopReadyPriority>
     f8c:	29 e0       	ldi	r18, 0x09	; 9
     f8e:	82 9f       	mul	r24, r18
     f90:	c0 01       	movw	r24, r0
     f92:	11 24       	eor	r1, r1
     f94:	b8 01       	movw	r22, r16
     f96:	87 57       	subi	r24, 0x77	; 119
     f98:	9e 4f       	sbci	r25, 0xFE	; 254
     f9a:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     f9e:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
     fa2:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
     fa6:	9e 89       	ldd	r25, Y+22	; 0x16
     fa8:	86 89       	ldd	r24, Z+22	; 0x16
     faa:	89 17       	cp	r24, r25
     fac:	10 f4       	brcc	.+4      	; 0xfb2 <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
     fae:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
     fb2:	81 e0       	ldi	r24, 0x01	; 1
     fb4:	01 c0       	rjmp	.+2      	; 0xfb8 <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
     fb6:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     fb8:	0f 90       	pop	r0
     fba:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     fbc:	df 91       	pop	r29
     fbe:	cf 91       	pop	r28
     fc0:	1f 91       	pop	r17
     fc2:	0f 91       	pop	r16
     fc4:	08 95       	ret

00000fc6 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
     fc6:	ef 92       	push	r14
     fc8:	ff 92       	push	r15
     fca:	0f 93       	push	r16
     fcc:	1f 93       	push	r17
     fce:	cf 93       	push	r28
     fd0:	df 93       	push	r29
     fd2:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
     fd4:	01 15       	cp	r16, r1
     fd6:	11 05       	cpc	r17, r1
     fd8:	49 f0       	breq	.+18     	; 0xfec <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     fda:	81 a1       	ldd	r24, Z+33	; 0x21
     fdc:	92 a1       	ldd	r25, Z+34	; 0x22
     fde:	a3 a1       	ldd	r26, Z+35	; 0x23
     fe0:	b4 a1       	ldd	r27, Z+36	; 0x24
     fe2:	e8 01       	movw	r28, r16
     fe4:	88 83       	st	Y, r24
     fe6:	99 83       	std	Y+1, r25	; 0x01
     fe8:	aa 83       	std	Y+2, r26	; 0x02
     fea:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     fec:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     fee:	82 e0       	ldi	r24, 0x02	; 2
     ff0:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
     ff2:	22 30       	cpi	r18, 0x02	; 2
     ff4:	89 f0       	breq	.+34     	; 0x1018 <xTaskGenericNotifyFromISR+0x52>
     ff6:	58 f4       	brcc	.+22     	; 0x100e <xTaskGenericNotifyFromISR+0x48>
     ff8:	21 30       	cpi	r18, 0x01	; 1
     ffa:	01 f5       	brne	.+64     	; 0x103c <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     ffc:	81 a1       	ldd	r24, Z+33	; 0x21
     ffe:	92 a1       	ldd	r25, Z+34	; 0x22
    1000:	a3 a1       	ldd	r26, Z+35	; 0x23
    1002:	b4 a1       	ldd	r27, Z+36	; 0x24
    1004:	48 2b       	or	r20, r24
    1006:	59 2b       	or	r21, r25
    1008:	6a 2b       	or	r22, r26
    100a:	7b 2b       	or	r23, r27
    100c:	13 c0       	rjmp	.+38     	; 0x1034 <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    100e:	23 30       	cpi	r18, 0x03	; 3
    1010:	89 f0       	breq	.+34     	; 0x1034 <xTaskGenericNotifyFromISR+0x6e>
    1012:	24 30       	cpi	r18, 0x04	; 4
    1014:	69 f0       	breq	.+26     	; 0x1030 <xTaskGenericNotifyFromISR+0x6a>
    1016:	12 c0       	rjmp	.+36     	; 0x103c <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1018:	81 a1       	ldd	r24, Z+33	; 0x21
    101a:	92 a1       	ldd	r25, Z+34	; 0x22
    101c:	a3 a1       	ldd	r26, Z+35	; 0x23
    101e:	b4 a1       	ldd	r27, Z+36	; 0x24
    1020:	01 96       	adiw	r24, 0x01	; 1
    1022:	a1 1d       	adc	r26, r1
    1024:	b1 1d       	adc	r27, r1
    1026:	81 a3       	std	Z+33, r24	; 0x21
    1028:	92 a3       	std	Z+34, r25	; 0x22
    102a:	a3 a3       	std	Z+35, r26	; 0x23
    102c:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    102e:	06 c0       	rjmp	.+12     	; 0x103c <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1030:	32 30       	cpi	r19, 0x02	; 2
    1032:	d9 f1       	breq	.+118    	; 0x10aa <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1034:	41 a3       	std	Z+33, r20	; 0x21
    1036:	52 a3       	std	Z+34, r21	; 0x22
    1038:	63 a3       	std	Z+35, r22	; 0x23
    103a:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    103c:	31 30       	cpi	r19, 0x01	; 1
    103e:	11 f0       	breq	.+4      	; 0x1044 <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	34 c0       	rjmp	.+104    	; 0x10ac <xTaskGenericNotifyFromISR+0xe6>
    1044:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1046:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <uxSchedulerSuspended>
    104a:	81 11       	cpse	r24, r1
    104c:	15 c0       	rjmp	.+42     	; 0x1078 <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    104e:	8f 01       	movw	r16, r30
    1050:	0e 5f       	subi	r16, 0xFE	; 254
    1052:	1f 4f       	sbci	r17, 0xFF	; 255
    1054:	c8 01       	movw	r24, r16
    1056:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    105a:	8e 89       	ldd	r24, Y+22	; 0x16
    105c:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <uxTopReadyPriority>
    1060:	98 17       	cp	r25, r24
    1062:	10 f4       	brcc	.+4      	; 0x1068 <xTaskGenericNotifyFromISR+0xa2>
    1064:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxTopReadyPriority>
    1068:	e9 e0       	ldi	r30, 0x09	; 9
    106a:	8e 9f       	mul	r24, r30
    106c:	c0 01       	movw	r24, r0
    106e:	11 24       	eor	r1, r1
    1070:	b8 01       	movw	r22, r16
    1072:	87 57       	subi	r24, 0x77	; 119
    1074:	9e 4f       	sbci	r25, 0xFE	; 254
    1076:	05 c0       	rjmp	.+10     	; 0x1082 <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1078:	bf 01       	movw	r22, r30
    107a:	64 5f       	subi	r22, 0xF4	; 244
    107c:	7f 4f       	sbci	r23, 0xFF	; 255
    107e:	8a e6       	ldi	r24, 0x6A	; 106
    1080:	91 e0       	ldi	r25, 0x01	; 1
    1082:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1086:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
    108a:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
    108e:	9e 89       	ldd	r25, Y+22	; 0x16
    1090:	86 89       	ldd	r24, Z+22	; 0x16
    1092:	89 17       	cp	r24, r25
    1094:	a8 f6       	brcc	.-86     	; 0x1040 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1096:	e1 14       	cp	r14, r1
    1098:	f1 04       	cpc	r15, r1
    109a:	19 f0       	breq	.+6      	; 0x10a2 <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    109c:	81 e0       	ldi	r24, 0x01	; 1
    109e:	e7 01       	movw	r28, r14
    10a0:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    10a2:	81 e0       	ldi	r24, 0x01	; 1
    10a4:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <xYieldPending>
    10a8:	01 c0       	rjmp	.+2      	; 0x10ac <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    10aa:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    10ac:	df 91       	pop	r29
    10ae:	cf 91       	pop	r28
    10b0:	1f 91       	pop	r17
    10b2:	0f 91       	pop	r16
    10b4:	ff 90       	pop	r15
    10b6:	ef 90       	pop	r14
    10b8:	08 95       	ret

000010ba <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    10ba:	ef 92       	push	r14
    10bc:	ff 92       	push	r15
    10be:	0f 93       	push	r16
    10c0:	1f 93       	push	r17
    10c2:	cf 93       	push	r28
    10c4:	df 93       	push	r29
    10c6:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    10c8:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    10ca:	82 e0       	ldi	r24, 0x02	; 2
    10cc:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    10ce:	81 a1       	ldd	r24, Z+33	; 0x21
    10d0:	92 a1       	ldd	r25, Z+34	; 0x22
    10d2:	a3 a1       	ldd	r26, Z+35	; 0x23
    10d4:	b4 a1       	ldd	r27, Z+36	; 0x24
    10d6:	01 96       	adiw	r24, 0x01	; 1
    10d8:	a1 1d       	adc	r26, r1
    10da:	b1 1d       	adc	r27, r1
    10dc:	81 a3       	std	Z+33, r24	; 0x21
    10de:	92 a3       	std	Z+34, r25	; 0x22
    10e0:	a3 a3       	std	Z+35, r26	; 0x23
    10e2:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    10e4:	21 30       	cpi	r18, 0x01	; 1
    10e6:	a1 f5       	brne	.+104    	; 0x1150 <vTaskNotifyGiveFromISR+0x96>
    10e8:	8b 01       	movw	r16, r22
    10ea:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    10ec:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <uxSchedulerSuspended>
    10f0:	81 11       	cpse	r24, r1
    10f2:	16 c0       	rjmp	.+44     	; 0x1120 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    10f4:	7f 01       	movw	r14, r30
    10f6:	22 e0       	ldi	r18, 0x02	; 2
    10f8:	e2 0e       	add	r14, r18
    10fa:	f1 1c       	adc	r15, r1
    10fc:	c7 01       	movw	r24, r14
    10fe:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1102:	8e 89       	ldd	r24, Y+22	; 0x16
    1104:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <uxTopReadyPriority>
    1108:	98 17       	cp	r25, r24
    110a:	10 f4       	brcc	.+4      	; 0x1110 <vTaskNotifyGiveFromISR+0x56>
    110c:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxTopReadyPriority>
    1110:	e9 e0       	ldi	r30, 0x09	; 9
    1112:	8e 9f       	mul	r24, r30
    1114:	c0 01       	movw	r24, r0
    1116:	11 24       	eor	r1, r1
    1118:	b7 01       	movw	r22, r14
    111a:	87 57       	subi	r24, 0x77	; 119
    111c:	9e 4f       	sbci	r25, 0xFE	; 254
    111e:	05 c0       	rjmp	.+10     	; 0x112a <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1120:	bf 01       	movw	r22, r30
    1122:	64 5f       	subi	r22, 0xF4	; 244
    1124:	7f 4f       	sbci	r23, 0xFF	; 255
    1126:	8a e6       	ldi	r24, 0x6A	; 106
    1128:	91 e0       	ldi	r25, 0x01	; 1
    112a:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    112e:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentTCB>
    1132:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
    1136:	9e 89       	ldd	r25, Y+22	; 0x16
    1138:	86 89       	ldd	r24, Z+22	; 0x16
    113a:	89 17       	cp	r24, r25
    113c:	48 f4       	brcc	.+18     	; 0x1150 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    113e:	01 15       	cp	r16, r1
    1140:	11 05       	cpc	r17, r1
    1142:	19 f0       	breq	.+6      	; 0x114a <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1144:	81 e0       	ldi	r24, 0x01	; 1
    1146:	f8 01       	movw	r30, r16
    1148:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    114a:	81 e0       	ldi	r24, 0x01	; 1
    114c:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    1150:	df 91       	pop	r29
    1152:	cf 91       	pop	r28
    1154:	1f 91       	pop	r17
    1156:	0f 91       	pop	r16
    1158:	ff 90       	pop	r15
    115a:	ef 90       	pop	r14
    115c:	08 95       	ret

0000115e <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    115e:	00 97       	sbiw	r24, 0x00	; 0
    1160:	21 f4       	brne	.+8      	; 0x116a <xTaskNotifyStateClear+0xc>
    1162:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <pxCurrentTCB>
    1166:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    116a:	0f b6       	in	r0, 0x3f	; 63
    116c:	f8 94       	cli
    116e:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    1170:	fc 01       	movw	r30, r24
    1172:	25 a1       	ldd	r18, Z+37	; 0x25
    1174:	22 30       	cpi	r18, 0x02	; 2
    1176:	19 f4       	brne	.+6      	; 0x117e <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1178:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    117a:	81 e0       	ldi	r24, 0x01	; 1
    117c:	01 c0       	rjmp	.+2      	; 0x1180 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    117e:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    1180:	0f 90       	pop	r0
    1182:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1184:	08 95       	ret

00001186 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1186:	0f b6       	in	r0, 0x3f	; 63
    1188:	f8 94       	cli
    118a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    118c:	fc 01       	movw	r30, r24
    118e:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1190:	0f 90       	pop	r0
    1192:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1194:	81 e0       	ldi	r24, 0x01	; 1
    1196:	91 11       	cpse	r25, r1
    1198:	80 e0       	ldi	r24, 0x00	; 0
}
    119a:	08 95       	ret

0000119c <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    119c:	0f 93       	push	r16
    119e:	1f 93       	push	r17
    11a0:	cf 93       	push	r28
    11a2:	df 93       	push	r29
    11a4:	ec 01       	movw	r28, r24
    11a6:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    11a8:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    11aa:	4c 8d       	ldd	r20, Y+28	; 0x1c
    11ac:	44 23       	and	r20, r20
    11ae:	b1 f1       	breq	.+108    	; 0x121c <prvCopyDataToQueue+0x80>
    11b0:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    11b2:	01 11       	cpse	r16, r1
    11b4:	15 c0       	rjmp	.+42     	; 0x11e0 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    11b6:	8a 81       	ldd	r24, Y+2	; 0x02
    11b8:	9b 81       	ldd	r25, Y+3	; 0x03
    11ba:	0e 94 e9 11 	call	0x23d2	; 0x23d2 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    11be:	2c 8d       	ldd	r18, Y+28	; 0x1c
    11c0:	8a 81       	ldd	r24, Y+2	; 0x02
    11c2:	9b 81       	ldd	r25, Y+3	; 0x03
    11c4:	82 0f       	add	r24, r18
    11c6:	91 1d       	adc	r25, r1
    11c8:	9b 83       	std	Y+3, r25	; 0x03
    11ca:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    11cc:	2c 81       	ldd	r18, Y+4	; 0x04
    11ce:	3d 81       	ldd	r19, Y+5	; 0x05
    11d0:	82 17       	cp	r24, r18
    11d2:	93 07       	cpc	r25, r19
    11d4:	18 f1       	brcs	.+70     	; 0x121c <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    11d6:	88 81       	ld	r24, Y
    11d8:	99 81       	ldd	r25, Y+1	; 0x01
    11da:	9b 83       	std	Y+3, r25	; 0x03
    11dc:	8a 83       	std	Y+2, r24	; 0x02
    11de:	1e c0       	rjmp	.+60     	; 0x121c <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    11e0:	8e 81       	ldd	r24, Y+6	; 0x06
    11e2:	9f 81       	ldd	r25, Y+7	; 0x07
    11e4:	0e 94 e9 11 	call	0x23d2	; 0x23d2 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    11e8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	91 95       	neg	r25
    11ee:	81 95       	neg	r24
    11f0:	91 09       	sbc	r25, r1
    11f2:	2e 81       	ldd	r18, Y+6	; 0x06
    11f4:	3f 81       	ldd	r19, Y+7	; 0x07
    11f6:	28 0f       	add	r18, r24
    11f8:	39 1f       	adc	r19, r25
    11fa:	3f 83       	std	Y+7, r19	; 0x07
    11fc:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    11fe:	48 81       	ld	r20, Y
    1200:	59 81       	ldd	r21, Y+1	; 0x01
    1202:	24 17       	cp	r18, r20
    1204:	35 07       	cpc	r19, r21
    1206:	30 f4       	brcc	.+12     	; 0x1214 <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1208:	2c 81       	ldd	r18, Y+4	; 0x04
    120a:	3d 81       	ldd	r19, Y+5	; 0x05
    120c:	82 0f       	add	r24, r18
    120e:	93 1f       	adc	r25, r19
    1210:	9f 83       	std	Y+7, r25	; 0x07
    1212:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1214:	02 30       	cpi	r16, 0x02	; 2
    1216:	11 f4       	brne	.+4      	; 0x121c <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1218:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    121a:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    121c:	1f 5f       	subi	r17, 0xFF	; 255
    121e:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    1220:	80 e0       	ldi	r24, 0x00	; 0
    1222:	df 91       	pop	r29
    1224:	cf 91       	pop	r28
    1226:	1f 91       	pop	r17
    1228:	0f 91       	pop	r16
    122a:	08 95       	ret

0000122c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    122c:	fc 01       	movw	r30, r24
    122e:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1230:	44 8d       	ldd	r20, Z+28	; 0x1c
    1232:	44 23       	and	r20, r20
    1234:	a1 f0       	breq	.+40     	; 0x125e <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1236:	50 e0       	ldi	r21, 0x00	; 0
    1238:	26 81       	ldd	r18, Z+6	; 0x06
    123a:	37 81       	ldd	r19, Z+7	; 0x07
    123c:	24 0f       	add	r18, r20
    123e:	35 1f       	adc	r19, r21
    1240:	37 83       	std	Z+7, r19	; 0x07
    1242:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1244:	64 81       	ldd	r22, Z+4	; 0x04
    1246:	75 81       	ldd	r23, Z+5	; 0x05
    1248:	26 17       	cp	r18, r22
    124a:	37 07       	cpc	r19, r23
    124c:	20 f0       	brcs	.+8      	; 0x1256 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    124e:	20 81       	ld	r18, Z
    1250:	31 81       	ldd	r19, Z+1	; 0x01
    1252:	37 83       	std	Z+7, r19	; 0x07
    1254:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1256:	66 81       	ldd	r22, Z+6	; 0x06
    1258:	77 81       	ldd	r23, Z+7	; 0x07
    125a:	0c 94 e9 11 	jmp	0x23d2	; 0x23d2 <memcpy>
    125e:	08 95       	ret

00001260 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1260:	ef 92       	push	r14
    1262:	ff 92       	push	r15
    1264:	1f 93       	push	r17
    1266:	cf 93       	push	r28
    1268:	df 93       	push	r29
    126a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    126c:	0f b6       	in	r0, 0x3f	; 63
    126e:	f8 94       	cli
    1270:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1272:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1274:	7c 01       	movw	r14, r24
    1276:	81 e1       	ldi	r24, 0x11	; 17
    1278:	e8 0e       	add	r14, r24
    127a:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    127c:	11 16       	cp	r1, r17
    127e:	5c f4       	brge	.+22     	; 0x1296 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1280:	89 89       	ldd	r24, Y+17	; 0x11
    1282:	88 23       	and	r24, r24
    1284:	41 f0       	breq	.+16     	; 0x1296 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1286:	c7 01       	movw	r24, r14
    1288:	0e 94 c6 05 	call	0xb8c	; 0xb8c <xTaskRemoveFromEventList>
    128c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    128e:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskMissedYield>
    1292:	11 50       	subi	r17, 0x01	; 1
    1294:	f3 cf       	rjmp	.-26     	; 0x127c <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1296:	8f ef       	ldi	r24, 0xFF	; 255
    1298:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    129a:	0f 90       	pop	r0
    129c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    129e:	0f b6       	in	r0, 0x3f	; 63
    12a0:	f8 94       	cli
    12a2:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    12a4:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12a6:	7e 01       	movw	r14, r28
    12a8:	88 e0       	ldi	r24, 0x08	; 8
    12aa:	e8 0e       	add	r14, r24
    12ac:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    12ae:	11 16       	cp	r1, r17
    12b0:	5c f4       	brge	.+22     	; 0x12c8 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12b2:	88 85       	ldd	r24, Y+8	; 0x08
    12b4:	88 23       	and	r24, r24
    12b6:	41 f0       	breq	.+16     	; 0x12c8 <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12b8:	c7 01       	movw	r24, r14
    12ba:	0e 94 c6 05 	call	0xb8c	; 0xb8c <xTaskRemoveFromEventList>
    12be:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    12c0:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskMissedYield>
    12c4:	11 50       	subi	r17, 0x01	; 1
    12c6:	f3 cf       	rjmp	.-26     	; 0x12ae <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    12c8:	8f ef       	ldi	r24, 0xFF	; 255
    12ca:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    12cc:	0f 90       	pop	r0
    12ce:	0f be       	out	0x3f, r0	; 63
}
    12d0:	df 91       	pop	r29
    12d2:	cf 91       	pop	r28
    12d4:	1f 91       	pop	r17
    12d6:	ff 90       	pop	r15
    12d8:	ef 90       	pop	r14
    12da:	08 95       	ret

000012dc <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    12dc:	cf 93       	push	r28
    12de:	df 93       	push	r29
    12e0:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    12e2:	0f b6       	in	r0, 0x3f	; 63
    12e4:	f8 94       	cli
    12e6:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    12e8:	48 81       	ld	r20, Y
    12ea:	59 81       	ldd	r21, Y+1	; 0x01
    12ec:	8b 8d       	ldd	r24, Y+27	; 0x1b
    12ee:	7c 8d       	ldd	r23, Y+28	; 0x1c
    12f0:	9a 01       	movw	r18, r20
    12f2:	87 9f       	mul	r24, r23
    12f4:	20 0d       	add	r18, r0
    12f6:	31 1d       	adc	r19, r1
    12f8:	11 24       	eor	r1, r1
    12fa:	3d 83       	std	Y+5, r19	; 0x05
    12fc:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    12fe:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1300:	5b 83       	std	Y+3, r21	; 0x03
    1302:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1304:	90 e0       	ldi	r25, 0x00	; 0
    1306:	01 97       	sbiw	r24, 0x01	; 1
    1308:	78 9f       	mul	r23, r24
    130a:	90 01       	movw	r18, r0
    130c:	79 9f       	mul	r23, r25
    130e:	30 0d       	add	r19, r0
    1310:	11 24       	eor	r1, r1
    1312:	ca 01       	movw	r24, r20
    1314:	82 0f       	add	r24, r18
    1316:	93 1f       	adc	r25, r19
    1318:	9f 83       	std	Y+7, r25	; 0x07
    131a:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    131c:	8f ef       	ldi	r24, 0xFF	; 255
    131e:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1320:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1322:	61 11       	cpse	r22, r1
    1324:	0c c0       	rjmp	.+24     	; 0x133e <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1326:	88 85       	ldd	r24, Y+8	; 0x08
    1328:	88 23       	and	r24, r24
    132a:	89 f0       	breq	.+34     	; 0x134e <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    132c:	ce 01       	movw	r24, r28
    132e:	08 96       	adiw	r24, 0x08	; 8
    1330:	0e 94 c6 05 	call	0xb8c	; 0xb8c <xTaskRemoveFromEventList>
    1334:	88 23       	and	r24, r24
    1336:	59 f0       	breq	.+22     	; 0x134e <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1338:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
    133c:	08 c0       	rjmp	.+16     	; 0x134e <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    133e:	ce 01       	movw	r24, r28
    1340:	08 96       	adiw	r24, 0x08	; 8
    1342:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1346:	ce 01       	movw	r24, r28
    1348:	41 96       	adiw	r24, 0x11	; 17
    134a:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    134e:	0f 90       	pop	r0
    1350:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1352:	81 e0       	ldi	r24, 0x01	; 1
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
    1358:	08 95       	ret

0000135a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    135a:	0f 93       	push	r16
    135c:	1f 93       	push	r17
    135e:	cf 93       	push	r28
    1360:	df 93       	push	r29
    1362:	08 2f       	mov	r16, r24
    1364:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1366:	66 23       	and	r22, r22
    1368:	21 f0       	breq	.+8      	; 0x1372 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    136a:	86 9f       	mul	r24, r22
    136c:	c0 01       	movw	r24, r0
    136e:	11 24       	eor	r1, r1
    1370:	02 c0       	rjmp	.+4      	; 0x1376 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1372:	80 e0       	ldi	r24, 0x00	; 0
    1374:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1376:	4f 96       	adiw	r24, 0x1f	; 31
    1378:	0e 94 04 10 	call	0x2008	; 0x2008 <pvPortMalloc>
    137c:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    137e:	00 97       	sbiw	r24, 0x00	; 0
    1380:	71 f0       	breq	.+28     	; 0x139e <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1382:	11 11       	cpse	r17, r1
    1384:	03 c0       	rjmp	.+6      	; 0x138c <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1386:	99 83       	std	Y+1, r25	; 0x01
    1388:	88 83       	st	Y, r24
    138a:	03 c0       	rjmp	.+6      	; 0x1392 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    138c:	4f 96       	adiw	r24, 0x1f	; 31
    138e:	99 83       	std	Y+1, r25	; 0x01
    1390:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1392:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1394:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1396:	61 e0       	ldi	r22, 0x01	; 1
    1398:	ce 01       	movw	r24, r28
    139a:	0e 94 6e 09 	call	0x12dc	; 0x12dc <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    139e:	ce 01       	movw	r24, r28
    13a0:	df 91       	pop	r29
    13a2:	cf 91       	pop	r28
    13a4:	1f 91       	pop	r17
    13a6:	0f 91       	pop	r16
    13a8:	08 95       	ret

000013aa <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    13aa:	af 92       	push	r10
    13ac:	bf 92       	push	r11
    13ae:	cf 92       	push	r12
    13b0:	df 92       	push	r13
    13b2:	ff 92       	push	r15
    13b4:	0f 93       	push	r16
    13b6:	1f 93       	push	r17
    13b8:	cf 93       	push	r28
    13ba:	df 93       	push	r29
    13bc:	00 d0       	rcall	.+0      	; 0x13be <xQueueGenericSend+0x14>
    13be:	00 d0       	rcall	.+0      	; 0x13c0 <xQueueGenericSend+0x16>
    13c0:	1f 92       	push	r1
    13c2:	cd b7       	in	r28, 0x3d	; 61
    13c4:	de b7       	in	r29, 0x3e	; 62
    13c6:	8c 01       	movw	r16, r24
    13c8:	6b 01       	movw	r12, r22
    13ca:	5d 83       	std	Y+5, r21	; 0x05
    13cc:	4c 83       	std	Y+4, r20	; 0x04
    13ce:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    13d0:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    13d2:	58 01       	movw	r10, r16
    13d4:	98 e0       	ldi	r25, 0x08	; 8
    13d6:	a9 0e       	add	r10, r25
    13d8:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    13da:	0f b6       	in	r0, 0x3f	; 63
    13dc:	f8 94       	cli
    13de:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    13e0:	f8 01       	movw	r30, r16
    13e2:	22 8d       	ldd	r18, Z+26	; 0x1a
    13e4:	93 8d       	ldd	r25, Z+27	; 0x1b
    13e6:	29 17       	cp	r18, r25
    13e8:	18 f0       	brcs	.+6      	; 0x13f0 <xQueueGenericSend+0x46>
    13ea:	f2 e0       	ldi	r31, 0x02	; 2
    13ec:	ff 12       	cpse	r15, r31
    13ee:	14 c0       	rjmp	.+40     	; 0x1418 <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    13f0:	4f 2d       	mov	r20, r15
    13f2:	b6 01       	movw	r22, r12
    13f4:	c8 01       	movw	r24, r16
    13f6:	0e 94 ce 08 	call	0x119c	; 0x119c <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13fa:	f8 01       	movw	r30, r16
    13fc:	91 89       	ldd	r25, Z+17	; 0x11
    13fe:	99 23       	and	r25, r25
    1400:	21 f0       	breq	.+8      	; 0x140a <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1402:	c8 01       	movw	r24, r16
    1404:	41 96       	adiw	r24, 0x11	; 17
    1406:	0e 94 c6 05 	call	0xb8c	; 0xb8c <xTaskRemoveFromEventList>
    140a:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    140c:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1410:	0f 90       	pop	r0
    1412:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1414:	81 e0       	ldi	r24, 0x01	; 1
    1416:	50 c0       	rjmp	.+160    	; 0x14b8 <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1418:	2c 81       	ldd	r18, Y+4	; 0x04
    141a:	3d 81       	ldd	r19, Y+5	; 0x05
    141c:	23 2b       	or	r18, r19
    141e:	19 f4       	brne	.+6      	; 0x1426 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1420:	0f 90       	pop	r0
    1422:	0f be       	out	0x3f, r0	; 63
    1424:	48 c0       	rjmp	.+144    	; 0x14b6 <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1426:	81 11       	cpse	r24, r1
    1428:	04 c0       	rjmp	.+8      	; 0x1432 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    142a:	ce 01       	movw	r24, r28
    142c:	01 96       	adiw	r24, 0x01	; 1
    142e:	0e 94 48 06 	call	0xc90	; 0xc90 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1432:	0f 90       	pop	r0
    1434:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1436:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    143a:	0f b6       	in	r0, 0x3f	; 63
    143c:	f8 94       	cli
    143e:	0f 92       	push	r0
    1440:	f8 01       	movw	r30, r16
    1442:	85 8d       	ldd	r24, Z+29	; 0x1d
    1444:	8f 3f       	cpi	r24, 0xFF	; 255
    1446:	09 f4       	brne	.+2      	; 0x144a <xQueueGenericSend+0xa0>
    1448:	15 8e       	std	Z+29, r1	; 0x1d
    144a:	f8 01       	movw	r30, r16
    144c:	86 8d       	ldd	r24, Z+30	; 0x1e
    144e:	8f 3f       	cpi	r24, 0xFF	; 255
    1450:	09 f4       	brne	.+2      	; 0x1454 <xQueueGenericSend+0xaa>
    1452:	16 8e       	std	Z+30, r1	; 0x1e
    1454:	0f 90       	pop	r0
    1456:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1458:	be 01       	movw	r22, r28
    145a:	6c 5f       	subi	r22, 0xFC	; 252
    145c:	7f 4f       	sbci	r23, 0xFF	; 255
    145e:	ce 01       	movw	r24, r28
    1460:	01 96       	adiw	r24, 0x01	; 1
    1462:	0e 94 53 06 	call	0xca6	; 0xca6 <xTaskCheckForTimeOut>
    1466:	81 11       	cpse	r24, r1
    1468:	21 c0       	rjmp	.+66     	; 0x14ac <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    146a:	0f b6       	in	r0, 0x3f	; 63
    146c:	f8 94       	cli
    146e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1470:	f8 01       	movw	r30, r16
    1472:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1474:	0f 90       	pop	r0
    1476:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1478:	83 8d       	ldd	r24, Z+27	; 0x1b
    147a:	98 13       	cpse	r25, r24
    147c:	11 c0       	rjmp	.+34     	; 0x14a0 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    147e:	6c 81       	ldd	r22, Y+4	; 0x04
    1480:	7d 81       	ldd	r23, Y+5	; 0x05
    1482:	c5 01       	movw	r24, r10
    1484:	0e 94 9d 05 	call	0xb3a	; 0xb3a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1488:	c8 01       	movw	r24, r16
    148a:	0e 94 30 09 	call	0x1260	; 0x1260 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    148e:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>
    1492:	88 23       	and	r24, r24
    1494:	11 f0       	breq	.+4      	; 0x149a <xQueueGenericSend+0xf0>
    1496:	81 e0       	ldi	r24, 0x01	; 1
    1498:	a0 cf       	rjmp	.-192    	; 0x13da <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    149a:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
    149e:	fb cf       	rjmp	.-10     	; 0x1496 <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    14a0:	c8 01       	movw	r24, r16
    14a2:	0e 94 30 09 	call	0x1260	; 0x1260 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    14a6:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>
    14aa:	f5 cf       	rjmp	.-22     	; 0x1496 <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    14ac:	c8 01       	movw	r24, r16
    14ae:	0e 94 30 09 	call	0x1260	; 0x1260 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    14b2:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    14b6:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    14b8:	0f 90       	pop	r0
    14ba:	0f 90       	pop	r0
    14bc:	0f 90       	pop	r0
    14be:	0f 90       	pop	r0
    14c0:	0f 90       	pop	r0
    14c2:	df 91       	pop	r29
    14c4:	cf 91       	pop	r28
    14c6:	1f 91       	pop	r17
    14c8:	0f 91       	pop	r16
    14ca:	ff 90       	pop	r15
    14cc:	df 90       	pop	r13
    14ce:	cf 90       	pop	r12
    14d0:	bf 90       	pop	r11
    14d2:	af 90       	pop	r10
    14d4:	08 95       	ret

000014d6 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    14d6:	ef 92       	push	r14
    14d8:	ff 92       	push	r15
    14da:	1f 93       	push	r17
    14dc:	cf 93       	push	r28
    14de:	df 93       	push	r29
    14e0:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    14e2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    14e4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    14e6:	98 17       	cp	r25, r24
    14e8:	10 f0       	brcs	.+4      	; 0x14ee <xQueueGenericSendFromISR+0x18>
    14ea:	22 30       	cpi	r18, 0x02	; 2
    14ec:	e1 f4       	brne	.+56     	; 0x1526 <xQueueGenericSendFromISR+0x50>
    14ee:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    14f0:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    14f2:	42 2f       	mov	r20, r18
    14f4:	ce 01       	movw	r24, r28
    14f6:	0e 94 ce 08 	call	0x119c	; 0x119c <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    14fa:	1f 3f       	cpi	r17, 0xFF	; 255
    14fc:	81 f4       	brne	.+32     	; 0x151e <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14fe:	89 89       	ldd	r24, Y+17	; 0x11
    1500:	88 23       	and	r24, r24
    1502:	79 f0       	breq	.+30     	; 0x1522 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1504:	ce 01       	movw	r24, r28
    1506:	41 96       	adiw	r24, 0x11	; 17
    1508:	0e 94 c6 05 	call	0xb8c	; 0xb8c <xTaskRemoveFromEventList>
    150c:	88 23       	and	r24, r24
    150e:	49 f0       	breq	.+18     	; 0x1522 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1510:	e1 14       	cp	r14, r1
    1512:	f1 04       	cpc	r15, r1
    1514:	31 f0       	breq	.+12     	; 0x1522 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1516:	81 e0       	ldi	r24, 0x01	; 1
    1518:	f7 01       	movw	r30, r14
    151a:	80 83       	st	Z, r24
    151c:	05 c0       	rjmp	.+10     	; 0x1528 <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    151e:	1f 5f       	subi	r17, 0xFF	; 255
    1520:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    1522:	81 e0       	ldi	r24, 0x01	; 1
    1524:	01 c0       	rjmp	.+2      	; 0x1528 <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1526:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1528:	df 91       	pop	r29
    152a:	cf 91       	pop	r28
    152c:	1f 91       	pop	r17
    152e:	ff 90       	pop	r15
    1530:	ef 90       	pop	r14
    1532:	08 95       	ret

00001534 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1534:	cf 93       	push	r28
    1536:	df 93       	push	r29
    1538:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    153a:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    153c:	83 8d       	ldd	r24, Z+27	; 0x1b
    153e:	98 17       	cp	r25, r24
    1540:	c0 f4       	brcc	.+48     	; 0x1572 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1542:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1544:	9f 5f       	subi	r25, 0xFF	; 255
    1546:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1548:	8f 3f       	cpi	r24, 0xFF	; 255
    154a:	79 f4       	brne	.+30     	; 0x156a <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    154c:	81 89       	ldd	r24, Z+17	; 0x11
    154e:	88 23       	and	r24, r24
    1550:	71 f0       	breq	.+28     	; 0x156e <xQueueGiveFromISR+0x3a>
    1552:	eb 01       	movw	r28, r22
    1554:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1556:	41 96       	adiw	r24, 0x11	; 17
    1558:	0e 94 c6 05 	call	0xb8c	; 0xb8c <xTaskRemoveFromEventList>
    155c:	88 23       	and	r24, r24
    155e:	39 f0       	breq	.+14     	; 0x156e <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1560:	20 97       	sbiw	r28, 0x00	; 0
    1562:	29 f0       	breq	.+10     	; 0x156e <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1564:	81 e0       	ldi	r24, 0x01	; 1
    1566:	88 83       	st	Y, r24
    1568:	05 c0       	rjmp	.+10     	; 0x1574 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    156a:	8f 5f       	subi	r24, 0xFF	; 255
    156c:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    156e:	81 e0       	ldi	r24, 0x01	; 1
    1570:	01 c0       	rjmp	.+2      	; 0x1574 <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1572:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1574:	df 91       	pop	r29
    1576:	cf 91       	pop	r28
    1578:	08 95       	ret

0000157a <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    157a:	af 92       	push	r10
    157c:	bf 92       	push	r11
    157e:	cf 92       	push	r12
    1580:	df 92       	push	r13
    1582:	ff 92       	push	r15
    1584:	0f 93       	push	r16
    1586:	1f 93       	push	r17
    1588:	cf 93       	push	r28
    158a:	df 93       	push	r29
    158c:	00 d0       	rcall	.+0      	; 0x158e <xQueueReceive+0x14>
    158e:	00 d0       	rcall	.+0      	; 0x1590 <xQueueReceive+0x16>
    1590:	1f 92       	push	r1
    1592:	cd b7       	in	r28, 0x3d	; 61
    1594:	de b7       	in	r29, 0x3e	; 62
    1596:	8c 01       	movw	r16, r24
    1598:	6b 01       	movw	r12, r22
    159a:	5d 83       	std	Y+5, r21	; 0x05
    159c:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    159e:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15a0:	58 01       	movw	r10, r16
    15a2:	91 e1       	ldi	r25, 0x11	; 17
    15a4:	a9 0e       	add	r10, r25
    15a6:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    15a8:	0f b6       	in	r0, 0x3f	; 63
    15aa:	f8 94       	cli
    15ac:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    15ae:	f8 01       	movw	r30, r16
    15b0:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    15b2:	ff 20       	and	r15, r15
    15b4:	a9 f0       	breq	.+42     	; 0x15e0 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    15b6:	b6 01       	movw	r22, r12
    15b8:	c8 01       	movw	r24, r16
    15ba:	0e 94 16 09 	call	0x122c	; 0x122c <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    15be:	fa 94       	dec	r15
    15c0:	f8 01       	movw	r30, r16
    15c2:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15c4:	80 85       	ldd	r24, Z+8	; 0x08
    15c6:	88 23       	and	r24, r24
    15c8:	39 f0       	breq	.+14     	; 0x15d8 <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15ca:	c8 01       	movw	r24, r16
    15cc:	08 96       	adiw	r24, 0x08	; 8
    15ce:	0e 94 c6 05 	call	0xb8c	; 0xb8c <xTaskRemoveFromEventList>
    15d2:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    15d4:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    15d8:	0f 90       	pop	r0
    15da:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    15dc:	81 e0       	ldi	r24, 0x01	; 1
    15de:	50 c0       	rjmp	.+160    	; 0x1680 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    15e0:	2c 81       	ldd	r18, Y+4	; 0x04
    15e2:	3d 81       	ldd	r19, Y+5	; 0x05
    15e4:	23 2b       	or	r18, r19
    15e6:	19 f4       	brne	.+6      	; 0x15ee <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    15e8:	0f 90       	pop	r0
    15ea:	0f be       	out	0x3f, r0	; 63
    15ec:	48 c0       	rjmp	.+144    	; 0x167e <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    15ee:	81 11       	cpse	r24, r1
    15f0:	04 c0       	rjmp	.+8      	; 0x15fa <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    15f2:	ce 01       	movw	r24, r28
    15f4:	01 96       	adiw	r24, 0x01	; 1
    15f6:	0e 94 48 06 	call	0xc90	; 0xc90 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    15fa:	0f 90       	pop	r0
    15fc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15fe:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1602:	0f b6       	in	r0, 0x3f	; 63
    1604:	f8 94       	cli
    1606:	0f 92       	push	r0
    1608:	f8 01       	movw	r30, r16
    160a:	85 8d       	ldd	r24, Z+29	; 0x1d
    160c:	8f 3f       	cpi	r24, 0xFF	; 255
    160e:	09 f4       	brne	.+2      	; 0x1612 <xQueueReceive+0x98>
    1610:	15 8e       	std	Z+29, r1	; 0x1d
    1612:	f8 01       	movw	r30, r16
    1614:	86 8d       	ldd	r24, Z+30	; 0x1e
    1616:	8f 3f       	cpi	r24, 0xFF	; 255
    1618:	09 f4       	brne	.+2      	; 0x161c <xQueueReceive+0xa2>
    161a:	16 8e       	std	Z+30, r1	; 0x1e
    161c:	0f 90       	pop	r0
    161e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1620:	be 01       	movw	r22, r28
    1622:	6c 5f       	subi	r22, 0xFC	; 252
    1624:	7f 4f       	sbci	r23, 0xFF	; 255
    1626:	ce 01       	movw	r24, r28
    1628:	01 96       	adiw	r24, 0x01	; 1
    162a:	0e 94 53 06 	call	0xca6	; 0xca6 <xTaskCheckForTimeOut>
    162e:	81 11       	cpse	r24, r1
    1630:	1c c0       	rjmp	.+56     	; 0x166a <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1632:	c8 01       	movw	r24, r16
    1634:	0e 94 c3 08 	call	0x1186	; 0x1186 <prvIsQueueEmpty>
    1638:	88 23       	and	r24, r24
    163a:	89 f0       	breq	.+34     	; 0x165e <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    163c:	6c 81       	ldd	r22, Y+4	; 0x04
    163e:	7d 81       	ldd	r23, Y+5	; 0x05
    1640:	c5 01       	movw	r24, r10
    1642:	0e 94 9d 05 	call	0xb3a	; 0xb3a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1646:	c8 01       	movw	r24, r16
    1648:	0e 94 30 09 	call	0x1260	; 0x1260 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    164c:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>
    1650:	88 23       	and	r24, r24
    1652:	11 f0       	breq	.+4      	; 0x1658 <xQueueReceive+0xde>
    1654:	81 e0       	ldi	r24, 0x01	; 1
    1656:	a8 cf       	rjmp	.-176    	; 0x15a8 <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    1658:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
    165c:	fb cf       	rjmp	.-10     	; 0x1654 <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    165e:	c8 01       	movw	r24, r16
    1660:	0e 94 30 09 	call	0x1260	; 0x1260 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1664:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>
    1668:	f5 cf       	rjmp	.-22     	; 0x1654 <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    166a:	c8 01       	movw	r24, r16
    166c:	0e 94 30 09 	call	0x1260	; 0x1260 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1670:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1674:	c8 01       	movw	r24, r16
    1676:	0e 94 c3 08 	call	0x1186	; 0x1186 <prvIsQueueEmpty>
    167a:	88 23       	and	r24, r24
    167c:	59 f3       	breq	.-42     	; 0x1654 <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    167e:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1680:	0f 90       	pop	r0
    1682:	0f 90       	pop	r0
    1684:	0f 90       	pop	r0
    1686:	0f 90       	pop	r0
    1688:	0f 90       	pop	r0
    168a:	df 91       	pop	r29
    168c:	cf 91       	pop	r28
    168e:	1f 91       	pop	r17
    1690:	0f 91       	pop	r16
    1692:	ff 90       	pop	r15
    1694:	df 90       	pop	r13
    1696:	cf 90       	pop	r12
    1698:	bf 90       	pop	r11
    169a:	af 90       	pop	r10
    169c:	08 95       	ret

0000169e <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    169e:	ef 92       	push	r14
    16a0:	ff 92       	push	r15
    16a2:	0f 93       	push	r16
    16a4:	1f 93       	push	r17
    16a6:	cf 93       	push	r28
    16a8:	df 93       	push	r29
    16aa:	00 d0       	rcall	.+0      	; 0x16ac <xQueueSemaphoreTake+0xe>
    16ac:	00 d0       	rcall	.+0      	; 0x16ae <xQueueSemaphoreTake+0x10>
    16ae:	1f 92       	push	r1
    16b0:	cd b7       	in	r28, 0x3d	; 61
    16b2:	de b7       	in	r29, 0x3e	; 62
    16b4:	8c 01       	movw	r16, r24
    16b6:	7d 83       	std	Y+5, r23	; 0x05
    16b8:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    16ba:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16bc:	78 01       	movw	r14, r16
    16be:	81 e1       	ldi	r24, 0x11	; 17
    16c0:	e8 0e       	add	r14, r24
    16c2:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    16c4:	0f b6       	in	r0, 0x3f	; 63
    16c6:	f8 94       	cli
    16c8:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    16ca:	f8 01       	movw	r30, r16
    16cc:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    16ce:	88 23       	and	r24, r24
    16d0:	81 f0       	breq	.+32     	; 0x16f2 <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    16d2:	81 50       	subi	r24, 0x01	; 1
    16d4:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16d6:	80 85       	ldd	r24, Z+8	; 0x08
    16d8:	88 23       	and	r24, r24
    16da:	39 f0       	breq	.+14     	; 0x16ea <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16dc:	c8 01       	movw	r24, r16
    16de:	08 96       	adiw	r24, 0x08	; 8
    16e0:	0e 94 c6 05 	call	0xb8c	; 0xb8c <xTaskRemoveFromEventList>
    16e4:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    16e6:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    16ea:	0f 90       	pop	r0
    16ec:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    16ee:	81 e0       	ldi	r24, 0x01	; 1
    16f0:	50 c0       	rjmp	.+160    	; 0x1792 <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    16f2:	2c 81       	ldd	r18, Y+4	; 0x04
    16f4:	3d 81       	ldd	r19, Y+5	; 0x05
    16f6:	23 2b       	or	r18, r19
    16f8:	19 f4       	brne	.+6      	; 0x1700 <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    16fa:	0f 90       	pop	r0
    16fc:	0f be       	out	0x3f, r0	; 63
    16fe:	48 c0       	rjmp	.+144    	; 0x1790 <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1700:	91 11       	cpse	r25, r1
    1702:	04 c0       	rjmp	.+8      	; 0x170c <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1704:	ce 01       	movw	r24, r28
    1706:	01 96       	adiw	r24, 0x01	; 1
    1708:	0e 94 48 06 	call	0xc90	; 0xc90 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    170c:	0f 90       	pop	r0
    170e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1710:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1714:	0f b6       	in	r0, 0x3f	; 63
    1716:	f8 94       	cli
    1718:	0f 92       	push	r0
    171a:	f8 01       	movw	r30, r16
    171c:	85 8d       	ldd	r24, Z+29	; 0x1d
    171e:	8f 3f       	cpi	r24, 0xFF	; 255
    1720:	09 f4       	brne	.+2      	; 0x1724 <xQueueSemaphoreTake+0x86>
    1722:	15 8e       	std	Z+29, r1	; 0x1d
    1724:	f8 01       	movw	r30, r16
    1726:	86 8d       	ldd	r24, Z+30	; 0x1e
    1728:	8f 3f       	cpi	r24, 0xFF	; 255
    172a:	09 f4       	brne	.+2      	; 0x172e <xQueueSemaphoreTake+0x90>
    172c:	16 8e       	std	Z+30, r1	; 0x1e
    172e:	0f 90       	pop	r0
    1730:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1732:	be 01       	movw	r22, r28
    1734:	6c 5f       	subi	r22, 0xFC	; 252
    1736:	7f 4f       	sbci	r23, 0xFF	; 255
    1738:	ce 01       	movw	r24, r28
    173a:	01 96       	adiw	r24, 0x01	; 1
    173c:	0e 94 53 06 	call	0xca6	; 0xca6 <xTaskCheckForTimeOut>
    1740:	81 11       	cpse	r24, r1
    1742:	1c c0       	rjmp	.+56     	; 0x177c <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1744:	c8 01       	movw	r24, r16
    1746:	0e 94 c3 08 	call	0x1186	; 0x1186 <prvIsQueueEmpty>
    174a:	88 23       	and	r24, r24
    174c:	89 f0       	breq	.+34     	; 0x1770 <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    174e:	6c 81       	ldd	r22, Y+4	; 0x04
    1750:	7d 81       	ldd	r23, Y+5	; 0x05
    1752:	c7 01       	movw	r24, r14
    1754:	0e 94 9d 05 	call	0xb3a	; 0xb3a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1758:	c8 01       	movw	r24, r16
    175a:	0e 94 30 09 	call	0x1260	; 0x1260 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    175e:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>
    1762:	88 23       	and	r24, r24
    1764:	11 f0       	breq	.+4      	; 0x176a <xQueueSemaphoreTake+0xcc>
    1766:	91 e0       	ldi	r25, 0x01	; 1
    1768:	ad cf       	rjmp	.-166    	; 0x16c4 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    176a:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
    176e:	fb cf       	rjmp	.-10     	; 0x1766 <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1770:	c8 01       	movw	r24, r16
    1772:	0e 94 30 09 	call	0x1260	; 0x1260 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1776:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>
    177a:	f5 cf       	rjmp	.-22     	; 0x1766 <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    177c:	c8 01       	movw	r24, r16
    177e:	0e 94 30 09 	call	0x1260	; 0x1260 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1782:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1786:	c8 01       	movw	r24, r16
    1788:	0e 94 c3 08 	call	0x1186	; 0x1186 <prvIsQueueEmpty>
    178c:	88 23       	and	r24, r24
    178e:	59 f3       	breq	.-42     	; 0x1766 <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1790:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1792:	0f 90       	pop	r0
    1794:	0f 90       	pop	r0
    1796:	0f 90       	pop	r0
    1798:	0f 90       	pop	r0
    179a:	0f 90       	pop	r0
    179c:	df 91       	pop	r29
    179e:	cf 91       	pop	r28
    17a0:	1f 91       	pop	r17
    17a2:	0f 91       	pop	r16
    17a4:	ff 90       	pop	r15
    17a6:	ef 90       	pop	r14
    17a8:	08 95       	ret

000017aa <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    17aa:	cf 92       	push	r12
    17ac:	df 92       	push	r13
    17ae:	ef 92       	push	r14
    17b0:	ff 92       	push	r15
    17b2:	0f 93       	push	r16
    17b4:	1f 93       	push	r17
    17b6:	cf 93       	push	r28
    17b8:	df 93       	push	r29
    17ba:	00 d0       	rcall	.+0      	; 0x17bc <xQueuePeek+0x12>
    17bc:	00 d0       	rcall	.+0      	; 0x17be <xQueuePeek+0x14>
    17be:	1f 92       	push	r1
    17c0:	cd b7       	in	r28, 0x3d	; 61
    17c2:	de b7       	in	r29, 0x3e	; 62
    17c4:	8c 01       	movw	r16, r24
    17c6:	7b 01       	movw	r14, r22
    17c8:	5d 83       	std	Y+5, r21	; 0x05
    17ca:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    17cc:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17ce:	68 01       	movw	r12, r16
    17d0:	91 e1       	ldi	r25, 0x11	; 17
    17d2:	c9 0e       	add	r12, r25
    17d4:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    17d6:	0f b6       	in	r0, 0x3f	; 63
    17d8:	f8 94       	cli
    17da:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    17dc:	f8 01       	movw	r30, r16
    17de:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    17e0:	99 23       	and	r25, r25
    17e2:	b9 f0       	breq	.+46     	; 0x1812 <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    17e4:	c6 80       	ldd	r12, Z+6	; 0x06
    17e6:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    17e8:	b7 01       	movw	r22, r14
    17ea:	c8 01       	movw	r24, r16
    17ec:	0e 94 16 09 	call	0x122c	; 0x122c <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    17f0:	f8 01       	movw	r30, r16
    17f2:	d7 82       	std	Z+7, r13	; 0x07
    17f4:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17f6:	81 89       	ldd	r24, Z+17	; 0x11
    17f8:	88 23       	and	r24, r24
    17fa:	39 f0       	breq	.+14     	; 0x180a <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17fc:	c8 01       	movw	r24, r16
    17fe:	41 96       	adiw	r24, 0x11	; 17
    1800:	0e 94 c6 05 	call	0xb8c	; 0xb8c <xTaskRemoveFromEventList>
    1804:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1806:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    180a:	0f 90       	pop	r0
    180c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    180e:	81 e0       	ldi	r24, 0x01	; 1
    1810:	50 c0       	rjmp	.+160    	; 0x18b2 <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1812:	2c 81       	ldd	r18, Y+4	; 0x04
    1814:	3d 81       	ldd	r19, Y+5	; 0x05
    1816:	23 2b       	or	r18, r19
    1818:	19 f4       	brne	.+6      	; 0x1820 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    181a:	0f 90       	pop	r0
    181c:	0f be       	out	0x3f, r0	; 63
    181e:	48 c0       	rjmp	.+144    	; 0x18b0 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1820:	81 11       	cpse	r24, r1
    1822:	04 c0       	rjmp	.+8      	; 0x182c <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1824:	ce 01       	movw	r24, r28
    1826:	01 96       	adiw	r24, 0x01	; 1
    1828:	0e 94 48 06 	call	0xc90	; 0xc90 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    182c:	0f 90       	pop	r0
    182e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1830:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1834:	0f b6       	in	r0, 0x3f	; 63
    1836:	f8 94       	cli
    1838:	0f 92       	push	r0
    183a:	f8 01       	movw	r30, r16
    183c:	85 8d       	ldd	r24, Z+29	; 0x1d
    183e:	8f 3f       	cpi	r24, 0xFF	; 255
    1840:	09 f4       	brne	.+2      	; 0x1844 <xQueuePeek+0x9a>
    1842:	15 8e       	std	Z+29, r1	; 0x1d
    1844:	f8 01       	movw	r30, r16
    1846:	86 8d       	ldd	r24, Z+30	; 0x1e
    1848:	8f 3f       	cpi	r24, 0xFF	; 255
    184a:	09 f4       	brne	.+2      	; 0x184e <xQueuePeek+0xa4>
    184c:	16 8e       	std	Z+30, r1	; 0x1e
    184e:	0f 90       	pop	r0
    1850:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1852:	be 01       	movw	r22, r28
    1854:	6c 5f       	subi	r22, 0xFC	; 252
    1856:	7f 4f       	sbci	r23, 0xFF	; 255
    1858:	ce 01       	movw	r24, r28
    185a:	01 96       	adiw	r24, 0x01	; 1
    185c:	0e 94 53 06 	call	0xca6	; 0xca6 <xTaskCheckForTimeOut>
    1860:	81 11       	cpse	r24, r1
    1862:	1c c0       	rjmp	.+56     	; 0x189c <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1864:	c8 01       	movw	r24, r16
    1866:	0e 94 c3 08 	call	0x1186	; 0x1186 <prvIsQueueEmpty>
    186a:	88 23       	and	r24, r24
    186c:	89 f0       	breq	.+34     	; 0x1890 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    186e:	6c 81       	ldd	r22, Y+4	; 0x04
    1870:	7d 81       	ldd	r23, Y+5	; 0x05
    1872:	c6 01       	movw	r24, r12
    1874:	0e 94 9d 05 	call	0xb3a	; 0xb3a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1878:	c8 01       	movw	r24, r16
    187a:	0e 94 30 09 	call	0x1260	; 0x1260 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    187e:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>
    1882:	88 23       	and	r24, r24
    1884:	11 f0       	breq	.+4      	; 0x188a <xQueuePeek+0xe0>
    1886:	81 e0       	ldi	r24, 0x01	; 1
    1888:	a6 cf       	rjmp	.-180    	; 0x17d6 <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    188a:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vPortYield>
    188e:	fb cf       	rjmp	.-10     	; 0x1886 <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    1890:	c8 01       	movw	r24, r16
    1892:	0e 94 30 09 	call	0x1260	; 0x1260 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1896:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>
    189a:	f5 cf       	rjmp	.-22     	; 0x1886 <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    189c:	c8 01       	movw	r24, r16
    189e:	0e 94 30 09 	call	0x1260	; 0x1260 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18a2:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18a6:	c8 01       	movw	r24, r16
    18a8:	0e 94 c3 08 	call	0x1186	; 0x1186 <prvIsQueueEmpty>
    18ac:	88 23       	and	r24, r24
    18ae:	59 f3       	breq	.-42     	; 0x1886 <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    18b0:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    18b2:	0f 90       	pop	r0
    18b4:	0f 90       	pop	r0
    18b6:	0f 90       	pop	r0
    18b8:	0f 90       	pop	r0
    18ba:	0f 90       	pop	r0
    18bc:	df 91       	pop	r29
    18be:	cf 91       	pop	r28
    18c0:	1f 91       	pop	r17
    18c2:	0f 91       	pop	r16
    18c4:	ff 90       	pop	r15
    18c6:	ef 90       	pop	r14
    18c8:	df 90       	pop	r13
    18ca:	cf 90       	pop	r12
    18cc:	08 95       	ret

000018ce <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    18ce:	ef 92       	push	r14
    18d0:	ff 92       	push	r15
    18d2:	0f 93       	push	r16
    18d4:	1f 93       	push	r17
    18d6:	cf 93       	push	r28
    18d8:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    18da:	fc 01       	movw	r30, r24
    18dc:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    18de:	00 23       	and	r16, r16
    18e0:	e9 f0       	breq	.+58     	; 0x191c <xQueueReceiveFromISR+0x4e>
    18e2:	7a 01       	movw	r14, r20
    18e4:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    18e6:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    18e8:	0e 94 16 09 	call	0x122c	; 0x122c <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    18ec:	01 50       	subi	r16, 0x01	; 1
    18ee:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    18f0:	1f 3f       	cpi	r17, 0xFF	; 255
    18f2:	81 f4       	brne	.+32     	; 0x1914 <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18f4:	88 85       	ldd	r24, Y+8	; 0x08
    18f6:	88 23       	and	r24, r24
    18f8:	79 f0       	breq	.+30     	; 0x1918 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    18fa:	ce 01       	movw	r24, r28
    18fc:	08 96       	adiw	r24, 0x08	; 8
    18fe:	0e 94 c6 05 	call	0xb8c	; 0xb8c <xTaskRemoveFromEventList>
    1902:	88 23       	and	r24, r24
    1904:	49 f0       	breq	.+18     	; 0x1918 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1906:	e1 14       	cp	r14, r1
    1908:	f1 04       	cpc	r15, r1
    190a:	31 f0       	breq	.+12     	; 0x1918 <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    190c:	81 e0       	ldi	r24, 0x01	; 1
    190e:	f7 01       	movw	r30, r14
    1910:	80 83       	st	Z, r24
    1912:	05 c0       	rjmp	.+10     	; 0x191e <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1914:	1f 5f       	subi	r17, 0xFF	; 255
    1916:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1918:	81 e0       	ldi	r24, 0x01	; 1
    191a:	01 c0       	rjmp	.+2      	; 0x191e <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    191c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    191e:	df 91       	pop	r29
    1920:	cf 91       	pop	r28
    1922:	1f 91       	pop	r17
    1924:	0f 91       	pop	r16
    1926:	ff 90       	pop	r15
    1928:	ef 90       	pop	r14
    192a:	08 95       	ret

0000192c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    192c:	0f 93       	push	r16
    192e:	1f 93       	push	r17
    1930:	cf 93       	push	r28
    1932:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1934:	fc 01       	movw	r30, r24
    1936:	22 8d       	ldd	r18, Z+26	; 0x1a
    1938:	22 23       	and	r18, r18
    193a:	49 f0       	breq	.+18     	; 0x194e <xQueuePeekFromISR+0x22>
    193c:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    193e:	06 81       	ldd	r16, Z+6	; 0x06
    1940:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1942:	0e 94 16 09 	call	0x122c	; 0x122c <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1946:	1f 83       	std	Y+7, r17	; 0x07
    1948:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    194a:	81 e0       	ldi	r24, 0x01	; 1
    194c:	01 c0       	rjmp	.+2      	; 0x1950 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    194e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1950:	df 91       	pop	r29
    1952:	cf 91       	pop	r28
    1954:	1f 91       	pop	r17
    1956:	0f 91       	pop	r16
    1958:	08 95       	ret

0000195a <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    195a:	0f b6       	in	r0, 0x3f	; 63
    195c:	f8 94       	cli
    195e:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1960:	fc 01       	movw	r30, r24
    1962:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1964:	0f 90       	pop	r0
    1966:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1968:	08 95       	ret

0000196a <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    196a:	0f b6       	in	r0, 0x3f	; 63
    196c:	f8 94       	cli
    196e:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1970:	fc 01       	movw	r30, r24
    1972:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1974:	0f 90       	pop	r0
    1976:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1978:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    197a:	82 1b       	sub	r24, r18
    197c:	08 95       	ret

0000197e <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    197e:	fc 01       	movw	r30, r24
    1980:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1982:	08 95       	ret

00001984 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1984:	0c 94 36 10 	jmp	0x206c	; 0x206c <vPortFree>

00001988 <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1988:	fc 01       	movw	r30, r24
    198a:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    198c:	81 e0       	ldi	r24, 0x01	; 1
    198e:	91 11       	cpse	r25, r1
    1990:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1992:	08 95       	ret

00001994 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1994:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1996:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1998:	81 e0       	ldi	r24, 0x01	; 1
    199a:	23 8d       	ldd	r18, Z+27	; 0x1b
    199c:	29 13       	cpse	r18, r25
    199e:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    19a0:	08 95       	ret

000019a2 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    19a2:	cf 93       	push	r28
    19a4:	df 93       	push	r29
    19a6:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    19a8:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    19aa:	0f b6       	in	r0, 0x3f	; 63
    19ac:	f8 94       	cli
    19ae:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    19b0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19b2:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    19b4:	0f 90       	pop	r0
    19b6:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    19b8:	89 13       	cpse	r24, r25
    19ba:	0f c0       	rjmp	.+30     	; 0x19da <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    19bc:	41 15       	cp	r20, r1
    19be:	51 05       	cpc	r21, r1
    19c0:	49 f0       	breq	.+18     	; 0x19d4 <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    19c2:	be 01       	movw	r22, r28
    19c4:	68 5f       	subi	r22, 0xF8	; 248
    19c6:	7f 4f       	sbci	r23, 0xFF	; 255
    19c8:	ca 01       	movw	r24, r20
    19ca:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    19ce:	78 94       	sei
					return errQUEUE_BLOCKED;
    19d0:	8c ef       	ldi	r24, 0xFC	; 252
    19d2:	1b c0       	rjmp	.+54     	; 0x1a0a <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    19d4:	78 94       	sei
					return errQUEUE_FULL;
    19d6:	80 e0       	ldi	r24, 0x00	; 0
    19d8:	18 c0       	rjmp	.+48     	; 0x1a0a <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    19da:	78 94       	sei

		portDISABLE_INTERRUPTS();
    19dc:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    19de:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19e0:	89 17       	cp	r24, r25
    19e2:	88 f4       	brcc	.+34     	; 0x1a06 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    19e4:	40 e0       	ldi	r20, 0x00	; 0
    19e6:	ce 01       	movw	r24, r28
    19e8:	0e 94 ce 08 	call	0x119c	; 0x119c <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19ec:	89 89       	ldd	r24, Y+17	; 0x11
    19ee:	81 11       	cpse	r24, r1
    19f0:	02 c0       	rjmp	.+4      	; 0x19f6 <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    19f2:	81 e0       	ldi	r24, 0x01	; 1
    19f4:	09 c0       	rjmp	.+18     	; 0x1a08 <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19f6:	ce 01       	movw	r24, r28
    19f8:	41 96       	adiw	r24, 0x11	; 17
    19fa:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <xCoRoutineRemoveFromEventList>
    19fe:	88 23       	and	r24, r24
    1a00:	c1 f3       	breq	.-16     	; 0x19f2 <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1a02:	8b ef       	ldi	r24, 0xFB	; 251
    1a04:	01 c0       	rjmp	.+2      	; 0x1a08 <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1a06:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1a08:	78 94       	sei

		return xReturn;
	}
    1a0a:	df 91       	pop	r29
    1a0c:	cf 91       	pop	r28
    1a0e:	08 95       	ret

00001a10 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1a10:	cf 93       	push	r28
    1a12:	df 93       	push	r29
    1a14:	ec 01       	movw	r28, r24
    1a16:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1a18:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1a1a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a1c:	81 11       	cpse	r24, r1
    1a1e:	0f c0       	rjmp	.+30     	; 0x1a3e <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1a20:	41 15       	cp	r20, r1
    1a22:	51 05       	cpc	r21, r1
    1a24:	49 f0       	breq	.+18     	; 0x1a38 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1a26:	be 01       	movw	r22, r28
    1a28:	6f 5e       	subi	r22, 0xEF	; 239
    1a2a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a2c:	ca 01       	movw	r24, r20
    1a2e:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1a32:	78 94       	sei
					return errQUEUE_BLOCKED;
    1a34:	8c ef       	ldi	r24, 0xFC	; 252
    1a36:	30 c0       	rjmp	.+96     	; 0x1a98 <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1a38:	78 94       	sei
					return errQUEUE_FULL;
    1a3a:	80 e0       	ldi	r24, 0x00	; 0
    1a3c:	2d c0       	rjmp	.+90     	; 0x1a98 <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1a3e:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1a40:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a42:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a44:	88 23       	and	r24, r24
    1a46:	31 f1       	breq	.+76     	; 0x1a94 <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1a48:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1a4a:	50 e0       	ldi	r21, 0x00	; 0
    1a4c:	2e 81       	ldd	r18, Y+6	; 0x06
    1a4e:	3f 81       	ldd	r19, Y+7	; 0x07
    1a50:	24 0f       	add	r18, r20
    1a52:	35 1f       	adc	r19, r21
    1a54:	3f 83       	std	Y+7, r19	; 0x07
    1a56:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1a58:	8c 81       	ldd	r24, Y+4	; 0x04
    1a5a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a5c:	28 17       	cp	r18, r24
    1a5e:	39 07       	cpc	r19, r25
    1a60:	20 f0       	brcs	.+8      	; 0x1a6a <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1a62:	88 81       	ld	r24, Y
    1a64:	99 81       	ldd	r25, Y+1	; 0x01
    1a66:	9f 83       	std	Y+7, r25	; 0x07
    1a68:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1a6a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a6c:	91 50       	subi	r25, 0x01	; 1
    1a6e:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1a70:	6e 81       	ldd	r22, Y+6	; 0x06
    1a72:	7f 81       	ldd	r23, Y+7	; 0x07
    1a74:	cf 01       	movw	r24, r30
    1a76:	0e 94 e9 11 	call	0x23d2	; 0x23d2 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a7a:	88 85       	ldd	r24, Y+8	; 0x08
    1a7c:	81 11       	cpse	r24, r1
    1a7e:	02 c0       	rjmp	.+4      	; 0x1a84 <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1a80:	81 e0       	ldi	r24, 0x01	; 1
    1a82:	09 c0       	rjmp	.+18     	; 0x1a96 <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a84:	ce 01       	movw	r24, r28
    1a86:	08 96       	adiw	r24, 0x08	; 8
    1a88:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <xCoRoutineRemoveFromEventList>
    1a8c:	88 23       	and	r24, r24
    1a8e:	c1 f3       	breq	.-16     	; 0x1a80 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1a90:	8b ef       	ldi	r24, 0xFB	; 251
    1a92:	01 c0       	rjmp	.+2      	; 0x1a96 <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1a94:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1a96:	78 94       	sei

		return xReturn;
	}
    1a98:	df 91       	pop	r29
    1a9a:	cf 91       	pop	r28
    1a9c:	08 95       	ret

00001a9e <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1a9e:	0f 93       	push	r16
    1aa0:	1f 93       	push	r17
    1aa2:	cf 93       	push	r28
    1aa4:	8c 01       	movw	r16, r24
    1aa6:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1aa8:	fc 01       	movw	r30, r24
    1aaa:	92 8d       	ldd	r25, Z+26	; 0x1a
    1aac:	83 8d       	ldd	r24, Z+27	; 0x1b
    1aae:	98 17       	cp	r25, r24
    1ab0:	10 f0       	brcs	.+4      	; 0x1ab6 <xQueueCRSendFromISR+0x18>
    1ab2:	4c 2f       	mov	r20, r28
    1ab4:	12 c0       	rjmp	.+36     	; 0x1ada <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1ab6:	40 e0       	ldi	r20, 0x00	; 0
    1ab8:	c8 01       	movw	r24, r16
    1aba:	0e 94 ce 08 	call	0x119c	; 0x119c <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1abe:	c1 11       	cpse	r28, r1
    1ac0:	f8 cf       	rjmp	.-16     	; 0x1ab2 <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ac2:	f8 01       	movw	r30, r16
    1ac4:	81 89       	ldd	r24, Z+17	; 0x11
    1ac6:	88 23       	and	r24, r24
    1ac8:	39 f0       	breq	.+14     	; 0x1ad8 <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1aca:	c8 01       	movw	r24, r16
    1acc:	41 96       	adiw	r24, 0x11	; 17
    1ace:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1ad2:	41 e0       	ldi	r20, 0x01	; 1
    1ad4:	81 11       	cpse	r24, r1
    1ad6:	01 c0       	rjmp	.+2      	; 0x1ada <xQueueCRSendFromISR+0x3c>
    1ad8:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1ada:	84 2f       	mov	r24, r20
    1adc:	cf 91       	pop	r28
    1ade:	1f 91       	pop	r17
    1ae0:	0f 91       	pop	r16
    1ae2:	08 95       	ret

00001ae4 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1ae4:	0f 93       	push	r16
    1ae6:	1f 93       	push	r17
    1ae8:	cf 93       	push	r28
    1aea:	df 93       	push	r29
    1aec:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1aee:	82 8d       	ldd	r24, Z+26	; 0x1a
    1af0:	88 23       	and	r24, r24
    1af2:	79 f1       	breq	.+94     	; 0x1b52 <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1af4:	24 8d       	ldd	r18, Z+28	; 0x1c
    1af6:	30 e0       	ldi	r19, 0x00	; 0
    1af8:	a6 81       	ldd	r26, Z+6	; 0x06
    1afa:	b7 81       	ldd	r27, Z+7	; 0x07
    1afc:	a2 0f       	add	r26, r18
    1afe:	b3 1f       	adc	r27, r19
    1b00:	b7 83       	std	Z+7, r27	; 0x07
    1b02:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1b04:	84 81       	ldd	r24, Z+4	; 0x04
    1b06:	95 81       	ldd	r25, Z+5	; 0x05
    1b08:	a8 17       	cp	r26, r24
    1b0a:	b9 07       	cpc	r27, r25
    1b0c:	20 f0       	brcs	.+8      	; 0x1b16 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1b0e:	80 81       	ld	r24, Z
    1b10:	91 81       	ldd	r25, Z+1	; 0x01
    1b12:	97 83       	std	Z+7, r25	; 0x07
    1b14:	86 83       	std	Z+6, r24	; 0x06
    1b16:	8a 01       	movw	r16, r20
    1b18:	cb 01       	movw	r24, r22
    1b1a:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1b1c:	42 8d       	ldd	r20, Z+26	; 0x1a
    1b1e:	41 50       	subi	r20, 0x01	; 1
    1b20:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1b22:	66 81       	ldd	r22, Z+6	; 0x06
    1b24:	77 81       	ldd	r23, Z+7	; 0x07
    1b26:	a9 01       	movw	r20, r18
    1b28:	0e 94 e9 11 	call	0x23d2	; 0x23d2 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1b2c:	f8 01       	movw	r30, r16
    1b2e:	80 81       	ld	r24, Z
    1b30:	88 23       	and	r24, r24
    1b32:	11 f0       	breq	.+4      	; 0x1b38 <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1b34:	81 e0       	ldi	r24, 0x01	; 1
    1b36:	0e c0       	rjmp	.+28     	; 0x1b54 <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b38:	88 85       	ldd	r24, Y+8	; 0x08
    1b3a:	88 23       	and	r24, r24
    1b3c:	d9 f3       	breq	.-10     	; 0x1b34 <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b3e:	ce 01       	movw	r24, r28
    1b40:	08 96       	adiw	r24, 0x08	; 8
    1b42:	0e 94 df 0f 	call	0x1fbe	; 0x1fbe <xCoRoutineRemoveFromEventList>
    1b46:	88 23       	and	r24, r24
    1b48:	a9 f3       	breq	.-22     	; 0x1b34 <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1b4a:	81 e0       	ldi	r24, 0x01	; 1
    1b4c:	f8 01       	movw	r30, r16
    1b4e:	80 83       	st	Z, r24
    1b50:	01 c0       	rjmp	.+2      	; 0x1b54 <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1b52:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1b54:	df 91       	pop	r29
    1b56:	cf 91       	pop	r28
    1b58:	1f 91       	pop	r17
    1b5a:	0f 91       	pop	r16
    1b5c:	08 95       	ret

00001b5e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1b5e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b60:	03 96       	adiw	r24, 0x03	; 3
    1b62:	92 83       	std	Z+2, r25	; 0x02
    1b64:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b66:	2f ef       	ldi	r18, 0xFF	; 255
    1b68:	3f ef       	ldi	r19, 0xFF	; 255
    1b6a:	34 83       	std	Z+4, r19	; 0x04
    1b6c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b6e:	96 83       	std	Z+6, r25	; 0x06
    1b70:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b72:	90 87       	std	Z+8, r25	; 0x08
    1b74:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1b76:	10 82       	st	Z, r1
    1b78:	08 95       	ret

00001b7a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1b7a:	fc 01       	movw	r30, r24
    1b7c:	11 86       	std	Z+9, r1	; 0x09
    1b7e:	10 86       	std	Z+8, r1	; 0x08
    1b80:	08 95       	ret

00001b82 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1b82:	cf 93       	push	r28
    1b84:	df 93       	push	r29
    1b86:	9c 01       	movw	r18, r24
    1b88:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1b8a:	dc 01       	movw	r26, r24
    1b8c:	11 96       	adiw	r26, 0x01	; 1
    1b8e:	cd 91       	ld	r28, X+
    1b90:	dc 91       	ld	r29, X
    1b92:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1b94:	d3 83       	std	Z+3, r29	; 0x03
    1b96:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1b98:	8c 81       	ldd	r24, Y+4	; 0x04
    1b9a:	9d 81       	ldd	r25, Y+5	; 0x05
    1b9c:	95 83       	std	Z+5, r25	; 0x05
    1b9e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1ba0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ba2:	9d 81       	ldd	r25, Y+5	; 0x05
    1ba4:	dc 01       	movw	r26, r24
    1ba6:	13 96       	adiw	r26, 0x03	; 3
    1ba8:	7c 93       	st	X, r23
    1baa:	6e 93       	st	-X, r22
    1bac:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1bae:	7d 83       	std	Y+5, r23	; 0x05
    1bb0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1bb2:	31 87       	std	Z+9, r19	; 0x09
    1bb4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1bb6:	f9 01       	movw	r30, r18
    1bb8:	80 81       	ld	r24, Z
    1bba:	8f 5f       	subi	r24, 0xFF	; 255
    1bbc:	80 83       	st	Z, r24
}
    1bbe:	df 91       	pop	r29
    1bc0:	cf 91       	pop	r28
    1bc2:	08 95       	ret

00001bc4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1bc4:	0f 93       	push	r16
    1bc6:	1f 93       	push	r17
    1bc8:	cf 93       	push	r28
    1bca:	df 93       	push	r29
    1bcc:	8c 01       	movw	r16, r24
    1bce:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1bd0:	80 81       	ld	r24, Z
    1bd2:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1bd4:	8f 3f       	cpi	r24, 0xFF	; 255
    1bd6:	2f ef       	ldi	r18, 0xFF	; 255
    1bd8:	92 07       	cpc	r25, r18
    1bda:	21 f4       	brne	.+8      	; 0x1be4 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1bdc:	e8 01       	movw	r28, r16
    1bde:	af 81       	ldd	r26, Y+7	; 0x07
    1be0:	b8 85       	ldd	r27, Y+8	; 0x08
    1be2:	0e c0       	rjmp	.+28     	; 0x1c00 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1be4:	d8 01       	movw	r26, r16
    1be6:	13 96       	adiw	r26, 0x03	; 3
    1be8:	12 96       	adiw	r26, 0x02	; 2
    1bea:	2d 91       	ld	r18, X+
    1bec:	3c 91       	ld	r19, X
    1bee:	13 97       	sbiw	r26, 0x03	; 3
    1bf0:	e9 01       	movw	r28, r18
    1bf2:	48 81       	ld	r20, Y
    1bf4:	59 81       	ldd	r21, Y+1	; 0x01
    1bf6:	84 17       	cp	r24, r20
    1bf8:	95 07       	cpc	r25, r21
    1bfa:	10 f0       	brcs	.+4      	; 0x1c00 <vListInsert+0x3c>
    1bfc:	d9 01       	movw	r26, r18
    1bfe:	f4 cf       	rjmp	.-24     	; 0x1be8 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c00:	12 96       	adiw	r26, 0x02	; 2
    1c02:	8d 91       	ld	r24, X+
    1c04:	9c 91       	ld	r25, X
    1c06:	13 97       	sbiw	r26, 0x03	; 3
    1c08:	93 83       	std	Z+3, r25	; 0x03
    1c0a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c0c:	ec 01       	movw	r28, r24
    1c0e:	fd 83       	std	Y+5, r31	; 0x05
    1c10:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c12:	b5 83       	std	Z+5, r27	; 0x05
    1c14:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1c16:	13 96       	adiw	r26, 0x03	; 3
    1c18:	fc 93       	st	X, r31
    1c1a:	ee 93       	st	-X, r30
    1c1c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1c1e:	11 87       	std	Z+9, r17	; 0x09
    1c20:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1c22:	f8 01       	movw	r30, r16
    1c24:	80 81       	ld	r24, Z
    1c26:	8f 5f       	subi	r24, 0xFF	; 255
    1c28:	80 83       	st	Z, r24
}
    1c2a:	df 91       	pop	r29
    1c2c:	cf 91       	pop	r28
    1c2e:	1f 91       	pop	r17
    1c30:	0f 91       	pop	r16
    1c32:	08 95       	ret

00001c34 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1c34:	cf 93       	push	r28
    1c36:	df 93       	push	r29
    1c38:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1c3a:	a0 85       	ldd	r26, Z+8	; 0x08
    1c3c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c3e:	82 81       	ldd	r24, Z+2	; 0x02
    1c40:	93 81       	ldd	r25, Z+3	; 0x03
    1c42:	24 81       	ldd	r18, Z+4	; 0x04
    1c44:	35 81       	ldd	r19, Z+5	; 0x05
    1c46:	ec 01       	movw	r28, r24
    1c48:	3d 83       	std	Y+5, r19	; 0x05
    1c4a:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c4c:	c4 81       	ldd	r28, Z+4	; 0x04
    1c4e:	d5 81       	ldd	r29, Z+5	; 0x05
    1c50:	9b 83       	std	Y+3, r25	; 0x03
    1c52:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c54:	11 96       	adiw	r26, 0x01	; 1
    1c56:	8d 91       	ld	r24, X+
    1c58:	9c 91       	ld	r25, X
    1c5a:	12 97       	sbiw	r26, 0x02	; 2
    1c5c:	e8 17       	cp	r30, r24
    1c5e:	f9 07       	cpc	r31, r25
    1c60:	21 f4       	brne	.+8      	; 0x1c6a <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c62:	12 96       	adiw	r26, 0x02	; 2
    1c64:	dc 93       	st	X, r29
    1c66:	ce 93       	st	-X, r28
    1c68:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1c6a:	11 86       	std	Z+9, r1	; 0x09
    1c6c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1c6e:	8c 91       	ld	r24, X
    1c70:	81 50       	subi	r24, 0x01	; 1
    1c72:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1c74:	8c 91       	ld	r24, X
}
    1c76:	df 91       	pop	r29
    1c78:	cf 91       	pop	r28
    1c7a:	08 95       	ret

00001c7c <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1c7c:	cf 92       	push	r12
    1c7e:	df 92       	push	r13
    1c80:	ef 92       	push	r14
    1c82:	ff 92       	push	r15
    1c84:	1f 93       	push	r17
    1c86:	cf 93       	push	r28
    1c88:	df 93       	push	r29
    1c8a:	6c 01       	movw	r12, r24
    1c8c:	16 2f       	mov	r17, r22
    1c8e:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1c90:	8a e1       	ldi	r24, 0x1A	; 26
    1c92:	90 e0       	ldi	r25, 0x00	; 0
    1c94:	0e 94 04 10 	call	0x2008	; 0x2008 <pvPortMalloc>
    1c98:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1c9a:	89 2b       	or	r24, r25
    1c9c:	09 f4       	brne	.+2      	; 0x1ca0 <xCoRoutineCreate+0x24>
    1c9e:	57 c0       	rjmp	.+174    	; 0x1d4e <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1ca0:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <pxCurrentCoRoutine>
    1ca4:	90 91 ae 01 	lds	r25, 0x01AE	; 0x8001ae <pxCurrentCoRoutine+0x1>
    1ca8:	89 2b       	or	r24, r25
    1caa:	21 f5       	brne	.+72     	; 0x1cf4 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1cac:	d0 93 ae 01 	sts	0x01AE, r29	; 0x8001ae <pxCurrentCoRoutine+0x1>
    1cb0:	c0 93 ad 01 	sts	0x01AD, r28	; 0x8001ad <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1cb4:	85 ed       	ldi	r24, 0xD5	; 213
    1cb6:	91 e0       	ldi	r25, 0x01	; 1
    1cb8:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
    1cbc:	8e ed       	ldi	r24, 0xDE	; 222
    1cbe:	91 e0       	ldi	r25, 0x01	; 1
    1cc0:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1cc4:	8c ec       	ldi	r24, 0xCC	; 204
    1cc6:	91 e0       	ldi	r25, 0x01	; 1
    1cc8:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1ccc:	83 ec       	ldi	r24, 0xC3	; 195
    1cce:	91 e0       	ldi	r25, 0x01	; 1
    1cd0:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1cd4:	86 eb       	ldi	r24, 0xB6	; 182
    1cd6:	91 e0       	ldi	r25, 0x01	; 1
    1cd8:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1cdc:	8c ec       	ldi	r24, 0xCC	; 204
    1cde:	91 e0       	ldi	r25, 0x01	; 1
    1ce0:	90 93 c2 01 	sts	0x01C2, r25	; 0x8001c2 <pxDelayedCoRoutineList+0x1>
    1ce4:	80 93 c1 01 	sts	0x01C1, r24	; 0x8001c1 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1ce8:	83 ec       	ldi	r24, 0xC3	; 195
    1cea:	91 e0       	ldi	r25, 0x01	; 1
    1cec:	90 93 c0 01 	sts	0x01C0, r25	; 0x8001c0 <pxOverflowDelayedCoRoutineList+0x1>
    1cf0:	80 93 bf 01 	sts	0x01BF, r24	; 0x8001bf <pxOverflowDelayedCoRoutineList>
    1cf4:	11 11       	cpse	r17, r1
    1cf6:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1cf8:	19 8e       	std	Y+25, r1	; 0x19
    1cfa:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1cfc:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1cfe:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1d00:	fe 01       	movw	r30, r28
    1d02:	c1 92       	st	Z+, r12
    1d04:	d1 92       	st	Z+, r13
    1d06:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1d08:	cf 01       	movw	r24, r30
    1d0a:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1d0e:	ce 01       	movw	r24, r28
    1d10:	0c 96       	adiw	r24, 0x0c	; 12
    1d12:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1d16:	d9 87       	std	Y+9, r29	; 0x09
    1d18:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1d1a:	db 8b       	std	Y+19, r29	; 0x13
    1d1c:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    1d1e:	82 e0       	ldi	r24, 0x02	; 2
    1d20:	90 e0       	ldi	r25, 0x00	; 0
    1d22:	81 1b       	sub	r24, r17
    1d24:	91 09       	sbc	r25, r1
    1d26:	9d 87       	std	Y+13, r25	; 0x0d
    1d28:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1d2a:	8e 89       	ldd	r24, Y+22	; 0x16
    1d2c:	90 91 b5 01 	lds	r25, 0x01B5	; 0x8001b5 <uxTopCoRoutineReadyPriority>
    1d30:	98 17       	cp	r25, r24
    1d32:	10 f4       	brcc	.+4      	; 0x1d38 <xCoRoutineCreate+0xbc>
    1d34:	80 93 b5 01 	sts	0x01B5, r24	; 0x8001b5 <uxTopCoRoutineReadyPriority>
    1d38:	f9 e0       	ldi	r31, 0x09	; 9
    1d3a:	8f 9f       	mul	r24, r31
    1d3c:	c0 01       	movw	r24, r0
    1d3e:	11 24       	eor	r1, r1
    1d40:	b7 01       	movw	r22, r14
    1d42:	8b 52       	subi	r24, 0x2B	; 43
    1d44:	9e 4f       	sbci	r25, 0xFE	; 254
    1d46:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>

		xReturn = pdPASS;
    1d4a:	81 e0       	ldi	r24, 0x01	; 1
    1d4c:	01 c0       	rjmp	.+2      	; 0x1d50 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1d4e:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    1d50:	df 91       	pop	r29
    1d52:	cf 91       	pop	r28
    1d54:	1f 91       	pop	r17
    1d56:	ff 90       	pop	r15
    1d58:	ef 90       	pop	r14
    1d5a:	df 90       	pop	r13
    1d5c:	cf 90       	pop	r12
    1d5e:	08 95       	ret

00001d60 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    1d60:	0f 93       	push	r16
    1d62:	1f 93       	push	r17
    1d64:	cf 93       	push	r28
    1d66:	df 93       	push	r29
    1d68:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1d6a:	c0 91 b3 01 	lds	r28, 0x01B3	; 0x8001b3 <xCoRoutineTickCount>
    1d6e:	d0 91 b4 01 	lds	r29, 0x01B4	; 0x8001b4 <xCoRoutineTickCount+0x1>
    1d72:	c8 0f       	add	r28, r24
    1d74:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1d76:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <pxCurrentCoRoutine>
    1d7a:	90 91 ae 01 	lds	r25, 0x01AE	; 0x8001ae <pxCurrentCoRoutine+0x1>
    1d7e:	02 96       	adiw	r24, 0x02	; 2
    1d80:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1d84:	e0 91 ad 01 	lds	r30, 0x01AD	; 0x8001ad <pxCurrentCoRoutine>
    1d88:	f0 91 ae 01 	lds	r31, 0x01AE	; 0x8001ae <pxCurrentCoRoutine+0x1>
    1d8c:	d3 83       	std	Z+3, r29	; 0x03
    1d8e:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1d90:	80 91 b3 01 	lds	r24, 0x01B3	; 0x8001b3 <xCoRoutineTickCount>
    1d94:	90 91 b4 01 	lds	r25, 0x01B4	; 0x8001b4 <xCoRoutineTickCount+0x1>
    1d98:	bf 01       	movw	r22, r30
    1d9a:	6e 5f       	subi	r22, 0xFE	; 254
    1d9c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d9e:	c8 17       	cp	r28, r24
    1da0:	d9 07       	cpc	r29, r25
    1da2:	28 f4       	brcc	.+10     	; 0x1dae <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1da4:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <pxOverflowDelayedCoRoutineList>
    1da8:	90 91 c0 01 	lds	r25, 0x01C0	; 0x8001c0 <pxOverflowDelayedCoRoutineList+0x1>
    1dac:	04 c0       	rjmp	.+8      	; 0x1db6 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1dae:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <pxDelayedCoRoutineList>
    1db2:	90 91 c2 01 	lds	r25, 0x01C2	; 0x8001c2 <pxDelayedCoRoutineList+0x1>
    1db6:	0e 94 e2 0d 	call	0x1bc4	; 0x1bc4 <vListInsert>
	}

	if( pxEventList )
    1dba:	01 15       	cp	r16, r1
    1dbc:	11 05       	cpc	r17, r1
    1dbe:	69 f0       	breq	.+26     	; 0x1dda <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1dc0:	60 91 ad 01 	lds	r22, 0x01AD	; 0x8001ad <pxCurrentCoRoutine>
    1dc4:	70 91 ae 01 	lds	r23, 0x01AE	; 0x8001ae <pxCurrentCoRoutine+0x1>
    1dc8:	64 5f       	subi	r22, 0xF4	; 244
    1dca:	7f 4f       	sbci	r23, 0xFF	; 255
    1dcc:	c8 01       	movw	r24, r16
	}
}
    1dce:	df 91       	pop	r29
    1dd0:	cf 91       	pop	r28
    1dd2:	1f 91       	pop	r17
    1dd4:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1dd6:	0c 94 e2 0d 	jmp	0x1bc4	; 0x1bc4 <vListInsert>
	}
}
    1dda:	df 91       	pop	r29
    1ddc:	cf 91       	pop	r28
    1dde:	1f 91       	pop	r17
    1de0:	0f 91       	pop	r16
    1de2:	08 95       	ret

00001de4 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1de4:	ff 92       	push	r15
    1de6:	0f 93       	push	r16
    1de8:	1f 93       	push	r17
    1dea:	cf 93       	push	r28
    1dec:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1dee:	99 e0       	ldi	r25, 0x09	; 9
    1df0:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1df2:	80 91 b6 01 	lds	r24, 0x01B6	; 0x8001b6 <xPendingReadyCoRoutineList>
    1df6:	88 23       	and	r24, r24
    1df8:	11 f1       	breq	.+68     	; 0x1e3e <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1dfa:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1dfc:	e0 91 bb 01 	lds	r30, 0x01BB	; 0x8001bb <xPendingReadyCoRoutineList+0x5>
    1e00:	f0 91 bc 01 	lds	r31, 0x01BC	; 0x8001bc <xPendingReadyCoRoutineList+0x6>
    1e04:	c6 81       	ldd	r28, Z+6	; 0x06
    1e06:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1e08:	ce 01       	movw	r24, r28
    1e0a:	0c 96       	adiw	r24, 0x0c	; 12
    1e0c:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1e10:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1e12:	8e 01       	movw	r16, r28
    1e14:	0e 5f       	subi	r16, 0xFE	; 254
    1e16:	1f 4f       	sbci	r17, 0xFF	; 255
    1e18:	c8 01       	movw	r24, r16
    1e1a:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1e1e:	8e 89       	ldd	r24, Y+22	; 0x16
    1e20:	90 91 b5 01 	lds	r25, 0x01B5	; 0x8001b5 <uxTopCoRoutineReadyPriority>
    1e24:	98 17       	cp	r25, r24
    1e26:	10 f4       	brcc	.+4      	; 0x1e2c <vCoRoutineSchedule+0x48>
    1e28:	80 93 b5 01 	sts	0x01B5, r24	; 0x8001b5 <uxTopCoRoutineReadyPriority>
    1e2c:	f8 9e       	mul	r15, r24
    1e2e:	c0 01       	movw	r24, r0
    1e30:	11 24       	eor	r1, r1
    1e32:	b8 01       	movw	r22, r16
    1e34:	8b 52       	subi	r24, 0x2B	; 43
    1e36:	9e 4f       	sbci	r25, 0xFE	; 254
    1e38:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>
    1e3c:	da cf       	rjmp	.-76     	; 0x1df2 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1e3e:	0e 94 82 03 	call	0x704	; 0x704 <xTaskGetTickCount>
    1e42:	20 91 b1 01 	lds	r18, 0x01B1	; 0x8001b1 <xLastTickCount>
    1e46:	30 91 b2 01 	lds	r19, 0x01B2	; 0x8001b2 <xLastTickCount+0x1>
    1e4a:	82 1b       	sub	r24, r18
    1e4c:	93 0b       	sbc	r25, r19
    1e4e:	90 93 b0 01 	sts	0x01B0, r25	; 0x8001b0 <xPassedTicks+0x1>
    1e52:	80 93 af 01 	sts	0x01AF, r24	; 0x8001af <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1e56:	89 e0       	ldi	r24, 0x09	; 9
    1e58:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1e5a:	20 91 af 01 	lds	r18, 0x01AF	; 0x8001af <xPassedTicks>
    1e5e:	30 91 b0 01 	lds	r19, 0x01B0	; 0x8001b0 <xPassedTicks+0x1>
    1e62:	80 91 b3 01 	lds	r24, 0x01B3	; 0x8001b3 <xCoRoutineTickCount>
    1e66:	90 91 b4 01 	lds	r25, 0x01B4	; 0x8001b4 <xCoRoutineTickCount+0x1>
    1e6a:	21 15       	cp	r18, r1
    1e6c:	31 05       	cpc	r19, r1
    1e6e:	09 f4       	brne	.+2      	; 0x1e72 <vCoRoutineSchedule+0x8e>
    1e70:	54 c0       	rjmp	.+168    	; 0x1f1a <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    1e72:	01 96       	adiw	r24, 0x01	; 1
    1e74:	90 93 b4 01 	sts	0x01B4, r25	; 0x8001b4 <xCoRoutineTickCount+0x1>
    1e78:	80 93 b3 01 	sts	0x01B3, r24	; 0x8001b3 <xCoRoutineTickCount>
		xPassedTicks--;
    1e7c:	21 50       	subi	r18, 0x01	; 1
    1e7e:	31 09       	sbc	r19, r1
    1e80:	30 93 b0 01 	sts	0x01B0, r19	; 0x8001b0 <xPassedTicks+0x1>
    1e84:	20 93 af 01 	sts	0x01AF, r18	; 0x8001af <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1e88:	89 2b       	or	r24, r25
    1e8a:	09 f0       	breq	.+2      	; 0x1e8e <vCoRoutineSchedule+0xaa>
    1e8c:	3e c0       	rjmp	.+124    	; 0x1f0a <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1e8e:	80 91 c1 01 	lds	r24, 0x01C1	; 0x8001c1 <pxDelayedCoRoutineList>
    1e92:	90 91 c2 01 	lds	r25, 0x01C2	; 0x8001c2 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1e96:	20 91 bf 01 	lds	r18, 0x01BF	; 0x8001bf <pxOverflowDelayedCoRoutineList>
    1e9a:	30 91 c0 01 	lds	r19, 0x01C0	; 0x8001c0 <pxOverflowDelayedCoRoutineList+0x1>
    1e9e:	30 93 c2 01 	sts	0x01C2, r19	; 0x8001c2 <pxDelayedCoRoutineList+0x1>
    1ea2:	20 93 c1 01 	sts	0x01C1, r18	; 0x8001c1 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    1ea6:	90 93 c0 01 	sts	0x01C0, r25	; 0x8001c0 <pxOverflowDelayedCoRoutineList+0x1>
    1eaa:	80 93 bf 01 	sts	0x01BF, r24	; 0x8001bf <pxOverflowDelayedCoRoutineList>
    1eae:	2d c0       	rjmp	.+90     	; 0x1f0a <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1eb0:	05 80       	ldd	r0, Z+5	; 0x05
    1eb2:	f6 81       	ldd	r31, Z+6	; 0x06
    1eb4:	e0 2d       	mov	r30, r0
    1eb6:	c6 81       	ldd	r28, Z+6	; 0x06
    1eb8:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1eba:	2a 81       	ldd	r18, Y+2	; 0x02
    1ebc:	3b 81       	ldd	r19, Y+3	; 0x03
    1ebe:	80 91 b3 01 	lds	r24, 0x01B3	; 0x8001b3 <xCoRoutineTickCount>
    1ec2:	90 91 b4 01 	lds	r25, 0x01B4	; 0x8001b4 <xCoRoutineTickCount+0x1>
    1ec6:	82 17       	cp	r24, r18
    1ec8:	93 07       	cpc	r25, r19
    1eca:	38 f2       	brcs	.-114    	; 0x1e5a <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1ecc:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1ece:	8e 01       	movw	r16, r28
    1ed0:	0e 5f       	subi	r16, 0xFE	; 254
    1ed2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ed4:	c8 01       	movw	r24, r16
    1ed6:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    1eda:	8c 89       	ldd	r24, Y+20	; 0x14
    1edc:	9d 89       	ldd	r25, Y+21	; 0x15
    1ede:	89 2b       	or	r24, r25
    1ee0:	21 f0       	breq	.+8      	; 0x1eea <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1ee2:	ce 01       	movw	r24, r28
    1ee4:	0c 96       	adiw	r24, 0x0c	; 12
    1ee6:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1eea:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1eec:	8e 89       	ldd	r24, Y+22	; 0x16
    1eee:	90 91 b5 01 	lds	r25, 0x01B5	; 0x8001b5 <uxTopCoRoutineReadyPriority>
    1ef2:	98 17       	cp	r25, r24
    1ef4:	10 f4       	brcc	.+4      	; 0x1efa <vCoRoutineSchedule+0x116>
    1ef6:	80 93 b5 01 	sts	0x01B5, r24	; 0x8001b5 <uxTopCoRoutineReadyPriority>
    1efa:	f8 9e       	mul	r15, r24
    1efc:	c0 01       	movw	r24, r0
    1efe:	11 24       	eor	r1, r1
    1f00:	b8 01       	movw	r22, r16
    1f02:	8b 52       	subi	r24, 0x2B	; 43
    1f04:	9e 4f       	sbci	r25, 0xFE	; 254
    1f06:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1f0a:	e0 91 c1 01 	lds	r30, 0x01C1	; 0x8001c1 <pxDelayedCoRoutineList>
    1f0e:	f0 91 c2 01 	lds	r31, 0x01C2	; 0x8001c2 <pxDelayedCoRoutineList+0x1>
    1f12:	80 81       	ld	r24, Z
    1f14:	81 11       	cpse	r24, r1
    1f16:	cc cf       	rjmp	.-104    	; 0x1eb0 <vCoRoutineSchedule+0xcc>
    1f18:	a0 cf       	rjmp	.-192    	; 0x1e5a <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    1f1a:	90 93 b2 01 	sts	0x01B2, r25	; 0x8001b2 <xLastTickCount+0x1>
    1f1e:	80 93 b1 01 	sts	0x01B1, r24	; 0x8001b1 <xLastTickCount>
    1f22:	80 91 b5 01 	lds	r24, 0x01B5	; 0x8001b5 <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1f26:	69 e0       	ldi	r22, 0x09	; 9
    1f28:	48 2f       	mov	r20, r24
    1f2a:	50 e0       	ldi	r21, 0x00	; 0
    1f2c:	64 9f       	mul	r22, r20
    1f2e:	90 01       	movw	r18, r0
    1f30:	65 9f       	mul	r22, r21
    1f32:	30 0d       	add	r19, r0
    1f34:	11 24       	eor	r1, r1
    1f36:	f9 01       	movw	r30, r18
    1f38:	eb 52       	subi	r30, 0x2B	; 43
    1f3a:	fe 4f       	sbci	r31, 0xFE	; 254
    1f3c:	90 81       	ld	r25, Z
    1f3e:	91 11       	cpse	r25, r1
    1f40:	0c c0       	rjmp	.+24     	; 0x1f5a <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1f42:	81 11       	cpse	r24, r1
    1f44:	08 c0       	rjmp	.+16     	; 0x1f56 <vCoRoutineSchedule+0x172>
    1f46:	10 92 b5 01 	sts	0x01B5, r1	; 0x8001b5 <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    1f4a:	df 91       	pop	r29
    1f4c:	cf 91       	pop	r28
    1f4e:	1f 91       	pop	r17
    1f50:	0f 91       	pop	r16
    1f52:	ff 90       	pop	r15
    1f54:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1f56:	81 50       	subi	r24, 0x01	; 1
    1f58:	e7 cf       	rjmp	.-50     	; 0x1f28 <vCoRoutineSchedule+0x144>
    1f5a:	80 93 b5 01 	sts	0x01B5, r24	; 0x8001b5 <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1f5e:	a1 81       	ldd	r26, Z+1	; 0x01
    1f60:	b2 81       	ldd	r27, Z+2	; 0x02
    1f62:	12 96       	adiw	r26, 0x02	; 2
    1f64:	0d 90       	ld	r0, X+
    1f66:	bc 91       	ld	r27, X
    1f68:	a0 2d       	mov	r26, r0
    1f6a:	b2 83       	std	Z+2, r27	; 0x02
    1f6c:	a1 83       	std	Z+1, r26	; 0x01
    1f6e:	28 52       	subi	r18, 0x28	; 40
    1f70:	3e 4f       	sbci	r19, 0xFE	; 254
    1f72:	a2 17       	cp	r26, r18
    1f74:	b3 07       	cpc	r27, r19
    1f76:	31 f4       	brne	.+12     	; 0x1f84 <vCoRoutineSchedule+0x1a0>
    1f78:	12 96       	adiw	r26, 0x02	; 2
    1f7a:	8d 91       	ld	r24, X+
    1f7c:	9c 91       	ld	r25, X
    1f7e:	13 97       	sbiw	r26, 0x03	; 3
    1f80:	92 83       	std	Z+2, r25	; 0x02
    1f82:	81 83       	std	Z+1, r24	; 0x01
    1f84:	89 e0       	ldi	r24, 0x09	; 9
    1f86:	84 9f       	mul	r24, r20
    1f88:	f0 01       	movw	r30, r0
    1f8a:	85 9f       	mul	r24, r21
    1f8c:	f0 0d       	add	r31, r0
    1f8e:	11 24       	eor	r1, r1
    1f90:	eb 52       	subi	r30, 0x2B	; 43
    1f92:	fe 4f       	sbci	r31, 0xFE	; 254
    1f94:	01 80       	ldd	r0, Z+1	; 0x01
    1f96:	f2 81       	ldd	r31, Z+2	; 0x02
    1f98:	e0 2d       	mov	r30, r0
    1f9a:	86 81       	ldd	r24, Z+6	; 0x06
    1f9c:	97 81       	ldd	r25, Z+7	; 0x07
    1f9e:	90 93 ae 01 	sts	0x01AE, r25	; 0x8001ae <pxCurrentCoRoutine+0x1>
    1fa2:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1fa6:	dc 01       	movw	r26, r24
    1fa8:	ed 91       	ld	r30, X+
    1faa:	fc 91       	ld	r31, X
    1fac:	11 97       	sbiw	r26, 0x01	; 1
    1fae:	57 96       	adiw	r26, 0x17	; 23
    1fb0:	6c 91       	ld	r22, X

	return;
}
    1fb2:	df 91       	pop	r29
    1fb4:	cf 91       	pop	r28
    1fb6:	1f 91       	pop	r17
    1fb8:	0f 91       	pop	r16
    1fba:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1fbc:	09 94       	ijmp

00001fbe <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    1fbe:	0f 93       	push	r16
    1fc0:	1f 93       	push	r17
    1fc2:	cf 93       	push	r28
    1fc4:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1fc6:	dc 01       	movw	r26, r24
    1fc8:	15 96       	adiw	r26, 0x05	; 5
    1fca:	ed 91       	ld	r30, X+
    1fcc:	fc 91       	ld	r31, X
    1fce:	16 97       	sbiw	r26, 0x06	; 6
    1fd0:	c6 81       	ldd	r28, Z+6	; 0x06
    1fd2:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1fd4:	8e 01       	movw	r16, r28
    1fd6:	04 5f       	subi	r16, 0xF4	; 244
    1fd8:	1f 4f       	sbci	r17, 0xFF	; 255
    1fda:	c8 01       	movw	r24, r16
    1fdc:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1fe0:	b8 01       	movw	r22, r16
    1fe2:	86 eb       	ldi	r24, 0xB6	; 182
    1fe4:	91 e0       	ldi	r25, 0x01	; 1
    1fe6:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1fea:	e0 91 ad 01 	lds	r30, 0x01AD	; 0x8001ad <pxCurrentCoRoutine>
    1fee:	f0 91 ae 01 	lds	r31, 0x01AE	; 0x8001ae <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1ff2:	81 e0       	ldi	r24, 0x01	; 1
    1ff4:	2e 89       	ldd	r18, Y+22	; 0x16
    1ff6:	96 89       	ldd	r25, Z+22	; 0x16
    1ff8:	29 17       	cp	r18, r25
    1ffa:	08 f4       	brcc	.+2      	; 0x1ffe <xCoRoutineRemoveFromEventList+0x40>
    1ffc:	80 e0       	ldi	r24, 0x00	; 0
}
    1ffe:	df 91       	pop	r29
    2000:	cf 91       	pop	r28
    2002:	1f 91       	pop	r17
    2004:	0f 91       	pop	r16
    2006:	08 95       	ret

00002008 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2008:	cf 93       	push	r28
    200a:	df 93       	push	r29
    200c:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    200e:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2012:	80 91 e7 01 	lds	r24, 0x01E7	; 0x8001e7 <pucAlignedHeap.2081>
    2016:	90 91 e8 01 	lds	r25, 0x01E8	; 0x8001e8 <pucAlignedHeap.2081+0x1>
    201a:	89 2b       	or	r24, r25
    201c:	31 f4       	brne	.+12     	; 0x202a <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    201e:	8c ee       	ldi	r24, 0xEC	; 236
    2020:	91 e0       	ldi	r25, 0x01	; 1
    2022:	90 93 e8 01 	sts	0x01E8, r25	; 0x8001e8 <pucAlignedHeap.2081+0x1>
    2026:	80 93 e7 01 	sts	0x01E7, r24	; 0x8001e7 <pucAlignedHeap.2081>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    202a:	20 91 e9 01 	lds	r18, 0x01E9	; 0x8001e9 <xNextFreeByte>
    202e:	30 91 ea 01 	lds	r19, 0x01EA	; 0x8001ea <xNextFreeByte+0x1>
    2032:	c9 01       	movw	r24, r18
    2034:	8c 0f       	add	r24, r28
    2036:	9d 1f       	adc	r25, r29
    2038:	8b 3d       	cpi	r24, 0xDB	; 219
    203a:	45 e0       	ldi	r20, 0x05	; 5
    203c:	94 07       	cpc	r25, r20
    203e:	70 f4       	brcc	.+28     	; 0x205c <pvPortMalloc+0x54>
    2040:	28 17       	cp	r18, r24
    2042:	39 07       	cpc	r19, r25
    2044:	58 f4       	brcc	.+22     	; 0x205c <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2046:	c0 91 e7 01 	lds	r28, 0x01E7	; 0x8001e7 <pucAlignedHeap.2081>
    204a:	d0 91 e8 01 	lds	r29, 0x01E8	; 0x8001e8 <pucAlignedHeap.2081+0x1>
    204e:	c2 0f       	add	r28, r18
    2050:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2052:	90 93 ea 01 	sts	0x01EA, r25	; 0x8001ea <xNextFreeByte+0x1>
    2056:	80 93 e9 01 	sts	0x01E9, r24	; 0x8001e9 <xNextFreeByte>
    205a:	02 c0       	rjmp	.+4      	; 0x2060 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    205c:	c0 e0       	ldi	r28, 0x00	; 0
    205e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2060:	0e 94 48 04 	call	0x890	; 0x890 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2064:	ce 01       	movw	r24, r28
    2066:	df 91       	pop	r29
    2068:	cf 91       	pop	r28
    206a:	08 95       	ret

0000206c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    206c:	08 95       	ret

0000206e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    206e:	10 92 ea 01 	sts	0x01EA, r1	; 0x8001ea <xNextFreeByte+0x1>
    2072:	10 92 e9 01 	sts	0x01E9, r1	; 0x8001e9 <xNextFreeByte>
    2076:	08 95       	ret

00002078 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2078:	20 91 e9 01 	lds	r18, 0x01E9	; 0x8001e9 <xNextFreeByte>
    207c:	30 91 ea 01 	lds	r19, 0x01EA	; 0x8001ea <xNextFreeByte+0x1>
}
    2080:	8b ed       	ldi	r24, 0xDB	; 219
    2082:	95 e0       	ldi	r25, 0x05	; 5
    2084:	82 1b       	sub	r24, r18
    2086:	93 0b       	sbc	r25, r19
    2088:	08 95       	ret

0000208a <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    208a:	31 e1       	ldi	r19, 0x11	; 17
    208c:	fc 01       	movw	r30, r24
    208e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2090:	31 97       	sbiw	r30, 0x01	; 1
    2092:	22 e2       	ldi	r18, 0x22	; 34
    2094:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2096:	31 97       	sbiw	r30, 0x01	; 1
    2098:	a3 e3       	ldi	r26, 0x33	; 51
    209a:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    209c:	31 97       	sbiw	r30, 0x01	; 1
    209e:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20a0:	31 97       	sbiw	r30, 0x01	; 1
    20a2:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    20a4:	31 97       	sbiw	r30, 0x01	; 1
    20a6:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    20a8:	31 97       	sbiw	r30, 0x01	; 1
    20aa:	60 e8       	ldi	r22, 0x80	; 128
    20ac:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    20ae:	31 97       	sbiw	r30, 0x01	; 1
    20b0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    20b2:	31 97       	sbiw	r30, 0x01	; 1
    20b4:	62 e0       	ldi	r22, 0x02	; 2
    20b6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    20b8:	31 97       	sbiw	r30, 0x01	; 1
    20ba:	63 e0       	ldi	r22, 0x03	; 3
    20bc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    20be:	31 97       	sbiw	r30, 0x01	; 1
    20c0:	64 e0       	ldi	r22, 0x04	; 4
    20c2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    20c4:	31 97       	sbiw	r30, 0x01	; 1
    20c6:	65 e0       	ldi	r22, 0x05	; 5
    20c8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    20ca:	31 97       	sbiw	r30, 0x01	; 1
    20cc:	66 e0       	ldi	r22, 0x06	; 6
    20ce:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    20d0:	31 97       	sbiw	r30, 0x01	; 1
    20d2:	67 e0       	ldi	r22, 0x07	; 7
    20d4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    20d6:	31 97       	sbiw	r30, 0x01	; 1
    20d8:	68 e0       	ldi	r22, 0x08	; 8
    20da:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    20dc:	31 97       	sbiw	r30, 0x01	; 1
    20de:	69 e0       	ldi	r22, 0x09	; 9
    20e0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    20e2:	31 97       	sbiw	r30, 0x01	; 1
    20e4:	60 e1       	ldi	r22, 0x10	; 16
    20e6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    20e8:	31 97       	sbiw	r30, 0x01	; 1
    20ea:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    20ec:	31 97       	sbiw	r30, 0x01	; 1
    20ee:	32 e1       	ldi	r19, 0x12	; 18
    20f0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    20f2:	31 97       	sbiw	r30, 0x01	; 1
    20f4:	33 e1       	ldi	r19, 0x13	; 19
    20f6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    20f8:	31 97       	sbiw	r30, 0x01	; 1
    20fa:	34 e1       	ldi	r19, 0x14	; 20
    20fc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    20fe:	31 97       	sbiw	r30, 0x01	; 1
    2100:	35 e1       	ldi	r19, 0x15	; 21
    2102:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2104:	31 97       	sbiw	r30, 0x01	; 1
    2106:	36 e1       	ldi	r19, 0x16	; 22
    2108:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    210a:	31 97       	sbiw	r30, 0x01	; 1
    210c:	37 e1       	ldi	r19, 0x17	; 23
    210e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2110:	31 97       	sbiw	r30, 0x01	; 1
    2112:	38 e1       	ldi	r19, 0x18	; 24
    2114:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2116:	31 97       	sbiw	r30, 0x01	; 1
    2118:	39 e1       	ldi	r19, 0x19	; 25
    211a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    211c:	31 97       	sbiw	r30, 0x01	; 1
    211e:	30 e2       	ldi	r19, 0x20	; 32
    2120:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2122:	31 97       	sbiw	r30, 0x01	; 1
    2124:	31 e2       	ldi	r19, 0x21	; 33
    2126:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2128:	31 97       	sbiw	r30, 0x01	; 1
    212a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    212c:	31 97       	sbiw	r30, 0x01	; 1
    212e:	23 e2       	ldi	r18, 0x23	; 35
    2130:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2132:	31 97       	sbiw	r30, 0x01	; 1
    2134:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2136:	31 97       	sbiw	r30, 0x01	; 1
    2138:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    213a:	31 97       	sbiw	r30, 0x01	; 1
    213c:	26 e2       	ldi	r18, 0x26	; 38
    213e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2140:	31 97       	sbiw	r30, 0x01	; 1
    2142:	27 e2       	ldi	r18, 0x27	; 39
    2144:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2146:	31 97       	sbiw	r30, 0x01	; 1
    2148:	28 e2       	ldi	r18, 0x28	; 40
    214a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    214c:	31 97       	sbiw	r30, 0x01	; 1
    214e:	29 e2       	ldi	r18, 0x29	; 41
    2150:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2152:	31 97       	sbiw	r30, 0x01	; 1
    2154:	20 e3       	ldi	r18, 0x30	; 48
    2156:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2158:	31 97       	sbiw	r30, 0x01	; 1
    215a:	21 e3       	ldi	r18, 0x31	; 49
    215c:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    215e:	86 97       	sbiw	r24, 0x26	; 38
    2160:	08 95       	ret

00002162 <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    2162:	89 ef       	ldi	r24, 0xF9	; 249
    2164:	90 e0       	ldi	r25, 0x00	; 0
    2166:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
    216a:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    216e:	e0 e8       	ldi	r30, 0x80	; 128
    2170:	f0 e0       	ldi	r31, 0x00	; 0
    2172:	80 81       	ld	r24, Z
    2174:	8c 7f       	andi	r24, 0xFC	; 252
    2176:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2178:	8b e0       	ldi	r24, 0x0B	; 11
    217a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    217e:	ef e6       	ldi	r30, 0x6F	; 111
    2180:	f0 e0       	ldi	r31, 0x00	; 0
    2182:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2184:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    2186:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2188:	a0 91 47 01 	lds	r26, 0x0147	; 0x800147 <pxCurrentTCB>
    218c:	b0 91 48 01 	lds	r27, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
    2190:	cd 91       	ld	r28, X+
    2192:	cd bf       	out	0x3d, r28	; 61
    2194:	dd 91       	ld	r29, X+
    2196:	de bf       	out	0x3e, r29	; 62
    2198:	ff 91       	pop	r31
    219a:	ef 91       	pop	r30
    219c:	df 91       	pop	r29
    219e:	cf 91       	pop	r28
    21a0:	bf 91       	pop	r27
    21a2:	af 91       	pop	r26
    21a4:	9f 91       	pop	r25
    21a6:	8f 91       	pop	r24
    21a8:	7f 91       	pop	r23
    21aa:	6f 91       	pop	r22
    21ac:	5f 91       	pop	r21
    21ae:	4f 91       	pop	r20
    21b0:	3f 91       	pop	r19
    21b2:	2f 91       	pop	r18
    21b4:	1f 91       	pop	r17
    21b6:	0f 91       	pop	r16
    21b8:	ff 90       	pop	r15
    21ba:	ef 90       	pop	r14
    21bc:	df 90       	pop	r13
    21be:	cf 90       	pop	r12
    21c0:	bf 90       	pop	r11
    21c2:	af 90       	pop	r10
    21c4:	9f 90       	pop	r9
    21c6:	8f 90       	pop	r8
    21c8:	7f 90       	pop	r7
    21ca:	6f 90       	pop	r6
    21cc:	5f 90       	pop	r5
    21ce:	4f 90       	pop	r4
    21d0:	3f 90       	pop	r3
    21d2:	2f 90       	pop	r2
    21d4:	1f 90       	pop	r1
    21d6:	0f 90       	pop	r0
    21d8:	0f be       	out	0x3f, r0	; 63
    21da:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    21dc:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    21de:	81 e0       	ldi	r24, 0x01	; 1
    21e0:	08 95       	ret

000021e2 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    21e2:	08 95       	ret

000021e4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    21e4:	0f 92       	push	r0
    21e6:	0f b6       	in	r0, 0x3f	; 63
    21e8:	f8 94       	cli
    21ea:	0f 92       	push	r0
    21ec:	1f 92       	push	r1
    21ee:	11 24       	eor	r1, r1
    21f0:	2f 92       	push	r2
    21f2:	3f 92       	push	r3
    21f4:	4f 92       	push	r4
    21f6:	5f 92       	push	r5
    21f8:	6f 92       	push	r6
    21fa:	7f 92       	push	r7
    21fc:	8f 92       	push	r8
    21fe:	9f 92       	push	r9
    2200:	af 92       	push	r10
    2202:	bf 92       	push	r11
    2204:	cf 92       	push	r12
    2206:	df 92       	push	r13
    2208:	ef 92       	push	r14
    220a:	ff 92       	push	r15
    220c:	0f 93       	push	r16
    220e:	1f 93       	push	r17
    2210:	2f 93       	push	r18
    2212:	3f 93       	push	r19
    2214:	4f 93       	push	r20
    2216:	5f 93       	push	r21
    2218:	6f 93       	push	r22
    221a:	7f 93       	push	r23
    221c:	8f 93       	push	r24
    221e:	9f 93       	push	r25
    2220:	af 93       	push	r26
    2222:	bf 93       	push	r27
    2224:	cf 93       	push	r28
    2226:	df 93       	push	r29
    2228:	ef 93       	push	r30
    222a:	ff 93       	push	r31
    222c:	a0 91 47 01 	lds	r26, 0x0147	; 0x800147 <pxCurrentTCB>
    2230:	b0 91 48 01 	lds	r27, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
    2234:	0d b6       	in	r0, 0x3d	; 61
    2236:	0d 92       	st	X+, r0
    2238:	0e b6       	in	r0, 0x3e	; 62
    223a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    223c:	0e 94 04 05 	call	0xa08	; 0xa08 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2240:	a0 91 47 01 	lds	r26, 0x0147	; 0x800147 <pxCurrentTCB>
    2244:	b0 91 48 01 	lds	r27, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
    2248:	cd 91       	ld	r28, X+
    224a:	cd bf       	out	0x3d, r28	; 61
    224c:	dd 91       	ld	r29, X+
    224e:	de bf       	out	0x3e, r29	; 62
    2250:	ff 91       	pop	r31
    2252:	ef 91       	pop	r30
    2254:	df 91       	pop	r29
    2256:	cf 91       	pop	r28
    2258:	bf 91       	pop	r27
    225a:	af 91       	pop	r26
    225c:	9f 91       	pop	r25
    225e:	8f 91       	pop	r24
    2260:	7f 91       	pop	r23
    2262:	6f 91       	pop	r22
    2264:	5f 91       	pop	r21
    2266:	4f 91       	pop	r20
    2268:	3f 91       	pop	r19
    226a:	2f 91       	pop	r18
    226c:	1f 91       	pop	r17
    226e:	0f 91       	pop	r16
    2270:	ff 90       	pop	r15
    2272:	ef 90       	pop	r14
    2274:	df 90       	pop	r13
    2276:	cf 90       	pop	r12
    2278:	bf 90       	pop	r11
    227a:	af 90       	pop	r10
    227c:	9f 90       	pop	r9
    227e:	8f 90       	pop	r8
    2280:	7f 90       	pop	r7
    2282:	6f 90       	pop	r6
    2284:	5f 90       	pop	r5
    2286:	4f 90       	pop	r4
    2288:	3f 90       	pop	r3
    228a:	2f 90       	pop	r2
    228c:	1f 90       	pop	r1
    228e:	0f 90       	pop	r0
    2290:	0f be       	out	0x3f, r0	; 63
    2292:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2294:	08 95       	ret

00002296 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2296:	0f 92       	push	r0
    2298:	0f b6       	in	r0, 0x3f	; 63
    229a:	f8 94       	cli
    229c:	0f 92       	push	r0
    229e:	1f 92       	push	r1
    22a0:	11 24       	eor	r1, r1
    22a2:	2f 92       	push	r2
    22a4:	3f 92       	push	r3
    22a6:	4f 92       	push	r4
    22a8:	5f 92       	push	r5
    22aa:	6f 92       	push	r6
    22ac:	7f 92       	push	r7
    22ae:	8f 92       	push	r8
    22b0:	9f 92       	push	r9
    22b2:	af 92       	push	r10
    22b4:	bf 92       	push	r11
    22b6:	cf 92       	push	r12
    22b8:	df 92       	push	r13
    22ba:	ef 92       	push	r14
    22bc:	ff 92       	push	r15
    22be:	0f 93       	push	r16
    22c0:	1f 93       	push	r17
    22c2:	2f 93       	push	r18
    22c4:	3f 93       	push	r19
    22c6:	4f 93       	push	r20
    22c8:	5f 93       	push	r21
    22ca:	6f 93       	push	r22
    22cc:	7f 93       	push	r23
    22ce:	8f 93       	push	r24
    22d0:	9f 93       	push	r25
    22d2:	af 93       	push	r26
    22d4:	bf 93       	push	r27
    22d6:	cf 93       	push	r28
    22d8:	df 93       	push	r29
    22da:	ef 93       	push	r30
    22dc:	ff 93       	push	r31
    22de:	a0 91 47 01 	lds	r26, 0x0147	; 0x800147 <pxCurrentTCB>
    22e2:	b0 91 48 01 	lds	r27, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
    22e6:	0d b6       	in	r0, 0x3d	; 61
    22e8:	0d 92       	st	X+, r0
    22ea:	0e b6       	in	r0, 0x3e	; 62
    22ec:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    22ee:	0e 94 9c 03 	call	0x738	; 0x738 <xTaskIncrementTick>
    22f2:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    22f4:	0e 94 04 05 	call	0xa08	; 0xa08 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    22f8:	a0 91 47 01 	lds	r26, 0x0147	; 0x800147 <pxCurrentTCB>
    22fc:	b0 91 48 01 	lds	r27, 0x0148	; 0x800148 <pxCurrentTCB+0x1>
    2300:	cd 91       	ld	r28, X+
    2302:	cd bf       	out	0x3d, r28	; 61
    2304:	dd 91       	ld	r29, X+
    2306:	de bf       	out	0x3e, r29	; 62
    2308:	ff 91       	pop	r31
    230a:	ef 91       	pop	r30
    230c:	df 91       	pop	r29
    230e:	cf 91       	pop	r28
    2310:	bf 91       	pop	r27
    2312:	af 91       	pop	r26
    2314:	9f 91       	pop	r25
    2316:	8f 91       	pop	r24
    2318:	7f 91       	pop	r23
    231a:	6f 91       	pop	r22
    231c:	5f 91       	pop	r21
    231e:	4f 91       	pop	r20
    2320:	3f 91       	pop	r19
    2322:	2f 91       	pop	r18
    2324:	1f 91       	pop	r17
    2326:	0f 91       	pop	r16
    2328:	ff 90       	pop	r15
    232a:	ef 90       	pop	r14
    232c:	df 90       	pop	r13
    232e:	cf 90       	pop	r12
    2330:	bf 90       	pop	r11
    2332:	af 90       	pop	r10
    2334:	9f 90       	pop	r9
    2336:	8f 90       	pop	r8
    2338:	7f 90       	pop	r7
    233a:	6f 90       	pop	r6
    233c:	5f 90       	pop	r5
    233e:	4f 90       	pop	r4
    2340:	3f 90       	pop	r3
    2342:	2f 90       	pop	r2
    2344:	1f 90       	pop	r1
    2346:	0f 90       	pop	r0
    2348:	0f be       	out	0x3f, r0	; 63
    234a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    234c:	08 95       	ret

0000234e <__vector_11>:
    234e:	0e 94 4b 11 	call	0x2296	; 0x2296 <vPortYieldFromTick>
    2352:	18 95       	reti

00002354 <main>:
 * \brief Main function.
 *
 * \return
 ******************************************************************************/
int main(void)
{
    2354:	ef 92       	push	r14
    2356:	ff 92       	push	r15
    2358:	0f 93       	push	r16
    235a:	cf 93       	push	r28
    235c:	df 93       	push	r29
    235e:	00 d0       	rcall	.+0      	; 0x2360 <main+0xc>
    2360:	00 d0       	rcall	.+0      	; 0x2362 <main+0xe>
    2362:	cd b7       	in	r28, 0x3d	; 61
    2364:	de b7       	in	r29, 0x3e	; 62
    // Create task.
    xTaskHandle blink_handle;
    xTaskHandle serial_handle;

    xTaskCreate
    2366:	ce 01       	movw	r24, r28
    2368:	03 96       	adiw	r24, 0x03	; 3
    236a:	7c 01       	movw	r14, r24
    236c:	02 e0       	ldi	r16, 0x02	; 2
    236e:	20 e0       	ldi	r18, 0x00	; 0
    2370:	30 e0       	ldi	r19, 0x00	; 0
    2372:	45 e5       	ldi	r20, 0x55	; 85
    2374:	50 e0       	ldi	r21, 0x00	; 0
    2376:	64 e1       	ldi	r22, 0x14	; 20
    2378:	71 e0       	ldi	r23, 0x01	; 1
    237a:	85 ea       	ldi	r24, 0xA5	; 165
    237c:	90 e0       	ldi	r25, 0x00	; 0
    237e:	0e 94 68 01 	call	0x2d0	; 0x2d0 <xTaskCreate>
         NULL,
         mainLED_counter_TASK_PRIORITY,
         &blink_handle
        );

    xTaskCreate
    2382:	ce 01       	movw	r24, r28
    2384:	01 96       	adiw	r24, 0x01	; 1
    2386:	7c 01       	movw	r14, r24
    2388:	01 e0       	ldi	r16, 0x01	; 1
    238a:	20 e0       	ldi	r18, 0x00	; 0
    238c:	30 e0       	ldi	r19, 0x00	; 0
    238e:	45 e5       	ldi	r20, 0x55	; 85
    2390:	50 e0       	ldi	r21, 0x00	; 0
    2392:	6a e1       	ldi	r22, 0x1A	; 26
    2394:	71 e0       	ldi	r23, 0x01	; 1
    2396:	83 e5       	ldi	r24, 0x53	; 83
    2398:	90 e0       	ldi	r25, 0x00	; 0
    239a:	0e 94 68 01 	call	0x2d0	; 0x2d0 <xTaskCreate>
         mainBUTTON_TASK_PRIORITY,
         &serial_handle
        );

    // Start scheduler.
    vTaskStartScheduler();
    239e:	0e 94 4d 03 	call	0x69a	; 0x69a <vTaskStartScheduler>

    return 0;
}
    23a2:	80 e0       	ldi	r24, 0x00	; 0
    23a4:	90 e0       	ldi	r25, 0x00	; 0
    23a6:	0f 90       	pop	r0
    23a8:	0f 90       	pop	r0
    23aa:	0f 90       	pop	r0
    23ac:	0f 90       	pop	r0
    23ae:	df 91       	pop	r29
    23b0:	cf 91       	pop	r28
    23b2:	0f 91       	pop	r16
    23b4:	ff 90       	pop	r15
    23b6:	ef 90       	pop	r14
    23b8:	08 95       	ret

000023ba <__udivmodqi4>:
    23ba:	99 1b       	sub	r25, r25
    23bc:	79 e0       	ldi	r23, 0x09	; 9
    23be:	04 c0       	rjmp	.+8      	; 0x23c8 <__udivmodqi4_ep>

000023c0 <__udivmodqi4_loop>:
    23c0:	99 1f       	adc	r25, r25
    23c2:	96 17       	cp	r25, r22
    23c4:	08 f0       	brcs	.+2      	; 0x23c8 <__udivmodqi4_ep>
    23c6:	96 1b       	sub	r25, r22

000023c8 <__udivmodqi4_ep>:
    23c8:	88 1f       	adc	r24, r24
    23ca:	7a 95       	dec	r23
    23cc:	c9 f7       	brne	.-14     	; 0x23c0 <__udivmodqi4_loop>
    23ce:	80 95       	com	r24
    23d0:	08 95       	ret

000023d2 <memcpy>:
    23d2:	fb 01       	movw	r30, r22
    23d4:	dc 01       	movw	r26, r24
    23d6:	02 c0       	rjmp	.+4      	; 0x23dc <memcpy+0xa>
    23d8:	01 90       	ld	r0, Z+
    23da:	0d 92       	st	X+, r0
    23dc:	41 50       	subi	r20, 0x01	; 1
    23de:	50 40       	sbci	r21, 0x00	; 0
    23e0:	d8 f7       	brcc	.-10     	; 0x23d8 <memcpy+0x6>
    23e2:	08 95       	ret

000023e4 <_exit>:
    23e4:	f8 94       	cli

000023e6 <__stop_program>:
    23e6:	ff cf       	rjmp	.-2      	; 0x23e6 <__stop_program>


freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000044  00800100  00002b9a  00002c2e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b9a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000068c  00800144  00800144  00002c72  2**0
                  ALLOC
  3 .stab         00007578  00000000  00000000  00002c74  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004498  00000000  00000000  0000a1ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000e684  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000e698  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000e6d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000eccc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000f26e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0000f288  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 40 12 	jmp	0x2480	; 0x2480 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 2f 01 	jmp	0x25e	; 0x25e <__vector_21>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ea e9       	ldi	r30, 0x9A	; 154
      7c:	fb e2       	ldi	r31, 0x2B	; 43
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a4 34       	cpi	r26, 0x44	; 68
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	a4 e4       	ldi	r26, 0x44	; 68
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a0 3d       	cpi	r26, 0xD0	; 208
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 43 12 	call	0x2486	; 0x2486 <main>
      9e:	0c 94 cb 15 	jmp	0x2b96	; 0x2b96 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <uart_transmit>:
#endif
  UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */
  UCSR0B = _BV(RXEN0) | _BV(TXEN0); /* Enable RX and TX */
}

int uart_transmit(char c, FILE *stream) {
      a6:	cf 93       	push	r28
      a8:	c8 2f       	mov	r28, r24
  while (!(UCSR0A & _BV(UDRE0))) taskYIELD();
      aa:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
      ae:	85 fd       	sbrc	r24, 5
      b0:	03 c0       	rjmp	.+6      	; 0xb8 <uart_transmit+0x12>
      b2:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
      b6:	f9 cf       	rjmp	.-14     	; 0xaa <uart_transmit+0x4>
  UDR0 = c;
      b8:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
  return 0;
}
      bc:	80 e0       	ldi	r24, 0x00	; 0
      be:	90 e0       	ldi	r25, 0x00	; 0
      c0:	cf 91       	pop	r28
      c2:	08 95       	ret

000000c4 <uart_receive>:

int uart_receive(FILE *stream) {
  while (!(UCSR0A & _BV(RXC0))) taskYIELD();
      c4:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
      c8:	87 fd       	sbrc	r24, 7
      ca:	03 c0       	rjmp	.+6      	; 0xd2 <uart_receive+0xe>
      cc:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
      d0:	f9 cf       	rjmp	.-14     	; 0xc4 <uart_receive>
  return UDR0;
      d2:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
}
      d6:	90 e0       	ldi	r25, 0x00	; 0
      d8:	08 95       	ret

000000da <readADC>:
}

ISR(ADC_vect) {xSemaphoreGive(semADCComplete);}

// __attribute((always_inline)) 
static inline uint16_t readADC(uint8_t mux){
      da:	cf 93       	push	r28
      dc:	df 93       	push	r29
      de:	c8 2f       	mov	r28, r24
    xSemaphoreTake(semADC,portMAX_DELAY);
      e0:	6f ef       	ldi	r22, 0xFF	; 255
      e2:	7f ef       	ldi	r23, 0xFF	; 255
      e4:	80 91 c4 07 	lds	r24, 0x07C4	; 0x8007c4 <semADC>
      e8:	90 91 c5 07 	lds	r25, 0x07C5	; 0x8007c5 <semADC+0x1>
      ec:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <xQueueSemaphoreTake>
    uint16_t adc_state;
    ADMUX &= 0xf0;
      f0:	ec e7       	ldi	r30, 0x7C	; 124
      f2:	f0 e0       	ldi	r31, 0x00	; 0
      f4:	80 81       	ld	r24, Z
      f6:	80 7f       	andi	r24, 0xF0	; 240
      f8:	80 83       	st	Z, r24
    ADMUX |= mux;
      fa:	80 81       	ld	r24, Z
      fc:	c8 2b       	or	r28, r24
      fe:	c0 83       	st	Z, r28
    ADCSRA |= _BV(ADSC);
     100:	ea e7       	ldi	r30, 0x7A	; 122
     102:	f0 e0       	ldi	r31, 0x00	; 0
     104:	80 81       	ld	r24, Z
     106:	80 64       	ori	r24, 0x40	; 64
     108:	80 83       	st	Z, r24
    // xSemaphoreTake(semADCComplete,portMAX_DELAY);
    adc_state = ADC;
     10a:	c0 91 78 00 	lds	r28, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7f8078>
     10e:	d0 91 79 00 	lds	r29, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7f8079>
    xSemaphoreGive(semADC);
     112:	20 e0       	ldi	r18, 0x00	; 0
     114:	40 e0       	ldi	r20, 0x00	; 0
     116:	50 e0       	ldi	r21, 0x00	; 0
     118:	60 e0       	ldi	r22, 0x00	; 0
     11a:	70 e0       	ldi	r23, 0x00	; 0
     11c:	80 91 c4 07 	lds	r24, 0x07C4	; 0x8007c4 <semADC>
     120:	90 91 c5 07 	lds	r25, 0x07C5	; 0x8007c5 <semADC+0x1>
     124:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <xQueueGenericSend>
    return adc_state;   
}
     128:	ce 01       	movw	r24, r28
     12a:	df 91       	pop	r29
     12c:	cf 91       	pop	r28
     12e:	08 95       	ret

00000130 <vADC_READ3>:
        vTaskDelay(400/portTICK_PERIOD_MS);
    }
}


static void vADC_READ3(void *pvParameters){
     130:	cf 93       	push	r28
     132:	df 93       	push	r29
     134:	cd b7       	in	r28, 0x3d	; 61
     136:	de b7       	in	r29, 0x3e	; 62
     138:	2a 97       	sbiw	r28, 0x0a	; 10
     13a:	0f b6       	in	r0, 0x3f	; 63
     13c:	f8 94       	cli
     13e:	de bf       	out	0x3e, r29	; 62
     140:	0f be       	out	0x3f, r0	; 63
     142:	cd bf       	out	0x3d, r28	; 61
     144:	d8 2e       	mov	r13, r24
    uint16_t adc;
    char buf[10];
    while(1){
        adc = readADC(input);
        // xSemaphoreTake(printSEM,portMAX_DELAY);
        itoa(adc,buf,10);
     146:	ce 01       	movw	r24, r28
     148:	01 96       	adiw	r24, 0x01	; 1
     14a:	7c 01       	movw	r14, r24
        printf("ADC3:\t%s\r\n",buf);
     14c:	0e e0       	ldi	r16, 0x0E	; 14
     14e:	11 e0       	ldi	r17, 0x01	; 1
static void vADC_READ3(void *pvParameters){
    uint8_t input = (uint8_t)pvParameters;
    uint16_t adc;
    char buf[10];
    while(1){
        adc = readADC(input);
     150:	8d 2d       	mov	r24, r13
     152:	0e 94 6d 00 	call	0xda	; 0xda <readADC>
        // xSemaphoreTake(printSEM,portMAX_DELAY);
        itoa(adc,buf,10);
     156:	4a e0       	ldi	r20, 0x0A	; 10
     158:	50 e0       	ldi	r21, 0x00	; 0
     15a:	b7 01       	movw	r22, r14
     15c:	0e 94 ad 12 	call	0x255a	; 0x255a <itoa>
        printf("ADC3:\t%s\r\n",buf);
     160:	ff 92       	push	r15
     162:	ef 92       	push	r14
     164:	1f 93       	push	r17
     166:	0f 93       	push	r16
     168:	0e 94 dd 12 	call	0x25ba	; 0x25ba <printf>
        fflush(stdout);
        // xSemaphoreGive(printSEM);
        vTaskDelay(2000/portTICK_PERIOD_MS);
     16c:	80 ed       	ldi	r24, 0xD0	; 208
     16e:	97 e0       	ldi	r25, 0x07	; 7
     170:	0e 94 88 05 	call	0xb10	; 0xb10 <vTaskDelay>
     174:	0f 90       	pop	r0
     176:	0f 90       	pop	r0
     178:	0f 90       	pop	r0
     17a:	0f 90       	pop	r0
     17c:	e9 cf       	rjmp	.-46     	; 0x150 <vADC_READ3+0x20>

0000017e <vADC_READ2>:
        vTaskDelay(500/portTICK_PERIOD_MS);
    }
}


static void vADC_READ2(void *pvParameters){
     17e:	cf 93       	push	r28
     180:	df 93       	push	r29
     182:	cd b7       	in	r28, 0x3d	; 61
     184:	de b7       	in	r29, 0x3e	; 62
     186:	2a 97       	sbiw	r28, 0x0a	; 10
     188:	0f b6       	in	r0, 0x3f	; 63
     18a:	f8 94       	cli
     18c:	de bf       	out	0x3e, r29	; 62
     18e:	0f be       	out	0x3f, r0	; 63
     190:	cd bf       	out	0x3d, r28	; 61
     192:	d8 2e       	mov	r13, r24
    uint16_t adc;
    char buf[10];
    while(1){
        adc = readADC(input);
        // xSemaphoreTake(printSEM,portMAX_DELAY);
        itoa(adc,buf,10);
     194:	ce 01       	movw	r24, r28
     196:	01 96       	adiw	r24, 0x01	; 1
     198:	7c 01       	movw	r14, r24
        printf("ADC2:\t%s\r\n",buf);
     19a:	09 e1       	ldi	r16, 0x19	; 25
     19c:	11 e0       	ldi	r17, 0x01	; 1
static void vADC_READ2(void *pvParameters){
    uint8_t input = (uint8_t)pvParameters;
    uint16_t adc;
    char buf[10];
    while(1){
        adc = readADC(input);
     19e:	8d 2d       	mov	r24, r13
     1a0:	0e 94 6d 00 	call	0xda	; 0xda <readADC>
        // xSemaphoreTake(printSEM,portMAX_DELAY);
        itoa(adc,buf,10);
     1a4:	4a e0       	ldi	r20, 0x0A	; 10
     1a6:	50 e0       	ldi	r21, 0x00	; 0
     1a8:	b7 01       	movw	r22, r14
     1aa:	0e 94 ad 12 	call	0x255a	; 0x255a <itoa>
        printf("ADC2:\t%s\r\n",buf);
     1ae:	ff 92       	push	r15
     1b0:	ef 92       	push	r14
     1b2:	1f 93       	push	r17
     1b4:	0f 93       	push	r16
     1b6:	0e 94 dd 12 	call	0x25ba	; 0x25ba <printf>
        fflush(stdout);
        // xSemaphoreGive(printSEM);
        vTaskDelay(400/portTICK_PERIOD_MS);
     1ba:	80 e9       	ldi	r24, 0x90	; 144
     1bc:	91 e0       	ldi	r25, 0x01	; 1
     1be:	0e 94 88 05 	call	0xb10	; 0xb10 <vTaskDelay>
     1c2:	0f 90       	pop	r0
     1c4:	0f 90       	pop	r0
     1c6:	0f 90       	pop	r0
     1c8:	0f 90       	pop	r0
     1ca:	e9 cf       	rjmp	.-46     	; 0x19e <vADC_READ2+0x20>

000001cc <vADC_READ1>:
    adc_state = ADC;
    xSemaphoreGive(semADC);
    return adc_state;   
}

static void vADC_READ1(void *pvParameters){
     1cc:	cf 93       	push	r28
     1ce:	df 93       	push	r29
     1d0:	cd b7       	in	r28, 0x3d	; 61
     1d2:	de b7       	in	r29, 0x3e	; 62
     1d4:	2a 97       	sbiw	r28, 0x0a	; 10
     1d6:	0f b6       	in	r0, 0x3f	; 63
     1d8:	f8 94       	cli
     1da:	de bf       	out	0x3e, r29	; 62
     1dc:	0f be       	out	0x3f, r0	; 63
     1de:	cd bf       	out	0x3d, r28	; 61
     1e0:	d8 2e       	mov	r13, r24
    uint16_t adc;
    char buf[10];
    while(1){
        adc = readADC(input);
        // xSemaphoreTake(printSEM,portMAX_DELAY);
        itoa(adc,buf,10);
     1e2:	ce 01       	movw	r24, r28
     1e4:	01 96       	adiw	r24, 0x01	; 1
     1e6:	7c 01       	movw	r14, r24
        printf("ADC1:\t%s\r\n",buf);
     1e8:	04 e2       	ldi	r16, 0x24	; 36
     1ea:	11 e0       	ldi	r17, 0x01	; 1
static void vADC_READ1(void *pvParameters){
    uint8_t input = (uint8_t)pvParameters;
    uint16_t adc;
    char buf[10];
    while(1){
        adc = readADC(input);
     1ec:	8d 2d       	mov	r24, r13
     1ee:	0e 94 6d 00 	call	0xda	; 0xda <readADC>
        // xSemaphoreTake(printSEM,portMAX_DELAY);
        itoa(adc,buf,10);
     1f2:	4a e0       	ldi	r20, 0x0A	; 10
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	b7 01       	movw	r22, r14
     1f8:	0e 94 ad 12 	call	0x255a	; 0x255a <itoa>
        printf("ADC1:\t%s\r\n",buf);
     1fc:	ff 92       	push	r15
     1fe:	ef 92       	push	r14
     200:	1f 93       	push	r17
     202:	0f 93       	push	r16
     204:	0e 94 dd 12 	call	0x25ba	; 0x25ba <printf>
        fflush(stdout);
        // xSemaphoreGive(printSEM);
        vTaskDelay(500/portTICK_PERIOD_MS);
     208:	84 ef       	ldi	r24, 0xF4	; 244
     20a:	91 e0       	ldi	r25, 0x01	; 1
     20c:	0e 94 88 05 	call	0xb10	; 0xb10 <vTaskDelay>
     210:	0f 90       	pop	r0
     212:	0f 90       	pop	r0
     214:	0f 90       	pop	r0
     216:	0f 90       	pop	r0
     218:	e9 cf       	rjmp	.-46     	; 0x1ec <vADC_READ1+0x20>

0000021a <uart_init>:
int uart_receive(FILE *stream);

FILE uart_file = FDEV_SETUP_STREAM(uart_transmit, uart_receive, _FDEV_SETUP_RW);

void uart_init() {
  UBRR0H = UBRRH_VALUE;
     21a:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
  UBRR0L = UBRRL_VALUE;
     21e:	87 e6       	ldi	r24, 0x67	; 103
     220:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
#if USE_2X
  UCSR0A |= _BV(U2X0);
#else
  UCSR0A &= ~(_BV(U2X0));
     224:	e0 ec       	ldi	r30, 0xC0	; 192
     226:	f0 e0       	ldi	r31, 0x00	; 0
     228:	80 81       	ld	r24, Z
     22a:	8d 7f       	andi	r24, 0xFD	; 253
     22c:	80 83       	st	Z, r24
#endif
  UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */
     22e:	86 e0       	ldi	r24, 0x06	; 6
     230:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
  UCSR0B = _BV(RXEN0) | _BV(TXEN0); /* Enable RX and TX */
     234:	88 e1       	ldi	r24, 0x18	; 24
     236:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     23a:	08 95       	ret

0000023c <adc_init>:
}

SemaphoreHandle_t semADC, semADCComplete, printSEM;

void adc_init(){
    ADMUX = _BV(REFS0); // referencja AVcc
     23c:	80 e4       	ldi	r24, 0x40	; 64
     23e:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7f807c>
    DIDR0 = _BV(ADC0D) | _BV(ADC1D) | _BV(ADC2D); // wyłącz wejście cyfrowe na ADC0, ADC1, ADC2
     242:	87 e0       	ldi	r24, 0x07	; 7
     244:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7f807e>
    ADCSRA = _BV(ADPS0) | _BV(ADPS1) | _BV(ADPS2); // preskaler 128
     248:	ea e7       	ldi	r30, 0x7A	; 122
     24a:	f0 e0       	ldi	r31, 0x00	; 0
     24c:	80 83       	st	Z, r24
    ADCSRA |= _BV(ADEN); // włącz ADC
     24e:	80 81       	ld	r24, Z
     250:	80 68       	ori	r24, 0x80	; 128
     252:	80 83       	st	Z, r24
    ADCSRA |= _BV(ADIE); // włącz interupty nad ADC
     254:	80 81       	ld	r24, Z
     256:	88 60       	ori	r24, 0x08	; 8
     258:	80 83       	st	Z, r24
     25a:	08 95       	ret

0000025c <vApplicationIdleHook>:
    vTaskStartScheduler();

    return 0;
}
void vApplicationIdleHook(void)
{
     25c:	08 95       	ret

0000025e <__vector_21>:

}

ISR(ADC_vect) {xSemaphoreGive(semADCComplete);}
     25e:	1f 92       	push	r1
     260:	0f 92       	push	r0
     262:	0f b6       	in	r0, 0x3f	; 63
     264:	0f 92       	push	r0
     266:	11 24       	eor	r1, r1
     268:	2f 93       	push	r18
     26a:	3f 93       	push	r19
     26c:	4f 93       	push	r20
     26e:	5f 93       	push	r21
     270:	6f 93       	push	r22
     272:	7f 93       	push	r23
     274:	8f 93       	push	r24
     276:	9f 93       	push	r25
     278:	af 93       	push	r26
     27a:	bf 93       	push	r27
     27c:	ef 93       	push	r30
     27e:	ff 93       	push	r31
     280:	20 e0       	ldi	r18, 0x00	; 0
     282:	40 e0       	ldi	r20, 0x00	; 0
     284:	50 e0       	ldi	r21, 0x00	; 0
     286:	60 e0       	ldi	r22, 0x00	; 0
     288:	70 e0       	ldi	r23, 0x00	; 0
     28a:	80 91 c6 07 	lds	r24, 0x07C6	; 0x8007c6 <semADCComplete>
     28e:	90 91 c7 07 	lds	r25, 0x07C7	; 0x8007c7 <semADCComplete+0x1>
     292:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <xQueueGenericSend>
     296:	ff 91       	pop	r31
     298:	ef 91       	pop	r30
     29a:	bf 91       	pop	r27
     29c:	af 91       	pop	r26
     29e:	9f 91       	pop	r25
     2a0:	8f 91       	pop	r24
     2a2:	7f 91       	pop	r23
     2a4:	6f 91       	pop	r22
     2a6:	5f 91       	pop	r21
     2a8:	4f 91       	pop	r20
     2aa:	3f 91       	pop	r19
     2ac:	2f 91       	pop	r18
     2ae:	0f 90       	pop	r0
     2b0:	0f be       	out	0x3f, r0	; 63
     2b2:	0f 90       	pop	r0
     2b4:	1f 90       	pop	r1
     2b6:	18 95       	reti

000002b8 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     2b8:	e0 91 72 01 	lds	r30, 0x0172	; 0x800172 <pxDelayedTaskList>
     2bc:	f0 91 73 01 	lds	r31, 0x0173	; 0x800173 <pxDelayedTaskList+0x1>
     2c0:	80 81       	ld	r24, Z
     2c2:	81 11       	cpse	r24, r1
     2c4:	03 c0       	rjmp	.+6      	; 0x2cc <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     2c6:	8f ef       	ldi	r24, 0xFF	; 255
     2c8:	9f ef       	ldi	r25, 0xFF	; 255
     2ca:	0c c0       	rjmp	.+24     	; 0x2e4 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     2cc:	e0 91 72 01 	lds	r30, 0x0172	; 0x800172 <pxDelayedTaskList>
     2d0:	f0 91 73 01 	lds	r31, 0x0173	; 0x800173 <pxDelayedTaskList+0x1>
     2d4:	05 80       	ldd	r0, Z+5	; 0x05
     2d6:	f6 81       	ldd	r31, Z+6	; 0x06
     2d8:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     2da:	06 80       	ldd	r0, Z+6	; 0x06
     2dc:	f7 81       	ldd	r31, Z+7	; 0x07
     2de:	e0 2d       	mov	r30, r0
     2e0:	82 81       	ldd	r24, Z+2	; 0x02
     2e2:	93 81       	ldd	r25, Z+3	; 0x03
     2e4:	90 93 4a 01 	sts	0x014A, r25	; 0x80014a <xNextTaskUnblockTime+0x1>
     2e8:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <xNextTaskUnblockTime>
     2ec:	08 95       	ret

000002ee <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     2ee:	ff 92       	push	r15
     2f0:	0f 93       	push	r16
     2f2:	1f 93       	push	r17
     2f4:	cf 93       	push	r28
     2f6:	df 93       	push	r29
     2f8:	ec 01       	movw	r28, r24
     2fa:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     2fc:	00 91 51 01 	lds	r16, 0x0151	; 0x800151 <xTickCount>
     300:	10 91 52 01 	lds	r17, 0x0152	; 0x800152 <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     304:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <__data_end>
     308:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <__data_end+0x1>
     30c:	02 96       	adiw	r24, 0x02	; 2
     30e:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     312:	cf 3f       	cpi	r28, 0xFF	; 255
     314:	8f ef       	ldi	r24, 0xFF	; 255
     316:	d8 07       	cpc	r29, r24
     318:	89 f4       	brne	.+34     	; 0x33c <prvAddCurrentTaskToDelayedList+0x4e>
     31a:	ff 20       	and	r15, r15
     31c:	79 f0       	breq	.+30     	; 0x33c <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     31e:	60 91 44 01 	lds	r22, 0x0144	; 0x800144 <__data_end>
     322:	70 91 45 01 	lds	r23, 0x0145	; 0x800145 <__data_end+0x1>
     326:	6e 5f       	subi	r22, 0xFE	; 254
     328:	7f 4f       	sbci	r23, 0xFF	; 255
     32a:	84 e5       	ldi	r24, 0x54	; 84
     32c:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     32e:	df 91       	pop	r29
     330:	cf 91       	pop	r28
     332:	1f 91       	pop	r17
     334:	0f 91       	pop	r16
     336:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     338:	0c 94 5a 0e 	jmp	0x1cb4	; 0x1cb4 <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     33c:	c0 0f       	add	r28, r16
     33e:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     340:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     344:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     348:	d3 83       	std	Z+3, r29	; 0x03
     34a:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     34c:	60 91 44 01 	lds	r22, 0x0144	; 0x800144 <__data_end>
     350:	70 91 45 01 	lds	r23, 0x0145	; 0x800145 <__data_end+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     354:	c0 17       	cp	r28, r16
     356:	d1 07       	cpc	r29, r17
     358:	68 f4       	brcc	.+26     	; 0x374 <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     35a:	80 91 70 01 	lds	r24, 0x0170	; 0x800170 <pxOverflowDelayedTaskList>
     35e:	90 91 71 01 	lds	r25, 0x0171	; 0x800171 <pxOverflowDelayedTaskList+0x1>
     362:	6e 5f       	subi	r22, 0xFE	; 254
     364:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     366:	df 91       	pop	r29
     368:	cf 91       	pop	r28
     36a:	1f 91       	pop	r17
     36c:	0f 91       	pop	r16
     36e:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     370:	0c 94 7b 0e 	jmp	0x1cf6	; 0x1cf6 <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     374:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <pxDelayedTaskList>
     378:	90 91 73 01 	lds	r25, 0x0173	; 0x800173 <pxDelayedTaskList+0x1>
     37c:	6e 5f       	subi	r22, 0xFE	; 254
     37e:	7f 4f       	sbci	r23, 0xFF	; 255
     380:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     384:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xNextTaskUnblockTime>
     388:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <xNextTaskUnblockTime+0x1>
     38c:	c8 17       	cp	r28, r24
     38e:	d9 07       	cpc	r29, r25
     390:	20 f4       	brcc	.+8      	; 0x39a <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     392:	d0 93 4a 01 	sts	0x014A, r29	; 0x80014a <xNextTaskUnblockTime+0x1>
     396:	c0 93 49 01 	sts	0x0149, r28	; 0x800149 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     39a:	df 91       	pop	r29
     39c:	cf 91       	pop	r28
     39e:	1f 91       	pop	r17
     3a0:	0f 91       	pop	r16
     3a2:	ff 90       	pop	r15
     3a4:	08 95       	ret

000003a6 <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     3a6:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <uxDeletedTasksWaitingCleanUp>
     3aa:	88 23       	and	r24, r24
     3ac:	09 f1       	breq	.+66     	; 0x3f0 <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     3ae:	0f b6       	in	r0, 0x3f	; 63
     3b0:	f8 94       	cli
     3b2:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     3b4:	e0 91 63 01 	lds	r30, 0x0163	; 0x800163 <xTasksWaitingTermination+0x5>
     3b8:	f0 91 64 01 	lds	r31, 0x0164	; 0x800164 <xTasksWaitingTermination+0x6>
     3bc:	c6 81       	ldd	r28, Z+6	; 0x06
     3be:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     3c0:	ce 01       	movw	r24, r28
     3c2:	02 96       	adiw	r24, 0x02	; 2
     3c4:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
				--uxCurrentNumberOfTasks;
     3c8:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <uxCurrentNumberOfTasks>
     3cc:	81 50       	subi	r24, 0x01	; 1
     3ce:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     3d2:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <uxDeletedTasksWaitingCleanUp>
     3d6:	81 50       	subi	r24, 0x01	; 1
     3d8:	80 93 5d 01 	sts	0x015D, r24	; 0x80015d <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     3dc:	0f 90       	pop	r0
     3de:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     3e0:	8f 89       	ldd	r24, Y+23	; 0x17
     3e2:	98 8d       	ldd	r25, Y+24	; 0x18
     3e4:	0e 94 cf 10 	call	0x219e	; 0x219e <vPortFree>
			vPortFree( pxTCB );
     3e8:	ce 01       	movw	r24, r28
     3ea:	0e 94 cf 10 	call	0x219e	; 0x219e <vPortFree>
     3ee:	db cf       	rjmp	.-74     	; 0x3a6 <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     3f0:	80 91 86 01 	lds	r24, 0x0186	; 0x800186 <pxReadyTasksLists>
     3f4:	82 30       	cpi	r24, 0x02	; 2
     3f6:	10 f0       	brcs	.+4      	; 0x3fc <prvIdleTask+0x56>
			{
				taskYIELD();
     3f8:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     3fc:	0e 94 2e 01 	call	0x25c	; 0x25c <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     400:	d2 cf       	rjmp	.-92     	; 0x3a6 <prvIdleTask>

00000402 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     402:	3f 92       	push	r3
     404:	4f 92       	push	r4
     406:	5f 92       	push	r5
     408:	6f 92       	push	r6
     40a:	7f 92       	push	r7
     40c:	8f 92       	push	r8
     40e:	9f 92       	push	r9
     410:	af 92       	push	r10
     412:	bf 92       	push	r11
     414:	cf 92       	push	r12
     416:	df 92       	push	r13
     418:	ef 92       	push	r14
     41a:	ff 92       	push	r15
     41c:	0f 93       	push	r16
     41e:	1f 93       	push	r17
     420:	cf 93       	push	r28
     422:	df 93       	push	r29
     424:	4c 01       	movw	r8, r24
     426:	16 2f       	mov	r17, r22
     428:	37 2e       	mov	r3, r23
     42a:	6a 01       	movw	r12, r20
     42c:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     42e:	ca 01       	movw	r24, r20
     430:	0e 94 9d 10 	call	0x213a	; 0x213a <pvPortMalloc>
     434:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     436:	89 2b       	or	r24, r25
     438:	09 f4       	brne	.+2      	; 0x43c <xTaskCreate+0x3a>
     43a:	d1 c0       	rjmp	.+418    	; 0x5de <xTaskCreate+0x1dc>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     43c:	86 e2       	ldi	r24, 0x26	; 38
     43e:	90 e0       	ldi	r25, 0x00	; 0
     440:	0e 94 9d 10 	call	0x213a	; 0x213a <pvPortMalloc>
     444:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     446:	89 2b       	or	r24, r25
     448:	79 f0       	breq	.+30     	; 0x468 <xTaskCreate+0x66>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     44a:	58 8e       	std	Y+24, r5	; 0x18
     44c:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     44e:	c6 01       	movw	r24, r12
     450:	01 97       	sbiw	r24, 0x01	; 1
     452:	32 01       	movw	r6, r4
     454:	68 0e       	add	r6, r24
     456:	79 1e       	adc	r7, r25
     458:	be 01       	movw	r22, r28
     45a:	67 5e       	subi	r22, 0xE7	; 231
     45c:	7f 4f       	sbci	r23, 0xFF	; 255
     45e:	e1 2f       	mov	r30, r17
     460:	f3 2d       	mov	r31, r3
     462:	cf 01       	movw	r24, r30
     464:	08 96       	adiw	r24, 0x08	; 8
     466:	07 c0       	rjmp	.+14     	; 0x476 <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     468:	c2 01       	movw	r24, r4
     46a:	0e 94 cf 10 	call	0x219e	; 0x219e <vPortFree>
     46e:	b7 c0       	rjmp	.+366    	; 0x5de <xTaskCreate+0x1dc>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     470:	e8 17       	cp	r30, r24
     472:	f9 07       	cpc	r31, r25
     474:	49 f0       	breq	.+18     	; 0x488 <xTaskCreate+0x86>
     476:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     478:	41 91       	ld	r20, Z+
     47a:	db 01       	movw	r26, r22
     47c:	4d 93       	st	X+, r20
     47e:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     480:	d9 01       	movw	r26, r18
     482:	2c 91       	ld	r18, X
     484:	21 11       	cpse	r18, r1
     486:	f4 cf       	rjmp	.-24     	; 0x470 <xTaskCreate+0x6e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     488:	18 a2       	std	Y+32, r1	; 0x20
     48a:	04 30       	cpi	r16, 0x04	; 4
     48c:	08 f0       	brcs	.+2      	; 0x490 <xTaskCreate+0x8e>
     48e:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     490:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     492:	6e 01       	movw	r12, r28
     494:	b2 e0       	ldi	r27, 0x02	; 2
     496:	cb 0e       	add	r12, r27
     498:	d1 1c       	adc	r13, r1
     49a:	c6 01       	movw	r24, r12
     49c:	0e 94 56 0e 	call	0x1cac	; 0x1cac <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     4a0:	ce 01       	movw	r24, r28
     4a2:	0c 96       	adiw	r24, 0x0c	; 12
     4a4:	0e 94 56 0e 	call	0x1cac	; 0x1cac <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     4a8:	d9 87       	std	Y+9, r29	; 0x09
     4aa:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     4ac:	84 e0       	ldi	r24, 0x04	; 4
     4ae:	90 e0       	ldi	r25, 0x00	; 0
     4b0:	80 1b       	sub	r24, r16
     4b2:	91 09       	sbc	r25, r1
     4b4:	9d 87       	std	Y+13, r25	; 0x0d
     4b6:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     4b8:	db 8b       	std	Y+19, r29	; 0x13
     4ba:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     4bc:	19 a2       	std	Y+33, r1	; 0x21
     4be:	1a a2       	std	Y+34, r1	; 0x22
     4c0:	1b a2       	std	Y+35, r1	; 0x23
     4c2:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     4c4:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     4c6:	a5 01       	movw	r20, r10
     4c8:	b4 01       	movw	r22, r8
     4ca:	c3 01       	movw	r24, r6
     4cc:	0e 94 de 10 	call	0x21bc	; 0x21bc <pxPortInitialiseStack>
     4d0:	99 83       	std	Y+1, r25	; 0x01
     4d2:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     4d4:	e1 14       	cp	r14, r1
     4d6:	f1 04       	cpc	r15, r1
     4d8:	19 f0       	breq	.+6      	; 0x4e0 <xTaskCreate+0xde>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     4da:	f7 01       	movw	r30, r14
     4dc:	d1 83       	std	Z+1, r29	; 0x01
     4de:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     4e0:	0f b6       	in	r0, 0x3f	; 63
     4e2:	f8 94       	cli
     4e4:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     4e6:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <uxCurrentNumberOfTasks>
     4ea:	8f 5f       	subi	r24, 0xFF	; 255
     4ec:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     4f0:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <__data_end>
     4f4:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <__data_end+0x1>
     4f8:	89 2b       	or	r24, r25
     4fa:	d1 f5       	brne	.+116    	; 0x570 <xTaskCreate+0x16e>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     4fc:	d0 93 45 01 	sts	0x0145, r29	; 0x800145 <__data_end+0x1>
     500:	c0 93 44 01 	sts	0x0144, r28	; 0x800144 <__data_end>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     504:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <uxCurrentNumberOfTasks>
     508:	81 30       	cpi	r24, 0x01	; 1
     50a:	09 f0       	breq	.+2      	; 0x50e <xTaskCreate+0x10c>
     50c:	41 c0       	rjmp	.+130    	; 0x590 <xTaskCreate+0x18e>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     50e:	86 e8       	ldi	r24, 0x86	; 134
     510:	91 e0       	ldi	r25, 0x01	; 1
     512:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
     516:	8f e8       	ldi	r24, 0x8F	; 143
     518:	91 e0       	ldi	r25, 0x01	; 1
     51a:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
     51e:	88 e9       	ldi	r24, 0x98	; 152
     520:	91 e0       	ldi	r25, 0x01	; 1
     522:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
     526:	81 ea       	ldi	r24, 0xA1	; 161
     528:	91 e0       	ldi	r25, 0x01	; 1
     52a:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     52e:	8d e7       	ldi	r24, 0x7D	; 125
     530:	91 e0       	ldi	r25, 0x01	; 1
     532:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     536:	84 e7       	ldi	r24, 0x74	; 116
     538:	91 e0       	ldi	r25, 0x01	; 1
     53a:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     53e:	87 e6       	ldi	r24, 0x67	; 103
     540:	91 e0       	ldi	r25, 0x01	; 1
     542:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     546:	8e e5       	ldi	r24, 0x5E	; 94
     548:	91 e0       	ldi	r25, 0x01	; 1
     54a:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     54e:	84 e5       	ldi	r24, 0x54	; 84
     550:	91 e0       	ldi	r25, 0x01	; 1
     552:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     556:	8d e7       	ldi	r24, 0x7D	; 125
     558:	91 e0       	ldi	r25, 0x01	; 1
     55a:	90 93 73 01 	sts	0x0173, r25	; 0x800173 <pxDelayedTaskList+0x1>
     55e:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     562:	84 e7       	ldi	r24, 0x74	; 116
     564:	91 e0       	ldi	r25, 0x01	; 1
     566:	90 93 71 01 	sts	0x0171, r25	; 0x800171 <pxOverflowDelayedTaskList+0x1>
     56a:	80 93 70 01 	sts	0x0170, r24	; 0x800170 <pxOverflowDelayedTaskList>
     56e:	10 c0       	rjmp	.+32     	; 0x590 <xTaskCreate+0x18e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     570:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <xSchedulerRunning>
     574:	81 11       	cpse	r24, r1
     576:	0c c0       	rjmp	.+24     	; 0x590 <xTaskCreate+0x18e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     578:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     57c:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     580:	96 89       	ldd	r25, Z+22	; 0x16
     582:	8e 89       	ldd	r24, Y+22	; 0x16
     584:	89 17       	cp	r24, r25
     586:	20 f0       	brcs	.+8      	; 0x590 <xTaskCreate+0x18e>
				{
					pxCurrentTCB = pxNewTCB;
     588:	d0 93 45 01 	sts	0x0145, r29	; 0x800145 <__data_end+0x1>
     58c:	c0 93 44 01 	sts	0x0144, r28	; 0x800144 <__data_end>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     590:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <uxTaskNumber>
     594:	8f 5f       	subi	r24, 0xFF	; 255
     596:	80 93 4b 01 	sts	0x014B, r24	; 0x80014b <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     59a:	8e 89       	ldd	r24, Y+22	; 0x16
     59c:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <uxTopReadyPriority>
     5a0:	98 17       	cp	r25, r24
     5a2:	10 f4       	brcc	.+4      	; 0x5a8 <xTaskCreate+0x1a6>
     5a4:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <uxTopReadyPriority>
     5a8:	f9 e0       	ldi	r31, 0x09	; 9
     5aa:	8f 9f       	mul	r24, r31
     5ac:	c0 01       	movw	r24, r0
     5ae:	11 24       	eor	r1, r1
     5b0:	b6 01       	movw	r22, r12
     5b2:	8a 57       	subi	r24, 0x7A	; 122
     5b4:	9e 4f       	sbci	r25, 0xFE	; 254
     5b6:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     5ba:	0f 90       	pop	r0
     5bc:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     5be:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <xSchedulerRunning>
     5c2:	88 23       	and	r24, r24
     5c4:	51 f0       	breq	.+20     	; 0x5da <xTaskCreate+0x1d8>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     5c6:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     5ca:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     5ce:	96 89       	ldd	r25, Z+22	; 0x16
     5d0:	8e 89       	ldd	r24, Y+22	; 0x16
     5d2:	98 17       	cp	r25, r24
     5d4:	10 f4       	brcc	.+4      	; 0x5da <xTaskCreate+0x1d8>
		{
			taskYIELD_IF_USING_PREEMPTION();
     5d6:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     5da:	81 e0       	ldi	r24, 0x01	; 1
     5dc:	01 c0       	rjmp	.+2      	; 0x5e0 <xTaskCreate+0x1de>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     5de:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     5e0:	df 91       	pop	r29
     5e2:	cf 91       	pop	r28
     5e4:	1f 91       	pop	r17
     5e6:	0f 91       	pop	r16
     5e8:	ff 90       	pop	r15
     5ea:	ef 90       	pop	r14
     5ec:	df 90       	pop	r13
     5ee:	cf 90       	pop	r12
     5f0:	bf 90       	pop	r11
     5f2:	af 90       	pop	r10
     5f4:	9f 90       	pop	r9
     5f6:	8f 90       	pop	r8
     5f8:	7f 90       	pop	r7
     5fa:	6f 90       	pop	r6
     5fc:	5f 90       	pop	r5
     5fe:	4f 90       	pop	r4
     600:	3f 90       	pop	r3
     602:	08 95       	ret

00000604 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     604:	0f 93       	push	r16
     606:	1f 93       	push	r17
     608:	cf 93       	push	r28
     60a:	df 93       	push	r29
     60c:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     60e:	0f b6       	in	r0, 0x3f	; 63
     610:	f8 94       	cli
     612:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     614:	89 2b       	or	r24, r25
     616:	21 f4       	brne	.+8      	; 0x620 <vTaskDelete+0x1c>
     618:	c0 91 44 01 	lds	r28, 0x0144	; 0x800144 <__data_end>
     61c:	d0 91 45 01 	lds	r29, 0x0145	; 0x800145 <__data_end+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     620:	8e 01       	movw	r16, r28
     622:	0e 5f       	subi	r16, 0xFE	; 254
     624:	1f 4f       	sbci	r17, 0xFF	; 255
     626:	c8 01       	movw	r24, r16
     628:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     62c:	8c 89       	ldd	r24, Y+20	; 0x14
     62e:	9d 89       	ldd	r25, Y+21	; 0x15
     630:	89 2b       	or	r24, r25
     632:	21 f0       	breq	.+8      	; 0x63c <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     634:	ce 01       	movw	r24, r28
     636:	0c 96       	adiw	r24, 0x0c	; 12
     638:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     63c:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <uxTaskNumber>
     640:	8f 5f       	subi	r24, 0xFF	; 255
     642:	80 93 4b 01 	sts	0x014B, r24	; 0x80014b <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     646:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <__data_end>
     64a:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <__data_end+0x1>
     64e:	c8 17       	cp	r28, r24
     650:	d9 07       	cpc	r29, r25
     652:	59 f4       	brne	.+22     	; 0x66a <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     654:	b8 01       	movw	r22, r16
     656:	8e e5       	ldi	r24, 0x5E	; 94
     658:	91 e0       	ldi	r25, 0x01	; 1
     65a:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     65e:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <uxDeletedTasksWaitingCleanUp>
     662:	8f 5f       	subi	r24, 0xFF	; 255
     664:	80 93 5d 01 	sts	0x015D, r24	; 0x80015d <uxDeletedTasksWaitingCleanUp>
     668:	0e c0       	rjmp	.+28     	; 0x686 <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     66a:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <uxCurrentNumberOfTasks>
     66e:	81 50       	subi	r24, 0x01	; 1
     670:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     674:	8f 89       	ldd	r24, Y+23	; 0x17
     676:	98 8d       	ldd	r25, Y+24	; 0x18
     678:	0e 94 cf 10 	call	0x219e	; 0x219e <vPortFree>
			vPortFree( pxTCB );
     67c:	ce 01       	movw	r24, r28
     67e:	0e 94 cf 10 	call	0x219e	; 0x219e <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     682:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     686:	0f 90       	pop	r0
     688:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     68a:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <xSchedulerRunning>
     68e:	88 23       	and	r24, r24
     690:	49 f0       	breq	.+18     	; 0x6a4 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     692:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <__data_end>
     696:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <__data_end+0x1>
     69a:	c8 17       	cp	r28, r24
     69c:	d9 07       	cpc	r29, r25
     69e:	11 f4       	brne	.+4      	; 0x6a4 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     6a0:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     6a4:	df 91       	pop	r29
     6a6:	cf 91       	pop	r28
     6a8:	1f 91       	pop	r17
     6aa:	0f 91       	pop	r16
     6ac:	08 95       	ret

000006ae <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     6ae:	0f 93       	push	r16
     6b0:	1f 93       	push	r17
     6b2:	cf 93       	push	r28
     6b4:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     6b6:	20 91 44 01 	lds	r18, 0x0144	; 0x800144 <__data_end>
     6ba:	30 91 45 01 	lds	r19, 0x0145	; 0x800145 <__data_end+0x1>
     6be:	82 17       	cp	r24, r18
     6c0:	93 07       	cpc	r25, r19
     6c2:	b9 f1       	breq	.+110    	; 0x732 <vTaskResume+0x84>
     6c4:	00 97       	sbiw	r24, 0x00	; 0
     6c6:	a9 f1       	breq	.+106    	; 0x732 <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     6c8:	0f b6       	in	r0, 0x3f	; 63
     6ca:	f8 94       	cli
     6cc:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     6ce:	fc 01       	movw	r30, r24
     6d0:	22 85       	ldd	r18, Z+10	; 0x0a
     6d2:	33 85       	ldd	r19, Z+11	; 0x0b
     6d4:	24 55       	subi	r18, 0x54	; 84
     6d6:	31 40       	sbci	r19, 0x01	; 1
     6d8:	51 f5       	brne	.+84     	; 0x72e <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     6da:	fc 01       	movw	r30, r24
     6dc:	24 89       	ldd	r18, Z+20	; 0x14
     6de:	35 89       	ldd	r19, Z+21	; 0x15
     6e0:	f1 e0       	ldi	r31, 0x01	; 1
     6e2:	27 36       	cpi	r18, 0x67	; 103
     6e4:	3f 07       	cpc	r19, r31
     6e6:	19 f1       	breq	.+70     	; 0x72e <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     6e8:	23 2b       	or	r18, r19
     6ea:	09 f5       	brne	.+66     	; 0x72e <vTaskResume+0x80>
     6ec:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     6ee:	8c 01       	movw	r16, r24
     6f0:	0e 5f       	subi	r16, 0xFE	; 254
     6f2:	1f 4f       	sbci	r17, 0xFF	; 255
     6f4:	c8 01       	movw	r24, r16
     6f6:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     6fa:	8e 89       	ldd	r24, Y+22	; 0x16
     6fc:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <uxTopReadyPriority>
     700:	98 17       	cp	r25, r24
     702:	10 f4       	brcc	.+4      	; 0x708 <vTaskResume+0x5a>
     704:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <uxTopReadyPriority>
     708:	29 e0       	ldi	r18, 0x09	; 9
     70a:	82 9f       	mul	r24, r18
     70c:	c0 01       	movw	r24, r0
     70e:	11 24       	eor	r1, r1
     710:	b8 01       	movw	r22, r16
     712:	8a 57       	subi	r24, 0x7A	; 122
     714:	9e 4f       	sbci	r25, 0xFE	; 254
     716:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     71a:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     71e:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     722:	9e 89       	ldd	r25, Y+22	; 0x16
     724:	86 89       	ldd	r24, Z+22	; 0x16
     726:	98 17       	cp	r25, r24
     728:	10 f0       	brcs	.+4      	; 0x72e <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     72a:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     72e:	0f 90       	pop	r0
     730:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     732:	df 91       	pop	r29
     734:	cf 91       	pop	r28
     736:	1f 91       	pop	r17
     738:	0f 91       	pop	r16
     73a:	08 95       	ret

0000073c <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     73c:	ef 92       	push	r14
     73e:	ff 92       	push	r15
     740:	1f 93       	push	r17
     742:	cf 93       	push	r28
     744:	df 93       	push	r29
     746:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     748:	8a 85       	ldd	r24, Y+10	; 0x0a
     74a:	9b 85       	ldd	r25, Y+11	; 0x0b
     74c:	84 55       	subi	r24, 0x54	; 84
     74e:	91 40       	sbci	r25, 0x01	; 1
     750:	99 f4       	brne	.+38     	; 0x778 <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     752:	8c 89       	ldd	r24, Y+20	; 0x14
     754:	9d 89       	ldd	r25, Y+21	; 0x15
     756:	21 e0       	ldi	r18, 0x01	; 1
     758:	87 36       	cpi	r24, 0x67	; 103
     75a:	92 07       	cpc	r25, r18
     75c:	69 f0       	breq	.+26     	; 0x778 <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     75e:	89 2b       	or	r24, r25
     760:	59 f4       	brne	.+22     	; 0x778 <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     762:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <uxSchedulerSuspended>
     766:	88 23       	and	r24, r24
     768:	49 f0       	breq	.+18     	; 0x77c <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     76a:	be 01       	movw	r22, r28
     76c:	64 5f       	subi	r22, 0xF4	; 244
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	87 e6       	ldi	r24, 0x67	; 103
     772:	91 e0       	ldi	r25, 0x01	; 1
     774:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     778:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     77a:	21 c0       	rjmp	.+66     	; 0x7be <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     77c:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     780:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     784:	11 e0       	ldi	r17, 0x01	; 1
     786:	9e 89       	ldd	r25, Y+22	; 0x16
     788:	86 89       	ldd	r24, Z+22	; 0x16
     78a:	98 17       	cp	r25, r24
     78c:	08 f4       	brcc	.+2      	; 0x790 <xTaskResumeFromISR+0x54>
     78e:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     790:	7e 01       	movw	r14, r28
     792:	82 e0       	ldi	r24, 0x02	; 2
     794:	e8 0e       	add	r14, r24
     796:	f1 1c       	adc	r15, r1
     798:	c7 01       	movw	r24, r14
     79a:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     79e:	8e 89       	ldd	r24, Y+22	; 0x16
     7a0:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <uxTopReadyPriority>
     7a4:	98 17       	cp	r25, r24
     7a6:	10 f4       	brcc	.+4      	; 0x7ac <xTaskResumeFromISR+0x70>
     7a8:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <uxTopReadyPriority>
     7ac:	29 e0       	ldi	r18, 0x09	; 9
     7ae:	82 9f       	mul	r24, r18
     7b0:	c0 01       	movw	r24, r0
     7b2:	11 24       	eor	r1, r1
     7b4:	b7 01       	movw	r22, r14
     7b6:	8a 57       	subi	r24, 0x7A	; 122
     7b8:	9e 4f       	sbci	r25, 0xFE	; 254
     7ba:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     7be:	81 2f       	mov	r24, r17
     7c0:	df 91       	pop	r29
     7c2:	cf 91       	pop	r28
     7c4:	1f 91       	pop	r17
     7c6:	ff 90       	pop	r15
     7c8:	ef 90       	pop	r14
     7ca:	08 95       	ret

000007cc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     7cc:	ef 92       	push	r14
     7ce:	ff 92       	push	r15
     7d0:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     7d2:	87 e4       	ldi	r24, 0x47	; 71
     7d4:	e8 2e       	mov	r14, r24
     7d6:	81 e0       	ldi	r24, 0x01	; 1
     7d8:	f8 2e       	mov	r15, r24
     7da:	00 e0       	ldi	r16, 0x00	; 0
     7dc:	20 e0       	ldi	r18, 0x00	; 0
     7de:	30 e0       	ldi	r19, 0x00	; 0
     7e0:	45 e5       	ldi	r20, 0x55	; 85
     7e2:	50 e0       	ldi	r21, 0x00	; 0
     7e4:	6e e3       	ldi	r22, 0x3E	; 62
     7e6:	71 e0       	ldi	r23, 0x01	; 1
     7e8:	83 ed       	ldi	r24, 0xD3	; 211
     7ea:	91 e0       	ldi	r25, 0x01	; 1
     7ec:	0e 94 01 02 	call	0x402	; 0x402 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     7f0:	81 30       	cpi	r24, 0x01	; 1
     7f2:	91 f4       	brne	.+36     	; 0x818 <__DATA_REGION_LENGTH__+0x18>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     7f4:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     7f6:	2f ef       	ldi	r18, 0xFF	; 255
     7f8:	3f ef       	ldi	r19, 0xFF	; 255
     7fa:	30 93 4a 01 	sts	0x014A, r19	; 0x80014a <xNextTaskUnblockTime+0x1>
     7fe:	20 93 49 01 	sts	0x0149, r18	; 0x800149 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     802:	80 93 4f 01 	sts	0x014F, r24	; 0x80014f <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     806:	10 92 52 01 	sts	0x0152, r1	; 0x800152 <xTickCount+0x1>
     80a:	10 92 51 01 	sts	0x0151, r1	; 0x800151 <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     80e:	0f 91       	pop	r16
     810:	ff 90       	pop	r15
     812:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     814:	0c 94 4a 11 	jmp	0x2294	; 0x2294 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     818:	0f 91       	pop	r16
     81a:	ff 90       	pop	r15
     81c:	ef 90       	pop	r14
     81e:	08 95       	ret

00000820 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     820:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     822:	10 92 4f 01 	sts	0x014F, r1	; 0x80014f <xSchedulerRunning>
	vPortEndScheduler();
     826:	0c 94 8a 11 	jmp	0x2314	; 0x2314 <vPortEndScheduler>

0000082a <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     82a:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <uxSchedulerSuspended>
     82e:	8f 5f       	subi	r24, 0xFF	; 255
     830:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <uxSchedulerSuspended>
     834:	08 95       	ret

00000836 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     836:	0f b6       	in	r0, 0x3f	; 63
     838:	f8 94       	cli
     83a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     83c:	80 91 51 01 	lds	r24, 0x0151	; 0x800151 <xTickCount>
     840:	90 91 52 01 	lds	r25, 0x0152	; 0x800152 <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     844:	0f 90       	pop	r0
     846:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     848:	08 95       	ret

0000084a <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     84a:	80 91 51 01 	lds	r24, 0x0151	; 0x800151 <xTickCount>
     84e:	90 91 52 01 	lds	r25, 0x0152	; 0x800152 <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     852:	08 95       	ret

00000854 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     854:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <uxCurrentNumberOfTasks>
}
     858:	08 95       	ret

0000085a <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     85a:	00 97       	sbiw	r24, 0x00	; 0
     85c:	21 f4       	brne	.+8      	; 0x866 <pcTaskGetName+0xc>
     85e:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <__data_end>
     862:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <__data_end+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     866:	49 96       	adiw	r24, 0x19	; 25
     868:	08 95       	ret

0000086a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     86a:	cf 92       	push	r12
     86c:	df 92       	push	r13
     86e:	ef 92       	push	r14
     870:	ff 92       	push	r15
     872:	0f 93       	push	r16
     874:	1f 93       	push	r17
     876:	cf 93       	push	r28
     878:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     87a:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <uxSchedulerSuspended>
     87e:	81 11       	cpse	r24, r1
     880:	8c c0       	rjmp	.+280    	; 0x99a <__stack+0x9b>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     882:	00 91 51 01 	lds	r16, 0x0151	; 0x800151 <xTickCount>
     886:	10 91 52 01 	lds	r17, 0x0152	; 0x800152 <xTickCount+0x1>
     88a:	0f 5f       	subi	r16, 0xFF	; 255
     88c:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     88e:	10 93 52 01 	sts	0x0152, r17	; 0x800152 <xTickCount+0x1>
     892:	00 93 51 01 	sts	0x0151, r16	; 0x800151 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     896:	01 15       	cp	r16, r1
     898:	11 05       	cpc	r17, r1
     89a:	b9 f4       	brne	.+46     	; 0x8ca <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     89c:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <pxDelayedTaskList>
     8a0:	90 91 73 01 	lds	r25, 0x0173	; 0x800173 <pxDelayedTaskList+0x1>
     8a4:	20 91 70 01 	lds	r18, 0x0170	; 0x800170 <pxOverflowDelayedTaskList>
     8a8:	30 91 71 01 	lds	r19, 0x0171	; 0x800171 <pxOverflowDelayedTaskList+0x1>
     8ac:	30 93 73 01 	sts	0x0173, r19	; 0x800173 <pxDelayedTaskList+0x1>
     8b0:	20 93 72 01 	sts	0x0172, r18	; 0x800172 <pxDelayedTaskList>
     8b4:	90 93 71 01 	sts	0x0171, r25	; 0x800171 <pxOverflowDelayedTaskList+0x1>
     8b8:	80 93 70 01 	sts	0x0170, r24	; 0x800170 <pxOverflowDelayedTaskList>
     8bc:	80 91 4c 01 	lds	r24, 0x014C	; 0x80014c <xNumOfOverflows>
     8c0:	8f 5f       	subi	r24, 0xFF	; 255
     8c2:	80 93 4c 01 	sts	0x014C, r24	; 0x80014c <xNumOfOverflows>
     8c6:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     8ca:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xNextTaskUnblockTime>
     8ce:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <xNextTaskUnblockTime+0x1>
     8d2:	c0 e0       	ldi	r28, 0x00	; 0
     8d4:	08 17       	cp	r16, r24
     8d6:	19 07       	cpc	r17, r25
     8d8:	08 f4       	brcc	.+2      	; 0x8dc <xTaskIncrementTick+0x72>
     8da:	4f c0       	rjmp	.+158    	; 0x97a <__stack+0x7b>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     8dc:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     8de:	e0 91 72 01 	lds	r30, 0x0172	; 0x800172 <pxDelayedTaskList>
     8e2:	f0 91 73 01 	lds	r31, 0x0173	; 0x800173 <pxDelayedTaskList+0x1>
     8e6:	80 81       	ld	r24, Z
     8e8:	81 11       	cpse	r24, r1
     8ea:	03 c0       	rjmp	.+6      	; 0x8f2 <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     8ec:	8f ef       	ldi	r24, 0xFF	; 255
     8ee:	9f ef       	ldi	r25, 0xFF	; 255
     8f0:	11 c0       	rjmp	.+34     	; 0x914 <__stack+0x15>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     8f2:	e0 91 72 01 	lds	r30, 0x0172	; 0x800172 <pxDelayedTaskList>
     8f6:	f0 91 73 01 	lds	r31, 0x0173	; 0x800173 <pxDelayedTaskList+0x1>
     8fa:	05 80       	ldd	r0, Z+5	; 0x05
     8fc:	f6 81       	ldd	r31, Z+6	; 0x06
     8fe:	e0 2d       	mov	r30, r0
     900:	e6 80       	ldd	r14, Z+6	; 0x06
     902:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     904:	d7 01       	movw	r26, r14
     906:	12 96       	adiw	r26, 0x02	; 2
     908:	8d 91       	ld	r24, X+
     90a:	9c 91       	ld	r25, X
     90c:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     90e:	08 17       	cp	r16, r24
     910:	19 07       	cpc	r17, r25
     912:	28 f4       	brcc	.+10     	; 0x91e <__stack+0x1f>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     914:	90 93 4a 01 	sts	0x014A, r25	; 0x80014a <xNextTaskUnblockTime+0x1>
     918:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     91c:	2e c0       	rjmp	.+92     	; 0x97a <__stack+0x7b>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     91e:	67 01       	movw	r12, r14
     920:	b2 e0       	ldi	r27, 0x02	; 2
     922:	cb 0e       	add	r12, r27
     924:	d1 1c       	adc	r13, r1
     926:	c6 01       	movw	r24, r12
     928:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     92c:	f7 01       	movw	r30, r14
     92e:	84 89       	ldd	r24, Z+20	; 0x14
     930:	95 89       	ldd	r25, Z+21	; 0x15
     932:	89 2b       	or	r24, r25
     934:	21 f0       	breq	.+8      	; 0x93e <__stack+0x3f>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     936:	c7 01       	movw	r24, r14
     938:	0c 96       	adiw	r24, 0x0c	; 12
     93a:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     93e:	d7 01       	movw	r26, r14
     940:	56 96       	adiw	r26, 0x16	; 22
     942:	8c 91       	ld	r24, X
     944:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <uxTopReadyPriority>
     948:	98 17       	cp	r25, r24
     94a:	10 f4       	brcc	.+4      	; 0x950 <__stack+0x51>
     94c:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <uxTopReadyPriority>
     950:	d8 9f       	mul	r29, r24
     952:	c0 01       	movw	r24, r0
     954:	11 24       	eor	r1, r1
     956:	b6 01       	movw	r22, r12
     958:	8a 57       	subi	r24, 0x7A	; 122
     95a:	9e 4f       	sbci	r25, 0xFE	; 254
     95c:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     960:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     964:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     968:	d7 01       	movw	r26, r14
     96a:	56 96       	adiw	r26, 0x16	; 22
     96c:	9c 91       	ld	r25, X
     96e:	86 89       	ldd	r24, Z+22	; 0x16
     970:	98 17       	cp	r25, r24
     972:	08 f4       	brcc	.+2      	; 0x976 <__stack+0x77>
     974:	b4 cf       	rjmp	.-152    	; 0x8de <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
     976:	c1 e0       	ldi	r28, 0x01	; 1
     978:	b2 cf       	rjmp	.-156    	; 0x8de <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     97a:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     97e:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     982:	e6 89       	ldd	r30, Z+22	; 0x16
     984:	b9 e0       	ldi	r27, 0x09	; 9
     986:	eb 9f       	mul	r30, r27
     988:	f0 01       	movw	r30, r0
     98a:	11 24       	eor	r1, r1
     98c:	ea 57       	subi	r30, 0x7A	; 122
     98e:	fe 4f       	sbci	r31, 0xFE	; 254
     990:	80 81       	ld	r24, Z
     992:	82 30       	cpi	r24, 0x02	; 2
     994:	40 f0       	brcs	.+16     	; 0x9a6 <__stack+0xa7>
			{
				xSwitchRequired = pdTRUE;
     996:	c1 e0       	ldi	r28, 0x01	; 1
     998:	06 c0       	rjmp	.+12     	; 0x9a6 <__stack+0xa7>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     99a:	80 91 4e 01 	lds	r24, 0x014E	; 0x80014e <uxPendedTicks>
     99e:	8f 5f       	subi	r24, 0xFF	; 255
     9a0:	80 93 4e 01 	sts	0x014E, r24	; 0x80014e <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     9a4:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     9a6:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <xYieldPending>
     9aa:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     9ac:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     9ae:	8c 2f       	mov	r24, r28
     9b0:	df 91       	pop	r29
     9b2:	cf 91       	pop	r28
     9b4:	1f 91       	pop	r17
     9b6:	0f 91       	pop	r16
     9b8:	ff 90       	pop	r15
     9ba:	ef 90       	pop	r14
     9bc:	df 90       	pop	r13
     9be:	cf 90       	pop	r12
     9c0:	08 95       	ret

000009c2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     9c2:	ef 92       	push	r14
     9c4:	ff 92       	push	r15
     9c6:	0f 93       	push	r16
     9c8:	1f 93       	push	r17
     9ca:	cf 93       	push	r28
     9cc:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     9ce:	0f b6       	in	r0, 0x3f	; 63
     9d0:	f8 94       	cli
     9d2:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     9d4:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <uxSchedulerSuspended>
     9d8:	81 50       	subi	r24, 0x01	; 1
     9da:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     9de:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <uxSchedulerSuspended>
     9e2:	88 23       	and	r24, r24
     9e4:	11 f0       	breq	.+4      	; 0x9ea <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     9e6:	80 e0       	ldi	r24, 0x00	; 0
     9e8:	52 c0       	rjmp	.+164    	; 0xa8e <xTaskResumeAll+0xcc>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     9ea:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <uxCurrentNumberOfTasks>
     9ee:	88 23       	and	r24, r24
     9f0:	d1 f3       	breq	.-12     	; 0x9e6 <xTaskResumeAll+0x24>
     9f2:	c0 e0       	ldi	r28, 0x00	; 0
     9f4:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     9f6:	89 e0       	ldi	r24, 0x09	; 9
     9f8:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     9fa:	ee 24       	eor	r14, r14
     9fc:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     9fe:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <xPendingReadyList>
     a02:	88 23       	and	r24, r24
     a04:	51 f1       	breq	.+84     	; 0xa5a <xTaskResumeAll+0x98>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     a06:	e0 91 6c 01 	lds	r30, 0x016C	; 0x80016c <xPendingReadyList+0x5>
     a0a:	f0 91 6d 01 	lds	r31, 0x016D	; 0x80016d <xPendingReadyList+0x6>
     a0e:	c6 81       	ldd	r28, Z+6	; 0x06
     a10:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     a12:	ce 01       	movw	r24, r28
     a14:	0c 96       	adiw	r24, 0x0c	; 12
     a16:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     a1a:	8e 01       	movw	r16, r28
     a1c:	0e 5f       	subi	r16, 0xFE	; 254
     a1e:	1f 4f       	sbci	r17, 0xFF	; 255
     a20:	c8 01       	movw	r24, r16
     a22:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     a26:	8e 89       	ldd	r24, Y+22	; 0x16
     a28:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <uxTopReadyPriority>
     a2c:	98 17       	cp	r25, r24
     a2e:	10 f4       	brcc	.+4      	; 0xa34 <xTaskResumeAll+0x72>
     a30:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <uxTopReadyPriority>
     a34:	f8 9e       	mul	r15, r24
     a36:	c0 01       	movw	r24, r0
     a38:	11 24       	eor	r1, r1
     a3a:	b8 01       	movw	r22, r16
     a3c:	8a 57       	subi	r24, 0x7A	; 122
     a3e:	9e 4f       	sbci	r25, 0xFE	; 254
     a40:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     a44:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     a48:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     a4c:	9e 89       	ldd	r25, Y+22	; 0x16
     a4e:	86 89       	ldd	r24, Z+22	; 0x16
     a50:	98 17       	cp	r25, r24
     a52:	a8 f2       	brcs	.-86     	; 0x9fe <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     a54:	e0 92 4d 01 	sts	0x014D, r14	; 0x80014d <xYieldPending>
     a58:	d2 cf       	rjmp	.-92     	; 0x9fe <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     a5a:	cd 2b       	or	r28, r29
     a5c:	11 f0       	breq	.+4      	; 0xa62 <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     a5e:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     a62:	c0 91 4e 01 	lds	r28, 0x014E	; 0x80014e <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     a66:	cc 23       	and	r28, r28
     a68:	51 f0       	breq	.+20     	; 0xa7e <xTaskResumeAll+0xbc>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     a6a:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     a6c:	0e 94 35 04 	call	0x86a	; 0x86a <xTaskIncrementTick>
     a70:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     a72:	d0 93 4d 01 	sts	0x014D, r29	; 0x80014d <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     a76:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     a78:	c9 f7       	brne	.-14     	; 0xa6c <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     a7a:	10 92 4e 01 	sts	0x014E, r1	; 0x80014e <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     a7e:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <xYieldPending>
     a82:	88 23       	and	r24, r24
     a84:	09 f4       	brne	.+2      	; 0xa88 <xTaskResumeAll+0xc6>
     a86:	af cf       	rjmp	.-162    	; 0x9e6 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     a88:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     a8c:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     a8e:	0f 90       	pop	r0
     a90:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     a92:	df 91       	pop	r29
     a94:	cf 91       	pop	r28
     a96:	1f 91       	pop	r17
     a98:	0f 91       	pop	r16
     a9a:	ff 90       	pop	r15
     a9c:	ef 90       	pop	r14
     a9e:	08 95       	ret

00000aa0 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     aa0:	0f 93       	push	r16
     aa2:	1f 93       	push	r17
     aa4:	cf 93       	push	r28
     aa6:	df 93       	push	r29
     aa8:	8c 01       	movw	r16, r24
     aaa:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     aac:	0e 94 15 04 	call	0x82a	; 0x82a <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     ab0:	40 91 51 01 	lds	r20, 0x0151	; 0x800151 <xTickCount>
     ab4:	50 91 52 01 	lds	r21, 0x0152	; 0x800152 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     ab8:	f8 01       	movw	r30, r16
     aba:	20 81       	ld	r18, Z
     abc:	31 81       	ldd	r19, Z+1	; 0x01
     abe:	c9 01       	movw	r24, r18
     ac0:	8c 0f       	add	r24, r28
     ac2:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     ac4:	42 17       	cp	r20, r18
     ac6:	53 07       	cpc	r21, r19
     ac8:	20 f4       	brcc	.+8      	; 0xad2 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     aca:	82 17       	cp	r24, r18
     acc:	93 07       	cpc	r25, r19
     ace:	40 f4       	brcc	.+16     	; 0xae0 <vTaskDelayUntil+0x40>
     ad0:	03 c0       	rjmp	.+6      	; 0xad8 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     ad2:	82 17       	cp	r24, r18
     ad4:	93 07       	cpc	r25, r19
     ad6:	30 f0       	brcs	.+12     	; 0xae4 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     ad8:	21 e0       	ldi	r18, 0x01	; 1
     ada:	48 17       	cp	r20, r24
     adc:	59 07       	cpc	r21, r25
     ade:	18 f0       	brcs	.+6      	; 0xae6 <vTaskDelayUntil+0x46>
     ae0:	20 e0       	ldi	r18, 0x00	; 0
     ae2:	01 c0       	rjmp	.+2      	; 0xae6 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     ae4:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     ae6:	f8 01       	movw	r30, r16
     ae8:	91 83       	std	Z+1, r25	; 0x01
     aea:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     aec:	22 23       	and	r18, r18
     aee:	29 f0       	breq	.+10     	; 0xafa <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     af0:	60 e0       	ldi	r22, 0x00	; 0
     af2:	84 1b       	sub	r24, r20
     af4:	95 0b       	sbc	r25, r21
     af6:	0e 94 77 01 	call	0x2ee	; 0x2ee <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     afa:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     afe:	81 11       	cpse	r24, r1
     b00:	02 c0       	rjmp	.+4      	; 0xb06 <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     b02:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b06:	df 91       	pop	r29
     b08:	cf 91       	pop	r28
     b0a:	1f 91       	pop	r17
     b0c:	0f 91       	pop	r16
     b0e:	08 95       	ret

00000b10 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     b10:	cf 93       	push	r28
     b12:	df 93       	push	r29
     b14:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     b16:	89 2b       	or	r24, r25
     b18:	19 f4       	brne	.+6      	; 0xb20 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     b1a:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
     b1e:	0a c0       	rjmp	.+20     	; 0xb34 <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     b20:	0e 94 15 04 	call	0x82a	; 0x82a <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     b24:	60 e0       	ldi	r22, 0x00	; 0
     b26:	ce 01       	movw	r24, r28
     b28:	0e 94 77 01 	call	0x2ee	; 0x2ee <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     b2c:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     b30:	88 23       	and	r24, r24
     b32:	99 f3       	breq	.-26     	; 0xb1a <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b34:	df 91       	pop	r29
     b36:	cf 91       	pop	r28
     b38:	08 95       	ret

00000b3a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     b3a:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <uxSchedulerSuspended>
     b3e:	88 23       	and	r24, r24
     b40:	21 f0       	breq	.+8      	; 0xb4a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     b42:	81 e0       	ldi	r24, 0x01	; 1
     b44:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <xYieldPending>
     b48:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     b4a:	10 92 4d 01 	sts	0x014D, r1	; 0x80014d <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     b4e:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <uxTopReadyPriority>
     b52:	69 e0       	ldi	r22, 0x09	; 9
     b54:	48 2f       	mov	r20, r24
     b56:	50 e0       	ldi	r21, 0x00	; 0
     b58:	64 9f       	mul	r22, r20
     b5a:	90 01       	movw	r18, r0
     b5c:	65 9f       	mul	r22, r21
     b5e:	30 0d       	add	r19, r0
     b60:	11 24       	eor	r1, r1
     b62:	f9 01       	movw	r30, r18
     b64:	ea 57       	subi	r30, 0x7A	; 122
     b66:	fe 4f       	sbci	r31, 0xFE	; 254
     b68:	90 81       	ld	r25, Z
     b6a:	91 11       	cpse	r25, r1
     b6c:	02 c0       	rjmp	.+4      	; 0xb72 <vTaskSwitchContext+0x38>
     b6e:	81 50       	subi	r24, 0x01	; 1
     b70:	f1 cf       	rjmp	.-30     	; 0xb54 <vTaskSwitchContext+0x1a>
     b72:	a1 81       	ldd	r26, Z+1	; 0x01
     b74:	b2 81       	ldd	r27, Z+2	; 0x02
     b76:	12 96       	adiw	r26, 0x02	; 2
     b78:	0d 90       	ld	r0, X+
     b7a:	bc 91       	ld	r27, X
     b7c:	a0 2d       	mov	r26, r0
     b7e:	b2 83       	std	Z+2, r27	; 0x02
     b80:	a1 83       	std	Z+1, r26	; 0x01
     b82:	27 57       	subi	r18, 0x77	; 119
     b84:	3e 4f       	sbci	r19, 0xFE	; 254
     b86:	a2 17       	cp	r26, r18
     b88:	b3 07       	cpc	r27, r19
     b8a:	31 f4       	brne	.+12     	; 0xb98 <vTaskSwitchContext+0x5e>
     b8c:	12 96       	adiw	r26, 0x02	; 2
     b8e:	2d 91       	ld	r18, X+
     b90:	3c 91       	ld	r19, X
     b92:	13 97       	sbiw	r26, 0x03	; 3
     b94:	32 83       	std	Z+2, r19	; 0x02
     b96:	21 83       	std	Z+1, r18	; 0x01
     b98:	99 e0       	ldi	r25, 0x09	; 9
     b9a:	94 9f       	mul	r25, r20
     b9c:	f0 01       	movw	r30, r0
     b9e:	95 9f       	mul	r25, r21
     ba0:	f0 0d       	add	r31, r0
     ba2:	11 24       	eor	r1, r1
     ba4:	ea 57       	subi	r30, 0x7A	; 122
     ba6:	fe 4f       	sbci	r31, 0xFE	; 254
     ba8:	01 80       	ldd	r0, Z+1	; 0x01
     baa:	f2 81       	ldd	r31, Z+2	; 0x02
     bac:	e0 2d       	mov	r30, r0
     bae:	26 81       	ldd	r18, Z+6	; 0x06
     bb0:	37 81       	ldd	r19, Z+7	; 0x07
     bb2:	30 93 45 01 	sts	0x0145, r19	; 0x800145 <__data_end+0x1>
     bb6:	20 93 44 01 	sts	0x0144, r18	; 0x800144 <__data_end>
     bba:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <uxTopReadyPriority>
     bbe:	08 95       	ret

00000bc0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     bc0:	0f 93       	push	r16
     bc2:	1f 93       	push	r17
     bc4:	cf 93       	push	r28
     bc6:	df 93       	push	r29
     bc8:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     bca:	0f b6       	in	r0, 0x3f	; 63
     bcc:	f8 94       	cli
     bce:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     bd0:	89 2b       	or	r24, r25
     bd2:	21 f4       	brne	.+8      	; 0xbdc <vTaskSuspend+0x1c>
     bd4:	c0 91 44 01 	lds	r28, 0x0144	; 0x800144 <__data_end>
     bd8:	d0 91 45 01 	lds	r29, 0x0145	; 0x800145 <__data_end+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     bdc:	8e 01       	movw	r16, r28
     bde:	0e 5f       	subi	r16, 0xFE	; 254
     be0:	1f 4f       	sbci	r17, 0xFF	; 255
     be2:	c8 01       	movw	r24, r16
     be4:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     be8:	8c 89       	ldd	r24, Y+20	; 0x14
     bea:	9d 89       	ldd	r25, Y+21	; 0x15
     bec:	89 2b       	or	r24, r25
     bee:	21 f0       	breq	.+8      	; 0xbf8 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     bf0:	ce 01       	movw	r24, r28
     bf2:	0c 96       	adiw	r24, 0x0c	; 12
     bf4:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     bf8:	b8 01       	movw	r22, r16
     bfa:	84 e5       	ldi	r24, 0x54	; 84
     bfc:	91 e0       	ldi	r25, 0x01	; 1
     bfe:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     c02:	8d a1       	ldd	r24, Y+37	; 0x25
     c04:	81 30       	cpi	r24, 0x01	; 1
     c06:	09 f4       	brne	.+2      	; 0xc0a <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     c08:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     c0a:	0f 90       	pop	r0
     c0c:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     c0e:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <xSchedulerRunning>
     c12:	88 23       	and	r24, r24
     c14:	39 f0       	breq	.+14     	; 0xc24 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     c16:	0f b6       	in	r0, 0x3f	; 63
     c18:	f8 94       	cli
     c1a:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     c1c:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     c20:	0f 90       	pop	r0
     c22:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     c24:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <__data_end>
     c28:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <__data_end+0x1>
     c2c:	c8 17       	cp	r28, r24
     c2e:	d9 07       	cpc	r29, r25
     c30:	c1 f4       	brne	.+48     	; 0xc62 <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     c32:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <xSchedulerRunning>
     c36:	88 23       	and	r24, r24
     c38:	19 f0       	breq	.+6      	; 0xc40 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     c3a:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
     c3e:	11 c0       	rjmp	.+34     	; 0xc62 <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     c40:	90 91 54 01 	lds	r25, 0x0154	; 0x800154 <xSuspendedTaskList>
     c44:	80 91 53 01 	lds	r24, 0x0153	; 0x800153 <uxCurrentNumberOfTasks>
     c48:	98 13       	cpse	r25, r24
     c4a:	05 c0       	rjmp	.+10     	; 0xc56 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     c4c:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <__data_end+0x1>
     c50:	10 92 44 01 	sts	0x0144, r1	; 0x800144 <__data_end>
     c54:	06 c0       	rjmp	.+12     	; 0xc62 <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     c56:	df 91       	pop	r29
     c58:	cf 91       	pop	r28
     c5a:	1f 91       	pop	r17
     c5c:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     c5e:	0c 94 9d 05 	jmp	0xb3a	; 0xb3a <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     c62:	df 91       	pop	r29
     c64:	cf 91       	pop	r28
     c66:	1f 91       	pop	r17
     c68:	0f 91       	pop	r16
     c6a:	08 95       	ret

00000c6c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     c6c:	cf 93       	push	r28
     c6e:	df 93       	push	r29
     c70:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     c72:	60 91 44 01 	lds	r22, 0x0144	; 0x800144 <__data_end>
     c76:	70 91 45 01 	lds	r23, 0x0145	; 0x800145 <__data_end+0x1>
     c7a:	64 5f       	subi	r22, 0xF4	; 244
     c7c:	7f 4f       	sbci	r23, 0xFF	; 255
     c7e:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c82:	61 e0       	ldi	r22, 0x01	; 1
     c84:	ce 01       	movw	r24, r28
}
     c86:	df 91       	pop	r29
     c88:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     c8a:	0c 94 77 01 	jmp	0x2ee	; 0x2ee <prvAddCurrentTaskToDelayedList>

00000c8e <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     c8e:	cf 93       	push	r28
     c90:	df 93       	push	r29
     c92:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c94:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     c98:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     c9c:	70 68       	ori	r23, 0x80	; 128
     c9e:	75 87       	std	Z+13, r23	; 0x0d
     ca0:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     ca2:	60 91 44 01 	lds	r22, 0x0144	; 0x800144 <__data_end>
     ca6:	70 91 45 01 	lds	r23, 0x0145	; 0x800145 <__data_end+0x1>
     caa:	64 5f       	subi	r22, 0xF4	; 244
     cac:	7f 4f       	sbci	r23, 0xFF	; 255
     cae:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     cb2:	61 e0       	ldi	r22, 0x01	; 1
     cb4:	ce 01       	movw	r24, r28
}
     cb6:	df 91       	pop	r29
     cb8:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     cba:	0c 94 77 01 	jmp	0x2ee	; 0x2ee <prvAddCurrentTaskToDelayedList>

00000cbe <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     cbe:	0f 93       	push	r16
     cc0:	1f 93       	push	r17
     cc2:	cf 93       	push	r28
     cc4:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     cc6:	dc 01       	movw	r26, r24
     cc8:	15 96       	adiw	r26, 0x05	; 5
     cca:	ed 91       	ld	r30, X+
     ccc:	fc 91       	ld	r31, X
     cce:	16 97       	sbiw	r26, 0x06	; 6
     cd0:	c6 81       	ldd	r28, Z+6	; 0x06
     cd2:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     cd4:	8e 01       	movw	r16, r28
     cd6:	04 5f       	subi	r16, 0xF4	; 244
     cd8:	1f 4f       	sbci	r17, 0xFF	; 255
     cda:	c8 01       	movw	r24, r16
     cdc:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     ce0:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <uxSchedulerSuspended>
     ce4:	81 11       	cpse	r24, r1
     ce6:	14 c0       	rjmp	.+40     	; 0xd10 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     ce8:	0a 50       	subi	r16, 0x0A	; 10
     cea:	11 09       	sbc	r17, r1
     cec:	c8 01       	movw	r24, r16
     cee:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     cf2:	8e 89       	ldd	r24, Y+22	; 0x16
     cf4:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <uxTopReadyPriority>
     cf8:	98 17       	cp	r25, r24
     cfa:	10 f4       	brcc	.+4      	; 0xd00 <xTaskRemoveFromEventList+0x42>
     cfc:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <uxTopReadyPriority>
     d00:	b9 e0       	ldi	r27, 0x09	; 9
     d02:	8b 9f       	mul	r24, r27
     d04:	c0 01       	movw	r24, r0
     d06:	11 24       	eor	r1, r1
     d08:	b8 01       	movw	r22, r16
     d0a:	8a 57       	subi	r24, 0x7A	; 122
     d0c:	9e 4f       	sbci	r25, 0xFE	; 254
     d0e:	03 c0       	rjmp	.+6      	; 0xd16 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     d10:	b8 01       	movw	r22, r16
     d12:	87 e6       	ldi	r24, 0x67	; 103
     d14:	91 e0       	ldi	r25, 0x01	; 1
     d16:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     d1a:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     d1e:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     d22:	9e 89       	ldd	r25, Y+22	; 0x16
     d24:	86 89       	ldd	r24, Z+22	; 0x16
     d26:	89 17       	cp	r24, r25
     d28:	20 f4       	brcc	.+8      	; 0xd32 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     d2a:	81 e0       	ldi	r24, 0x01	; 1
     d2c:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <xYieldPending>
     d30:	01 c0       	rjmp	.+2      	; 0xd34 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     d32:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     d34:	df 91       	pop	r29
     d36:	cf 91       	pop	r28
     d38:	1f 91       	pop	r17
     d3a:	0f 91       	pop	r16
     d3c:	08 95       	ret

00000d3e <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     d3e:	0f 93       	push	r16
     d40:	1f 93       	push	r17
     d42:	cf 93       	push	r28
     d44:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     d46:	70 68       	ori	r23, 0x80	; 128
     d48:	fc 01       	movw	r30, r24
     d4a:	71 83       	std	Z+1, r23	; 0x01
     d4c:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     d4e:	c6 81       	ldd	r28, Z+6	; 0x06
     d50:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     d52:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     d56:	8e 01       	movw	r16, r28
     d58:	0e 5f       	subi	r16, 0xFE	; 254
     d5a:	1f 4f       	sbci	r17, 0xFF	; 255
     d5c:	c8 01       	movw	r24, r16
     d5e:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     d62:	8e 89       	ldd	r24, Y+22	; 0x16
     d64:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <uxTopReadyPriority>
     d68:	98 17       	cp	r25, r24
     d6a:	10 f4       	brcc	.+4      	; 0xd70 <vTaskRemoveFromUnorderedEventList+0x32>
     d6c:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <uxTopReadyPriority>
     d70:	f9 e0       	ldi	r31, 0x09	; 9
     d72:	8f 9f       	mul	r24, r31
     d74:	c0 01       	movw	r24, r0
     d76:	11 24       	eor	r1, r1
     d78:	b8 01       	movw	r22, r16
     d7a:	8a 57       	subi	r24, 0x7A	; 122
     d7c:	9e 4f       	sbci	r25, 0xFE	; 254
     d7e:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     d82:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     d86:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     d8a:	9e 89       	ldd	r25, Y+22	; 0x16
     d8c:	86 89       	ldd	r24, Z+22	; 0x16
     d8e:	89 17       	cp	r24, r25
     d90:	18 f4       	brcc	.+6      	; 0xd98 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     d92:	81 e0       	ldi	r24, 0x01	; 1
     d94:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <xYieldPending>
	}
}
     d98:	df 91       	pop	r29
     d9a:	cf 91       	pop	r28
     d9c:	1f 91       	pop	r17
     d9e:	0f 91       	pop	r16
     da0:	08 95       	ret

00000da2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     da2:	0f b6       	in	r0, 0x3f	; 63
     da4:	f8 94       	cli
     da6:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     da8:	20 91 4c 01 	lds	r18, 0x014C	; 0x80014c <xNumOfOverflows>
     dac:	fc 01       	movw	r30, r24
     dae:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     db0:	20 91 51 01 	lds	r18, 0x0151	; 0x800151 <xTickCount>
     db4:	30 91 52 01 	lds	r19, 0x0152	; 0x800152 <xTickCount+0x1>
     db8:	32 83       	std	Z+2, r19	; 0x02
     dba:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     dbc:	0f 90       	pop	r0
     dbe:	0f be       	out	0x3f, r0	; 63
     dc0:	08 95       	ret

00000dc2 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     dc2:	20 91 4c 01 	lds	r18, 0x014C	; 0x80014c <xNumOfOverflows>
     dc6:	fc 01       	movw	r30, r24
     dc8:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     dca:	20 91 51 01 	lds	r18, 0x0151	; 0x800151 <xTickCount>
     dce:	30 91 52 01 	lds	r19, 0x0152	; 0x800152 <xTickCount+0x1>
     dd2:	32 83       	std	Z+2, r19	; 0x02
     dd4:	21 83       	std	Z+1, r18	; 0x01
     dd6:	08 95       	ret

00000dd8 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     dd8:	cf 93       	push	r28
     dda:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     ddc:	0f b6       	in	r0, 0x3f	; 63
     dde:	f8 94       	cli
     de0:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     de2:	40 91 51 01 	lds	r20, 0x0151	; 0x800151 <xTickCount>
     de6:	50 91 52 01 	lds	r21, 0x0152	; 0x800152 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     dea:	db 01       	movw	r26, r22
     dec:	2d 91       	ld	r18, X+
     dee:	3c 91       	ld	r19, X
     df0:	2f 3f       	cpi	r18, 0xFF	; 255
     df2:	bf ef       	ldi	r27, 0xFF	; 255
     df4:	3b 07       	cpc	r19, r27
     df6:	d9 f0       	breq	.+54     	; 0xe2e <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     df8:	ec 01       	movw	r28, r24
     dfa:	e9 81       	ldd	r30, Y+1	; 0x01
     dfc:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     dfe:	a0 91 4c 01 	lds	r26, 0x014C	; 0x80014c <xNumOfOverflows>
     e02:	b8 81       	ld	r27, Y
     e04:	ba 17       	cp	r27, r26
     e06:	19 f0       	breq	.+6      	; 0xe0e <xTaskCheckForTimeOut+0x36>
     e08:	4e 17       	cp	r20, r30
     e0a:	5f 07       	cpc	r21, r31
     e0c:	90 f4       	brcc	.+36     	; 0xe32 <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     e0e:	4e 1b       	sub	r20, r30
     e10:	5f 0b       	sbc	r21, r31
     e12:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     e14:	42 17       	cp	r20, r18
     e16:	53 07       	cpc	r21, r19
     e18:	38 f4       	brcc	.+14     	; 0xe28 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     e1a:	24 1b       	sub	r18, r20
     e1c:	35 0b       	sbc	r19, r21
     e1e:	31 83       	std	Z+1, r19	; 0x01
     e20:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     e22:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <vTaskInternalSetTimeOutState>
     e26:	03 c0       	rjmp	.+6      	; 0xe2e <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     e28:	11 82       	std	Z+1, r1	; 0x01
     e2a:	10 82       	st	Z, r1
     e2c:	02 c0       	rjmp	.+4      	; 0xe32 <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     e2e:	80 e0       	ldi	r24, 0x00	; 0
     e30:	01 c0       	rjmp	.+2      	; 0xe34 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     e32:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     e34:	0f 90       	pop	r0
     e36:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     e38:	df 91       	pop	r29
     e3a:	cf 91       	pop	r28
     e3c:	08 95       	ret

00000e3e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     e3e:	81 e0       	ldi	r24, 0x01	; 1
     e40:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <xYieldPending>
     e44:	08 95       	ret

00000e46 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     e46:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     e4a:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     e4e:	84 85       	ldd	r24, Z+12	; 0x0c
     e50:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     e52:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     e56:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     e5a:	a0 91 44 01 	lds	r26, 0x0144	; 0x800144 <__data_end>
     e5e:	b0 91 45 01 	lds	r27, 0x0145	; 0x800145 <__data_end+0x1>
     e62:	56 96       	adiw	r26, 0x16	; 22
     e64:	4c 91       	ld	r20, X
     e66:	24 e0       	ldi	r18, 0x04	; 4
     e68:	30 e0       	ldi	r19, 0x00	; 0
     e6a:	24 1b       	sub	r18, r20
     e6c:	31 09       	sbc	r19, r1
     e6e:	35 87       	std	Z+13, r19	; 0x0d
     e70:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     e72:	08 95       	ret

00000e74 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     e74:	0f 93       	push	r16
     e76:	1f 93       	push	r17
     e78:	18 2f       	mov	r17, r24
     e7a:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     e7c:	0f b6       	in	r0, 0x3f	; 63
     e7e:	f8 94       	cli
     e80:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     e82:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     e86:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     e8a:	41 a1       	ldd	r20, Z+33	; 0x21
     e8c:	52 a1       	ldd	r21, Z+34	; 0x22
     e8e:	63 a1       	ldd	r22, Z+35	; 0x23
     e90:	74 a1       	ldd	r23, Z+36	; 0x24
     e92:	45 2b       	or	r20, r21
     e94:	46 2b       	or	r20, r22
     e96:	47 2b       	or	r20, r23
     e98:	69 f4       	brne	.+26     	; 0xeb4 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     e9a:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     e9e:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     ea2:	21 e0       	ldi	r18, 0x01	; 1
     ea4:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     ea6:	00 97       	sbiw	r24, 0x00	; 0
     ea8:	29 f0       	breq	.+10     	; 0xeb4 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     eaa:	61 e0       	ldi	r22, 0x01	; 1
     eac:	0e 94 77 01 	call	0x2ee	; 0x2ee <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     eb0:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     eb4:	0f 90       	pop	r0
     eb6:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     eb8:	0f b6       	in	r0, 0x3f	; 63
     eba:	f8 94       	cli
     ebc:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
     ebe:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     ec2:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     ec6:	61 a1       	ldd	r22, Z+33	; 0x21
     ec8:	72 a1       	ldd	r23, Z+34	; 0x22
     eca:	83 a1       	ldd	r24, Z+35	; 0x23
     ecc:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
     ece:	61 15       	cp	r22, r1
     ed0:	71 05       	cpc	r23, r1
     ed2:	81 05       	cpc	r24, r1
     ed4:	91 05       	cpc	r25, r1
     ed6:	a9 f0       	breq	.+42     	; 0xf02 <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     ed8:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     edc:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
     ee0:	11 23       	and	r17, r17
     ee2:	29 f0       	breq	.+10     	; 0xeee <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     ee4:	11 a2       	std	Z+33, r1	; 0x21
     ee6:	12 a2       	std	Z+34, r1	; 0x22
     ee8:	13 a2       	std	Z+35, r1	; 0x23
     eea:	14 a2       	std	Z+36, r1	; 0x24
     eec:	0a c0       	rjmp	.+20     	; 0xf02 <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
     eee:	8b 01       	movw	r16, r22
     ef0:	9c 01       	movw	r18, r24
     ef2:	01 50       	subi	r16, 0x01	; 1
     ef4:	11 09       	sbc	r17, r1
     ef6:	21 09       	sbc	r18, r1
     ef8:	31 09       	sbc	r19, r1
     efa:	01 a3       	std	Z+33, r16	; 0x21
     efc:	12 a3       	std	Z+34, r17	; 0x22
     efe:	23 a3       	std	Z+35, r18	; 0x23
     f00:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     f02:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     f06:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     f0a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     f0c:	0f 90       	pop	r0
     f0e:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
     f10:	1f 91       	pop	r17
     f12:	0f 91       	pop	r16
     f14:	08 95       	ret

00000f16 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     f16:	4f 92       	push	r4
     f18:	5f 92       	push	r5
     f1a:	6f 92       	push	r6
     f1c:	7f 92       	push	r7
     f1e:	8f 92       	push	r8
     f20:	9f 92       	push	r9
     f22:	af 92       	push	r10
     f24:	bf 92       	push	r11
     f26:	ef 92       	push	r14
     f28:	ff 92       	push	r15
     f2a:	0f 93       	push	r16
     f2c:	1f 93       	push	r17
     f2e:	49 01       	movw	r8, r18
     f30:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     f32:	0f b6       	in	r0, 0x3f	; 63
     f34:	f8 94       	cli
     f36:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     f38:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     f3c:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     f40:	25 a1       	ldd	r18, Z+37	; 0x25
     f42:	22 30       	cpi	r18, 0x02	; 2
     f44:	39 f1       	breq	.+78     	; 0xf94 <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     f46:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     f4a:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     f4e:	21 a1       	ldd	r18, Z+33	; 0x21
     f50:	32 a1       	ldd	r19, Z+34	; 0x22
     f52:	43 a1       	ldd	r20, Z+35	; 0x23
     f54:	54 a1       	ldd	r21, Z+36	; 0x24
     f56:	2b 01       	movw	r4, r22
     f58:	3c 01       	movw	r6, r24
     f5a:	40 94       	com	r4
     f5c:	50 94       	com	r5
     f5e:	60 94       	com	r6
     f60:	70 94       	com	r7
     f62:	d3 01       	movw	r26, r6
     f64:	c2 01       	movw	r24, r4
     f66:	82 23       	and	r24, r18
     f68:	93 23       	and	r25, r19
     f6a:	a4 23       	and	r26, r20
     f6c:	b5 23       	and	r27, r21
     f6e:	81 a3       	std	Z+33, r24	; 0x21
     f70:	92 a3       	std	Z+34, r25	; 0x22
     f72:	a3 a3       	std	Z+35, r26	; 0x23
     f74:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     f76:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     f7a:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     f7e:	81 e0       	ldi	r24, 0x01	; 1
     f80:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     f82:	e1 14       	cp	r14, r1
     f84:	f1 04       	cpc	r15, r1
     f86:	31 f0       	breq	.+12     	; 0xf94 <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     f88:	61 e0       	ldi	r22, 0x01	; 1
     f8a:	c7 01       	movw	r24, r14
     f8c:	0e 94 77 01 	call	0x2ee	; 0x2ee <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     f90:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     f94:	0f 90       	pop	r0
     f96:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     f98:	0f b6       	in	r0, 0x3f	; 63
     f9a:	f8 94       	cli
     f9c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
     f9e:	01 15       	cp	r16, r1
     fa0:	11 05       	cpc	r17, r1
     fa2:	69 f0       	breq	.+26     	; 0xfbe <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     fa4:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     fa8:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     fac:	81 a1       	ldd	r24, Z+33	; 0x21
     fae:	92 a1       	ldd	r25, Z+34	; 0x22
     fb0:	a3 a1       	ldd	r26, Z+35	; 0x23
     fb2:	b4 a1       	ldd	r27, Z+36	; 0x24
     fb4:	f8 01       	movw	r30, r16
     fb6:	80 83       	st	Z, r24
     fb8:	91 83       	std	Z+1, r25	; 0x01
     fba:	a2 83       	std	Z+2, r26	; 0x02
     fbc:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     fbe:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     fc2:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     fc6:	85 a1       	ldd	r24, Z+37	; 0x25
     fc8:	82 30       	cpi	r24, 0x02	; 2
     fca:	c1 f4       	brne	.+48     	; 0xffc <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
     fcc:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
     fd0:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
     fd4:	41 a1       	ldd	r20, Z+33	; 0x21
     fd6:	52 a1       	ldd	r21, Z+34	; 0x22
     fd8:	63 a1       	ldd	r22, Z+35	; 0x23
     fda:	74 a1       	ldd	r23, Z+36	; 0x24
     fdc:	d5 01       	movw	r26, r10
     fde:	c4 01       	movw	r24, r8
     fe0:	80 95       	com	r24
     fe2:	90 95       	com	r25
     fe4:	a0 95       	com	r26
     fe6:	b0 95       	com	r27
     fe8:	84 23       	and	r24, r20
     fea:	95 23       	and	r25, r21
     fec:	a6 23       	and	r26, r22
     fee:	b7 23       	and	r27, r23
     ff0:	81 a3       	std	Z+33, r24	; 0x21
     ff2:	92 a3       	std	Z+34, r25	; 0x22
     ff4:	a3 a3       	std	Z+35, r26	; 0x23
     ff6:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
     ff8:	81 e0       	ldi	r24, 0x01	; 1
     ffa:	01 c0       	rjmp	.+2      	; 0xffe <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
     ffc:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     ffe:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
    1002:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
    1006:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    1008:	0f 90       	pop	r0
    100a:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    100c:	1f 91       	pop	r17
    100e:	0f 91       	pop	r16
    1010:	ff 90       	pop	r15
    1012:	ef 90       	pop	r14
    1014:	bf 90       	pop	r11
    1016:	af 90       	pop	r10
    1018:	9f 90       	pop	r9
    101a:	8f 90       	pop	r8
    101c:	7f 90       	pop	r7
    101e:	6f 90       	pop	r6
    1020:	5f 90       	pop	r5
    1022:	4f 90       	pop	r4
    1024:	08 95       	ret

00001026 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    1026:	0f 93       	push	r16
    1028:	1f 93       	push	r17
    102a:	cf 93       	push	r28
    102c:	df 93       	push	r29
    102e:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
    1030:	0f b6       	in	r0, 0x3f	; 63
    1032:	f8 94       	cli
    1034:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    1036:	01 15       	cp	r16, r1
    1038:	11 05       	cpc	r17, r1
    103a:	49 f0       	breq	.+18     	; 0x104e <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    103c:	81 a1       	ldd	r24, Z+33	; 0x21
    103e:	92 a1       	ldd	r25, Z+34	; 0x22
    1040:	a3 a1       	ldd	r26, Z+35	; 0x23
    1042:	b4 a1       	ldd	r27, Z+36	; 0x24
    1044:	e8 01       	movw	r28, r16
    1046:	88 83       	st	Y, r24
    1048:	99 83       	std	Y+1, r25	; 0x01
    104a:	aa 83       	std	Y+2, r26	; 0x02
    104c:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    104e:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1050:	82 e0       	ldi	r24, 0x02	; 2
    1052:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1054:	22 30       	cpi	r18, 0x02	; 2
    1056:	89 f0       	breq	.+34     	; 0x107a <xTaskGenericNotify+0x54>
    1058:	58 f4       	brcc	.+22     	; 0x1070 <xTaskGenericNotify+0x4a>
    105a:	21 30       	cpi	r18, 0x01	; 1
    105c:	01 f5       	brne	.+64     	; 0x109e <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    105e:	81 a1       	ldd	r24, Z+33	; 0x21
    1060:	92 a1       	ldd	r25, Z+34	; 0x22
    1062:	a3 a1       	ldd	r26, Z+35	; 0x23
    1064:	b4 a1       	ldd	r27, Z+36	; 0x24
    1066:	48 2b       	or	r20, r24
    1068:	59 2b       	or	r21, r25
    106a:	6a 2b       	or	r22, r26
    106c:	7b 2b       	or	r23, r27
    106e:	13 c0       	rjmp	.+38     	; 0x1096 <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1070:	23 30       	cpi	r18, 0x03	; 3
    1072:	89 f0       	breq	.+34     	; 0x1096 <xTaskGenericNotify+0x70>
    1074:	24 30       	cpi	r18, 0x04	; 4
    1076:	69 f0       	breq	.+26     	; 0x1092 <xTaskGenericNotify+0x6c>
    1078:	12 c0       	rjmp	.+36     	; 0x109e <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    107a:	81 a1       	ldd	r24, Z+33	; 0x21
    107c:	92 a1       	ldd	r25, Z+34	; 0x22
    107e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1080:	b4 a1       	ldd	r27, Z+36	; 0x24
    1082:	01 96       	adiw	r24, 0x01	; 1
    1084:	a1 1d       	adc	r26, r1
    1086:	b1 1d       	adc	r27, r1
    1088:	81 a3       	std	Z+33, r24	; 0x21
    108a:	92 a3       	std	Z+34, r25	; 0x22
    108c:	a3 a3       	std	Z+35, r26	; 0x23
    108e:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1090:	06 c0       	rjmp	.+12     	; 0x109e <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1092:	32 30       	cpi	r19, 0x02	; 2
    1094:	49 f1       	breq	.+82     	; 0x10e8 <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1096:	41 a3       	std	Z+33, r20	; 0x21
    1098:	52 a3       	std	Z+34, r21	; 0x22
    109a:	63 a3       	std	Z+35, r22	; 0x23
    109c:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    109e:	31 30       	cpi	r19, 0x01	; 1
    10a0:	09 f5       	brne	.+66     	; 0x10e4 <xTaskGenericNotify+0xbe>
    10a2:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    10a4:	8f 01       	movw	r16, r30
    10a6:	0e 5f       	subi	r16, 0xFE	; 254
    10a8:	1f 4f       	sbci	r17, 0xFF	; 255
    10aa:	c8 01       	movw	r24, r16
    10ac:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    10b0:	8e 89       	ldd	r24, Y+22	; 0x16
    10b2:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <uxTopReadyPriority>
    10b6:	98 17       	cp	r25, r24
    10b8:	10 f4       	brcc	.+4      	; 0x10be <xTaskGenericNotify+0x98>
    10ba:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <uxTopReadyPriority>
    10be:	29 e0       	ldi	r18, 0x09	; 9
    10c0:	82 9f       	mul	r24, r18
    10c2:	c0 01       	movw	r24, r0
    10c4:	11 24       	eor	r1, r1
    10c6:	b8 01       	movw	r22, r16
    10c8:	8a 57       	subi	r24, 0x7A	; 122
    10ca:	9e 4f       	sbci	r25, 0xFE	; 254
    10cc:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    10d0:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
    10d4:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
    10d8:	9e 89       	ldd	r25, Y+22	; 0x16
    10da:	86 89       	ldd	r24, Z+22	; 0x16
    10dc:	89 17       	cp	r24, r25
    10de:	10 f4       	brcc	.+4      	; 0x10e4 <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    10e0:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
    10e4:	81 e0       	ldi	r24, 0x01	; 1
    10e6:	01 c0       	rjmp	.+2      	; 0x10ea <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    10e8:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    10ea:	0f 90       	pop	r0
    10ec:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    10ee:	df 91       	pop	r29
    10f0:	cf 91       	pop	r28
    10f2:	1f 91       	pop	r17
    10f4:	0f 91       	pop	r16
    10f6:	08 95       	ret

000010f8 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    10f8:	ef 92       	push	r14
    10fa:	ff 92       	push	r15
    10fc:	0f 93       	push	r16
    10fe:	1f 93       	push	r17
    1100:	cf 93       	push	r28
    1102:	df 93       	push	r29
    1104:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    1106:	01 15       	cp	r16, r1
    1108:	11 05       	cpc	r17, r1
    110a:	49 f0       	breq	.+18     	; 0x111e <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    110c:	81 a1       	ldd	r24, Z+33	; 0x21
    110e:	92 a1       	ldd	r25, Z+34	; 0x22
    1110:	a3 a1       	ldd	r26, Z+35	; 0x23
    1112:	b4 a1       	ldd	r27, Z+36	; 0x24
    1114:	e8 01       	movw	r28, r16
    1116:	88 83       	st	Y, r24
    1118:	99 83       	std	Y+1, r25	; 0x01
    111a:	aa 83       	std	Y+2, r26	; 0x02
    111c:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    111e:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1120:	82 e0       	ldi	r24, 0x02	; 2
    1122:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1124:	22 30       	cpi	r18, 0x02	; 2
    1126:	89 f0       	breq	.+34     	; 0x114a <xTaskGenericNotifyFromISR+0x52>
    1128:	58 f4       	brcc	.+22     	; 0x1140 <xTaskGenericNotifyFromISR+0x48>
    112a:	21 30       	cpi	r18, 0x01	; 1
    112c:	01 f5       	brne	.+64     	; 0x116e <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    112e:	81 a1       	ldd	r24, Z+33	; 0x21
    1130:	92 a1       	ldd	r25, Z+34	; 0x22
    1132:	a3 a1       	ldd	r26, Z+35	; 0x23
    1134:	b4 a1       	ldd	r27, Z+36	; 0x24
    1136:	48 2b       	or	r20, r24
    1138:	59 2b       	or	r21, r25
    113a:	6a 2b       	or	r22, r26
    113c:	7b 2b       	or	r23, r27
    113e:	13 c0       	rjmp	.+38     	; 0x1166 <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    1140:	23 30       	cpi	r18, 0x03	; 3
    1142:	89 f0       	breq	.+34     	; 0x1166 <xTaskGenericNotifyFromISR+0x6e>
    1144:	24 30       	cpi	r18, 0x04	; 4
    1146:	69 f0       	breq	.+26     	; 0x1162 <xTaskGenericNotifyFromISR+0x6a>
    1148:	12 c0       	rjmp	.+36     	; 0x116e <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    114a:	81 a1       	ldd	r24, Z+33	; 0x21
    114c:	92 a1       	ldd	r25, Z+34	; 0x22
    114e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1150:	b4 a1       	ldd	r27, Z+36	; 0x24
    1152:	01 96       	adiw	r24, 0x01	; 1
    1154:	a1 1d       	adc	r26, r1
    1156:	b1 1d       	adc	r27, r1
    1158:	81 a3       	std	Z+33, r24	; 0x21
    115a:	92 a3       	std	Z+34, r25	; 0x22
    115c:	a3 a3       	std	Z+35, r26	; 0x23
    115e:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    1160:	06 c0       	rjmp	.+12     	; 0x116e <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1162:	32 30       	cpi	r19, 0x02	; 2
    1164:	d9 f1       	breq	.+118    	; 0x11dc <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1166:	41 a3       	std	Z+33, r20	; 0x21
    1168:	52 a3       	std	Z+34, r21	; 0x22
    116a:	63 a3       	std	Z+35, r22	; 0x23
    116c:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    116e:	31 30       	cpi	r19, 0x01	; 1
    1170:	11 f0       	breq	.+4      	; 0x1176 <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1172:	81 e0       	ldi	r24, 0x01	; 1
    1174:	34 c0       	rjmp	.+104    	; 0x11de <xTaskGenericNotifyFromISR+0xe6>
    1176:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1178:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <uxSchedulerSuspended>
    117c:	81 11       	cpse	r24, r1
    117e:	15 c0       	rjmp	.+42     	; 0x11aa <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1180:	8f 01       	movw	r16, r30
    1182:	0e 5f       	subi	r16, 0xFE	; 254
    1184:	1f 4f       	sbci	r17, 0xFF	; 255
    1186:	c8 01       	movw	r24, r16
    1188:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    118c:	8e 89       	ldd	r24, Y+22	; 0x16
    118e:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <uxTopReadyPriority>
    1192:	98 17       	cp	r25, r24
    1194:	10 f4       	brcc	.+4      	; 0x119a <xTaskGenericNotifyFromISR+0xa2>
    1196:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <uxTopReadyPriority>
    119a:	e9 e0       	ldi	r30, 0x09	; 9
    119c:	8e 9f       	mul	r24, r30
    119e:	c0 01       	movw	r24, r0
    11a0:	11 24       	eor	r1, r1
    11a2:	b8 01       	movw	r22, r16
    11a4:	8a 57       	subi	r24, 0x7A	; 122
    11a6:	9e 4f       	sbci	r25, 0xFE	; 254
    11a8:	05 c0       	rjmp	.+10     	; 0x11b4 <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    11aa:	bf 01       	movw	r22, r30
    11ac:	64 5f       	subi	r22, 0xF4	; 244
    11ae:	7f 4f       	sbci	r23, 0xFF	; 255
    11b0:	87 e6       	ldi	r24, 0x67	; 103
    11b2:	91 e0       	ldi	r25, 0x01	; 1
    11b4:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    11b8:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
    11bc:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
    11c0:	9e 89       	ldd	r25, Y+22	; 0x16
    11c2:	86 89       	ldd	r24, Z+22	; 0x16
    11c4:	89 17       	cp	r24, r25
    11c6:	a8 f6       	brcc	.-86     	; 0x1172 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    11c8:	e1 14       	cp	r14, r1
    11ca:	f1 04       	cpc	r15, r1
    11cc:	19 f0       	breq	.+6      	; 0x11d4 <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    11ce:	81 e0       	ldi	r24, 0x01	; 1
    11d0:	e7 01       	movw	r28, r14
    11d2:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    11d4:	81 e0       	ldi	r24, 0x01	; 1
    11d6:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <xYieldPending>
    11da:	01 c0       	rjmp	.+2      	; 0x11de <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    11dc:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    11de:	df 91       	pop	r29
    11e0:	cf 91       	pop	r28
    11e2:	1f 91       	pop	r17
    11e4:	0f 91       	pop	r16
    11e6:	ff 90       	pop	r15
    11e8:	ef 90       	pop	r14
    11ea:	08 95       	ret

000011ec <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    11ec:	ef 92       	push	r14
    11ee:	ff 92       	push	r15
    11f0:	0f 93       	push	r16
    11f2:	1f 93       	push	r17
    11f4:	cf 93       	push	r28
    11f6:	df 93       	push	r29
    11f8:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    11fa:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    11fc:	82 e0       	ldi	r24, 0x02	; 2
    11fe:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    1200:	81 a1       	ldd	r24, Z+33	; 0x21
    1202:	92 a1       	ldd	r25, Z+34	; 0x22
    1204:	a3 a1       	ldd	r26, Z+35	; 0x23
    1206:	b4 a1       	ldd	r27, Z+36	; 0x24
    1208:	01 96       	adiw	r24, 0x01	; 1
    120a:	a1 1d       	adc	r26, r1
    120c:	b1 1d       	adc	r27, r1
    120e:	81 a3       	std	Z+33, r24	; 0x21
    1210:	92 a3       	std	Z+34, r25	; 0x22
    1212:	a3 a3       	std	Z+35, r26	; 0x23
    1214:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1216:	21 30       	cpi	r18, 0x01	; 1
    1218:	a1 f5       	brne	.+104    	; 0x1282 <vTaskNotifyGiveFromISR+0x96>
    121a:	8b 01       	movw	r16, r22
    121c:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    121e:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <uxSchedulerSuspended>
    1222:	81 11       	cpse	r24, r1
    1224:	16 c0       	rjmp	.+44     	; 0x1252 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1226:	7f 01       	movw	r14, r30
    1228:	22 e0       	ldi	r18, 0x02	; 2
    122a:	e2 0e       	add	r14, r18
    122c:	f1 1c       	adc	r15, r1
    122e:	c7 01       	movw	r24, r14
    1230:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1234:	8e 89       	ldd	r24, Y+22	; 0x16
    1236:	90 91 50 01 	lds	r25, 0x0150	; 0x800150 <uxTopReadyPriority>
    123a:	98 17       	cp	r25, r24
    123c:	10 f4       	brcc	.+4      	; 0x1242 <vTaskNotifyGiveFromISR+0x56>
    123e:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <uxTopReadyPriority>
    1242:	e9 e0       	ldi	r30, 0x09	; 9
    1244:	8e 9f       	mul	r24, r30
    1246:	c0 01       	movw	r24, r0
    1248:	11 24       	eor	r1, r1
    124a:	b7 01       	movw	r22, r14
    124c:	8a 57       	subi	r24, 0x7A	; 122
    124e:	9e 4f       	sbci	r25, 0xFE	; 254
    1250:	05 c0       	rjmp	.+10     	; 0x125c <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1252:	bf 01       	movw	r22, r30
    1254:	64 5f       	subi	r22, 0xF4	; 244
    1256:	7f 4f       	sbci	r23, 0xFF	; 255
    1258:	87 e6       	ldi	r24, 0x67	; 103
    125a:	91 e0       	ldi	r25, 0x01	; 1
    125c:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1260:	e0 91 44 01 	lds	r30, 0x0144	; 0x800144 <__data_end>
    1264:	f0 91 45 01 	lds	r31, 0x0145	; 0x800145 <__data_end+0x1>
    1268:	9e 89       	ldd	r25, Y+22	; 0x16
    126a:	86 89       	ldd	r24, Z+22	; 0x16
    126c:	89 17       	cp	r24, r25
    126e:	48 f4       	brcc	.+18     	; 0x1282 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1270:	01 15       	cp	r16, r1
    1272:	11 05       	cpc	r17, r1
    1274:	19 f0       	breq	.+6      	; 0x127c <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	f8 01       	movw	r30, r16
    127a:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    127c:	81 e0       	ldi	r24, 0x01	; 1
    127e:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    1282:	df 91       	pop	r29
    1284:	cf 91       	pop	r28
    1286:	1f 91       	pop	r17
    1288:	0f 91       	pop	r16
    128a:	ff 90       	pop	r15
    128c:	ef 90       	pop	r14
    128e:	08 95       	ret

00001290 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    1290:	00 97       	sbiw	r24, 0x00	; 0
    1292:	21 f4       	brne	.+8      	; 0x129c <xTaskNotifyStateClear+0xc>
    1294:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <__data_end>
    1298:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <__data_end+0x1>

		taskENTER_CRITICAL();
    129c:	0f b6       	in	r0, 0x3f	; 63
    129e:	f8 94       	cli
    12a0:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    12a2:	fc 01       	movw	r30, r24
    12a4:	25 a1       	ldd	r18, Z+37	; 0x25
    12a6:	22 30       	cpi	r18, 0x02	; 2
    12a8:	19 f4       	brne	.+6      	; 0x12b0 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    12aa:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    12ac:	81 e0       	ldi	r24, 0x01	; 1
    12ae:	01 c0       	rjmp	.+2      	; 0x12b2 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    12b0:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    12b2:	0f 90       	pop	r0
    12b4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    12b6:	08 95       	ret

000012b8 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    12b8:	0f b6       	in	r0, 0x3f	; 63
    12ba:	f8 94       	cli
    12bc:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    12be:	fc 01       	movw	r30, r24
    12c0:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    12c2:	0f 90       	pop	r0
    12c4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    12c6:	81 e0       	ldi	r24, 0x01	; 1
    12c8:	91 11       	cpse	r25, r1
    12ca:	80 e0       	ldi	r24, 0x00	; 0
}
    12cc:	08 95       	ret

000012ce <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    12ce:	0f 93       	push	r16
    12d0:	1f 93       	push	r17
    12d2:	cf 93       	push	r28
    12d4:	df 93       	push	r29
    12d6:	ec 01       	movw	r28, r24
    12d8:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    12da:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    12dc:	4c 8d       	ldd	r20, Y+28	; 0x1c
    12de:	44 23       	and	r20, r20
    12e0:	b1 f1       	breq	.+108    	; 0x134e <prvCopyDataToQueue+0x80>
    12e2:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    12e4:	01 11       	cpse	r16, r1
    12e6:	15 c0       	rjmp	.+42     	; 0x1312 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    12e8:	8a 81       	ldd	r24, Y+2	; 0x02
    12ea:	9b 81       	ldd	r25, Y+3	; 0x03
    12ec:	0e 94 a4 12 	call	0x2548	; 0x2548 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    12f0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    12f2:	8a 81       	ldd	r24, Y+2	; 0x02
    12f4:	9b 81       	ldd	r25, Y+3	; 0x03
    12f6:	82 0f       	add	r24, r18
    12f8:	91 1d       	adc	r25, r1
    12fa:	9b 83       	std	Y+3, r25	; 0x03
    12fc:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    12fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1300:	3d 81       	ldd	r19, Y+5	; 0x05
    1302:	82 17       	cp	r24, r18
    1304:	93 07       	cpc	r25, r19
    1306:	18 f1       	brcs	.+70     	; 0x134e <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1308:	88 81       	ld	r24, Y
    130a:	99 81       	ldd	r25, Y+1	; 0x01
    130c:	9b 83       	std	Y+3, r25	; 0x03
    130e:	8a 83       	std	Y+2, r24	; 0x02
    1310:	1e c0       	rjmp	.+60     	; 0x134e <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1312:	8e 81       	ldd	r24, Y+6	; 0x06
    1314:	9f 81       	ldd	r25, Y+7	; 0x07
    1316:	0e 94 a4 12 	call	0x2548	; 0x2548 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    131a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    131c:	90 e0       	ldi	r25, 0x00	; 0
    131e:	91 95       	neg	r25
    1320:	81 95       	neg	r24
    1322:	91 09       	sbc	r25, r1
    1324:	2e 81       	ldd	r18, Y+6	; 0x06
    1326:	3f 81       	ldd	r19, Y+7	; 0x07
    1328:	28 0f       	add	r18, r24
    132a:	39 1f       	adc	r19, r25
    132c:	3f 83       	std	Y+7, r19	; 0x07
    132e:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1330:	48 81       	ld	r20, Y
    1332:	59 81       	ldd	r21, Y+1	; 0x01
    1334:	24 17       	cp	r18, r20
    1336:	35 07       	cpc	r19, r21
    1338:	30 f4       	brcc	.+12     	; 0x1346 <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    133a:	2c 81       	ldd	r18, Y+4	; 0x04
    133c:	3d 81       	ldd	r19, Y+5	; 0x05
    133e:	82 0f       	add	r24, r18
    1340:	93 1f       	adc	r25, r19
    1342:	9f 83       	std	Y+7, r25	; 0x07
    1344:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1346:	02 30       	cpi	r16, 0x02	; 2
    1348:	11 f4       	brne	.+4      	; 0x134e <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    134a:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    134c:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    134e:	1f 5f       	subi	r17, 0xFF	; 255
    1350:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    1352:	80 e0       	ldi	r24, 0x00	; 0
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
    1358:	1f 91       	pop	r17
    135a:	0f 91       	pop	r16
    135c:	08 95       	ret

0000135e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    135e:	fc 01       	movw	r30, r24
    1360:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1362:	44 8d       	ldd	r20, Z+28	; 0x1c
    1364:	44 23       	and	r20, r20
    1366:	a1 f0       	breq	.+40     	; 0x1390 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1368:	50 e0       	ldi	r21, 0x00	; 0
    136a:	26 81       	ldd	r18, Z+6	; 0x06
    136c:	37 81       	ldd	r19, Z+7	; 0x07
    136e:	24 0f       	add	r18, r20
    1370:	35 1f       	adc	r19, r21
    1372:	37 83       	std	Z+7, r19	; 0x07
    1374:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1376:	64 81       	ldd	r22, Z+4	; 0x04
    1378:	75 81       	ldd	r23, Z+5	; 0x05
    137a:	26 17       	cp	r18, r22
    137c:	37 07       	cpc	r19, r23
    137e:	20 f0       	brcs	.+8      	; 0x1388 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1380:	20 81       	ld	r18, Z
    1382:	31 81       	ldd	r19, Z+1	; 0x01
    1384:	37 83       	std	Z+7, r19	; 0x07
    1386:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1388:	66 81       	ldd	r22, Z+6	; 0x06
    138a:	77 81       	ldd	r23, Z+7	; 0x07
    138c:	0c 94 a4 12 	jmp	0x2548	; 0x2548 <memcpy>
    1390:	08 95       	ret

00001392 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1392:	ef 92       	push	r14
    1394:	ff 92       	push	r15
    1396:	1f 93       	push	r17
    1398:	cf 93       	push	r28
    139a:	df 93       	push	r29
    139c:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    139e:	0f b6       	in	r0, 0x3f	; 63
    13a0:	f8 94       	cli
    13a2:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    13a4:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13a6:	7c 01       	movw	r14, r24
    13a8:	81 e1       	ldi	r24, 0x11	; 17
    13aa:	e8 0e       	add	r14, r24
    13ac:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    13ae:	11 16       	cp	r1, r17
    13b0:	5c f4       	brge	.+22     	; 0x13c8 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13b2:	89 89       	ldd	r24, Y+17	; 0x11
    13b4:	88 23       	and	r24, r24
    13b6:	41 f0       	breq	.+16     	; 0x13c8 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13b8:	c7 01       	movw	r24, r14
    13ba:	0e 94 5f 06 	call	0xcbe	; 0xcbe <xTaskRemoveFromEventList>
    13be:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    13c0:	0e 94 1f 07 	call	0xe3e	; 0xe3e <vTaskMissedYield>
    13c4:	11 50       	subi	r17, 0x01	; 1
    13c6:	f3 cf       	rjmp	.-26     	; 0x13ae <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    13c8:	8f ef       	ldi	r24, 0xFF	; 255
    13ca:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    13cc:	0f 90       	pop	r0
    13ce:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    13d0:	0f b6       	in	r0, 0x3f	; 63
    13d2:	f8 94       	cli
    13d4:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    13d6:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    13d8:	7e 01       	movw	r14, r28
    13da:	88 e0       	ldi	r24, 0x08	; 8
    13dc:	e8 0e       	add	r14, r24
    13de:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    13e0:	11 16       	cp	r1, r17
    13e2:	5c f4       	brge	.+22     	; 0x13fa <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13e4:	88 85       	ldd	r24, Y+8	; 0x08
    13e6:	88 23       	and	r24, r24
    13e8:	41 f0       	breq	.+16     	; 0x13fa <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    13ea:	c7 01       	movw	r24, r14
    13ec:	0e 94 5f 06 	call	0xcbe	; 0xcbe <xTaskRemoveFromEventList>
    13f0:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    13f2:	0e 94 1f 07 	call	0xe3e	; 0xe3e <vTaskMissedYield>
    13f6:	11 50       	subi	r17, 0x01	; 1
    13f8:	f3 cf       	rjmp	.-26     	; 0x13e0 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    13fa:	8f ef       	ldi	r24, 0xFF	; 255
    13fc:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    13fe:	0f 90       	pop	r0
    1400:	0f be       	out	0x3f, r0	; 63
}
    1402:	df 91       	pop	r29
    1404:	cf 91       	pop	r28
    1406:	1f 91       	pop	r17
    1408:	ff 90       	pop	r15
    140a:	ef 90       	pop	r14
    140c:	08 95       	ret

0000140e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    140e:	cf 93       	push	r28
    1410:	df 93       	push	r29
    1412:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1414:	0f b6       	in	r0, 0x3f	; 63
    1416:	f8 94       	cli
    1418:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    141a:	48 81       	ld	r20, Y
    141c:	59 81       	ldd	r21, Y+1	; 0x01
    141e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1420:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1422:	9a 01       	movw	r18, r20
    1424:	87 9f       	mul	r24, r23
    1426:	20 0d       	add	r18, r0
    1428:	31 1d       	adc	r19, r1
    142a:	11 24       	eor	r1, r1
    142c:	3d 83       	std	Y+5, r19	; 0x05
    142e:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1430:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1432:	5b 83       	std	Y+3, r21	; 0x03
    1434:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1436:	90 e0       	ldi	r25, 0x00	; 0
    1438:	01 97       	sbiw	r24, 0x01	; 1
    143a:	78 9f       	mul	r23, r24
    143c:	90 01       	movw	r18, r0
    143e:	79 9f       	mul	r23, r25
    1440:	30 0d       	add	r19, r0
    1442:	11 24       	eor	r1, r1
    1444:	ca 01       	movw	r24, r20
    1446:	82 0f       	add	r24, r18
    1448:	93 1f       	adc	r25, r19
    144a:	9f 83       	std	Y+7, r25	; 0x07
    144c:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    144e:	8f ef       	ldi	r24, 0xFF	; 255
    1450:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1452:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1454:	61 11       	cpse	r22, r1
    1456:	0c c0       	rjmp	.+24     	; 0x1470 <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1458:	88 85       	ldd	r24, Y+8	; 0x08
    145a:	88 23       	and	r24, r24
    145c:	89 f0       	breq	.+34     	; 0x1480 <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    145e:	ce 01       	movw	r24, r28
    1460:	08 96       	adiw	r24, 0x08	; 8
    1462:	0e 94 5f 06 	call	0xcbe	; 0xcbe <xTaskRemoveFromEventList>
    1466:	88 23       	and	r24, r24
    1468:	59 f0       	breq	.+22     	; 0x1480 <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    146a:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
    146e:	08 c0       	rjmp	.+16     	; 0x1480 <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1470:	ce 01       	movw	r24, r28
    1472:	08 96       	adiw	r24, 0x08	; 8
    1474:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1478:	ce 01       	movw	r24, r28
    147a:	41 96       	adiw	r24, 0x11	; 17
    147c:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1480:	0f 90       	pop	r0
    1482:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1484:	81 e0       	ldi	r24, 0x01	; 1
    1486:	df 91       	pop	r29
    1488:	cf 91       	pop	r28
    148a:	08 95       	ret

0000148c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    148c:	0f 93       	push	r16
    148e:	1f 93       	push	r17
    1490:	cf 93       	push	r28
    1492:	df 93       	push	r29
    1494:	08 2f       	mov	r16, r24
    1496:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1498:	66 23       	and	r22, r22
    149a:	21 f0       	breq	.+8      	; 0x14a4 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    149c:	86 9f       	mul	r24, r22
    149e:	c0 01       	movw	r24, r0
    14a0:	11 24       	eor	r1, r1
    14a2:	02 c0       	rjmp	.+4      	; 0x14a8 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    14a4:	80 e0       	ldi	r24, 0x00	; 0
    14a6:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    14a8:	4f 96       	adiw	r24, 0x1f	; 31
    14aa:	0e 94 9d 10 	call	0x213a	; 0x213a <pvPortMalloc>
    14ae:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    14b0:	00 97       	sbiw	r24, 0x00	; 0
    14b2:	71 f0       	breq	.+28     	; 0x14d0 <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    14b4:	11 11       	cpse	r17, r1
    14b6:	03 c0       	rjmp	.+6      	; 0x14be <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    14b8:	99 83       	std	Y+1, r25	; 0x01
    14ba:	88 83       	st	Y, r24
    14bc:	03 c0       	rjmp	.+6      	; 0x14c4 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    14be:	4f 96       	adiw	r24, 0x1f	; 31
    14c0:	99 83       	std	Y+1, r25	; 0x01
    14c2:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    14c4:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    14c6:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    14c8:	61 e0       	ldi	r22, 0x01	; 1
    14ca:	ce 01       	movw	r24, r28
    14cc:	0e 94 07 0a 	call	0x140e	; 0x140e <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    14d0:	ce 01       	movw	r24, r28
    14d2:	df 91       	pop	r29
    14d4:	cf 91       	pop	r28
    14d6:	1f 91       	pop	r17
    14d8:	0f 91       	pop	r16
    14da:	08 95       	ret

000014dc <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    14dc:	af 92       	push	r10
    14de:	bf 92       	push	r11
    14e0:	cf 92       	push	r12
    14e2:	df 92       	push	r13
    14e4:	ff 92       	push	r15
    14e6:	0f 93       	push	r16
    14e8:	1f 93       	push	r17
    14ea:	cf 93       	push	r28
    14ec:	df 93       	push	r29
    14ee:	00 d0       	rcall	.+0      	; 0x14f0 <xQueueGenericSend+0x14>
    14f0:	00 d0       	rcall	.+0      	; 0x14f2 <xQueueGenericSend+0x16>
    14f2:	1f 92       	push	r1
    14f4:	cd b7       	in	r28, 0x3d	; 61
    14f6:	de b7       	in	r29, 0x3e	; 62
    14f8:	8c 01       	movw	r16, r24
    14fa:	6b 01       	movw	r12, r22
    14fc:	5d 83       	std	Y+5, r21	; 0x05
    14fe:	4c 83       	std	Y+4, r20	; 0x04
    1500:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1502:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1504:	58 01       	movw	r10, r16
    1506:	98 e0       	ldi	r25, 0x08	; 8
    1508:	a9 0e       	add	r10, r25
    150a:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    150c:	0f b6       	in	r0, 0x3f	; 63
    150e:	f8 94       	cli
    1510:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1512:	f8 01       	movw	r30, r16
    1514:	22 8d       	ldd	r18, Z+26	; 0x1a
    1516:	93 8d       	ldd	r25, Z+27	; 0x1b
    1518:	29 17       	cp	r18, r25
    151a:	18 f0       	brcs	.+6      	; 0x1522 <xQueueGenericSend+0x46>
    151c:	f2 e0       	ldi	r31, 0x02	; 2
    151e:	ff 12       	cpse	r15, r31
    1520:	14 c0       	rjmp	.+40     	; 0x154a <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1522:	4f 2d       	mov	r20, r15
    1524:	b6 01       	movw	r22, r12
    1526:	c8 01       	movw	r24, r16
    1528:	0e 94 67 09 	call	0x12ce	; 0x12ce <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    152c:	f8 01       	movw	r30, r16
    152e:	91 89       	ldd	r25, Z+17	; 0x11
    1530:	99 23       	and	r25, r25
    1532:	21 f0       	breq	.+8      	; 0x153c <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1534:	c8 01       	movw	r24, r16
    1536:	41 96       	adiw	r24, 0x11	; 17
    1538:	0e 94 5f 06 	call	0xcbe	; 0xcbe <xTaskRemoveFromEventList>
    153c:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    153e:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1542:	0f 90       	pop	r0
    1544:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1546:	81 e0       	ldi	r24, 0x01	; 1
    1548:	50 c0       	rjmp	.+160    	; 0x15ea <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    154a:	2c 81       	ldd	r18, Y+4	; 0x04
    154c:	3d 81       	ldd	r19, Y+5	; 0x05
    154e:	23 2b       	or	r18, r19
    1550:	19 f4       	brne	.+6      	; 0x1558 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1552:	0f 90       	pop	r0
    1554:	0f be       	out	0x3f, r0	; 63
    1556:	48 c0       	rjmp	.+144    	; 0x15e8 <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1558:	81 11       	cpse	r24, r1
    155a:	04 c0       	rjmp	.+8      	; 0x1564 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    155c:	ce 01       	movw	r24, r28
    155e:	01 96       	adiw	r24, 0x01	; 1
    1560:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1564:	0f 90       	pop	r0
    1566:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1568:	0e 94 15 04 	call	0x82a	; 0x82a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    156c:	0f b6       	in	r0, 0x3f	; 63
    156e:	f8 94       	cli
    1570:	0f 92       	push	r0
    1572:	f8 01       	movw	r30, r16
    1574:	85 8d       	ldd	r24, Z+29	; 0x1d
    1576:	8f 3f       	cpi	r24, 0xFF	; 255
    1578:	09 f4       	brne	.+2      	; 0x157c <xQueueGenericSend+0xa0>
    157a:	15 8e       	std	Z+29, r1	; 0x1d
    157c:	f8 01       	movw	r30, r16
    157e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1580:	8f 3f       	cpi	r24, 0xFF	; 255
    1582:	09 f4       	brne	.+2      	; 0x1586 <xQueueGenericSend+0xaa>
    1584:	16 8e       	std	Z+30, r1	; 0x1e
    1586:	0f 90       	pop	r0
    1588:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    158a:	be 01       	movw	r22, r28
    158c:	6c 5f       	subi	r22, 0xFC	; 252
    158e:	7f 4f       	sbci	r23, 0xFF	; 255
    1590:	ce 01       	movw	r24, r28
    1592:	01 96       	adiw	r24, 0x01	; 1
    1594:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <xTaskCheckForTimeOut>
    1598:	81 11       	cpse	r24, r1
    159a:	21 c0       	rjmp	.+66     	; 0x15de <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    159c:	0f b6       	in	r0, 0x3f	; 63
    159e:	f8 94       	cli
    15a0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    15a2:	f8 01       	movw	r30, r16
    15a4:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    15a6:	0f 90       	pop	r0
    15a8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    15aa:	83 8d       	ldd	r24, Z+27	; 0x1b
    15ac:	98 13       	cpse	r25, r24
    15ae:	11 c0       	rjmp	.+34     	; 0x15d2 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    15b0:	6c 81       	ldd	r22, Y+4	; 0x04
    15b2:	7d 81       	ldd	r23, Y+5	; 0x05
    15b4:	c5 01       	movw	r24, r10
    15b6:	0e 94 36 06 	call	0xc6c	; 0xc6c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    15ba:	c8 01       	movw	r24, r16
    15bc:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    15c0:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>
    15c4:	88 23       	and	r24, r24
    15c6:	11 f0       	breq	.+4      	; 0x15cc <xQueueGenericSend+0xf0>
    15c8:	81 e0       	ldi	r24, 0x01	; 1
    15ca:	a0 cf       	rjmp	.-192    	; 0x150c <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    15cc:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
    15d0:	fb cf       	rjmp	.-10     	; 0x15c8 <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    15d2:	c8 01       	movw	r24, r16
    15d4:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    15d8:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>
    15dc:	f5 cf       	rjmp	.-22     	; 0x15c8 <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    15de:	c8 01       	movw	r24, r16
    15e0:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    15e4:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    15e8:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    15ea:	0f 90       	pop	r0
    15ec:	0f 90       	pop	r0
    15ee:	0f 90       	pop	r0
    15f0:	0f 90       	pop	r0
    15f2:	0f 90       	pop	r0
    15f4:	df 91       	pop	r29
    15f6:	cf 91       	pop	r28
    15f8:	1f 91       	pop	r17
    15fa:	0f 91       	pop	r16
    15fc:	ff 90       	pop	r15
    15fe:	df 90       	pop	r13
    1600:	cf 90       	pop	r12
    1602:	bf 90       	pop	r11
    1604:	af 90       	pop	r10
    1606:	08 95       	ret

00001608 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1608:	ef 92       	push	r14
    160a:	ff 92       	push	r15
    160c:	1f 93       	push	r17
    160e:	cf 93       	push	r28
    1610:	df 93       	push	r29
    1612:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1614:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1616:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1618:	98 17       	cp	r25, r24
    161a:	10 f0       	brcs	.+4      	; 0x1620 <xQueueGenericSendFromISR+0x18>
    161c:	22 30       	cpi	r18, 0x02	; 2
    161e:	e1 f4       	brne	.+56     	; 0x1658 <xQueueGenericSendFromISR+0x50>
    1620:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1622:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1624:	42 2f       	mov	r20, r18
    1626:	ce 01       	movw	r24, r28
    1628:	0e 94 67 09 	call	0x12ce	; 0x12ce <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    162c:	1f 3f       	cpi	r17, 0xFF	; 255
    162e:	81 f4       	brne	.+32     	; 0x1650 <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1630:	89 89       	ldd	r24, Y+17	; 0x11
    1632:	88 23       	and	r24, r24
    1634:	79 f0       	breq	.+30     	; 0x1654 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1636:	ce 01       	movw	r24, r28
    1638:	41 96       	adiw	r24, 0x11	; 17
    163a:	0e 94 5f 06 	call	0xcbe	; 0xcbe <xTaskRemoveFromEventList>
    163e:	88 23       	and	r24, r24
    1640:	49 f0       	breq	.+18     	; 0x1654 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1642:	e1 14       	cp	r14, r1
    1644:	f1 04       	cpc	r15, r1
    1646:	31 f0       	breq	.+12     	; 0x1654 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1648:	81 e0       	ldi	r24, 0x01	; 1
    164a:	f7 01       	movw	r30, r14
    164c:	80 83       	st	Z, r24
    164e:	05 c0       	rjmp	.+10     	; 0x165a <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1650:	1f 5f       	subi	r17, 0xFF	; 255
    1652:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    1654:	81 e0       	ldi	r24, 0x01	; 1
    1656:	01 c0       	rjmp	.+2      	; 0x165a <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1658:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    165a:	df 91       	pop	r29
    165c:	cf 91       	pop	r28
    165e:	1f 91       	pop	r17
    1660:	ff 90       	pop	r15
    1662:	ef 90       	pop	r14
    1664:	08 95       	ret

00001666 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1666:	cf 93       	push	r28
    1668:	df 93       	push	r29
    166a:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    166c:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    166e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1670:	98 17       	cp	r25, r24
    1672:	c0 f4       	brcc	.+48     	; 0x16a4 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1674:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1676:	9f 5f       	subi	r25, 0xFF	; 255
    1678:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    167a:	8f 3f       	cpi	r24, 0xFF	; 255
    167c:	79 f4       	brne	.+30     	; 0x169c <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    167e:	81 89       	ldd	r24, Z+17	; 0x11
    1680:	88 23       	and	r24, r24
    1682:	71 f0       	breq	.+28     	; 0x16a0 <xQueueGiveFromISR+0x3a>
    1684:	eb 01       	movw	r28, r22
    1686:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1688:	41 96       	adiw	r24, 0x11	; 17
    168a:	0e 94 5f 06 	call	0xcbe	; 0xcbe <xTaskRemoveFromEventList>
    168e:	88 23       	and	r24, r24
    1690:	39 f0       	breq	.+14     	; 0x16a0 <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1692:	20 97       	sbiw	r28, 0x00	; 0
    1694:	29 f0       	breq	.+10     	; 0x16a0 <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1696:	81 e0       	ldi	r24, 0x01	; 1
    1698:	88 83       	st	Y, r24
    169a:	05 c0       	rjmp	.+10     	; 0x16a6 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    169c:	8f 5f       	subi	r24, 0xFF	; 255
    169e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    16a0:	81 e0       	ldi	r24, 0x01	; 1
    16a2:	01 c0       	rjmp	.+2      	; 0x16a6 <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    16a4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    16a6:	df 91       	pop	r29
    16a8:	cf 91       	pop	r28
    16aa:	08 95       	ret

000016ac <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    16ac:	af 92       	push	r10
    16ae:	bf 92       	push	r11
    16b0:	cf 92       	push	r12
    16b2:	df 92       	push	r13
    16b4:	ff 92       	push	r15
    16b6:	0f 93       	push	r16
    16b8:	1f 93       	push	r17
    16ba:	cf 93       	push	r28
    16bc:	df 93       	push	r29
    16be:	00 d0       	rcall	.+0      	; 0x16c0 <xQueueReceive+0x14>
    16c0:	00 d0       	rcall	.+0      	; 0x16c2 <xQueueReceive+0x16>
    16c2:	1f 92       	push	r1
    16c4:	cd b7       	in	r28, 0x3d	; 61
    16c6:	de b7       	in	r29, 0x3e	; 62
    16c8:	8c 01       	movw	r16, r24
    16ca:	6b 01       	movw	r12, r22
    16cc:	5d 83       	std	Y+5, r21	; 0x05
    16ce:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    16d0:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16d2:	58 01       	movw	r10, r16
    16d4:	91 e1       	ldi	r25, 0x11	; 17
    16d6:	a9 0e       	add	r10, r25
    16d8:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    16da:	0f b6       	in	r0, 0x3f	; 63
    16dc:	f8 94       	cli
    16de:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    16e0:	f8 01       	movw	r30, r16
    16e2:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    16e4:	ff 20       	and	r15, r15
    16e6:	a9 f0       	breq	.+42     	; 0x1712 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    16e8:	b6 01       	movw	r22, r12
    16ea:	c8 01       	movw	r24, r16
    16ec:	0e 94 af 09 	call	0x135e	; 0x135e <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    16f0:	fa 94       	dec	r15
    16f2:	f8 01       	movw	r30, r16
    16f4:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16f6:	80 85       	ldd	r24, Z+8	; 0x08
    16f8:	88 23       	and	r24, r24
    16fa:	39 f0       	breq	.+14     	; 0x170a <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16fc:	c8 01       	movw	r24, r16
    16fe:	08 96       	adiw	r24, 0x08	; 8
    1700:	0e 94 5f 06 	call	0xcbe	; 0xcbe <xTaskRemoveFromEventList>
    1704:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1706:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    170a:	0f 90       	pop	r0
    170c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    170e:	81 e0       	ldi	r24, 0x01	; 1
    1710:	50 c0       	rjmp	.+160    	; 0x17b2 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1712:	2c 81       	ldd	r18, Y+4	; 0x04
    1714:	3d 81       	ldd	r19, Y+5	; 0x05
    1716:	23 2b       	or	r18, r19
    1718:	19 f4       	brne	.+6      	; 0x1720 <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    171a:	0f 90       	pop	r0
    171c:	0f be       	out	0x3f, r0	; 63
    171e:	48 c0       	rjmp	.+144    	; 0x17b0 <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1720:	81 11       	cpse	r24, r1
    1722:	04 c0       	rjmp	.+8      	; 0x172c <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1724:	ce 01       	movw	r24, r28
    1726:	01 96       	adiw	r24, 0x01	; 1
    1728:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    172c:	0f 90       	pop	r0
    172e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1730:	0e 94 15 04 	call	0x82a	; 0x82a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1734:	0f b6       	in	r0, 0x3f	; 63
    1736:	f8 94       	cli
    1738:	0f 92       	push	r0
    173a:	f8 01       	movw	r30, r16
    173c:	85 8d       	ldd	r24, Z+29	; 0x1d
    173e:	8f 3f       	cpi	r24, 0xFF	; 255
    1740:	09 f4       	brne	.+2      	; 0x1744 <xQueueReceive+0x98>
    1742:	15 8e       	std	Z+29, r1	; 0x1d
    1744:	f8 01       	movw	r30, r16
    1746:	86 8d       	ldd	r24, Z+30	; 0x1e
    1748:	8f 3f       	cpi	r24, 0xFF	; 255
    174a:	09 f4       	brne	.+2      	; 0x174e <xQueueReceive+0xa2>
    174c:	16 8e       	std	Z+30, r1	; 0x1e
    174e:	0f 90       	pop	r0
    1750:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1752:	be 01       	movw	r22, r28
    1754:	6c 5f       	subi	r22, 0xFC	; 252
    1756:	7f 4f       	sbci	r23, 0xFF	; 255
    1758:	ce 01       	movw	r24, r28
    175a:	01 96       	adiw	r24, 0x01	; 1
    175c:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <xTaskCheckForTimeOut>
    1760:	81 11       	cpse	r24, r1
    1762:	1c c0       	rjmp	.+56     	; 0x179c <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1764:	c8 01       	movw	r24, r16
    1766:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <prvIsQueueEmpty>
    176a:	88 23       	and	r24, r24
    176c:	89 f0       	breq	.+34     	; 0x1790 <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    176e:	6c 81       	ldd	r22, Y+4	; 0x04
    1770:	7d 81       	ldd	r23, Y+5	; 0x05
    1772:	c5 01       	movw	r24, r10
    1774:	0e 94 36 06 	call	0xc6c	; 0xc6c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1778:	c8 01       	movw	r24, r16
    177a:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    177e:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>
    1782:	88 23       	and	r24, r24
    1784:	11 f0       	breq	.+4      	; 0x178a <xQueueReceive+0xde>
    1786:	81 e0       	ldi	r24, 0x01	; 1
    1788:	a8 cf       	rjmp	.-176    	; 0x16da <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    178a:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
    178e:	fb cf       	rjmp	.-10     	; 0x1786 <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1790:	c8 01       	movw	r24, r16
    1792:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1796:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>
    179a:	f5 cf       	rjmp	.-22     	; 0x1786 <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    179c:	c8 01       	movw	r24, r16
    179e:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    17a2:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17a6:	c8 01       	movw	r24, r16
    17a8:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <prvIsQueueEmpty>
    17ac:	88 23       	and	r24, r24
    17ae:	59 f3       	breq	.-42     	; 0x1786 <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    17b0:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    17b2:	0f 90       	pop	r0
    17b4:	0f 90       	pop	r0
    17b6:	0f 90       	pop	r0
    17b8:	0f 90       	pop	r0
    17ba:	0f 90       	pop	r0
    17bc:	df 91       	pop	r29
    17be:	cf 91       	pop	r28
    17c0:	1f 91       	pop	r17
    17c2:	0f 91       	pop	r16
    17c4:	ff 90       	pop	r15
    17c6:	df 90       	pop	r13
    17c8:	cf 90       	pop	r12
    17ca:	bf 90       	pop	r11
    17cc:	af 90       	pop	r10
    17ce:	08 95       	ret

000017d0 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    17d0:	ef 92       	push	r14
    17d2:	ff 92       	push	r15
    17d4:	0f 93       	push	r16
    17d6:	1f 93       	push	r17
    17d8:	cf 93       	push	r28
    17da:	df 93       	push	r29
    17dc:	00 d0       	rcall	.+0      	; 0x17de <xQueueSemaphoreTake+0xe>
    17de:	00 d0       	rcall	.+0      	; 0x17e0 <xQueueSemaphoreTake+0x10>
    17e0:	1f 92       	push	r1
    17e2:	cd b7       	in	r28, 0x3d	; 61
    17e4:	de b7       	in	r29, 0x3e	; 62
    17e6:	8c 01       	movw	r16, r24
    17e8:	7d 83       	std	Y+5, r23	; 0x05
    17ea:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    17ec:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17ee:	78 01       	movw	r14, r16
    17f0:	81 e1       	ldi	r24, 0x11	; 17
    17f2:	e8 0e       	add	r14, r24
    17f4:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    17f6:	0f b6       	in	r0, 0x3f	; 63
    17f8:	f8 94       	cli
    17fa:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    17fc:	f8 01       	movw	r30, r16
    17fe:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1800:	88 23       	and	r24, r24
    1802:	81 f0       	breq	.+32     	; 0x1824 <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1804:	81 50       	subi	r24, 0x01	; 1
    1806:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1808:	80 85       	ldd	r24, Z+8	; 0x08
    180a:	88 23       	and	r24, r24
    180c:	39 f0       	breq	.+14     	; 0x181c <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    180e:	c8 01       	movw	r24, r16
    1810:	08 96       	adiw	r24, 0x08	; 8
    1812:	0e 94 5f 06 	call	0xcbe	; 0xcbe <xTaskRemoveFromEventList>
    1816:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1818:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    181c:	0f 90       	pop	r0
    181e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1820:	81 e0       	ldi	r24, 0x01	; 1
    1822:	50 c0       	rjmp	.+160    	; 0x18c4 <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1824:	2c 81       	ldd	r18, Y+4	; 0x04
    1826:	3d 81       	ldd	r19, Y+5	; 0x05
    1828:	23 2b       	or	r18, r19
    182a:	19 f4       	brne	.+6      	; 0x1832 <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    182c:	0f 90       	pop	r0
    182e:	0f be       	out	0x3f, r0	; 63
    1830:	48 c0       	rjmp	.+144    	; 0x18c2 <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1832:	91 11       	cpse	r25, r1
    1834:	04 c0       	rjmp	.+8      	; 0x183e <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1836:	ce 01       	movw	r24, r28
    1838:	01 96       	adiw	r24, 0x01	; 1
    183a:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    183e:	0f 90       	pop	r0
    1840:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1842:	0e 94 15 04 	call	0x82a	; 0x82a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1846:	0f b6       	in	r0, 0x3f	; 63
    1848:	f8 94       	cli
    184a:	0f 92       	push	r0
    184c:	f8 01       	movw	r30, r16
    184e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1850:	8f 3f       	cpi	r24, 0xFF	; 255
    1852:	09 f4       	brne	.+2      	; 0x1856 <xQueueSemaphoreTake+0x86>
    1854:	15 8e       	std	Z+29, r1	; 0x1d
    1856:	f8 01       	movw	r30, r16
    1858:	86 8d       	ldd	r24, Z+30	; 0x1e
    185a:	8f 3f       	cpi	r24, 0xFF	; 255
    185c:	09 f4       	brne	.+2      	; 0x1860 <xQueueSemaphoreTake+0x90>
    185e:	16 8e       	std	Z+30, r1	; 0x1e
    1860:	0f 90       	pop	r0
    1862:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1864:	be 01       	movw	r22, r28
    1866:	6c 5f       	subi	r22, 0xFC	; 252
    1868:	7f 4f       	sbci	r23, 0xFF	; 255
    186a:	ce 01       	movw	r24, r28
    186c:	01 96       	adiw	r24, 0x01	; 1
    186e:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <xTaskCheckForTimeOut>
    1872:	81 11       	cpse	r24, r1
    1874:	1c c0       	rjmp	.+56     	; 0x18ae <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1876:	c8 01       	movw	r24, r16
    1878:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <prvIsQueueEmpty>
    187c:	88 23       	and	r24, r24
    187e:	89 f0       	breq	.+34     	; 0x18a2 <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1880:	6c 81       	ldd	r22, Y+4	; 0x04
    1882:	7d 81       	ldd	r23, Y+5	; 0x05
    1884:	c7 01       	movw	r24, r14
    1886:	0e 94 36 06 	call	0xc6c	; 0xc6c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    188a:	c8 01       	movw	r24, r16
    188c:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1890:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>
    1894:	88 23       	and	r24, r24
    1896:	11 f0       	breq	.+4      	; 0x189c <xQueueSemaphoreTake+0xcc>
    1898:	91 e0       	ldi	r25, 0x01	; 1
    189a:	ad cf       	rjmp	.-166    	; 0x17f6 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    189c:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
    18a0:	fb cf       	rjmp	.-10     	; 0x1898 <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    18a2:	c8 01       	movw	r24, r16
    18a4:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18a8:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>
    18ac:	f5 cf       	rjmp	.-22     	; 0x1898 <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    18ae:	c8 01       	movw	r24, r16
    18b0:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18b4:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18b8:	c8 01       	movw	r24, r16
    18ba:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <prvIsQueueEmpty>
    18be:	88 23       	and	r24, r24
    18c0:	59 f3       	breq	.-42     	; 0x1898 <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    18c2:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    18c4:	0f 90       	pop	r0
    18c6:	0f 90       	pop	r0
    18c8:	0f 90       	pop	r0
    18ca:	0f 90       	pop	r0
    18cc:	0f 90       	pop	r0
    18ce:	df 91       	pop	r29
    18d0:	cf 91       	pop	r28
    18d2:	1f 91       	pop	r17
    18d4:	0f 91       	pop	r16
    18d6:	ff 90       	pop	r15
    18d8:	ef 90       	pop	r14
    18da:	08 95       	ret

000018dc <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    18dc:	cf 92       	push	r12
    18de:	df 92       	push	r13
    18e0:	ef 92       	push	r14
    18e2:	ff 92       	push	r15
    18e4:	0f 93       	push	r16
    18e6:	1f 93       	push	r17
    18e8:	cf 93       	push	r28
    18ea:	df 93       	push	r29
    18ec:	00 d0       	rcall	.+0      	; 0x18ee <xQueuePeek+0x12>
    18ee:	00 d0       	rcall	.+0      	; 0x18f0 <xQueuePeek+0x14>
    18f0:	1f 92       	push	r1
    18f2:	cd b7       	in	r28, 0x3d	; 61
    18f4:	de b7       	in	r29, 0x3e	; 62
    18f6:	8c 01       	movw	r16, r24
    18f8:	7b 01       	movw	r14, r22
    18fa:	5d 83       	std	Y+5, r21	; 0x05
    18fc:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    18fe:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1900:	68 01       	movw	r12, r16
    1902:	91 e1       	ldi	r25, 0x11	; 17
    1904:	c9 0e       	add	r12, r25
    1906:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1908:	0f b6       	in	r0, 0x3f	; 63
    190a:	f8 94       	cli
    190c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    190e:	f8 01       	movw	r30, r16
    1910:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1912:	99 23       	and	r25, r25
    1914:	b9 f0       	breq	.+46     	; 0x1944 <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1916:	c6 80       	ldd	r12, Z+6	; 0x06
    1918:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    191a:	b7 01       	movw	r22, r14
    191c:	c8 01       	movw	r24, r16
    191e:	0e 94 af 09 	call	0x135e	; 0x135e <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1922:	f8 01       	movw	r30, r16
    1924:	d7 82       	std	Z+7, r13	; 0x07
    1926:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1928:	81 89       	ldd	r24, Z+17	; 0x11
    192a:	88 23       	and	r24, r24
    192c:	39 f0       	breq	.+14     	; 0x193c <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    192e:	c8 01       	movw	r24, r16
    1930:	41 96       	adiw	r24, 0x11	; 17
    1932:	0e 94 5f 06 	call	0xcbe	; 0xcbe <xTaskRemoveFromEventList>
    1936:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1938:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    193c:	0f 90       	pop	r0
    193e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1940:	81 e0       	ldi	r24, 0x01	; 1
    1942:	50 c0       	rjmp	.+160    	; 0x19e4 <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1944:	2c 81       	ldd	r18, Y+4	; 0x04
    1946:	3d 81       	ldd	r19, Y+5	; 0x05
    1948:	23 2b       	or	r18, r19
    194a:	19 f4       	brne	.+6      	; 0x1952 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    194c:	0f 90       	pop	r0
    194e:	0f be       	out	0x3f, r0	; 63
    1950:	48 c0       	rjmp	.+144    	; 0x19e2 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1952:	81 11       	cpse	r24, r1
    1954:	04 c0       	rjmp	.+8      	; 0x195e <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1956:	ce 01       	movw	r24, r28
    1958:	01 96       	adiw	r24, 0x01	; 1
    195a:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    195e:	0f 90       	pop	r0
    1960:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1962:	0e 94 15 04 	call	0x82a	; 0x82a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1966:	0f b6       	in	r0, 0x3f	; 63
    1968:	f8 94       	cli
    196a:	0f 92       	push	r0
    196c:	f8 01       	movw	r30, r16
    196e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1970:	8f 3f       	cpi	r24, 0xFF	; 255
    1972:	09 f4       	brne	.+2      	; 0x1976 <xQueuePeek+0x9a>
    1974:	15 8e       	std	Z+29, r1	; 0x1d
    1976:	f8 01       	movw	r30, r16
    1978:	86 8d       	ldd	r24, Z+30	; 0x1e
    197a:	8f 3f       	cpi	r24, 0xFF	; 255
    197c:	09 f4       	brne	.+2      	; 0x1980 <xQueuePeek+0xa4>
    197e:	16 8e       	std	Z+30, r1	; 0x1e
    1980:	0f 90       	pop	r0
    1982:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1984:	be 01       	movw	r22, r28
    1986:	6c 5f       	subi	r22, 0xFC	; 252
    1988:	7f 4f       	sbci	r23, 0xFF	; 255
    198a:	ce 01       	movw	r24, r28
    198c:	01 96       	adiw	r24, 0x01	; 1
    198e:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <xTaskCheckForTimeOut>
    1992:	81 11       	cpse	r24, r1
    1994:	1c c0       	rjmp	.+56     	; 0x19ce <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1996:	c8 01       	movw	r24, r16
    1998:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <prvIsQueueEmpty>
    199c:	88 23       	and	r24, r24
    199e:	89 f0       	breq	.+34     	; 0x19c2 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19a0:	6c 81       	ldd	r22, Y+4	; 0x04
    19a2:	7d 81       	ldd	r23, Y+5	; 0x05
    19a4:	c6 01       	movw	r24, r12
    19a6:	0e 94 36 06 	call	0xc6c	; 0xc6c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    19aa:	c8 01       	movw	r24, r16
    19ac:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    19b0:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>
    19b4:	88 23       	and	r24, r24
    19b6:	11 f0       	breq	.+4      	; 0x19bc <xQueuePeek+0xe0>
    19b8:	81 e0       	ldi	r24, 0x01	; 1
    19ba:	a6 cf       	rjmp	.-180    	; 0x1908 <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    19bc:	0e 94 8b 11 	call	0x2316	; 0x2316 <vPortYield>
    19c0:	fb cf       	rjmp	.-10     	; 0x19b8 <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    19c2:	c8 01       	movw	r24, r16
    19c4:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19c8:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>
    19cc:	f5 cf       	rjmp	.-22     	; 0x19b8 <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    19ce:	c8 01       	movw	r24, r16
    19d0:	0e 94 c9 09 	call	0x1392	; 0x1392 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19d4:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    19d8:	c8 01       	movw	r24, r16
    19da:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <prvIsQueueEmpty>
    19de:	88 23       	and	r24, r24
    19e0:	59 f3       	breq	.-42     	; 0x19b8 <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    19e2:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    19e4:	0f 90       	pop	r0
    19e6:	0f 90       	pop	r0
    19e8:	0f 90       	pop	r0
    19ea:	0f 90       	pop	r0
    19ec:	0f 90       	pop	r0
    19ee:	df 91       	pop	r29
    19f0:	cf 91       	pop	r28
    19f2:	1f 91       	pop	r17
    19f4:	0f 91       	pop	r16
    19f6:	ff 90       	pop	r15
    19f8:	ef 90       	pop	r14
    19fa:	df 90       	pop	r13
    19fc:	cf 90       	pop	r12
    19fe:	08 95       	ret

00001a00 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1a00:	ef 92       	push	r14
    1a02:	ff 92       	push	r15
    1a04:	0f 93       	push	r16
    1a06:	1f 93       	push	r17
    1a08:	cf 93       	push	r28
    1a0a:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a0c:	fc 01       	movw	r30, r24
    1a0e:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a10:	00 23       	and	r16, r16
    1a12:	e9 f0       	breq	.+58     	; 0x1a4e <xQueueReceiveFromISR+0x4e>
    1a14:	7a 01       	movw	r14, r20
    1a16:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1a18:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a1a:	0e 94 af 09 	call	0x135e	; 0x135e <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1a1e:	01 50       	subi	r16, 0x01	; 1
    1a20:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1a22:	1f 3f       	cpi	r17, 0xFF	; 255
    1a24:	81 f4       	brne	.+32     	; 0x1a46 <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a26:	88 85       	ldd	r24, Y+8	; 0x08
    1a28:	88 23       	and	r24, r24
    1a2a:	79 f0       	breq	.+30     	; 0x1a4a <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a2c:	ce 01       	movw	r24, r28
    1a2e:	08 96       	adiw	r24, 0x08	; 8
    1a30:	0e 94 5f 06 	call	0xcbe	; 0xcbe <xTaskRemoveFromEventList>
    1a34:	88 23       	and	r24, r24
    1a36:	49 f0       	breq	.+18     	; 0x1a4a <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1a38:	e1 14       	cp	r14, r1
    1a3a:	f1 04       	cpc	r15, r1
    1a3c:	31 f0       	breq	.+12     	; 0x1a4a <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1a3e:	81 e0       	ldi	r24, 0x01	; 1
    1a40:	f7 01       	movw	r30, r14
    1a42:	80 83       	st	Z, r24
    1a44:	05 c0       	rjmp	.+10     	; 0x1a50 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1a46:	1f 5f       	subi	r17, 0xFF	; 255
    1a48:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1a4a:	81 e0       	ldi	r24, 0x01	; 1
    1a4c:	01 c0       	rjmp	.+2      	; 0x1a50 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1a4e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a50:	df 91       	pop	r29
    1a52:	cf 91       	pop	r28
    1a54:	1f 91       	pop	r17
    1a56:	0f 91       	pop	r16
    1a58:	ff 90       	pop	r15
    1a5a:	ef 90       	pop	r14
    1a5c:	08 95       	ret

00001a5e <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1a5e:	0f 93       	push	r16
    1a60:	1f 93       	push	r17
    1a62:	cf 93       	push	r28
    1a64:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a66:	fc 01       	movw	r30, r24
    1a68:	22 8d       	ldd	r18, Z+26	; 0x1a
    1a6a:	22 23       	and	r18, r18
    1a6c:	49 f0       	breq	.+18     	; 0x1a80 <xQueuePeekFromISR+0x22>
    1a6e:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1a70:	06 81       	ldd	r16, Z+6	; 0x06
    1a72:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a74:	0e 94 af 09 	call	0x135e	; 0x135e <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1a78:	1f 83       	std	Y+7, r17	; 0x07
    1a7a:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1a7c:	81 e0       	ldi	r24, 0x01	; 1
    1a7e:	01 c0       	rjmp	.+2      	; 0x1a82 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1a80:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a82:	df 91       	pop	r29
    1a84:	cf 91       	pop	r28
    1a86:	1f 91       	pop	r17
    1a88:	0f 91       	pop	r16
    1a8a:	08 95       	ret

00001a8c <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1a8c:	0f b6       	in	r0, 0x3f	; 63
    1a8e:	f8 94       	cli
    1a90:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1a92:	fc 01       	movw	r30, r24
    1a94:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1a96:	0f 90       	pop	r0
    1a98:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1a9a:	08 95       	ret

00001a9c <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1a9c:	0f b6       	in	r0, 0x3f	; 63
    1a9e:	f8 94       	cli
    1aa0:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1aa2:	fc 01       	movw	r30, r24
    1aa4:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1aa6:	0f 90       	pop	r0
    1aa8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1aaa:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1aac:	82 1b       	sub	r24, r18
    1aae:	08 95       	ret

00001ab0 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1ab0:	fc 01       	movw	r30, r24
    1ab2:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ab4:	08 95       	ret

00001ab6 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1ab6:	0c 94 cf 10 	jmp	0x219e	; 0x219e <vPortFree>

00001aba <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1aba:	fc 01       	movw	r30, r24
    1abc:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1abe:	81 e0       	ldi	r24, 0x01	; 1
    1ac0:	91 11       	cpse	r25, r1
    1ac2:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1ac4:	08 95       	ret

00001ac6 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1ac6:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1ac8:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1aca:	81 e0       	ldi	r24, 0x01	; 1
    1acc:	23 8d       	ldd	r18, Z+27	; 0x1b
    1ace:	29 13       	cpse	r18, r25
    1ad0:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1ad2:	08 95       	ret

00001ad4 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1ad4:	cf 93       	push	r28
    1ad6:	df 93       	push	r29
    1ad8:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1ada:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1adc:	0f b6       	in	r0, 0x3f	; 63
    1ade:	f8 94       	cli
    1ae0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1ae2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ae4:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1ae6:	0f 90       	pop	r0
    1ae8:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1aea:	89 13       	cpse	r24, r25
    1aec:	0f c0       	rjmp	.+30     	; 0x1b0c <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1aee:	41 15       	cp	r20, r1
    1af0:	51 05       	cpc	r21, r1
    1af2:	49 f0       	breq	.+18     	; 0x1b06 <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1af4:	be 01       	movw	r22, r28
    1af6:	68 5f       	subi	r22, 0xF8	; 248
    1af8:	7f 4f       	sbci	r23, 0xFF	; 255
    1afa:	ca 01       	movw	r24, r20
    1afc:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1b00:	78 94       	sei
					return errQUEUE_BLOCKED;
    1b02:	8c ef       	ldi	r24, 0xFC	; 252
    1b04:	1b c0       	rjmp	.+54     	; 0x1b3c <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1b06:	78 94       	sei
					return errQUEUE_FULL;
    1b08:	80 e0       	ldi	r24, 0x00	; 0
    1b0a:	18 c0       	rjmp	.+48     	; 0x1b3c <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1b0c:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1b0e:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1b10:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b12:	89 17       	cp	r24, r25
    1b14:	88 f4       	brcc	.+34     	; 0x1b38 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1b16:	40 e0       	ldi	r20, 0x00	; 0
    1b18:	ce 01       	movw	r24, r28
    1b1a:	0e 94 67 09 	call	0x12ce	; 0x12ce <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b1e:	89 89       	ldd	r24, Y+17	; 0x11
    1b20:	81 11       	cpse	r24, r1
    1b22:	02 c0       	rjmp	.+4      	; 0x1b28 <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1b24:	81 e0       	ldi	r24, 0x01	; 1
    1b26:	09 c0       	rjmp	.+18     	; 0x1b3a <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b28:	ce 01       	movw	r24, r28
    1b2a:	41 96       	adiw	r24, 0x11	; 17
    1b2c:	0e 94 78 10 	call	0x20f0	; 0x20f0 <xCoRoutineRemoveFromEventList>
    1b30:	88 23       	and	r24, r24
    1b32:	c1 f3       	breq	.-16     	; 0x1b24 <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1b34:	8b ef       	ldi	r24, 0xFB	; 251
    1b36:	01 c0       	rjmp	.+2      	; 0x1b3a <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1b38:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1b3a:	78 94       	sei

		return xReturn;
	}
    1b3c:	df 91       	pop	r29
    1b3e:	cf 91       	pop	r28
    1b40:	08 95       	ret

00001b42 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1b42:	cf 93       	push	r28
    1b44:	df 93       	push	r29
    1b46:	ec 01       	movw	r28, r24
    1b48:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1b4a:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1b4c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b4e:	81 11       	cpse	r24, r1
    1b50:	0f c0       	rjmp	.+30     	; 0x1b70 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1b52:	41 15       	cp	r20, r1
    1b54:	51 05       	cpc	r21, r1
    1b56:	49 f0       	breq	.+18     	; 0x1b6a <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1b58:	be 01       	movw	r22, r28
    1b5a:	6f 5e       	subi	r22, 0xEF	; 239
    1b5c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b5e:	ca 01       	movw	r24, r20
    1b60:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1b64:	78 94       	sei
					return errQUEUE_BLOCKED;
    1b66:	8c ef       	ldi	r24, 0xFC	; 252
    1b68:	30 c0       	rjmp	.+96     	; 0x1bca <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1b6a:	78 94       	sei
					return errQUEUE_FULL;
    1b6c:	80 e0       	ldi	r24, 0x00	; 0
    1b6e:	2d c0       	rjmp	.+90     	; 0x1bca <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1b70:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1b72:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b74:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b76:	88 23       	and	r24, r24
    1b78:	31 f1       	breq	.+76     	; 0x1bc6 <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1b7a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1b7c:	50 e0       	ldi	r21, 0x00	; 0
    1b7e:	2e 81       	ldd	r18, Y+6	; 0x06
    1b80:	3f 81       	ldd	r19, Y+7	; 0x07
    1b82:	24 0f       	add	r18, r20
    1b84:	35 1f       	adc	r19, r21
    1b86:	3f 83       	std	Y+7, r19	; 0x07
    1b88:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1b8a:	8c 81       	ldd	r24, Y+4	; 0x04
    1b8c:	9d 81       	ldd	r25, Y+5	; 0x05
    1b8e:	28 17       	cp	r18, r24
    1b90:	39 07       	cpc	r19, r25
    1b92:	20 f0       	brcs	.+8      	; 0x1b9c <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1b94:	88 81       	ld	r24, Y
    1b96:	99 81       	ldd	r25, Y+1	; 0x01
    1b98:	9f 83       	std	Y+7, r25	; 0x07
    1b9a:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1b9c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1b9e:	91 50       	subi	r25, 0x01	; 1
    1ba0:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1ba2:	6e 81       	ldd	r22, Y+6	; 0x06
    1ba4:	7f 81       	ldd	r23, Y+7	; 0x07
    1ba6:	cf 01       	movw	r24, r30
    1ba8:	0e 94 a4 12 	call	0x2548	; 0x2548 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1bac:	88 85       	ldd	r24, Y+8	; 0x08
    1bae:	81 11       	cpse	r24, r1
    1bb0:	02 c0       	rjmp	.+4      	; 0x1bb6 <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1bb2:	81 e0       	ldi	r24, 0x01	; 1
    1bb4:	09 c0       	rjmp	.+18     	; 0x1bc8 <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bb6:	ce 01       	movw	r24, r28
    1bb8:	08 96       	adiw	r24, 0x08	; 8
    1bba:	0e 94 78 10 	call	0x20f0	; 0x20f0 <xCoRoutineRemoveFromEventList>
    1bbe:	88 23       	and	r24, r24
    1bc0:	c1 f3       	breq	.-16     	; 0x1bb2 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1bc2:	8b ef       	ldi	r24, 0xFB	; 251
    1bc4:	01 c0       	rjmp	.+2      	; 0x1bc8 <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1bc6:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1bc8:	78 94       	sei

		return xReturn;
	}
    1bca:	df 91       	pop	r29
    1bcc:	cf 91       	pop	r28
    1bce:	08 95       	ret

00001bd0 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1bd0:	0f 93       	push	r16
    1bd2:	1f 93       	push	r17
    1bd4:	cf 93       	push	r28
    1bd6:	8c 01       	movw	r16, r24
    1bd8:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1bda:	fc 01       	movw	r30, r24
    1bdc:	92 8d       	ldd	r25, Z+26	; 0x1a
    1bde:	83 8d       	ldd	r24, Z+27	; 0x1b
    1be0:	98 17       	cp	r25, r24
    1be2:	10 f0       	brcs	.+4      	; 0x1be8 <xQueueCRSendFromISR+0x18>
    1be4:	4c 2f       	mov	r20, r28
    1be6:	12 c0       	rjmp	.+36     	; 0x1c0c <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1be8:	40 e0       	ldi	r20, 0x00	; 0
    1bea:	c8 01       	movw	r24, r16
    1bec:	0e 94 67 09 	call	0x12ce	; 0x12ce <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1bf0:	c1 11       	cpse	r28, r1
    1bf2:	f8 cf       	rjmp	.-16     	; 0x1be4 <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1bf4:	f8 01       	movw	r30, r16
    1bf6:	81 89       	ldd	r24, Z+17	; 0x11
    1bf8:	88 23       	and	r24, r24
    1bfa:	39 f0       	breq	.+14     	; 0x1c0a <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1bfc:	c8 01       	movw	r24, r16
    1bfe:	41 96       	adiw	r24, 0x11	; 17
    1c00:	0e 94 78 10 	call	0x20f0	; 0x20f0 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1c04:	41 e0       	ldi	r20, 0x01	; 1
    1c06:	81 11       	cpse	r24, r1
    1c08:	01 c0       	rjmp	.+2      	; 0x1c0c <xQueueCRSendFromISR+0x3c>
    1c0a:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1c0c:	84 2f       	mov	r24, r20
    1c0e:	cf 91       	pop	r28
    1c10:	1f 91       	pop	r17
    1c12:	0f 91       	pop	r16
    1c14:	08 95       	ret

00001c16 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1c16:	0f 93       	push	r16
    1c18:	1f 93       	push	r17
    1c1a:	cf 93       	push	r28
    1c1c:	df 93       	push	r29
    1c1e:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c20:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c22:	88 23       	and	r24, r24
    1c24:	79 f1       	breq	.+94     	; 0x1c84 <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1c26:	24 8d       	ldd	r18, Z+28	; 0x1c
    1c28:	30 e0       	ldi	r19, 0x00	; 0
    1c2a:	a6 81       	ldd	r26, Z+6	; 0x06
    1c2c:	b7 81       	ldd	r27, Z+7	; 0x07
    1c2e:	a2 0f       	add	r26, r18
    1c30:	b3 1f       	adc	r27, r19
    1c32:	b7 83       	std	Z+7, r27	; 0x07
    1c34:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1c36:	84 81       	ldd	r24, Z+4	; 0x04
    1c38:	95 81       	ldd	r25, Z+5	; 0x05
    1c3a:	a8 17       	cp	r26, r24
    1c3c:	b9 07       	cpc	r27, r25
    1c3e:	20 f0       	brcs	.+8      	; 0x1c48 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1c40:	80 81       	ld	r24, Z
    1c42:	91 81       	ldd	r25, Z+1	; 0x01
    1c44:	97 83       	std	Z+7, r25	; 0x07
    1c46:	86 83       	std	Z+6, r24	; 0x06
    1c48:	8a 01       	movw	r16, r20
    1c4a:	cb 01       	movw	r24, r22
    1c4c:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1c4e:	42 8d       	ldd	r20, Z+26	; 0x1a
    1c50:	41 50       	subi	r20, 0x01	; 1
    1c52:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1c54:	66 81       	ldd	r22, Z+6	; 0x06
    1c56:	77 81       	ldd	r23, Z+7	; 0x07
    1c58:	a9 01       	movw	r20, r18
    1c5a:	0e 94 a4 12 	call	0x2548	; 0x2548 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1c5e:	f8 01       	movw	r30, r16
    1c60:	80 81       	ld	r24, Z
    1c62:	88 23       	and	r24, r24
    1c64:	11 f0       	breq	.+4      	; 0x1c6a <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1c66:	81 e0       	ldi	r24, 0x01	; 1
    1c68:	0e c0       	rjmp	.+28     	; 0x1c86 <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c6a:	88 85       	ldd	r24, Y+8	; 0x08
    1c6c:	88 23       	and	r24, r24
    1c6e:	d9 f3       	breq	.-10     	; 0x1c66 <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c70:	ce 01       	movw	r24, r28
    1c72:	08 96       	adiw	r24, 0x08	; 8
    1c74:	0e 94 78 10 	call	0x20f0	; 0x20f0 <xCoRoutineRemoveFromEventList>
    1c78:	88 23       	and	r24, r24
    1c7a:	a9 f3       	breq	.-22     	; 0x1c66 <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1c7c:	81 e0       	ldi	r24, 0x01	; 1
    1c7e:	f8 01       	movw	r30, r16
    1c80:	80 83       	st	Z, r24
    1c82:	01 c0       	rjmp	.+2      	; 0x1c86 <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1c84:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1c86:	df 91       	pop	r29
    1c88:	cf 91       	pop	r28
    1c8a:	1f 91       	pop	r17
    1c8c:	0f 91       	pop	r16
    1c8e:	08 95       	ret

00001c90 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1c90:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c92:	03 96       	adiw	r24, 0x03	; 3
    1c94:	92 83       	std	Z+2, r25	; 0x02
    1c96:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1c98:	2f ef       	ldi	r18, 0xFF	; 255
    1c9a:	3f ef       	ldi	r19, 0xFF	; 255
    1c9c:	34 83       	std	Z+4, r19	; 0x04
    1c9e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1ca0:	96 83       	std	Z+6, r25	; 0x06
    1ca2:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1ca4:	90 87       	std	Z+8, r25	; 0x08
    1ca6:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1ca8:	10 82       	st	Z, r1
    1caa:	08 95       	ret

00001cac <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1cac:	fc 01       	movw	r30, r24
    1cae:	11 86       	std	Z+9, r1	; 0x09
    1cb0:	10 86       	std	Z+8, r1	; 0x08
    1cb2:	08 95       	ret

00001cb4 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1cb4:	cf 93       	push	r28
    1cb6:	df 93       	push	r29
    1cb8:	9c 01       	movw	r18, r24
    1cba:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1cbc:	dc 01       	movw	r26, r24
    1cbe:	11 96       	adiw	r26, 0x01	; 1
    1cc0:	cd 91       	ld	r28, X+
    1cc2:	dc 91       	ld	r29, X
    1cc4:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1cc6:	d3 83       	std	Z+3, r29	; 0x03
    1cc8:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1cca:	8c 81       	ldd	r24, Y+4	; 0x04
    1ccc:	9d 81       	ldd	r25, Y+5	; 0x05
    1cce:	95 83       	std	Z+5, r25	; 0x05
    1cd0:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1cd2:	8c 81       	ldd	r24, Y+4	; 0x04
    1cd4:	9d 81       	ldd	r25, Y+5	; 0x05
    1cd6:	dc 01       	movw	r26, r24
    1cd8:	13 96       	adiw	r26, 0x03	; 3
    1cda:	7c 93       	st	X, r23
    1cdc:	6e 93       	st	-X, r22
    1cde:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1ce0:	7d 83       	std	Y+5, r23	; 0x05
    1ce2:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1ce4:	31 87       	std	Z+9, r19	; 0x09
    1ce6:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1ce8:	f9 01       	movw	r30, r18
    1cea:	80 81       	ld	r24, Z
    1cec:	8f 5f       	subi	r24, 0xFF	; 255
    1cee:	80 83       	st	Z, r24
}
    1cf0:	df 91       	pop	r29
    1cf2:	cf 91       	pop	r28
    1cf4:	08 95       	ret

00001cf6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1cf6:	0f 93       	push	r16
    1cf8:	1f 93       	push	r17
    1cfa:	cf 93       	push	r28
    1cfc:	df 93       	push	r29
    1cfe:	8c 01       	movw	r16, r24
    1d00:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1d02:	80 81       	ld	r24, Z
    1d04:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1d06:	8f 3f       	cpi	r24, 0xFF	; 255
    1d08:	2f ef       	ldi	r18, 0xFF	; 255
    1d0a:	92 07       	cpc	r25, r18
    1d0c:	21 f4       	brne	.+8      	; 0x1d16 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1d0e:	e8 01       	movw	r28, r16
    1d10:	af 81       	ldd	r26, Y+7	; 0x07
    1d12:	b8 85       	ldd	r27, Y+8	; 0x08
    1d14:	0e c0       	rjmp	.+28     	; 0x1d32 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1d16:	d8 01       	movw	r26, r16
    1d18:	13 96       	adiw	r26, 0x03	; 3
    1d1a:	12 96       	adiw	r26, 0x02	; 2
    1d1c:	2d 91       	ld	r18, X+
    1d1e:	3c 91       	ld	r19, X
    1d20:	13 97       	sbiw	r26, 0x03	; 3
    1d22:	e9 01       	movw	r28, r18
    1d24:	48 81       	ld	r20, Y
    1d26:	59 81       	ldd	r21, Y+1	; 0x01
    1d28:	84 17       	cp	r24, r20
    1d2a:	95 07       	cpc	r25, r21
    1d2c:	10 f0       	brcs	.+4      	; 0x1d32 <vListInsert+0x3c>
    1d2e:	d9 01       	movw	r26, r18
    1d30:	f4 cf       	rjmp	.-24     	; 0x1d1a <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1d32:	12 96       	adiw	r26, 0x02	; 2
    1d34:	8d 91       	ld	r24, X+
    1d36:	9c 91       	ld	r25, X
    1d38:	13 97       	sbiw	r26, 0x03	; 3
    1d3a:	93 83       	std	Z+3, r25	; 0x03
    1d3c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1d3e:	ec 01       	movw	r28, r24
    1d40:	fd 83       	std	Y+5, r31	; 0x05
    1d42:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1d44:	b5 83       	std	Z+5, r27	; 0x05
    1d46:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1d48:	13 96       	adiw	r26, 0x03	; 3
    1d4a:	fc 93       	st	X, r31
    1d4c:	ee 93       	st	-X, r30
    1d4e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1d50:	11 87       	std	Z+9, r17	; 0x09
    1d52:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1d54:	f8 01       	movw	r30, r16
    1d56:	80 81       	ld	r24, Z
    1d58:	8f 5f       	subi	r24, 0xFF	; 255
    1d5a:	80 83       	st	Z, r24
}
    1d5c:	df 91       	pop	r29
    1d5e:	cf 91       	pop	r28
    1d60:	1f 91       	pop	r17
    1d62:	0f 91       	pop	r16
    1d64:	08 95       	ret

00001d66 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1d66:	cf 93       	push	r28
    1d68:	df 93       	push	r29
    1d6a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1d6c:	a0 85       	ldd	r26, Z+8	; 0x08
    1d6e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1d70:	82 81       	ldd	r24, Z+2	; 0x02
    1d72:	93 81       	ldd	r25, Z+3	; 0x03
    1d74:	24 81       	ldd	r18, Z+4	; 0x04
    1d76:	35 81       	ldd	r19, Z+5	; 0x05
    1d78:	ec 01       	movw	r28, r24
    1d7a:	3d 83       	std	Y+5, r19	; 0x05
    1d7c:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1d7e:	c4 81       	ldd	r28, Z+4	; 0x04
    1d80:	d5 81       	ldd	r29, Z+5	; 0x05
    1d82:	9b 83       	std	Y+3, r25	; 0x03
    1d84:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1d86:	11 96       	adiw	r26, 0x01	; 1
    1d88:	8d 91       	ld	r24, X+
    1d8a:	9c 91       	ld	r25, X
    1d8c:	12 97       	sbiw	r26, 0x02	; 2
    1d8e:	e8 17       	cp	r30, r24
    1d90:	f9 07       	cpc	r31, r25
    1d92:	21 f4       	brne	.+8      	; 0x1d9c <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1d94:	12 96       	adiw	r26, 0x02	; 2
    1d96:	dc 93       	st	X, r29
    1d98:	ce 93       	st	-X, r28
    1d9a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1d9c:	11 86       	std	Z+9, r1	; 0x09
    1d9e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1da0:	8c 91       	ld	r24, X
    1da2:	81 50       	subi	r24, 0x01	; 1
    1da4:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1da6:	8c 91       	ld	r24, X
}
    1da8:	df 91       	pop	r29
    1daa:	cf 91       	pop	r28
    1dac:	08 95       	ret

00001dae <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1dae:	cf 92       	push	r12
    1db0:	df 92       	push	r13
    1db2:	ef 92       	push	r14
    1db4:	ff 92       	push	r15
    1db6:	1f 93       	push	r17
    1db8:	cf 93       	push	r28
    1dba:	df 93       	push	r29
    1dbc:	6c 01       	movw	r12, r24
    1dbe:	16 2f       	mov	r17, r22
    1dc0:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1dc2:	8a e1       	ldi	r24, 0x1A	; 26
    1dc4:	90 e0       	ldi	r25, 0x00	; 0
    1dc6:	0e 94 9d 10 	call	0x213a	; 0x213a <pvPortMalloc>
    1dca:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1dcc:	89 2b       	or	r24, r25
    1dce:	09 f4       	brne	.+2      	; 0x1dd2 <xCoRoutineCreate+0x24>
    1dd0:	57 c0       	rjmp	.+174    	; 0x1e80 <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1dd2:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <pxCurrentCoRoutine>
    1dd6:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <pxCurrentCoRoutine+0x1>
    1dda:	89 2b       	or	r24, r25
    1ddc:	21 f5       	brne	.+72     	; 0x1e26 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1dde:	d0 93 ab 01 	sts	0x01AB, r29	; 0x8001ab <pxCurrentCoRoutine+0x1>
    1de2:	c0 93 aa 01 	sts	0x01AA, r28	; 0x8001aa <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1de6:	82 ed       	ldi	r24, 0xD2	; 210
    1de8:	91 e0       	ldi	r25, 0x01	; 1
    1dea:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
    1dee:	8b ed       	ldi	r24, 0xDB	; 219
    1df0:	91 e0       	ldi	r25, 0x01	; 1
    1df2:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1df6:	89 ec       	ldi	r24, 0xC9	; 201
    1df8:	91 e0       	ldi	r25, 0x01	; 1
    1dfa:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1dfe:	80 ec       	ldi	r24, 0xC0	; 192
    1e00:	91 e0       	ldi	r25, 0x01	; 1
    1e02:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1e06:	83 eb       	ldi	r24, 0xB3	; 179
    1e08:	91 e0       	ldi	r25, 0x01	; 1
    1e0a:	0e 94 48 0e 	call	0x1c90	; 0x1c90 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1e0e:	89 ec       	ldi	r24, 0xC9	; 201
    1e10:	91 e0       	ldi	r25, 0x01	; 1
    1e12:	90 93 bf 01 	sts	0x01BF, r25	; 0x8001bf <pxDelayedCoRoutineList+0x1>
    1e16:	80 93 be 01 	sts	0x01BE, r24	; 0x8001be <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1e1a:	80 ec       	ldi	r24, 0xC0	; 192
    1e1c:	91 e0       	ldi	r25, 0x01	; 1
    1e1e:	90 93 bd 01 	sts	0x01BD, r25	; 0x8001bd <pxOverflowDelayedCoRoutineList+0x1>
    1e22:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <pxOverflowDelayedCoRoutineList>
    1e26:	11 11       	cpse	r17, r1
    1e28:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1e2a:	19 8e       	std	Y+25, r1	; 0x19
    1e2c:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1e2e:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1e30:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1e32:	fe 01       	movw	r30, r28
    1e34:	c1 92       	st	Z+, r12
    1e36:	d1 92       	st	Z+, r13
    1e38:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1e3a:	cf 01       	movw	r24, r30
    1e3c:	0e 94 56 0e 	call	0x1cac	; 0x1cac <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1e40:	ce 01       	movw	r24, r28
    1e42:	0c 96       	adiw	r24, 0x0c	; 12
    1e44:	0e 94 56 0e 	call	0x1cac	; 0x1cac <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1e48:	d9 87       	std	Y+9, r29	; 0x09
    1e4a:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1e4c:	db 8b       	std	Y+19, r29	; 0x13
    1e4e:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    1e50:	82 e0       	ldi	r24, 0x02	; 2
    1e52:	90 e0       	ldi	r25, 0x00	; 0
    1e54:	81 1b       	sub	r24, r17
    1e56:	91 09       	sbc	r25, r1
    1e58:	9d 87       	std	Y+13, r25	; 0x0d
    1e5a:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1e5c:	8e 89       	ldd	r24, Y+22	; 0x16
    1e5e:	90 91 b2 01 	lds	r25, 0x01B2	; 0x8001b2 <uxTopCoRoutineReadyPriority>
    1e62:	98 17       	cp	r25, r24
    1e64:	10 f4       	brcc	.+4      	; 0x1e6a <xCoRoutineCreate+0xbc>
    1e66:	80 93 b2 01 	sts	0x01B2, r24	; 0x8001b2 <uxTopCoRoutineReadyPriority>
    1e6a:	f9 e0       	ldi	r31, 0x09	; 9
    1e6c:	8f 9f       	mul	r24, r31
    1e6e:	c0 01       	movw	r24, r0
    1e70:	11 24       	eor	r1, r1
    1e72:	b7 01       	movw	r22, r14
    1e74:	8e 52       	subi	r24, 0x2E	; 46
    1e76:	9e 4f       	sbci	r25, 0xFE	; 254
    1e78:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>

		xReturn = pdPASS;
    1e7c:	81 e0       	ldi	r24, 0x01	; 1
    1e7e:	01 c0       	rjmp	.+2      	; 0x1e82 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1e80:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    1e82:	df 91       	pop	r29
    1e84:	cf 91       	pop	r28
    1e86:	1f 91       	pop	r17
    1e88:	ff 90       	pop	r15
    1e8a:	ef 90       	pop	r14
    1e8c:	df 90       	pop	r13
    1e8e:	cf 90       	pop	r12
    1e90:	08 95       	ret

00001e92 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    1e92:	0f 93       	push	r16
    1e94:	1f 93       	push	r17
    1e96:	cf 93       	push	r28
    1e98:	df 93       	push	r29
    1e9a:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1e9c:	c0 91 b0 01 	lds	r28, 0x01B0	; 0x8001b0 <xCoRoutineTickCount>
    1ea0:	d0 91 b1 01 	lds	r29, 0x01B1	; 0x8001b1 <xCoRoutineTickCount+0x1>
    1ea4:	c8 0f       	add	r28, r24
    1ea6:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1ea8:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <pxCurrentCoRoutine>
    1eac:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <pxCurrentCoRoutine+0x1>
    1eb0:	02 96       	adiw	r24, 0x02	; 2
    1eb2:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1eb6:	e0 91 aa 01 	lds	r30, 0x01AA	; 0x8001aa <pxCurrentCoRoutine>
    1eba:	f0 91 ab 01 	lds	r31, 0x01AB	; 0x8001ab <pxCurrentCoRoutine+0x1>
    1ebe:	d3 83       	std	Z+3, r29	; 0x03
    1ec0:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1ec2:	80 91 b0 01 	lds	r24, 0x01B0	; 0x8001b0 <xCoRoutineTickCount>
    1ec6:	90 91 b1 01 	lds	r25, 0x01B1	; 0x8001b1 <xCoRoutineTickCount+0x1>
    1eca:	bf 01       	movw	r22, r30
    1ecc:	6e 5f       	subi	r22, 0xFE	; 254
    1ece:	7f 4f       	sbci	r23, 0xFF	; 255
    1ed0:	c8 17       	cp	r28, r24
    1ed2:	d9 07       	cpc	r29, r25
    1ed4:	28 f4       	brcc	.+10     	; 0x1ee0 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1ed6:	80 91 bc 01 	lds	r24, 0x01BC	; 0x8001bc <pxOverflowDelayedCoRoutineList>
    1eda:	90 91 bd 01 	lds	r25, 0x01BD	; 0x8001bd <pxOverflowDelayedCoRoutineList+0x1>
    1ede:	04 c0       	rjmp	.+8      	; 0x1ee8 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1ee0:	80 91 be 01 	lds	r24, 0x01BE	; 0x8001be <pxDelayedCoRoutineList>
    1ee4:	90 91 bf 01 	lds	r25, 0x01BF	; 0x8001bf <pxDelayedCoRoutineList+0x1>
    1ee8:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <vListInsert>
	}

	if( pxEventList )
    1eec:	01 15       	cp	r16, r1
    1eee:	11 05       	cpc	r17, r1
    1ef0:	69 f0       	breq	.+26     	; 0x1f0c <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1ef2:	60 91 aa 01 	lds	r22, 0x01AA	; 0x8001aa <pxCurrentCoRoutine>
    1ef6:	70 91 ab 01 	lds	r23, 0x01AB	; 0x8001ab <pxCurrentCoRoutine+0x1>
    1efa:	64 5f       	subi	r22, 0xF4	; 244
    1efc:	7f 4f       	sbci	r23, 0xFF	; 255
    1efe:	c8 01       	movw	r24, r16
	}
}
    1f00:	df 91       	pop	r29
    1f02:	cf 91       	pop	r28
    1f04:	1f 91       	pop	r17
    1f06:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1f08:	0c 94 7b 0e 	jmp	0x1cf6	; 0x1cf6 <vListInsert>
	}
}
    1f0c:	df 91       	pop	r29
    1f0e:	cf 91       	pop	r28
    1f10:	1f 91       	pop	r17
    1f12:	0f 91       	pop	r16
    1f14:	08 95       	ret

00001f16 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1f16:	ff 92       	push	r15
    1f18:	0f 93       	push	r16
    1f1a:	1f 93       	push	r17
    1f1c:	cf 93       	push	r28
    1f1e:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1f20:	99 e0       	ldi	r25, 0x09	; 9
    1f22:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1f24:	80 91 b3 01 	lds	r24, 0x01B3	; 0x8001b3 <xPendingReadyCoRoutineList>
    1f28:	88 23       	and	r24, r24
    1f2a:	11 f1       	breq	.+68     	; 0x1f70 <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1f2c:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1f2e:	e0 91 b8 01 	lds	r30, 0x01B8	; 0x8001b8 <xPendingReadyCoRoutineList+0x5>
    1f32:	f0 91 b9 01 	lds	r31, 0x01B9	; 0x8001b9 <xPendingReadyCoRoutineList+0x6>
    1f36:	c6 81       	ldd	r28, Z+6	; 0x06
    1f38:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1f3a:	ce 01       	movw	r24, r28
    1f3c:	0c 96       	adiw	r24, 0x0c	; 12
    1f3e:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1f42:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1f44:	8e 01       	movw	r16, r28
    1f46:	0e 5f       	subi	r16, 0xFE	; 254
    1f48:	1f 4f       	sbci	r17, 0xFF	; 255
    1f4a:	c8 01       	movw	r24, r16
    1f4c:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1f50:	8e 89       	ldd	r24, Y+22	; 0x16
    1f52:	90 91 b2 01 	lds	r25, 0x01B2	; 0x8001b2 <uxTopCoRoutineReadyPriority>
    1f56:	98 17       	cp	r25, r24
    1f58:	10 f4       	brcc	.+4      	; 0x1f5e <vCoRoutineSchedule+0x48>
    1f5a:	80 93 b2 01 	sts	0x01B2, r24	; 0x8001b2 <uxTopCoRoutineReadyPriority>
    1f5e:	f8 9e       	mul	r15, r24
    1f60:	c0 01       	movw	r24, r0
    1f62:	11 24       	eor	r1, r1
    1f64:	b8 01       	movw	r22, r16
    1f66:	8e 52       	subi	r24, 0x2E	; 46
    1f68:	9e 4f       	sbci	r25, 0xFE	; 254
    1f6a:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>
    1f6e:	da cf       	rjmp	.-76     	; 0x1f24 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1f70:	0e 94 1b 04 	call	0x836	; 0x836 <xTaskGetTickCount>
    1f74:	20 91 ae 01 	lds	r18, 0x01AE	; 0x8001ae <xLastTickCount>
    1f78:	30 91 af 01 	lds	r19, 0x01AF	; 0x8001af <xLastTickCount+0x1>
    1f7c:	82 1b       	sub	r24, r18
    1f7e:	93 0b       	sbc	r25, r19
    1f80:	90 93 ad 01 	sts	0x01AD, r25	; 0x8001ad <xPassedTicks+0x1>
    1f84:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1f88:	89 e0       	ldi	r24, 0x09	; 9
    1f8a:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1f8c:	20 91 ac 01 	lds	r18, 0x01AC	; 0x8001ac <xPassedTicks>
    1f90:	30 91 ad 01 	lds	r19, 0x01AD	; 0x8001ad <xPassedTicks+0x1>
    1f94:	80 91 b0 01 	lds	r24, 0x01B0	; 0x8001b0 <xCoRoutineTickCount>
    1f98:	90 91 b1 01 	lds	r25, 0x01B1	; 0x8001b1 <xCoRoutineTickCount+0x1>
    1f9c:	21 15       	cp	r18, r1
    1f9e:	31 05       	cpc	r19, r1
    1fa0:	09 f4       	brne	.+2      	; 0x1fa4 <vCoRoutineSchedule+0x8e>
    1fa2:	54 c0       	rjmp	.+168    	; 0x204c <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    1fa4:	01 96       	adiw	r24, 0x01	; 1
    1fa6:	90 93 b1 01 	sts	0x01B1, r25	; 0x8001b1 <xCoRoutineTickCount+0x1>
    1faa:	80 93 b0 01 	sts	0x01B0, r24	; 0x8001b0 <xCoRoutineTickCount>
		xPassedTicks--;
    1fae:	21 50       	subi	r18, 0x01	; 1
    1fb0:	31 09       	sbc	r19, r1
    1fb2:	30 93 ad 01 	sts	0x01AD, r19	; 0x8001ad <xPassedTicks+0x1>
    1fb6:	20 93 ac 01 	sts	0x01AC, r18	; 0x8001ac <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1fba:	89 2b       	or	r24, r25
    1fbc:	09 f0       	breq	.+2      	; 0x1fc0 <vCoRoutineSchedule+0xaa>
    1fbe:	3e c0       	rjmp	.+124    	; 0x203c <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1fc0:	80 91 be 01 	lds	r24, 0x01BE	; 0x8001be <pxDelayedCoRoutineList>
    1fc4:	90 91 bf 01 	lds	r25, 0x01BF	; 0x8001bf <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1fc8:	20 91 bc 01 	lds	r18, 0x01BC	; 0x8001bc <pxOverflowDelayedCoRoutineList>
    1fcc:	30 91 bd 01 	lds	r19, 0x01BD	; 0x8001bd <pxOverflowDelayedCoRoutineList+0x1>
    1fd0:	30 93 bf 01 	sts	0x01BF, r19	; 0x8001bf <pxDelayedCoRoutineList+0x1>
    1fd4:	20 93 be 01 	sts	0x01BE, r18	; 0x8001be <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    1fd8:	90 93 bd 01 	sts	0x01BD, r25	; 0x8001bd <pxOverflowDelayedCoRoutineList+0x1>
    1fdc:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <pxOverflowDelayedCoRoutineList>
    1fe0:	2d c0       	rjmp	.+90     	; 0x203c <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1fe2:	05 80       	ldd	r0, Z+5	; 0x05
    1fe4:	f6 81       	ldd	r31, Z+6	; 0x06
    1fe6:	e0 2d       	mov	r30, r0
    1fe8:	c6 81       	ldd	r28, Z+6	; 0x06
    1fea:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1fec:	2a 81       	ldd	r18, Y+2	; 0x02
    1fee:	3b 81       	ldd	r19, Y+3	; 0x03
    1ff0:	80 91 b0 01 	lds	r24, 0x01B0	; 0x8001b0 <xCoRoutineTickCount>
    1ff4:	90 91 b1 01 	lds	r25, 0x01B1	; 0x8001b1 <xCoRoutineTickCount+0x1>
    1ff8:	82 17       	cp	r24, r18
    1ffa:	93 07       	cpc	r25, r19
    1ffc:	38 f2       	brcs	.-114    	; 0x1f8c <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1ffe:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    2000:	8e 01       	movw	r16, r28
    2002:	0e 5f       	subi	r16, 0xFE	; 254
    2004:	1f 4f       	sbci	r17, 0xFF	; 255
    2006:	c8 01       	movw	r24, r16
    2008:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    200c:	8c 89       	ldd	r24, Y+20	; 0x14
    200e:	9d 89       	ldd	r25, Y+21	; 0x15
    2010:	89 2b       	or	r24, r25
    2012:	21 f0       	breq	.+8      	; 0x201c <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    2014:	ce 01       	movw	r24, r28
    2016:	0c 96       	adiw	r24, 0x0c	; 12
    2018:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    201c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    201e:	8e 89       	ldd	r24, Y+22	; 0x16
    2020:	90 91 b2 01 	lds	r25, 0x01B2	; 0x8001b2 <uxTopCoRoutineReadyPriority>
    2024:	98 17       	cp	r25, r24
    2026:	10 f4       	brcc	.+4      	; 0x202c <vCoRoutineSchedule+0x116>
    2028:	80 93 b2 01 	sts	0x01B2, r24	; 0x8001b2 <uxTopCoRoutineReadyPriority>
    202c:	f8 9e       	mul	r15, r24
    202e:	c0 01       	movw	r24, r0
    2030:	11 24       	eor	r1, r1
    2032:	b8 01       	movw	r22, r16
    2034:	8e 52       	subi	r24, 0x2E	; 46
    2036:	9e 4f       	sbci	r25, 0xFE	; 254
    2038:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    203c:	e0 91 be 01 	lds	r30, 0x01BE	; 0x8001be <pxDelayedCoRoutineList>
    2040:	f0 91 bf 01 	lds	r31, 0x01BF	; 0x8001bf <pxDelayedCoRoutineList+0x1>
    2044:	80 81       	ld	r24, Z
    2046:	81 11       	cpse	r24, r1
    2048:	cc cf       	rjmp	.-104    	; 0x1fe2 <vCoRoutineSchedule+0xcc>
    204a:	a0 cf       	rjmp	.-192    	; 0x1f8c <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    204c:	90 93 af 01 	sts	0x01AF, r25	; 0x8001af <xLastTickCount+0x1>
    2050:	80 93 ae 01 	sts	0x01AE, r24	; 0x8001ae <xLastTickCount>
    2054:	80 91 b2 01 	lds	r24, 0x01B2	; 0x8001b2 <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2058:	69 e0       	ldi	r22, 0x09	; 9
    205a:	48 2f       	mov	r20, r24
    205c:	50 e0       	ldi	r21, 0x00	; 0
    205e:	64 9f       	mul	r22, r20
    2060:	90 01       	movw	r18, r0
    2062:	65 9f       	mul	r22, r21
    2064:	30 0d       	add	r19, r0
    2066:	11 24       	eor	r1, r1
    2068:	f9 01       	movw	r30, r18
    206a:	ee 52       	subi	r30, 0x2E	; 46
    206c:	fe 4f       	sbci	r31, 0xFE	; 254
    206e:	90 81       	ld	r25, Z
    2070:	91 11       	cpse	r25, r1
    2072:	0c c0       	rjmp	.+24     	; 0x208c <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2074:	81 11       	cpse	r24, r1
    2076:	08 c0       	rjmp	.+16     	; 0x2088 <vCoRoutineSchedule+0x172>
    2078:	10 92 b2 01 	sts	0x01B2, r1	; 0x8001b2 <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    207c:	df 91       	pop	r29
    207e:	cf 91       	pop	r28
    2080:	1f 91       	pop	r17
    2082:	0f 91       	pop	r16
    2084:	ff 90       	pop	r15
    2086:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2088:	81 50       	subi	r24, 0x01	; 1
    208a:	e7 cf       	rjmp	.-50     	; 0x205a <vCoRoutineSchedule+0x144>
    208c:	80 93 b2 01 	sts	0x01B2, r24	; 0x8001b2 <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2090:	a1 81       	ldd	r26, Z+1	; 0x01
    2092:	b2 81       	ldd	r27, Z+2	; 0x02
    2094:	12 96       	adiw	r26, 0x02	; 2
    2096:	0d 90       	ld	r0, X+
    2098:	bc 91       	ld	r27, X
    209a:	a0 2d       	mov	r26, r0
    209c:	b2 83       	std	Z+2, r27	; 0x02
    209e:	a1 83       	std	Z+1, r26	; 0x01
    20a0:	2b 52       	subi	r18, 0x2B	; 43
    20a2:	3e 4f       	sbci	r19, 0xFE	; 254
    20a4:	a2 17       	cp	r26, r18
    20a6:	b3 07       	cpc	r27, r19
    20a8:	31 f4       	brne	.+12     	; 0x20b6 <vCoRoutineSchedule+0x1a0>
    20aa:	12 96       	adiw	r26, 0x02	; 2
    20ac:	8d 91       	ld	r24, X+
    20ae:	9c 91       	ld	r25, X
    20b0:	13 97       	sbiw	r26, 0x03	; 3
    20b2:	92 83       	std	Z+2, r25	; 0x02
    20b4:	81 83       	std	Z+1, r24	; 0x01
    20b6:	89 e0       	ldi	r24, 0x09	; 9
    20b8:	84 9f       	mul	r24, r20
    20ba:	f0 01       	movw	r30, r0
    20bc:	85 9f       	mul	r24, r21
    20be:	f0 0d       	add	r31, r0
    20c0:	11 24       	eor	r1, r1
    20c2:	ee 52       	subi	r30, 0x2E	; 46
    20c4:	fe 4f       	sbci	r31, 0xFE	; 254
    20c6:	01 80       	ldd	r0, Z+1	; 0x01
    20c8:	f2 81       	ldd	r31, Z+2	; 0x02
    20ca:	e0 2d       	mov	r30, r0
    20cc:	86 81       	ldd	r24, Z+6	; 0x06
    20ce:	97 81       	ldd	r25, Z+7	; 0x07
    20d0:	90 93 ab 01 	sts	0x01AB, r25	; 0x8001ab <pxCurrentCoRoutine+0x1>
    20d4:	80 93 aa 01 	sts	0x01AA, r24	; 0x8001aa <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    20d8:	dc 01       	movw	r26, r24
    20da:	ed 91       	ld	r30, X+
    20dc:	fc 91       	ld	r31, X
    20de:	11 97       	sbiw	r26, 0x01	; 1
    20e0:	57 96       	adiw	r26, 0x17	; 23
    20e2:	6c 91       	ld	r22, X

	return;
}
    20e4:	df 91       	pop	r29
    20e6:	cf 91       	pop	r28
    20e8:	1f 91       	pop	r17
    20ea:	0f 91       	pop	r16
    20ec:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    20ee:	09 94       	ijmp

000020f0 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    20f0:	0f 93       	push	r16
    20f2:	1f 93       	push	r17
    20f4:	cf 93       	push	r28
    20f6:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    20f8:	dc 01       	movw	r26, r24
    20fa:	15 96       	adiw	r26, 0x05	; 5
    20fc:	ed 91       	ld	r30, X+
    20fe:	fc 91       	ld	r31, X
    2100:	16 97       	sbiw	r26, 0x06	; 6
    2102:	c6 81       	ldd	r28, Z+6	; 0x06
    2104:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2106:	8e 01       	movw	r16, r28
    2108:	04 5f       	subi	r16, 0xF4	; 244
    210a:	1f 4f       	sbci	r17, 0xFF	; 255
    210c:	c8 01       	movw	r24, r16
    210e:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2112:	b8 01       	movw	r22, r16
    2114:	83 eb       	ldi	r24, 0xB3	; 179
    2116:	91 e0       	ldi	r25, 0x01	; 1
    2118:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    211c:	e0 91 aa 01 	lds	r30, 0x01AA	; 0x8001aa <pxCurrentCoRoutine>
    2120:	f0 91 ab 01 	lds	r31, 0x01AB	; 0x8001ab <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2124:	81 e0       	ldi	r24, 0x01	; 1
    2126:	2e 89       	ldd	r18, Y+22	; 0x16
    2128:	96 89       	ldd	r25, Z+22	; 0x16
    212a:	29 17       	cp	r18, r25
    212c:	08 f4       	brcc	.+2      	; 0x2130 <xCoRoutineRemoveFromEventList+0x40>
    212e:	80 e0       	ldi	r24, 0x00	; 0
}
    2130:	df 91       	pop	r29
    2132:	cf 91       	pop	r28
    2134:	1f 91       	pop	r17
    2136:	0f 91       	pop	r16
    2138:	08 95       	ret

0000213a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    213a:	cf 93       	push	r28
    213c:	df 93       	push	r29
    213e:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2140:	0e 94 15 04 	call	0x82a	; 0x82a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2144:	80 91 e4 01 	lds	r24, 0x01E4	; 0x8001e4 <pucAlignedHeap.2081>
    2148:	90 91 e5 01 	lds	r25, 0x01E5	; 0x8001e5 <pucAlignedHeap.2081+0x1>
    214c:	89 2b       	or	r24, r25
    214e:	31 f4       	brne	.+12     	; 0x215c <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2150:	89 ee       	ldi	r24, 0xE9	; 233
    2152:	91 e0       	ldi	r25, 0x01	; 1
    2154:	90 93 e5 01 	sts	0x01E5, r25	; 0x8001e5 <pucAlignedHeap.2081+0x1>
    2158:	80 93 e4 01 	sts	0x01E4, r24	; 0x8001e4 <pucAlignedHeap.2081>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    215c:	20 91 e6 01 	lds	r18, 0x01E6	; 0x8001e6 <xNextFreeByte>
    2160:	30 91 e7 01 	lds	r19, 0x01E7	; 0x8001e7 <xNextFreeByte+0x1>
    2164:	c9 01       	movw	r24, r18
    2166:	8c 0f       	add	r24, r28
    2168:	9d 1f       	adc	r25, r29
    216a:	8b 3d       	cpi	r24, 0xDB	; 219
    216c:	45 e0       	ldi	r20, 0x05	; 5
    216e:	94 07       	cpc	r25, r20
    2170:	70 f4       	brcc	.+28     	; 0x218e <pvPortMalloc+0x54>
    2172:	28 17       	cp	r18, r24
    2174:	39 07       	cpc	r19, r25
    2176:	58 f4       	brcc	.+22     	; 0x218e <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2178:	c0 91 e4 01 	lds	r28, 0x01E4	; 0x8001e4 <pucAlignedHeap.2081>
    217c:	d0 91 e5 01 	lds	r29, 0x01E5	; 0x8001e5 <pucAlignedHeap.2081+0x1>
    2180:	c2 0f       	add	r28, r18
    2182:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    2184:	90 93 e7 01 	sts	0x01E7, r25	; 0x8001e7 <xNextFreeByte+0x1>
    2188:	80 93 e6 01 	sts	0x01E6, r24	; 0x8001e6 <xNextFreeByte>
    218c:	02 c0       	rjmp	.+4      	; 0x2192 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    218e:	c0 e0       	ldi	r28, 0x00	; 0
    2190:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2192:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    2196:	ce 01       	movw	r24, r28
    2198:	df 91       	pop	r29
    219a:	cf 91       	pop	r28
    219c:	08 95       	ret

0000219e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    219e:	08 95       	ret

000021a0 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    21a0:	10 92 e7 01 	sts	0x01E7, r1	; 0x8001e7 <xNextFreeByte+0x1>
    21a4:	10 92 e6 01 	sts	0x01E6, r1	; 0x8001e6 <xNextFreeByte>
    21a8:	08 95       	ret

000021aa <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    21aa:	20 91 e6 01 	lds	r18, 0x01E6	; 0x8001e6 <xNextFreeByte>
    21ae:	30 91 e7 01 	lds	r19, 0x01E7	; 0x8001e7 <xNextFreeByte+0x1>
}
    21b2:	8b ed       	ldi	r24, 0xDB	; 219
    21b4:	95 e0       	ldi	r25, 0x05	; 5
    21b6:	82 1b       	sub	r24, r18
    21b8:	93 0b       	sbc	r25, r19
    21ba:	08 95       	ret

000021bc <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    21bc:	31 e1       	ldi	r19, 0x11	; 17
    21be:	fc 01       	movw	r30, r24
    21c0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    21c2:	31 97       	sbiw	r30, 0x01	; 1
    21c4:	22 e2       	ldi	r18, 0x22	; 34
    21c6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    21c8:	31 97       	sbiw	r30, 0x01	; 1
    21ca:	a3 e3       	ldi	r26, 0x33	; 51
    21cc:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    21ce:	31 97       	sbiw	r30, 0x01	; 1
    21d0:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    21d2:	31 97       	sbiw	r30, 0x01	; 1
    21d4:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    21d6:	31 97       	sbiw	r30, 0x01	; 1
    21d8:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    21da:	31 97       	sbiw	r30, 0x01	; 1
    21dc:	60 e8       	ldi	r22, 0x80	; 128
    21de:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    21e0:	31 97       	sbiw	r30, 0x01	; 1
    21e2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    21e4:	31 97       	sbiw	r30, 0x01	; 1
    21e6:	62 e0       	ldi	r22, 0x02	; 2
    21e8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    21ea:	31 97       	sbiw	r30, 0x01	; 1
    21ec:	63 e0       	ldi	r22, 0x03	; 3
    21ee:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    21f0:	31 97       	sbiw	r30, 0x01	; 1
    21f2:	64 e0       	ldi	r22, 0x04	; 4
    21f4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    21f6:	31 97       	sbiw	r30, 0x01	; 1
    21f8:	65 e0       	ldi	r22, 0x05	; 5
    21fa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    21fc:	31 97       	sbiw	r30, 0x01	; 1
    21fe:	66 e0       	ldi	r22, 0x06	; 6
    2200:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2202:	31 97       	sbiw	r30, 0x01	; 1
    2204:	67 e0       	ldi	r22, 0x07	; 7
    2206:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2208:	31 97       	sbiw	r30, 0x01	; 1
    220a:	68 e0       	ldi	r22, 0x08	; 8
    220c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    220e:	31 97       	sbiw	r30, 0x01	; 1
    2210:	69 e0       	ldi	r22, 0x09	; 9
    2212:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2214:	31 97       	sbiw	r30, 0x01	; 1
    2216:	60 e1       	ldi	r22, 0x10	; 16
    2218:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    221a:	31 97       	sbiw	r30, 0x01	; 1
    221c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    221e:	31 97       	sbiw	r30, 0x01	; 1
    2220:	32 e1       	ldi	r19, 0x12	; 18
    2222:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2224:	31 97       	sbiw	r30, 0x01	; 1
    2226:	33 e1       	ldi	r19, 0x13	; 19
    2228:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    222a:	31 97       	sbiw	r30, 0x01	; 1
    222c:	34 e1       	ldi	r19, 0x14	; 20
    222e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    2230:	31 97       	sbiw	r30, 0x01	; 1
    2232:	35 e1       	ldi	r19, 0x15	; 21
    2234:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2236:	31 97       	sbiw	r30, 0x01	; 1
    2238:	36 e1       	ldi	r19, 0x16	; 22
    223a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    223c:	31 97       	sbiw	r30, 0x01	; 1
    223e:	37 e1       	ldi	r19, 0x17	; 23
    2240:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2242:	31 97       	sbiw	r30, 0x01	; 1
    2244:	38 e1       	ldi	r19, 0x18	; 24
    2246:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2248:	31 97       	sbiw	r30, 0x01	; 1
    224a:	39 e1       	ldi	r19, 0x19	; 25
    224c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    224e:	31 97       	sbiw	r30, 0x01	; 1
    2250:	30 e2       	ldi	r19, 0x20	; 32
    2252:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2254:	31 97       	sbiw	r30, 0x01	; 1
    2256:	31 e2       	ldi	r19, 0x21	; 33
    2258:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    225a:	31 97       	sbiw	r30, 0x01	; 1
    225c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    225e:	31 97       	sbiw	r30, 0x01	; 1
    2260:	23 e2       	ldi	r18, 0x23	; 35
    2262:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2264:	31 97       	sbiw	r30, 0x01	; 1
    2266:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2268:	31 97       	sbiw	r30, 0x01	; 1
    226a:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    226c:	31 97       	sbiw	r30, 0x01	; 1
    226e:	26 e2       	ldi	r18, 0x26	; 38
    2270:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2272:	31 97       	sbiw	r30, 0x01	; 1
    2274:	27 e2       	ldi	r18, 0x27	; 39
    2276:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2278:	31 97       	sbiw	r30, 0x01	; 1
    227a:	28 e2       	ldi	r18, 0x28	; 40
    227c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    227e:	31 97       	sbiw	r30, 0x01	; 1
    2280:	29 e2       	ldi	r18, 0x29	; 41
    2282:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2284:	31 97       	sbiw	r30, 0x01	; 1
    2286:	20 e3       	ldi	r18, 0x30	; 48
    2288:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    228a:	31 97       	sbiw	r30, 0x01	; 1
    228c:	21 e3       	ldi	r18, 0x31	; 49
    228e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2290:	86 97       	sbiw	r24, 0x26	; 38
    2292:	08 95       	ret

00002294 <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    2294:	89 ef       	ldi	r24, 0xF9	; 249
    2296:	90 e0       	ldi	r25, 0x00	; 0
    2298:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
    229c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    22a0:	e0 e8       	ldi	r30, 0x80	; 128
    22a2:	f0 e0       	ldi	r31, 0x00	; 0
    22a4:	80 81       	ld	r24, Z
    22a6:	8c 7f       	andi	r24, 0xFC	; 252
    22a8:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    22aa:	8b e0       	ldi	r24, 0x0B	; 11
    22ac:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    22b0:	ef e6       	ldi	r30, 0x6F	; 111
    22b2:	f0 e0       	ldi	r31, 0x00	; 0
    22b4:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    22b6:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    22b8:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    22ba:	a0 91 44 01 	lds	r26, 0x0144	; 0x800144 <__data_end>
    22be:	b0 91 45 01 	lds	r27, 0x0145	; 0x800145 <__data_end+0x1>
    22c2:	cd 91       	ld	r28, X+
    22c4:	cd bf       	out	0x3d, r28	; 61
    22c6:	dd 91       	ld	r29, X+
    22c8:	de bf       	out	0x3e, r29	; 62
    22ca:	ff 91       	pop	r31
    22cc:	ef 91       	pop	r30
    22ce:	df 91       	pop	r29
    22d0:	cf 91       	pop	r28
    22d2:	bf 91       	pop	r27
    22d4:	af 91       	pop	r26
    22d6:	9f 91       	pop	r25
    22d8:	8f 91       	pop	r24
    22da:	7f 91       	pop	r23
    22dc:	6f 91       	pop	r22
    22de:	5f 91       	pop	r21
    22e0:	4f 91       	pop	r20
    22e2:	3f 91       	pop	r19
    22e4:	2f 91       	pop	r18
    22e6:	1f 91       	pop	r17
    22e8:	0f 91       	pop	r16
    22ea:	ff 90       	pop	r15
    22ec:	ef 90       	pop	r14
    22ee:	df 90       	pop	r13
    22f0:	cf 90       	pop	r12
    22f2:	bf 90       	pop	r11
    22f4:	af 90       	pop	r10
    22f6:	9f 90       	pop	r9
    22f8:	8f 90       	pop	r8
    22fa:	7f 90       	pop	r7
    22fc:	6f 90       	pop	r6
    22fe:	5f 90       	pop	r5
    2300:	4f 90       	pop	r4
    2302:	3f 90       	pop	r3
    2304:	2f 90       	pop	r2
    2306:	1f 90       	pop	r1
    2308:	0f 90       	pop	r0
    230a:	0f be       	out	0x3f, r0	; 63
    230c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    230e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2310:	81 e0       	ldi	r24, 0x01	; 1
    2312:	08 95       	ret

00002314 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2314:	08 95       	ret

00002316 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2316:	0f 92       	push	r0
    2318:	0f b6       	in	r0, 0x3f	; 63
    231a:	f8 94       	cli
    231c:	0f 92       	push	r0
    231e:	1f 92       	push	r1
    2320:	11 24       	eor	r1, r1
    2322:	2f 92       	push	r2
    2324:	3f 92       	push	r3
    2326:	4f 92       	push	r4
    2328:	5f 92       	push	r5
    232a:	6f 92       	push	r6
    232c:	7f 92       	push	r7
    232e:	8f 92       	push	r8
    2330:	9f 92       	push	r9
    2332:	af 92       	push	r10
    2334:	bf 92       	push	r11
    2336:	cf 92       	push	r12
    2338:	df 92       	push	r13
    233a:	ef 92       	push	r14
    233c:	ff 92       	push	r15
    233e:	0f 93       	push	r16
    2340:	1f 93       	push	r17
    2342:	2f 93       	push	r18
    2344:	3f 93       	push	r19
    2346:	4f 93       	push	r20
    2348:	5f 93       	push	r21
    234a:	6f 93       	push	r22
    234c:	7f 93       	push	r23
    234e:	8f 93       	push	r24
    2350:	9f 93       	push	r25
    2352:	af 93       	push	r26
    2354:	bf 93       	push	r27
    2356:	cf 93       	push	r28
    2358:	df 93       	push	r29
    235a:	ef 93       	push	r30
    235c:	ff 93       	push	r31
    235e:	a0 91 44 01 	lds	r26, 0x0144	; 0x800144 <__data_end>
    2362:	b0 91 45 01 	lds	r27, 0x0145	; 0x800145 <__data_end+0x1>
    2366:	0d b6       	in	r0, 0x3d	; 61
    2368:	0d 92       	st	X+, r0
    236a:	0e b6       	in	r0, 0x3e	; 62
    236c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    236e:	0e 94 9d 05 	call	0xb3a	; 0xb3a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2372:	a0 91 44 01 	lds	r26, 0x0144	; 0x800144 <__data_end>
    2376:	b0 91 45 01 	lds	r27, 0x0145	; 0x800145 <__data_end+0x1>
    237a:	cd 91       	ld	r28, X+
    237c:	cd bf       	out	0x3d, r28	; 61
    237e:	dd 91       	ld	r29, X+
    2380:	de bf       	out	0x3e, r29	; 62
    2382:	ff 91       	pop	r31
    2384:	ef 91       	pop	r30
    2386:	df 91       	pop	r29
    2388:	cf 91       	pop	r28
    238a:	bf 91       	pop	r27
    238c:	af 91       	pop	r26
    238e:	9f 91       	pop	r25
    2390:	8f 91       	pop	r24
    2392:	7f 91       	pop	r23
    2394:	6f 91       	pop	r22
    2396:	5f 91       	pop	r21
    2398:	4f 91       	pop	r20
    239a:	3f 91       	pop	r19
    239c:	2f 91       	pop	r18
    239e:	1f 91       	pop	r17
    23a0:	0f 91       	pop	r16
    23a2:	ff 90       	pop	r15
    23a4:	ef 90       	pop	r14
    23a6:	df 90       	pop	r13
    23a8:	cf 90       	pop	r12
    23aa:	bf 90       	pop	r11
    23ac:	af 90       	pop	r10
    23ae:	9f 90       	pop	r9
    23b0:	8f 90       	pop	r8
    23b2:	7f 90       	pop	r7
    23b4:	6f 90       	pop	r6
    23b6:	5f 90       	pop	r5
    23b8:	4f 90       	pop	r4
    23ba:	3f 90       	pop	r3
    23bc:	2f 90       	pop	r2
    23be:	1f 90       	pop	r1
    23c0:	0f 90       	pop	r0
    23c2:	0f be       	out	0x3f, r0	; 63
    23c4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    23c6:	08 95       	ret

000023c8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    23c8:	0f 92       	push	r0
    23ca:	0f b6       	in	r0, 0x3f	; 63
    23cc:	f8 94       	cli
    23ce:	0f 92       	push	r0
    23d0:	1f 92       	push	r1
    23d2:	11 24       	eor	r1, r1
    23d4:	2f 92       	push	r2
    23d6:	3f 92       	push	r3
    23d8:	4f 92       	push	r4
    23da:	5f 92       	push	r5
    23dc:	6f 92       	push	r6
    23de:	7f 92       	push	r7
    23e0:	8f 92       	push	r8
    23e2:	9f 92       	push	r9
    23e4:	af 92       	push	r10
    23e6:	bf 92       	push	r11
    23e8:	cf 92       	push	r12
    23ea:	df 92       	push	r13
    23ec:	ef 92       	push	r14
    23ee:	ff 92       	push	r15
    23f0:	0f 93       	push	r16
    23f2:	1f 93       	push	r17
    23f4:	2f 93       	push	r18
    23f6:	3f 93       	push	r19
    23f8:	4f 93       	push	r20
    23fa:	5f 93       	push	r21
    23fc:	6f 93       	push	r22
    23fe:	7f 93       	push	r23
    2400:	8f 93       	push	r24
    2402:	9f 93       	push	r25
    2404:	af 93       	push	r26
    2406:	bf 93       	push	r27
    2408:	cf 93       	push	r28
    240a:	df 93       	push	r29
    240c:	ef 93       	push	r30
    240e:	ff 93       	push	r31
    2410:	a0 91 44 01 	lds	r26, 0x0144	; 0x800144 <__data_end>
    2414:	b0 91 45 01 	lds	r27, 0x0145	; 0x800145 <__data_end+0x1>
    2418:	0d b6       	in	r0, 0x3d	; 61
    241a:	0d 92       	st	X+, r0
    241c:	0e b6       	in	r0, 0x3e	; 62
    241e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2420:	0e 94 35 04 	call	0x86a	; 0x86a <xTaskIncrementTick>
    2424:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2426:	0e 94 9d 05 	call	0xb3a	; 0xb3a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    242a:	a0 91 44 01 	lds	r26, 0x0144	; 0x800144 <__data_end>
    242e:	b0 91 45 01 	lds	r27, 0x0145	; 0x800145 <__data_end+0x1>
    2432:	cd 91       	ld	r28, X+
    2434:	cd bf       	out	0x3d, r28	; 61
    2436:	dd 91       	ld	r29, X+
    2438:	de bf       	out	0x3e, r29	; 62
    243a:	ff 91       	pop	r31
    243c:	ef 91       	pop	r30
    243e:	df 91       	pop	r29
    2440:	cf 91       	pop	r28
    2442:	bf 91       	pop	r27
    2444:	af 91       	pop	r26
    2446:	9f 91       	pop	r25
    2448:	8f 91       	pop	r24
    244a:	7f 91       	pop	r23
    244c:	6f 91       	pop	r22
    244e:	5f 91       	pop	r21
    2450:	4f 91       	pop	r20
    2452:	3f 91       	pop	r19
    2454:	2f 91       	pop	r18
    2456:	1f 91       	pop	r17
    2458:	0f 91       	pop	r16
    245a:	ff 90       	pop	r15
    245c:	ef 90       	pop	r14
    245e:	df 90       	pop	r13
    2460:	cf 90       	pop	r12
    2462:	bf 90       	pop	r11
    2464:	af 90       	pop	r10
    2466:	9f 90       	pop	r9
    2468:	8f 90       	pop	r8
    246a:	7f 90       	pop	r7
    246c:	6f 90       	pop	r6
    246e:	5f 90       	pop	r5
    2470:	4f 90       	pop	r4
    2472:	3f 90       	pop	r3
    2474:	2f 90       	pop	r2
    2476:	1f 90       	pop	r1
    2478:	0f 90       	pop	r0
    247a:	0f be       	out	0x3f, r0	; 63
    247c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    247e:	08 95       	ret

00002480 <__vector_11>:
    2480:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <vPortYieldFromTick>
    2484:	18 95       	reti

00002486 <main>:
    ADCSRA |= _BV(ADEN); // włącz ADC
    ADCSRA |= _BV(ADIE); // włącz interupty nad ADC
}

int main(void)
{
    2486:	ef 92       	push	r14
    2488:	ff 92       	push	r15
    248a:	0f 93       	push	r16
    248c:	cf 93       	push	r28
    248e:	df 93       	push	r29
    2490:	00 d0       	rcall	.+0      	; 0x2492 <main+0xc>
    2492:	00 d0       	rcall	.+0      	; 0x2494 <main+0xe>
    2494:	00 d0       	rcall	.+0      	; 0x2496 <main+0x10>
    2496:	cd b7       	in	r28, 0x3d	; 61
    2498:	de b7       	in	r29, 0x3e	; 62
    xTaskHandle adc1,adc2,adc3;
    uart_init();
    249a:	0e 94 0d 01 	call	0x21a	; 0x21a <uart_init>
    stdin = stdout = stderr = &uart_file;
    249e:	ea ec       	ldi	r30, 0xCA	; 202
    24a0:	f7 e0       	ldi	r31, 0x07	; 7
    24a2:	80 e0       	ldi	r24, 0x00	; 0
    24a4:	91 e0       	ldi	r25, 0x01	; 1
    24a6:	95 83       	std	Z+5, r25	; 0x05
    24a8:	84 83       	std	Z+4, r24	; 0x04
    24aa:	93 83       	std	Z+3, r25	; 0x03
    24ac:	82 83       	std	Z+2, r24	; 0x02
    24ae:	91 83       	std	Z+1, r25	; 0x01
    24b0:	80 83       	st	Z, r24
    adc_init();
    24b2:	0e 94 1e 01 	call	0x23c	; 0x23c <adc_init>

    sei();
    24b6:	78 94       	sei
    semADC = xSemaphoreCreateBinary();
    24b8:	43 e0       	ldi	r20, 0x03	; 3
    24ba:	60 e0       	ldi	r22, 0x00	; 0
    24bc:	81 e0       	ldi	r24, 0x01	; 1
    24be:	0e 94 46 0a 	call	0x148c	; 0x148c <xQueueGenericCreate>
    24c2:	90 93 c5 07 	sts	0x07C5, r25	; 0x8007c5 <semADC+0x1>
    24c6:	80 93 c4 07 	sts	0x07C4, r24	; 0x8007c4 <semADC>
    // semADCComplete = xSemaphoreCreateBinary();
    // printSEM = xSemaphoreCreateBinary();

    xSemaphoreGive(semADC);
    24ca:	20 e0       	ldi	r18, 0x00	; 0
    24cc:	40 e0       	ldi	r20, 0x00	; 0
    24ce:	50 e0       	ldi	r21, 0x00	; 0
    24d0:	60 e0       	ldi	r22, 0x00	; 0
    24d2:	70 e0       	ldi	r23, 0x00	; 0
    24d4:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <xQueueGenericSend>
    // xSemaphoreGive(printSEM);

    xTaskCreate(vADC_READ1,"ADC1",400,(void*)0,mainADC_TASK_1,&adc1);
    24d8:	ce 01       	movw	r24, r28
    24da:	05 96       	adiw	r24, 0x05	; 5
    24dc:	7c 01       	movw	r14, r24
    24de:	01 e0       	ldi	r16, 0x01	; 1
    24e0:	20 e0       	ldi	r18, 0x00	; 0
    24e2:	30 e0       	ldi	r19, 0x00	; 0
    24e4:	40 e9       	ldi	r20, 0x90	; 144
    24e6:	51 e0       	ldi	r21, 0x01	; 1
    24e8:	6f e2       	ldi	r22, 0x2F	; 47
    24ea:	71 e0       	ldi	r23, 0x01	; 1
    24ec:	86 ee       	ldi	r24, 0xE6	; 230
    24ee:	90 e0       	ldi	r25, 0x00	; 0
    24f0:	0e 94 01 02 	call	0x402	; 0x402 <xTaskCreate>
    xTaskCreate(vADC_READ2,"ADC2",400,(void*)(0xe),mainADC_TASK_2,&adc2);
    24f4:	ce 01       	movw	r24, r28
    24f6:	03 96       	adiw	r24, 0x03	; 3
    24f8:	7c 01       	movw	r14, r24
    24fa:	2e e0       	ldi	r18, 0x0E	; 14
    24fc:	30 e0       	ldi	r19, 0x00	; 0
    24fe:	40 e9       	ldi	r20, 0x90	; 144
    2500:	51 e0       	ldi	r21, 0x01	; 1
    2502:	64 e3       	ldi	r22, 0x34	; 52
    2504:	71 e0       	ldi	r23, 0x01	; 1
    2506:	8f eb       	ldi	r24, 0xBF	; 191
    2508:	90 e0       	ldi	r25, 0x00	; 0
    250a:	0e 94 01 02 	call	0x402	; 0x402 <xTaskCreate>
    xTaskCreate(vADC_READ3,"ADC3",400,(void*)(_BV(MUX0)),mainADC_TASK_3,&adc3);
    250e:	ce 01       	movw	r24, r28
    2510:	01 96       	adiw	r24, 0x01	; 1
    2512:	7c 01       	movw	r14, r24
    2514:	21 e0       	ldi	r18, 0x01	; 1
    2516:	30 e0       	ldi	r19, 0x00	; 0
    2518:	40 e9       	ldi	r20, 0x90	; 144
    251a:	51 e0       	ldi	r21, 0x01	; 1
    251c:	69 e3       	ldi	r22, 0x39	; 57
    251e:	71 e0       	ldi	r23, 0x01	; 1
    2520:	88 e9       	ldi	r24, 0x98	; 152
    2522:	90 e0       	ldi	r25, 0x00	; 0
    2524:	0e 94 01 02 	call	0x402	; 0x402 <xTaskCreate>

    vTaskStartScheduler();
    2528:	0e 94 e6 03 	call	0x7cc	; 0x7cc <vTaskStartScheduler>

    return 0;
}
    252c:	80 e0       	ldi	r24, 0x00	; 0
    252e:	90 e0       	ldi	r25, 0x00	; 0
    2530:	26 96       	adiw	r28, 0x06	; 6
    2532:	0f b6       	in	r0, 0x3f	; 63
    2534:	f8 94       	cli
    2536:	de bf       	out	0x3e, r29	; 62
    2538:	0f be       	out	0x3f, r0	; 63
    253a:	cd bf       	out	0x3d, r28	; 61
    253c:	df 91       	pop	r29
    253e:	cf 91       	pop	r28
    2540:	0f 91       	pop	r16
    2542:	ff 90       	pop	r15
    2544:	ef 90       	pop	r14
    2546:	08 95       	ret

00002548 <memcpy>:
    2548:	fb 01       	movw	r30, r22
    254a:	dc 01       	movw	r26, r24
    254c:	02 c0       	rjmp	.+4      	; 0x2552 <memcpy+0xa>
    254e:	01 90       	ld	r0, Z+
    2550:	0d 92       	st	X+, r0
    2552:	41 50       	subi	r20, 0x01	; 1
    2554:	50 40       	sbci	r21, 0x00	; 0
    2556:	d8 f7       	brcc	.-10     	; 0x254e <memcpy+0x6>
    2558:	08 95       	ret

0000255a <itoa>:
    255a:	45 32       	cpi	r20, 0x25	; 37
    255c:	51 05       	cpc	r21, r1
    255e:	20 f4       	brcc	.+8      	; 0x2568 <itoa+0xe>
    2560:	42 30       	cpi	r20, 0x02	; 2
    2562:	10 f0       	brcs	.+4      	; 0x2568 <itoa+0xe>
    2564:	0c 94 b8 12 	jmp	0x2570	; 0x2570 <__itoa_ncheck>
    2568:	fb 01       	movw	r30, r22
    256a:	10 82       	st	Z, r1
    256c:	cb 01       	movw	r24, r22
    256e:	08 95       	ret

00002570 <__itoa_ncheck>:
    2570:	bb 27       	eor	r27, r27
    2572:	4a 30       	cpi	r20, 0x0A	; 10
    2574:	31 f4       	brne	.+12     	; 0x2582 <__itoa_ncheck+0x12>
    2576:	99 23       	and	r25, r25
    2578:	22 f4       	brpl	.+8      	; 0x2582 <__itoa_ncheck+0x12>
    257a:	bd e2       	ldi	r27, 0x2D	; 45
    257c:	90 95       	com	r25
    257e:	81 95       	neg	r24
    2580:	9f 4f       	sbci	r25, 0xFF	; 255
    2582:	0c 94 c4 12 	jmp	0x2588	; 0x2588 <__utoa_common>

00002586 <__utoa_ncheck>:
    2586:	bb 27       	eor	r27, r27

00002588 <__utoa_common>:
    2588:	fb 01       	movw	r30, r22
    258a:	55 27       	eor	r21, r21
    258c:	aa 27       	eor	r26, r26
    258e:	88 0f       	add	r24, r24
    2590:	99 1f       	adc	r25, r25
    2592:	aa 1f       	adc	r26, r26
    2594:	a4 17       	cp	r26, r20
    2596:	10 f0       	brcs	.+4      	; 0x259c <__utoa_common+0x14>
    2598:	a4 1b       	sub	r26, r20
    259a:	83 95       	inc	r24
    259c:	50 51       	subi	r21, 0x10	; 16
    259e:	b9 f7       	brne	.-18     	; 0x258e <__utoa_common+0x6>
    25a0:	a0 5d       	subi	r26, 0xD0	; 208
    25a2:	aa 33       	cpi	r26, 0x3A	; 58
    25a4:	08 f0       	brcs	.+2      	; 0x25a8 <__utoa_common+0x20>
    25a6:	a9 5d       	subi	r26, 0xD9	; 217
    25a8:	a1 93       	st	Z+, r26
    25aa:	00 97       	sbiw	r24, 0x00	; 0
    25ac:	79 f7       	brne	.-34     	; 0x258c <__utoa_common+0x4>
    25ae:	b1 11       	cpse	r27, r1
    25b0:	b1 93       	st	Z+, r27
    25b2:	11 92       	st	Z+, r1
    25b4:	cb 01       	movw	r24, r22
    25b6:	0c 94 ea 14 	jmp	0x29d4	; 0x29d4 <strrev>

000025ba <printf>:
    25ba:	a0 e0       	ldi	r26, 0x00	; 0
    25bc:	b0 e0       	ldi	r27, 0x00	; 0
    25be:	e3 ee       	ldi	r30, 0xE3	; 227
    25c0:	f2 e1       	ldi	r31, 0x12	; 18
    25c2:	0c 94 a4 15 	jmp	0x2b48	; 0x2b48 <__prologue_saves__+0x20>
    25c6:	ae 01       	movw	r20, r28
    25c8:	4b 5f       	subi	r20, 0xFB	; 251
    25ca:	5f 4f       	sbci	r21, 0xFF	; 255
    25cc:	fa 01       	movw	r30, r20
    25ce:	61 91       	ld	r22, Z+
    25d0:	71 91       	ld	r23, Z+
    25d2:	af 01       	movw	r20, r30
    25d4:	80 91 cc 07 	lds	r24, 0x07CC	; 0x8007cc <__iob+0x2>
    25d8:	90 91 cd 07 	lds	r25, 0x07CD	; 0x8007cd <__iob+0x3>
    25dc:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <vfprintf>
    25e0:	e2 e0       	ldi	r30, 0x02	; 2
    25e2:	0c 94 c0 15 	jmp	0x2b80	; 0x2b80 <__epilogue_restores__+0x20>

000025e6 <vfprintf>:
    25e6:	ab e0       	ldi	r26, 0x0B	; 11
    25e8:	b0 e0       	ldi	r27, 0x00	; 0
    25ea:	e9 ef       	ldi	r30, 0xF9	; 249
    25ec:	f2 e1       	ldi	r31, 0x12	; 18
    25ee:	0c 94 94 15 	jmp	0x2b28	; 0x2b28 <__prologue_saves__>
    25f2:	6c 01       	movw	r12, r24
    25f4:	7b 01       	movw	r14, r22
    25f6:	8a 01       	movw	r16, r20
    25f8:	fc 01       	movw	r30, r24
    25fa:	17 82       	std	Z+7, r1	; 0x07
    25fc:	16 82       	std	Z+6, r1	; 0x06
    25fe:	83 81       	ldd	r24, Z+3	; 0x03
    2600:	81 ff       	sbrs	r24, 1
    2602:	cc c1       	rjmp	.+920    	; 0x299c <vfprintf+0x3b6>
    2604:	ce 01       	movw	r24, r28
    2606:	01 96       	adiw	r24, 0x01	; 1
    2608:	3c 01       	movw	r6, r24
    260a:	f6 01       	movw	r30, r12
    260c:	93 81       	ldd	r25, Z+3	; 0x03
    260e:	f7 01       	movw	r30, r14
    2610:	93 fd       	sbrc	r25, 3
    2612:	85 91       	lpm	r24, Z+
    2614:	93 ff       	sbrs	r25, 3
    2616:	81 91       	ld	r24, Z+
    2618:	7f 01       	movw	r14, r30
    261a:	88 23       	and	r24, r24
    261c:	09 f4       	brne	.+2      	; 0x2620 <vfprintf+0x3a>
    261e:	ba c1       	rjmp	.+884    	; 0x2994 <vfprintf+0x3ae>
    2620:	85 32       	cpi	r24, 0x25	; 37
    2622:	39 f4       	brne	.+14     	; 0x2632 <vfprintf+0x4c>
    2624:	93 fd       	sbrc	r25, 3
    2626:	85 91       	lpm	r24, Z+
    2628:	93 ff       	sbrs	r25, 3
    262a:	81 91       	ld	r24, Z+
    262c:	7f 01       	movw	r14, r30
    262e:	85 32       	cpi	r24, 0x25	; 37
    2630:	29 f4       	brne	.+10     	; 0x263c <vfprintf+0x56>
    2632:	b6 01       	movw	r22, r12
    2634:	90 e0       	ldi	r25, 0x00	; 0
    2636:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <fputc>
    263a:	e7 cf       	rjmp	.-50     	; 0x260a <vfprintf+0x24>
    263c:	91 2c       	mov	r9, r1
    263e:	21 2c       	mov	r2, r1
    2640:	31 2c       	mov	r3, r1
    2642:	ff e1       	ldi	r31, 0x1F	; 31
    2644:	f3 15       	cp	r31, r3
    2646:	d8 f0       	brcs	.+54     	; 0x267e <vfprintf+0x98>
    2648:	8b 32       	cpi	r24, 0x2B	; 43
    264a:	79 f0       	breq	.+30     	; 0x266a <vfprintf+0x84>
    264c:	38 f4       	brcc	.+14     	; 0x265c <vfprintf+0x76>
    264e:	80 32       	cpi	r24, 0x20	; 32
    2650:	79 f0       	breq	.+30     	; 0x2670 <vfprintf+0x8a>
    2652:	83 32       	cpi	r24, 0x23	; 35
    2654:	a1 f4       	brne	.+40     	; 0x267e <vfprintf+0x98>
    2656:	23 2d       	mov	r18, r3
    2658:	20 61       	ori	r18, 0x10	; 16
    265a:	1d c0       	rjmp	.+58     	; 0x2696 <vfprintf+0xb0>
    265c:	8d 32       	cpi	r24, 0x2D	; 45
    265e:	61 f0       	breq	.+24     	; 0x2678 <vfprintf+0x92>
    2660:	80 33       	cpi	r24, 0x30	; 48
    2662:	69 f4       	brne	.+26     	; 0x267e <vfprintf+0x98>
    2664:	23 2d       	mov	r18, r3
    2666:	21 60       	ori	r18, 0x01	; 1
    2668:	16 c0       	rjmp	.+44     	; 0x2696 <vfprintf+0xb0>
    266a:	83 2d       	mov	r24, r3
    266c:	82 60       	ori	r24, 0x02	; 2
    266e:	38 2e       	mov	r3, r24
    2670:	e3 2d       	mov	r30, r3
    2672:	e4 60       	ori	r30, 0x04	; 4
    2674:	3e 2e       	mov	r3, r30
    2676:	2a c0       	rjmp	.+84     	; 0x26cc <vfprintf+0xe6>
    2678:	f3 2d       	mov	r31, r3
    267a:	f8 60       	ori	r31, 0x08	; 8
    267c:	1d c0       	rjmp	.+58     	; 0x26b8 <vfprintf+0xd2>
    267e:	37 fc       	sbrc	r3, 7
    2680:	2d c0       	rjmp	.+90     	; 0x26dc <vfprintf+0xf6>
    2682:	20 ed       	ldi	r18, 0xD0	; 208
    2684:	28 0f       	add	r18, r24
    2686:	2a 30       	cpi	r18, 0x0A	; 10
    2688:	40 f0       	brcs	.+16     	; 0x269a <vfprintf+0xb4>
    268a:	8e 32       	cpi	r24, 0x2E	; 46
    268c:	b9 f4       	brne	.+46     	; 0x26bc <vfprintf+0xd6>
    268e:	36 fc       	sbrc	r3, 6
    2690:	81 c1       	rjmp	.+770    	; 0x2994 <vfprintf+0x3ae>
    2692:	23 2d       	mov	r18, r3
    2694:	20 64       	ori	r18, 0x40	; 64
    2696:	32 2e       	mov	r3, r18
    2698:	19 c0       	rjmp	.+50     	; 0x26cc <vfprintf+0xe6>
    269a:	36 fe       	sbrs	r3, 6
    269c:	06 c0       	rjmp	.+12     	; 0x26aa <vfprintf+0xc4>
    269e:	8a e0       	ldi	r24, 0x0A	; 10
    26a0:	98 9e       	mul	r9, r24
    26a2:	20 0d       	add	r18, r0
    26a4:	11 24       	eor	r1, r1
    26a6:	92 2e       	mov	r9, r18
    26a8:	11 c0       	rjmp	.+34     	; 0x26cc <vfprintf+0xe6>
    26aa:	ea e0       	ldi	r30, 0x0A	; 10
    26ac:	2e 9e       	mul	r2, r30
    26ae:	20 0d       	add	r18, r0
    26b0:	11 24       	eor	r1, r1
    26b2:	22 2e       	mov	r2, r18
    26b4:	f3 2d       	mov	r31, r3
    26b6:	f0 62       	ori	r31, 0x20	; 32
    26b8:	3f 2e       	mov	r3, r31
    26ba:	08 c0       	rjmp	.+16     	; 0x26cc <vfprintf+0xe6>
    26bc:	8c 36       	cpi	r24, 0x6C	; 108
    26be:	21 f4       	brne	.+8      	; 0x26c8 <vfprintf+0xe2>
    26c0:	83 2d       	mov	r24, r3
    26c2:	80 68       	ori	r24, 0x80	; 128
    26c4:	38 2e       	mov	r3, r24
    26c6:	02 c0       	rjmp	.+4      	; 0x26cc <vfprintf+0xe6>
    26c8:	88 36       	cpi	r24, 0x68	; 104
    26ca:	41 f4       	brne	.+16     	; 0x26dc <vfprintf+0xf6>
    26cc:	f7 01       	movw	r30, r14
    26ce:	93 fd       	sbrc	r25, 3
    26d0:	85 91       	lpm	r24, Z+
    26d2:	93 ff       	sbrs	r25, 3
    26d4:	81 91       	ld	r24, Z+
    26d6:	7f 01       	movw	r14, r30
    26d8:	81 11       	cpse	r24, r1
    26da:	b3 cf       	rjmp	.-154    	; 0x2642 <vfprintf+0x5c>
    26dc:	98 2f       	mov	r25, r24
    26de:	9f 7d       	andi	r25, 0xDF	; 223
    26e0:	95 54       	subi	r25, 0x45	; 69
    26e2:	93 30       	cpi	r25, 0x03	; 3
    26e4:	28 f4       	brcc	.+10     	; 0x26f0 <vfprintf+0x10a>
    26e6:	0c 5f       	subi	r16, 0xFC	; 252
    26e8:	1f 4f       	sbci	r17, 0xFF	; 255
    26ea:	9f e3       	ldi	r25, 0x3F	; 63
    26ec:	99 83       	std	Y+1, r25	; 0x01
    26ee:	0d c0       	rjmp	.+26     	; 0x270a <vfprintf+0x124>
    26f0:	83 36       	cpi	r24, 0x63	; 99
    26f2:	31 f0       	breq	.+12     	; 0x2700 <vfprintf+0x11a>
    26f4:	83 37       	cpi	r24, 0x73	; 115
    26f6:	71 f0       	breq	.+28     	; 0x2714 <vfprintf+0x12e>
    26f8:	83 35       	cpi	r24, 0x53	; 83
    26fa:	09 f0       	breq	.+2      	; 0x26fe <vfprintf+0x118>
    26fc:	59 c0       	rjmp	.+178    	; 0x27b0 <vfprintf+0x1ca>
    26fe:	21 c0       	rjmp	.+66     	; 0x2742 <vfprintf+0x15c>
    2700:	f8 01       	movw	r30, r16
    2702:	80 81       	ld	r24, Z
    2704:	89 83       	std	Y+1, r24	; 0x01
    2706:	0e 5f       	subi	r16, 0xFE	; 254
    2708:	1f 4f       	sbci	r17, 0xFF	; 255
    270a:	88 24       	eor	r8, r8
    270c:	83 94       	inc	r8
    270e:	91 2c       	mov	r9, r1
    2710:	53 01       	movw	r10, r6
    2712:	13 c0       	rjmp	.+38     	; 0x273a <vfprintf+0x154>
    2714:	28 01       	movw	r4, r16
    2716:	f2 e0       	ldi	r31, 0x02	; 2
    2718:	4f 0e       	add	r4, r31
    271a:	51 1c       	adc	r5, r1
    271c:	f8 01       	movw	r30, r16
    271e:	a0 80       	ld	r10, Z
    2720:	b1 80       	ldd	r11, Z+1	; 0x01
    2722:	36 fe       	sbrs	r3, 6
    2724:	03 c0       	rjmp	.+6      	; 0x272c <vfprintf+0x146>
    2726:	69 2d       	mov	r22, r9
    2728:	70 e0       	ldi	r23, 0x00	; 0
    272a:	02 c0       	rjmp	.+4      	; 0x2730 <vfprintf+0x14a>
    272c:	6f ef       	ldi	r22, 0xFF	; 255
    272e:	7f ef       	ldi	r23, 0xFF	; 255
    2730:	c5 01       	movw	r24, r10
    2732:	0e 94 df 14 	call	0x29be	; 0x29be <strnlen>
    2736:	4c 01       	movw	r8, r24
    2738:	82 01       	movw	r16, r4
    273a:	f3 2d       	mov	r31, r3
    273c:	ff 77       	andi	r31, 0x7F	; 127
    273e:	3f 2e       	mov	r3, r31
    2740:	16 c0       	rjmp	.+44     	; 0x276e <vfprintf+0x188>
    2742:	28 01       	movw	r4, r16
    2744:	22 e0       	ldi	r18, 0x02	; 2
    2746:	42 0e       	add	r4, r18
    2748:	51 1c       	adc	r5, r1
    274a:	f8 01       	movw	r30, r16
    274c:	a0 80       	ld	r10, Z
    274e:	b1 80       	ldd	r11, Z+1	; 0x01
    2750:	36 fe       	sbrs	r3, 6
    2752:	03 c0       	rjmp	.+6      	; 0x275a <vfprintf+0x174>
    2754:	69 2d       	mov	r22, r9
    2756:	70 e0       	ldi	r23, 0x00	; 0
    2758:	02 c0       	rjmp	.+4      	; 0x275e <vfprintf+0x178>
    275a:	6f ef       	ldi	r22, 0xFF	; 255
    275c:	7f ef       	ldi	r23, 0xFF	; 255
    275e:	c5 01       	movw	r24, r10
    2760:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <strnlen_P>
    2764:	4c 01       	movw	r8, r24
    2766:	f3 2d       	mov	r31, r3
    2768:	f0 68       	ori	r31, 0x80	; 128
    276a:	3f 2e       	mov	r3, r31
    276c:	82 01       	movw	r16, r4
    276e:	33 fc       	sbrc	r3, 3
    2770:	1b c0       	rjmp	.+54     	; 0x27a8 <vfprintf+0x1c2>
    2772:	82 2d       	mov	r24, r2
    2774:	90 e0       	ldi	r25, 0x00	; 0
    2776:	88 16       	cp	r8, r24
    2778:	99 06       	cpc	r9, r25
    277a:	b0 f4       	brcc	.+44     	; 0x27a8 <vfprintf+0x1c2>
    277c:	b6 01       	movw	r22, r12
    277e:	80 e2       	ldi	r24, 0x20	; 32
    2780:	90 e0       	ldi	r25, 0x00	; 0
    2782:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <fputc>
    2786:	2a 94       	dec	r2
    2788:	f4 cf       	rjmp	.-24     	; 0x2772 <vfprintf+0x18c>
    278a:	f5 01       	movw	r30, r10
    278c:	37 fc       	sbrc	r3, 7
    278e:	85 91       	lpm	r24, Z+
    2790:	37 fe       	sbrs	r3, 7
    2792:	81 91       	ld	r24, Z+
    2794:	5f 01       	movw	r10, r30
    2796:	b6 01       	movw	r22, r12
    2798:	90 e0       	ldi	r25, 0x00	; 0
    279a:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <fputc>
    279e:	21 10       	cpse	r2, r1
    27a0:	2a 94       	dec	r2
    27a2:	21 e0       	ldi	r18, 0x01	; 1
    27a4:	82 1a       	sub	r8, r18
    27a6:	91 08       	sbc	r9, r1
    27a8:	81 14       	cp	r8, r1
    27aa:	91 04       	cpc	r9, r1
    27ac:	71 f7       	brne	.-36     	; 0x278a <vfprintf+0x1a4>
    27ae:	e8 c0       	rjmp	.+464    	; 0x2980 <vfprintf+0x39a>
    27b0:	84 36       	cpi	r24, 0x64	; 100
    27b2:	11 f0       	breq	.+4      	; 0x27b8 <vfprintf+0x1d2>
    27b4:	89 36       	cpi	r24, 0x69	; 105
    27b6:	41 f5       	brne	.+80     	; 0x2808 <vfprintf+0x222>
    27b8:	f8 01       	movw	r30, r16
    27ba:	37 fe       	sbrs	r3, 7
    27bc:	07 c0       	rjmp	.+14     	; 0x27cc <vfprintf+0x1e6>
    27be:	60 81       	ld	r22, Z
    27c0:	71 81       	ldd	r23, Z+1	; 0x01
    27c2:	82 81       	ldd	r24, Z+2	; 0x02
    27c4:	93 81       	ldd	r25, Z+3	; 0x03
    27c6:	0c 5f       	subi	r16, 0xFC	; 252
    27c8:	1f 4f       	sbci	r17, 0xFF	; 255
    27ca:	08 c0       	rjmp	.+16     	; 0x27dc <vfprintf+0x1f6>
    27cc:	60 81       	ld	r22, Z
    27ce:	71 81       	ldd	r23, Z+1	; 0x01
    27d0:	07 2e       	mov	r0, r23
    27d2:	00 0c       	add	r0, r0
    27d4:	88 0b       	sbc	r24, r24
    27d6:	99 0b       	sbc	r25, r25
    27d8:	0e 5f       	subi	r16, 0xFE	; 254
    27da:	1f 4f       	sbci	r17, 0xFF	; 255
    27dc:	f3 2d       	mov	r31, r3
    27de:	ff 76       	andi	r31, 0x6F	; 111
    27e0:	3f 2e       	mov	r3, r31
    27e2:	97 ff       	sbrs	r25, 7
    27e4:	09 c0       	rjmp	.+18     	; 0x27f8 <vfprintf+0x212>
    27e6:	90 95       	com	r25
    27e8:	80 95       	com	r24
    27ea:	70 95       	com	r23
    27ec:	61 95       	neg	r22
    27ee:	7f 4f       	sbci	r23, 0xFF	; 255
    27f0:	8f 4f       	sbci	r24, 0xFF	; 255
    27f2:	9f 4f       	sbci	r25, 0xFF	; 255
    27f4:	f0 68       	ori	r31, 0x80	; 128
    27f6:	3f 2e       	mov	r3, r31
    27f8:	2a e0       	ldi	r18, 0x0A	; 10
    27fa:	30 e0       	ldi	r19, 0x00	; 0
    27fc:	a3 01       	movw	r20, r6
    27fe:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <__ultoa_invert>
    2802:	88 2e       	mov	r8, r24
    2804:	86 18       	sub	r8, r6
    2806:	45 c0       	rjmp	.+138    	; 0x2892 <vfprintf+0x2ac>
    2808:	85 37       	cpi	r24, 0x75	; 117
    280a:	31 f4       	brne	.+12     	; 0x2818 <vfprintf+0x232>
    280c:	23 2d       	mov	r18, r3
    280e:	2f 7e       	andi	r18, 0xEF	; 239
    2810:	b2 2e       	mov	r11, r18
    2812:	2a e0       	ldi	r18, 0x0A	; 10
    2814:	30 e0       	ldi	r19, 0x00	; 0
    2816:	25 c0       	rjmp	.+74     	; 0x2862 <vfprintf+0x27c>
    2818:	93 2d       	mov	r25, r3
    281a:	99 7f       	andi	r25, 0xF9	; 249
    281c:	b9 2e       	mov	r11, r25
    281e:	8f 36       	cpi	r24, 0x6F	; 111
    2820:	c1 f0       	breq	.+48     	; 0x2852 <vfprintf+0x26c>
    2822:	18 f4       	brcc	.+6      	; 0x282a <vfprintf+0x244>
    2824:	88 35       	cpi	r24, 0x58	; 88
    2826:	79 f0       	breq	.+30     	; 0x2846 <vfprintf+0x260>
    2828:	b5 c0       	rjmp	.+362    	; 0x2994 <vfprintf+0x3ae>
    282a:	80 37       	cpi	r24, 0x70	; 112
    282c:	19 f0       	breq	.+6      	; 0x2834 <vfprintf+0x24e>
    282e:	88 37       	cpi	r24, 0x78	; 120
    2830:	21 f0       	breq	.+8      	; 0x283a <vfprintf+0x254>
    2832:	b0 c0       	rjmp	.+352    	; 0x2994 <vfprintf+0x3ae>
    2834:	e9 2f       	mov	r30, r25
    2836:	e0 61       	ori	r30, 0x10	; 16
    2838:	be 2e       	mov	r11, r30
    283a:	b4 fe       	sbrs	r11, 4
    283c:	0d c0       	rjmp	.+26     	; 0x2858 <vfprintf+0x272>
    283e:	fb 2d       	mov	r31, r11
    2840:	f4 60       	ori	r31, 0x04	; 4
    2842:	bf 2e       	mov	r11, r31
    2844:	09 c0       	rjmp	.+18     	; 0x2858 <vfprintf+0x272>
    2846:	34 fe       	sbrs	r3, 4
    2848:	0a c0       	rjmp	.+20     	; 0x285e <vfprintf+0x278>
    284a:	29 2f       	mov	r18, r25
    284c:	26 60       	ori	r18, 0x06	; 6
    284e:	b2 2e       	mov	r11, r18
    2850:	06 c0       	rjmp	.+12     	; 0x285e <vfprintf+0x278>
    2852:	28 e0       	ldi	r18, 0x08	; 8
    2854:	30 e0       	ldi	r19, 0x00	; 0
    2856:	05 c0       	rjmp	.+10     	; 0x2862 <vfprintf+0x27c>
    2858:	20 e1       	ldi	r18, 0x10	; 16
    285a:	30 e0       	ldi	r19, 0x00	; 0
    285c:	02 c0       	rjmp	.+4      	; 0x2862 <vfprintf+0x27c>
    285e:	20 e1       	ldi	r18, 0x10	; 16
    2860:	32 e0       	ldi	r19, 0x02	; 2
    2862:	f8 01       	movw	r30, r16
    2864:	b7 fe       	sbrs	r11, 7
    2866:	07 c0       	rjmp	.+14     	; 0x2876 <vfprintf+0x290>
    2868:	60 81       	ld	r22, Z
    286a:	71 81       	ldd	r23, Z+1	; 0x01
    286c:	82 81       	ldd	r24, Z+2	; 0x02
    286e:	93 81       	ldd	r25, Z+3	; 0x03
    2870:	0c 5f       	subi	r16, 0xFC	; 252
    2872:	1f 4f       	sbci	r17, 0xFF	; 255
    2874:	06 c0       	rjmp	.+12     	; 0x2882 <vfprintf+0x29c>
    2876:	60 81       	ld	r22, Z
    2878:	71 81       	ldd	r23, Z+1	; 0x01
    287a:	80 e0       	ldi	r24, 0x00	; 0
    287c:	90 e0       	ldi	r25, 0x00	; 0
    287e:	0e 5f       	subi	r16, 0xFE	; 254
    2880:	1f 4f       	sbci	r17, 0xFF	; 255
    2882:	a3 01       	movw	r20, r6
    2884:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <__ultoa_invert>
    2888:	88 2e       	mov	r8, r24
    288a:	86 18       	sub	r8, r6
    288c:	fb 2d       	mov	r31, r11
    288e:	ff 77       	andi	r31, 0x7F	; 127
    2890:	3f 2e       	mov	r3, r31
    2892:	36 fe       	sbrs	r3, 6
    2894:	0d c0       	rjmp	.+26     	; 0x28b0 <vfprintf+0x2ca>
    2896:	23 2d       	mov	r18, r3
    2898:	2e 7f       	andi	r18, 0xFE	; 254
    289a:	a2 2e       	mov	r10, r18
    289c:	89 14       	cp	r8, r9
    289e:	58 f4       	brcc	.+22     	; 0x28b6 <vfprintf+0x2d0>
    28a0:	34 fe       	sbrs	r3, 4
    28a2:	0b c0       	rjmp	.+22     	; 0x28ba <vfprintf+0x2d4>
    28a4:	32 fc       	sbrc	r3, 2
    28a6:	09 c0       	rjmp	.+18     	; 0x28ba <vfprintf+0x2d4>
    28a8:	83 2d       	mov	r24, r3
    28aa:	8e 7e       	andi	r24, 0xEE	; 238
    28ac:	a8 2e       	mov	r10, r24
    28ae:	05 c0       	rjmp	.+10     	; 0x28ba <vfprintf+0x2d4>
    28b0:	b8 2c       	mov	r11, r8
    28b2:	a3 2c       	mov	r10, r3
    28b4:	03 c0       	rjmp	.+6      	; 0x28bc <vfprintf+0x2d6>
    28b6:	b8 2c       	mov	r11, r8
    28b8:	01 c0       	rjmp	.+2      	; 0x28bc <vfprintf+0x2d6>
    28ba:	b9 2c       	mov	r11, r9
    28bc:	a4 fe       	sbrs	r10, 4
    28be:	0f c0       	rjmp	.+30     	; 0x28de <vfprintf+0x2f8>
    28c0:	fe 01       	movw	r30, r28
    28c2:	e8 0d       	add	r30, r8
    28c4:	f1 1d       	adc	r31, r1
    28c6:	80 81       	ld	r24, Z
    28c8:	80 33       	cpi	r24, 0x30	; 48
    28ca:	21 f4       	brne	.+8      	; 0x28d4 <vfprintf+0x2ee>
    28cc:	9a 2d       	mov	r25, r10
    28ce:	99 7e       	andi	r25, 0xE9	; 233
    28d0:	a9 2e       	mov	r10, r25
    28d2:	09 c0       	rjmp	.+18     	; 0x28e6 <vfprintf+0x300>
    28d4:	a2 fe       	sbrs	r10, 2
    28d6:	06 c0       	rjmp	.+12     	; 0x28e4 <vfprintf+0x2fe>
    28d8:	b3 94       	inc	r11
    28da:	b3 94       	inc	r11
    28dc:	04 c0       	rjmp	.+8      	; 0x28e6 <vfprintf+0x300>
    28de:	8a 2d       	mov	r24, r10
    28e0:	86 78       	andi	r24, 0x86	; 134
    28e2:	09 f0       	breq	.+2      	; 0x28e6 <vfprintf+0x300>
    28e4:	b3 94       	inc	r11
    28e6:	a3 fc       	sbrc	r10, 3
    28e8:	11 c0       	rjmp	.+34     	; 0x290c <vfprintf+0x326>
    28ea:	a0 fe       	sbrs	r10, 0
    28ec:	06 c0       	rjmp	.+12     	; 0x28fa <vfprintf+0x314>
    28ee:	b2 14       	cp	r11, r2
    28f0:	88 f4       	brcc	.+34     	; 0x2914 <vfprintf+0x32e>
    28f2:	28 0c       	add	r2, r8
    28f4:	92 2c       	mov	r9, r2
    28f6:	9b 18       	sub	r9, r11
    28f8:	0e c0       	rjmp	.+28     	; 0x2916 <vfprintf+0x330>
    28fa:	b2 14       	cp	r11, r2
    28fc:	60 f4       	brcc	.+24     	; 0x2916 <vfprintf+0x330>
    28fe:	b6 01       	movw	r22, r12
    2900:	80 e2       	ldi	r24, 0x20	; 32
    2902:	90 e0       	ldi	r25, 0x00	; 0
    2904:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <fputc>
    2908:	b3 94       	inc	r11
    290a:	f7 cf       	rjmp	.-18     	; 0x28fa <vfprintf+0x314>
    290c:	b2 14       	cp	r11, r2
    290e:	18 f4       	brcc	.+6      	; 0x2916 <vfprintf+0x330>
    2910:	2b 18       	sub	r2, r11
    2912:	02 c0       	rjmp	.+4      	; 0x2918 <vfprintf+0x332>
    2914:	98 2c       	mov	r9, r8
    2916:	21 2c       	mov	r2, r1
    2918:	a4 fe       	sbrs	r10, 4
    291a:	10 c0       	rjmp	.+32     	; 0x293c <vfprintf+0x356>
    291c:	b6 01       	movw	r22, r12
    291e:	80 e3       	ldi	r24, 0x30	; 48
    2920:	90 e0       	ldi	r25, 0x00	; 0
    2922:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <fputc>
    2926:	a2 fe       	sbrs	r10, 2
    2928:	17 c0       	rjmp	.+46     	; 0x2958 <vfprintf+0x372>
    292a:	a1 fc       	sbrc	r10, 1
    292c:	03 c0       	rjmp	.+6      	; 0x2934 <vfprintf+0x34e>
    292e:	88 e7       	ldi	r24, 0x78	; 120
    2930:	90 e0       	ldi	r25, 0x00	; 0
    2932:	02 c0       	rjmp	.+4      	; 0x2938 <vfprintf+0x352>
    2934:	88 e5       	ldi	r24, 0x58	; 88
    2936:	90 e0       	ldi	r25, 0x00	; 0
    2938:	b6 01       	movw	r22, r12
    293a:	0c c0       	rjmp	.+24     	; 0x2954 <vfprintf+0x36e>
    293c:	8a 2d       	mov	r24, r10
    293e:	86 78       	andi	r24, 0x86	; 134
    2940:	59 f0       	breq	.+22     	; 0x2958 <vfprintf+0x372>
    2942:	a1 fe       	sbrs	r10, 1
    2944:	02 c0       	rjmp	.+4      	; 0x294a <vfprintf+0x364>
    2946:	8b e2       	ldi	r24, 0x2B	; 43
    2948:	01 c0       	rjmp	.+2      	; 0x294c <vfprintf+0x366>
    294a:	80 e2       	ldi	r24, 0x20	; 32
    294c:	a7 fc       	sbrc	r10, 7
    294e:	8d e2       	ldi	r24, 0x2D	; 45
    2950:	b6 01       	movw	r22, r12
    2952:	90 e0       	ldi	r25, 0x00	; 0
    2954:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <fputc>
    2958:	89 14       	cp	r8, r9
    295a:	38 f4       	brcc	.+14     	; 0x296a <vfprintf+0x384>
    295c:	b6 01       	movw	r22, r12
    295e:	80 e3       	ldi	r24, 0x30	; 48
    2960:	90 e0       	ldi	r25, 0x00	; 0
    2962:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <fputc>
    2966:	9a 94       	dec	r9
    2968:	f7 cf       	rjmp	.-18     	; 0x2958 <vfprintf+0x372>
    296a:	8a 94       	dec	r8
    296c:	f3 01       	movw	r30, r6
    296e:	e8 0d       	add	r30, r8
    2970:	f1 1d       	adc	r31, r1
    2972:	80 81       	ld	r24, Z
    2974:	b6 01       	movw	r22, r12
    2976:	90 e0       	ldi	r25, 0x00	; 0
    2978:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <fputc>
    297c:	81 10       	cpse	r8, r1
    297e:	f5 cf       	rjmp	.-22     	; 0x296a <vfprintf+0x384>
    2980:	22 20       	and	r2, r2
    2982:	09 f4       	brne	.+2      	; 0x2986 <vfprintf+0x3a0>
    2984:	42 ce       	rjmp	.-892    	; 0x260a <vfprintf+0x24>
    2986:	b6 01       	movw	r22, r12
    2988:	80 e2       	ldi	r24, 0x20	; 32
    298a:	90 e0       	ldi	r25, 0x00	; 0
    298c:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <fputc>
    2990:	2a 94       	dec	r2
    2992:	f6 cf       	rjmp	.-20     	; 0x2980 <vfprintf+0x39a>
    2994:	f6 01       	movw	r30, r12
    2996:	86 81       	ldd	r24, Z+6	; 0x06
    2998:	97 81       	ldd	r25, Z+7	; 0x07
    299a:	02 c0       	rjmp	.+4      	; 0x29a0 <vfprintf+0x3ba>
    299c:	8f ef       	ldi	r24, 0xFF	; 255
    299e:	9f ef       	ldi	r25, 0xFF	; 255
    29a0:	2b 96       	adiw	r28, 0x0b	; 11
    29a2:	e2 e1       	ldi	r30, 0x12	; 18
    29a4:	0c 94 b0 15 	jmp	0x2b60	; 0x2b60 <__epilogue_restores__>

000029a8 <strnlen_P>:
    29a8:	fc 01       	movw	r30, r24
    29aa:	05 90       	lpm	r0, Z+
    29ac:	61 50       	subi	r22, 0x01	; 1
    29ae:	70 40       	sbci	r23, 0x00	; 0
    29b0:	01 10       	cpse	r0, r1
    29b2:	d8 f7       	brcc	.-10     	; 0x29aa <strnlen_P+0x2>
    29b4:	80 95       	com	r24
    29b6:	90 95       	com	r25
    29b8:	8e 0f       	add	r24, r30
    29ba:	9f 1f       	adc	r25, r31
    29bc:	08 95       	ret

000029be <strnlen>:
    29be:	fc 01       	movw	r30, r24
    29c0:	61 50       	subi	r22, 0x01	; 1
    29c2:	70 40       	sbci	r23, 0x00	; 0
    29c4:	01 90       	ld	r0, Z+
    29c6:	01 10       	cpse	r0, r1
    29c8:	d8 f7       	brcc	.-10     	; 0x29c0 <strnlen+0x2>
    29ca:	80 95       	com	r24
    29cc:	90 95       	com	r25
    29ce:	8e 0f       	add	r24, r30
    29d0:	9f 1f       	adc	r25, r31
    29d2:	08 95       	ret

000029d4 <strrev>:
    29d4:	dc 01       	movw	r26, r24
    29d6:	fc 01       	movw	r30, r24
    29d8:	67 2f       	mov	r22, r23
    29da:	71 91       	ld	r23, Z+
    29dc:	77 23       	and	r23, r23
    29de:	e1 f7       	brne	.-8      	; 0x29d8 <strrev+0x4>
    29e0:	32 97       	sbiw	r30, 0x02	; 2
    29e2:	04 c0       	rjmp	.+8      	; 0x29ec <strrev+0x18>
    29e4:	7c 91       	ld	r23, X
    29e6:	6d 93       	st	X+, r22
    29e8:	70 83       	st	Z, r23
    29ea:	62 91       	ld	r22, -Z
    29ec:	ae 17       	cp	r26, r30
    29ee:	bf 07       	cpc	r27, r31
    29f0:	c8 f3       	brcs	.-14     	; 0x29e4 <strrev+0x10>
    29f2:	08 95       	ret

000029f4 <fputc>:
    29f4:	0f 93       	push	r16
    29f6:	1f 93       	push	r17
    29f8:	cf 93       	push	r28
    29fa:	df 93       	push	r29
    29fc:	fb 01       	movw	r30, r22
    29fe:	23 81       	ldd	r18, Z+3	; 0x03
    2a00:	21 fd       	sbrc	r18, 1
    2a02:	03 c0       	rjmp	.+6      	; 0x2a0a <fputc+0x16>
    2a04:	8f ef       	ldi	r24, 0xFF	; 255
    2a06:	9f ef       	ldi	r25, 0xFF	; 255
    2a08:	2c c0       	rjmp	.+88     	; 0x2a62 <fputc+0x6e>
    2a0a:	22 ff       	sbrs	r18, 2
    2a0c:	16 c0       	rjmp	.+44     	; 0x2a3a <fputc+0x46>
    2a0e:	46 81       	ldd	r20, Z+6	; 0x06
    2a10:	57 81       	ldd	r21, Z+7	; 0x07
    2a12:	24 81       	ldd	r18, Z+4	; 0x04
    2a14:	35 81       	ldd	r19, Z+5	; 0x05
    2a16:	42 17       	cp	r20, r18
    2a18:	53 07       	cpc	r21, r19
    2a1a:	44 f4       	brge	.+16     	; 0x2a2c <fputc+0x38>
    2a1c:	a0 81       	ld	r26, Z
    2a1e:	b1 81       	ldd	r27, Z+1	; 0x01
    2a20:	9d 01       	movw	r18, r26
    2a22:	2f 5f       	subi	r18, 0xFF	; 255
    2a24:	3f 4f       	sbci	r19, 0xFF	; 255
    2a26:	31 83       	std	Z+1, r19	; 0x01
    2a28:	20 83       	st	Z, r18
    2a2a:	8c 93       	st	X, r24
    2a2c:	26 81       	ldd	r18, Z+6	; 0x06
    2a2e:	37 81       	ldd	r19, Z+7	; 0x07
    2a30:	2f 5f       	subi	r18, 0xFF	; 255
    2a32:	3f 4f       	sbci	r19, 0xFF	; 255
    2a34:	37 83       	std	Z+7, r19	; 0x07
    2a36:	26 83       	std	Z+6, r18	; 0x06
    2a38:	14 c0       	rjmp	.+40     	; 0x2a62 <fputc+0x6e>
    2a3a:	8b 01       	movw	r16, r22
    2a3c:	ec 01       	movw	r28, r24
    2a3e:	fb 01       	movw	r30, r22
    2a40:	00 84       	ldd	r0, Z+8	; 0x08
    2a42:	f1 85       	ldd	r31, Z+9	; 0x09
    2a44:	e0 2d       	mov	r30, r0
    2a46:	09 95       	icall
    2a48:	89 2b       	or	r24, r25
    2a4a:	e1 f6       	brne	.-72     	; 0x2a04 <fputc+0x10>
    2a4c:	d8 01       	movw	r26, r16
    2a4e:	16 96       	adiw	r26, 0x06	; 6
    2a50:	8d 91       	ld	r24, X+
    2a52:	9c 91       	ld	r25, X
    2a54:	17 97       	sbiw	r26, 0x07	; 7
    2a56:	01 96       	adiw	r24, 0x01	; 1
    2a58:	17 96       	adiw	r26, 0x07	; 7
    2a5a:	9c 93       	st	X, r25
    2a5c:	8e 93       	st	-X, r24
    2a5e:	16 97       	sbiw	r26, 0x06	; 6
    2a60:	ce 01       	movw	r24, r28
    2a62:	df 91       	pop	r29
    2a64:	cf 91       	pop	r28
    2a66:	1f 91       	pop	r17
    2a68:	0f 91       	pop	r16
    2a6a:	08 95       	ret

00002a6c <__ultoa_invert>:
    2a6c:	fa 01       	movw	r30, r20
    2a6e:	aa 27       	eor	r26, r26
    2a70:	28 30       	cpi	r18, 0x08	; 8
    2a72:	51 f1       	breq	.+84     	; 0x2ac8 <__ultoa_invert+0x5c>
    2a74:	20 31       	cpi	r18, 0x10	; 16
    2a76:	81 f1       	breq	.+96     	; 0x2ad8 <__ultoa_invert+0x6c>
    2a78:	e8 94       	clt
    2a7a:	6f 93       	push	r22
    2a7c:	6e 7f       	andi	r22, 0xFE	; 254
    2a7e:	6e 5f       	subi	r22, 0xFE	; 254
    2a80:	7f 4f       	sbci	r23, 0xFF	; 255
    2a82:	8f 4f       	sbci	r24, 0xFF	; 255
    2a84:	9f 4f       	sbci	r25, 0xFF	; 255
    2a86:	af 4f       	sbci	r26, 0xFF	; 255
    2a88:	b1 e0       	ldi	r27, 0x01	; 1
    2a8a:	3e d0       	rcall	.+124    	; 0x2b08 <__ultoa_invert+0x9c>
    2a8c:	b4 e0       	ldi	r27, 0x04	; 4
    2a8e:	3c d0       	rcall	.+120    	; 0x2b08 <__ultoa_invert+0x9c>
    2a90:	67 0f       	add	r22, r23
    2a92:	78 1f       	adc	r23, r24
    2a94:	89 1f       	adc	r24, r25
    2a96:	9a 1f       	adc	r25, r26
    2a98:	a1 1d       	adc	r26, r1
    2a9a:	68 0f       	add	r22, r24
    2a9c:	79 1f       	adc	r23, r25
    2a9e:	8a 1f       	adc	r24, r26
    2aa0:	91 1d       	adc	r25, r1
    2aa2:	a1 1d       	adc	r26, r1
    2aa4:	6a 0f       	add	r22, r26
    2aa6:	71 1d       	adc	r23, r1
    2aa8:	81 1d       	adc	r24, r1
    2aaa:	91 1d       	adc	r25, r1
    2aac:	a1 1d       	adc	r26, r1
    2aae:	20 d0       	rcall	.+64     	; 0x2af0 <__ultoa_invert+0x84>
    2ab0:	09 f4       	brne	.+2      	; 0x2ab4 <__ultoa_invert+0x48>
    2ab2:	68 94       	set
    2ab4:	3f 91       	pop	r19
    2ab6:	2a e0       	ldi	r18, 0x0A	; 10
    2ab8:	26 9f       	mul	r18, r22
    2aba:	11 24       	eor	r1, r1
    2abc:	30 19       	sub	r19, r0
    2abe:	30 5d       	subi	r19, 0xD0	; 208
    2ac0:	31 93       	st	Z+, r19
    2ac2:	de f6       	brtc	.-74     	; 0x2a7a <__ultoa_invert+0xe>
    2ac4:	cf 01       	movw	r24, r30
    2ac6:	08 95       	ret
    2ac8:	46 2f       	mov	r20, r22
    2aca:	47 70       	andi	r20, 0x07	; 7
    2acc:	40 5d       	subi	r20, 0xD0	; 208
    2ace:	41 93       	st	Z+, r20
    2ad0:	b3 e0       	ldi	r27, 0x03	; 3
    2ad2:	0f d0       	rcall	.+30     	; 0x2af2 <__ultoa_invert+0x86>
    2ad4:	c9 f7       	brne	.-14     	; 0x2ac8 <__ultoa_invert+0x5c>
    2ad6:	f6 cf       	rjmp	.-20     	; 0x2ac4 <__ultoa_invert+0x58>
    2ad8:	46 2f       	mov	r20, r22
    2ada:	4f 70       	andi	r20, 0x0F	; 15
    2adc:	40 5d       	subi	r20, 0xD0	; 208
    2ade:	4a 33       	cpi	r20, 0x3A	; 58
    2ae0:	18 f0       	brcs	.+6      	; 0x2ae8 <__ultoa_invert+0x7c>
    2ae2:	49 5d       	subi	r20, 0xD9	; 217
    2ae4:	31 fd       	sbrc	r19, 1
    2ae6:	40 52       	subi	r20, 0x20	; 32
    2ae8:	41 93       	st	Z+, r20
    2aea:	02 d0       	rcall	.+4      	; 0x2af0 <__ultoa_invert+0x84>
    2aec:	a9 f7       	brne	.-22     	; 0x2ad8 <__ultoa_invert+0x6c>
    2aee:	ea cf       	rjmp	.-44     	; 0x2ac4 <__ultoa_invert+0x58>
    2af0:	b4 e0       	ldi	r27, 0x04	; 4
    2af2:	a6 95       	lsr	r26
    2af4:	97 95       	ror	r25
    2af6:	87 95       	ror	r24
    2af8:	77 95       	ror	r23
    2afa:	67 95       	ror	r22
    2afc:	ba 95       	dec	r27
    2afe:	c9 f7       	brne	.-14     	; 0x2af2 <__ultoa_invert+0x86>
    2b00:	00 97       	sbiw	r24, 0x00	; 0
    2b02:	61 05       	cpc	r22, r1
    2b04:	71 05       	cpc	r23, r1
    2b06:	08 95       	ret
    2b08:	9b 01       	movw	r18, r22
    2b0a:	ac 01       	movw	r20, r24
    2b0c:	0a 2e       	mov	r0, r26
    2b0e:	06 94       	lsr	r0
    2b10:	57 95       	ror	r21
    2b12:	47 95       	ror	r20
    2b14:	37 95       	ror	r19
    2b16:	27 95       	ror	r18
    2b18:	ba 95       	dec	r27
    2b1a:	c9 f7       	brne	.-14     	; 0x2b0e <__ultoa_invert+0xa2>
    2b1c:	62 0f       	add	r22, r18
    2b1e:	73 1f       	adc	r23, r19
    2b20:	84 1f       	adc	r24, r20
    2b22:	95 1f       	adc	r25, r21
    2b24:	a0 1d       	adc	r26, r0
    2b26:	08 95       	ret

00002b28 <__prologue_saves__>:
    2b28:	2f 92       	push	r2
    2b2a:	3f 92       	push	r3
    2b2c:	4f 92       	push	r4
    2b2e:	5f 92       	push	r5
    2b30:	6f 92       	push	r6
    2b32:	7f 92       	push	r7
    2b34:	8f 92       	push	r8
    2b36:	9f 92       	push	r9
    2b38:	af 92       	push	r10
    2b3a:	bf 92       	push	r11
    2b3c:	cf 92       	push	r12
    2b3e:	df 92       	push	r13
    2b40:	ef 92       	push	r14
    2b42:	ff 92       	push	r15
    2b44:	0f 93       	push	r16
    2b46:	1f 93       	push	r17
    2b48:	cf 93       	push	r28
    2b4a:	df 93       	push	r29
    2b4c:	cd b7       	in	r28, 0x3d	; 61
    2b4e:	de b7       	in	r29, 0x3e	; 62
    2b50:	ca 1b       	sub	r28, r26
    2b52:	db 0b       	sbc	r29, r27
    2b54:	0f b6       	in	r0, 0x3f	; 63
    2b56:	f8 94       	cli
    2b58:	de bf       	out	0x3e, r29	; 62
    2b5a:	0f be       	out	0x3f, r0	; 63
    2b5c:	cd bf       	out	0x3d, r28	; 61
    2b5e:	09 94       	ijmp

00002b60 <__epilogue_restores__>:
    2b60:	2a 88       	ldd	r2, Y+18	; 0x12
    2b62:	39 88       	ldd	r3, Y+17	; 0x11
    2b64:	48 88       	ldd	r4, Y+16	; 0x10
    2b66:	5f 84       	ldd	r5, Y+15	; 0x0f
    2b68:	6e 84       	ldd	r6, Y+14	; 0x0e
    2b6a:	7d 84       	ldd	r7, Y+13	; 0x0d
    2b6c:	8c 84       	ldd	r8, Y+12	; 0x0c
    2b6e:	9b 84       	ldd	r9, Y+11	; 0x0b
    2b70:	aa 84       	ldd	r10, Y+10	; 0x0a
    2b72:	b9 84       	ldd	r11, Y+9	; 0x09
    2b74:	c8 84       	ldd	r12, Y+8	; 0x08
    2b76:	df 80       	ldd	r13, Y+7	; 0x07
    2b78:	ee 80       	ldd	r14, Y+6	; 0x06
    2b7a:	fd 80       	ldd	r15, Y+5	; 0x05
    2b7c:	0c 81       	ldd	r16, Y+4	; 0x04
    2b7e:	1b 81       	ldd	r17, Y+3	; 0x03
    2b80:	aa 81       	ldd	r26, Y+2	; 0x02
    2b82:	b9 81       	ldd	r27, Y+1	; 0x01
    2b84:	ce 0f       	add	r28, r30
    2b86:	d1 1d       	adc	r29, r1
    2b88:	0f b6       	in	r0, 0x3f	; 63
    2b8a:	f8 94       	cli
    2b8c:	de bf       	out	0x3e, r29	; 62
    2b8e:	0f be       	out	0x3f, r0	; 63
    2b90:	cd bf       	out	0x3d, r28	; 61
    2b92:	ed 01       	movw	r28, r26
    2b94:	08 95       	ret

00002b96 <_exit>:
    2b96:	f8 94       	cli

00002b98 <__stop_program>:
    2b98:	ff cf       	rjmp	.-2      	; 0x2b98 <__stop_program>

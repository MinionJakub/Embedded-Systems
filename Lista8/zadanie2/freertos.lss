
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005e  00800100  000030d8  0000316c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000030d8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000688  0080015e  0080015e  000031ca  2**0
                  ALLOC
  3 .stab         000072fc  00000000  00000000  000031cc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000043c8  00000000  00000000  0000a4c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000e890  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000e8a4  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000e8e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000eed8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  0000f47a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  0000f494  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3a 00 	jmp	0x74	; 0x74 <__ctors_end>
       4:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
       8:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
       c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      10:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      14:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      18:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      1c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      20:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      24:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      28:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      2c:	0c 94 d7 11 	jmp	0x23ae	; 0x23ae <__vector_11>
      30:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      34:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      38:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      3c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      40:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      44:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      48:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      4c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      50:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      54:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      58:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      5c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      60:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      64:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>

00000068 <__trampolines_end>:
      68:	63 64       	ori	r22, 0x43	; 67
      6a:	69 6e       	ori	r22, 0xE9	; 233
      6c:	6f 70       	andi	r22, 0x0F	; 15
      6e:	73 75       	andi	r23, 0x53	; 83
      70:	78 58       	subi	r23, 0x88	; 136
      72:	5b 00       	.word	0x005b	; ????

00000074 <__ctors_end>:
      74:	11 24       	eor	r1, r1
      76:	1f be       	out	0x3f, r1	; 63
      78:	cf ef       	ldi	r28, 0xFF	; 255
      7a:	d8 e0       	ldi	r29, 0x08	; 8
      7c:	de bf       	out	0x3e, r29	; 62
      7e:	cd bf       	out	0x3d, r28	; 61

00000080 <__do_copy_data>:
      80:	11 e0       	ldi	r17, 0x01	; 1
      82:	a0 e0       	ldi	r26, 0x00	; 0
      84:	b1 e0       	ldi	r27, 0x01	; 1
      86:	e8 ed       	ldi	r30, 0xD8	; 216
      88:	f0 e3       	ldi	r31, 0x30	; 48
      8a:	02 c0       	rjmp	.+4      	; 0x90 <__do_copy_data+0x10>
      8c:	05 90       	lpm	r0, Z+
      8e:	0d 92       	st	X+, r0
      90:	ae 35       	cpi	r26, 0x5E	; 94
      92:	b1 07       	cpc	r27, r17
      94:	d9 f7       	brne	.-10     	; 0x8c <__do_copy_data+0xc>

00000096 <__do_clear_bss>:
      96:	27 e0       	ldi	r18, 0x07	; 7
      98:	ae e5       	ldi	r26, 0x5E	; 94
      9a:	b1 e0       	ldi	r27, 0x01	; 1
      9c:	01 c0       	rjmp	.+2      	; 0xa0 <.do_clear_bss_start>

0000009e <.do_clear_bss_loop>:
      9e:	1d 92       	st	X+, r1

000000a0 <.do_clear_bss_start>:
      a0:	a6 3e       	cpi	r26, 0xE6	; 230
      a2:	b2 07       	cpc	r27, r18
      a4:	e1 f7       	brne	.-8      	; 0x9e <.do_clear_bss_loop>
      a6:	0e 94 da 11 	call	0x23b4	; 0x23b4 <main>
      aa:	0c 94 6a 18 	jmp	0x30d4	; 0x30d4 <_exit>

000000ae <__bad_interrupt>:
      ae:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b2 <uart_transmit>:
  UCSR0B = _BV(RXEN0) | _BV(TXEN0);
  // ustaw format 8n1
  UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
}

int uart_transmit(char c, FILE *stream) {
      b2:	cf 93       	push	r28
      b4:	c8 2f       	mov	r28, r24
  while (!(UCSR0A & _BV(UDRE0))) taskYIELD();
      b6:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
      ba:	85 fd       	sbrc	r24, 5
      bc:	03 c0       	rjmp	.+6      	; 0xc4 <uart_transmit+0x12>
      be:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
      c2:	f9 cf       	rjmp	.-14     	; 0xb6 <uart_transmit+0x4>
  UDR0 = c;
      c4:	c0 93 c6 00 	sts	0x00C6, r28	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
  return 0;
}
      c8:	80 e0       	ldi	r24, 0x00	; 0
      ca:	90 e0       	ldi	r25, 0x00	; 0
      cc:	cf 91       	pop	r28
      ce:	08 95       	ret

000000d0 <uart_receive>:

int uart_receive(FILE *stream) {
  while (!(UCSR0A & _BV(RXC0))) taskYIELD();
      d0:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
      d4:	87 fd       	sbrc	r24, 7
      d6:	03 c0       	rjmp	.+6      	; 0xde <uart_receive+0xe>
      d8:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
      dc:	f9 cf       	rjmp	.-14     	; 0xd0 <uart_receive>
  return UDR0;
      de:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
}
      e2:	90 e0       	ldi	r25, 0x00	; 0
      e4:	08 95       	ret

000000e6 <vWriter>:
{

}

static void vWriter(void* pvParameters)
{
      e6:	cf 93       	push	r28
      e8:	df 93       	push	r29
      ea:	00 d0       	rcall	.+0      	; 0xec <vWriter+0x6>
      ec:	cd b7       	in	r28, 0x3d	; 61
      ee:	de b7       	in	r29, 0x3e	; 62
    BaseType_t xStatus;
    uint16_t SendValue;
    printf("Wpisz wartosc\r\n");
      f0:	8e e0       	ldi	r24, 0x0E	; 14
      f2:	91 e0       	ldi	r25, 0x01	; 1
      f4:	0e 94 41 12 	call	0x2482	; 0x2482 <puts>
    while(1){
        scanf("%"SCNu16,&SendValue);
      f8:	8e 01       	movw	r16, r28
      fa:	0f 5f       	subi	r16, 0xFF	; 255
      fc:	1f 4f       	sbci	r17, 0xFF	; 255
      fe:	8d e1       	ldi	r24, 0x1D	; 29
     100:	e8 2e       	mov	r14, r24
     102:	81 e0       	ldi	r24, 0x01	; 1
     104:	f8 2e       	mov	r15, r24
        printf("Send:\t%"PRIu16"\r\n",SendValue);
     106:	90 e2       	ldi	r25, 0x20	; 32
     108:	c9 2e       	mov	r12, r25
     10a:	91 e0       	ldi	r25, 0x01	; 1
     10c:	d9 2e       	mov	r13, r25
{
    BaseType_t xStatus;
    uint16_t SendValue;
    printf("Wpisz wartosc\r\n");
    while(1){
        scanf("%"SCNu16,&SendValue);
     10e:	1f 93       	push	r17
     110:	0f 93       	push	r16
     112:	ff 92       	push	r15
     114:	ef 92       	push	r14
     116:	0e 94 71 12 	call	0x24e2	; 0x24e2 <scanf>
        printf("Send:\t%"PRIu16"\r\n",SendValue);
     11a:	8a 81       	ldd	r24, Y+2	; 0x02
     11c:	8f 93       	push	r24
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	8f 93       	push	r24
     122:	df 92       	push	r13
     124:	cf 92       	push	r12
     126:	0e 94 2b 12 	call	0x2456	; 0x2456 <printf>
        xStatus = xQueueSendToBack(xQueue,&SendValue,0);
     12a:	20 e0       	ldi	r18, 0x00	; 0
     12c:	40 e0       	ldi	r20, 0x00	; 0
     12e:	50 e0       	ldi	r21, 0x00	; 0
     130:	b8 01       	movw	r22, r16
     132:	80 91 de 07 	lds	r24, 0x07DE	; 0x8007de <xQueue>
     136:	90 91 df 07 	lds	r25, 0x07DF	; 0x8007df <xQueue+0x1>
     13a:	0e 94 05 0a 	call	0x140a	; 0x140a <xQueueGenericSend>
        if(xStatus != pdPASS) printf("COULDN'T SEND VALUE\r\n");
     13e:	0f b6       	in	r0, 0x3f	; 63
     140:	f8 94       	cli
     142:	de bf       	out	0x3e, r29	; 62
     144:	0f be       	out	0x3f, r0	; 63
     146:	cd bf       	out	0x3d, r28	; 61
     148:	81 30       	cpi	r24, 0x01	; 1
     14a:	09 f3       	breq	.-62     	; 0x10e <vWriter+0x28>
     14c:	8b e2       	ldi	r24, 0x2B	; 43
     14e:	91 e0       	ldi	r25, 0x01	; 1
     150:	0e 94 41 12 	call	0x2482	; 0x2482 <puts>
     154:	dc cf       	rjmp	.-72     	; 0x10e <vWriter+0x28>

00000156 <uart_init>:

// inicjalizacja UART
void uart_init(void)
{
  // ustaw baudrate
  UBRR0 = UBRR_VALUE;
     156:	87 e6       	ldi	r24, 0x67	; 103
     158:	90 e0       	ldi	r25, 0x00	; 0
     15a:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
     15e:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
  // wyczyść rejestr UCSR0A
  UCSR0A = 0;
     162:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7f80c0>
  // włącz odbiornik i nadajnik
  UCSR0B = _BV(RXEN0) | _BV(TXEN0);
     166:	88 e1       	ldi	r24, 0x18	; 24
     168:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
  // ustaw format 8n1
  UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
     16c:	86 e0       	ldi	r24, 0x06	; 6
     16e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
     172:	08 95       	ret

00000174 <vBlinker>:
#define LED PB2
#define LED_DDR DDRB
#define LED_PORT PORTB

static void vBlinker(void* pvParameters)
{
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
     178:	00 d0       	rcall	.+0      	; 0x17a <vBlinker+0x6>
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
    uart_init();
     17e:	0e 94 ab 00 	call	0x156	; 0x156 <uart_init>
    stdin = stdout = stderr = &uart_file;
     182:	80 e0       	ldi	r24, 0x00	; 0
     184:	91 e0       	ldi	r25, 0x01	; 1
     186:	90 93 e5 07 	sts	0x07E5, r25	; 0x8007e5 <__iob+0x5>
     18a:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <__iob+0x4>
     18e:	90 93 e3 07 	sts	0x07E3, r25	; 0x8007e3 <__iob+0x3>
     192:	80 93 e2 07 	sts	0x07E2, r24	; 0x8007e2 <__iob+0x2>
     196:	90 93 e1 07 	sts	0x07E1, r25	; 0x8007e1 <__iob+0x1>
     19a:	80 93 e0 07 	sts	0x07E0, r24	; 0x8007e0 <__iob>
    BaseType_t xStatus;
    uint16_t value;
    const TickType_t xTicksToWait = pdMS_TO_TICKS(100);
    LED_DDR |= _BV(LED);
     19e:	22 9a       	sbi	0x04, 2	; 4
    while(1){
        xStatus = xQueueReceive(xQueue,&value,100/portTICK_PERIOD_MS);
        if(xStatus == pdPASS){
            printf("Read:\t%"PRIu16"\r\n",value);
     1a0:	00 e4       	ldi	r16, 0x40	; 64
     1a2:	11 e0       	ldi	r17, 0x01	; 1
    BaseType_t xStatus;
    uint16_t value;
    const TickType_t xTicksToWait = pdMS_TO_TICKS(100);
    LED_DDR |= _BV(LED);
    while(1){
        xStatus = xQueueReceive(xQueue,&value,100/portTICK_PERIOD_MS);
     1a4:	44 e6       	ldi	r20, 0x64	; 100
     1a6:	50 e0       	ldi	r21, 0x00	; 0
     1a8:	be 01       	movw	r22, r28
     1aa:	6f 5f       	subi	r22, 0xFF	; 255
     1ac:	7f 4f       	sbci	r23, 0xFF	; 255
     1ae:	80 91 de 07 	lds	r24, 0x07DE	; 0x8007de <xQueue>
     1b2:	90 91 df 07 	lds	r25, 0x07DF	; 0x8007df <xQueue+0x1>
     1b6:	0e 94 ed 0a 	call	0x15da	; 0x15da <xQueueReceive>
        if(xStatus == pdPASS){
     1ba:	81 30       	cpi	r24, 0x01	; 1
     1bc:	99 f7       	brne	.-26     	; 0x1a4 <vBlinker+0x30>
            printf("Read:\t%"PRIu16"\r\n",value);
     1be:	8a 81       	ldd	r24, Y+2	; 0x02
     1c0:	8f 93       	push	r24
     1c2:	89 81       	ldd	r24, Y+1	; 0x01
     1c4:	8f 93       	push	r24
     1c6:	1f 93       	push	r17
     1c8:	0f 93       	push	r16
     1ca:	0e 94 2b 12 	call	0x2456	; 0x2456 <printf>
            LED_PORT |= _BV(LED);
     1ce:	2a 9a       	sbi	0x05, 2	; 5
            uint16_t timing = value/portTICK_PERIOD_MS;
            vTaskDelay(timing);
     1d0:	89 81       	ldd	r24, Y+1	; 0x01
     1d2:	9a 81       	ldd	r25, Y+2	; 0x02
     1d4:	0e 94 1f 05 	call	0xa3e	; 0xa3e <vTaskDelay>
            // _delay_ms(value);
            LED_PORT &= ~_BV(LED);
     1d8:	2a 98       	cbi	0x05, 2	; 5
     1da:	0f 90       	pop	r0
     1dc:	0f 90       	pop	r0
     1de:	0f 90       	pop	r0
     1e0:	0f 90       	pop	r0
     1e2:	e0 cf       	rjmp	.-64     	; 0x1a4 <vBlinker+0x30>

000001e4 <vApplicationIdleHook>:
    return 0;
}


void vApplicationIdleHook(void)
{
     1e4:	08 95       	ret

000001e6 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     1e6:	e0 91 8c 01 	lds	r30, 0x018C	; 0x80018c <pxDelayedTaskList>
     1ea:	f0 91 8d 01 	lds	r31, 0x018D	; 0x80018d <pxDelayedTaskList+0x1>
     1ee:	80 81       	ld	r24, Z
     1f0:	81 11       	cpse	r24, r1
     1f2:	03 c0       	rjmp	.+6      	; 0x1fa <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     1f4:	8f ef       	ldi	r24, 0xFF	; 255
     1f6:	9f ef       	ldi	r25, 0xFF	; 255
     1f8:	0c c0       	rjmp	.+24     	; 0x212 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     1fa:	e0 91 8c 01 	lds	r30, 0x018C	; 0x80018c <pxDelayedTaskList>
     1fe:	f0 91 8d 01 	lds	r31, 0x018D	; 0x80018d <pxDelayedTaskList+0x1>
     202:	05 80       	ldd	r0, Z+5	; 0x05
     204:	f6 81       	ldd	r31, Z+6	; 0x06
     206:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     208:	06 80       	ldd	r0, Z+6	; 0x06
     20a:	f7 81       	ldd	r31, Z+7	; 0x07
     20c:	e0 2d       	mov	r30, r0
     20e:	82 81       	ldd	r24, Z+2	; 0x02
     210:	93 81       	ldd	r25, Z+3	; 0x03
     212:	90 93 64 01 	sts	0x0164, r25	; 0x800164 <xNextTaskUnblockTime+0x1>
     216:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <xNextTaskUnblockTime>
     21a:	08 95       	ret

0000021c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     21c:	ff 92       	push	r15
     21e:	0f 93       	push	r16
     220:	1f 93       	push	r17
     222:	cf 93       	push	r28
     224:	df 93       	push	r29
     226:	ec 01       	movw	r28, r24
     228:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     22a:	00 91 6b 01 	lds	r16, 0x016B	; 0x80016b <xTickCount>
     22e:	10 91 6c 01 	lds	r17, 0x016C	; 0x80016c <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     232:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <__data_end>
     236:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <__data_end+0x1>
     23a:	02 96       	adiw	r24, 0x02	; 2
     23c:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     240:	cf 3f       	cpi	r28, 0xFF	; 255
     242:	8f ef       	ldi	r24, 0xFF	; 255
     244:	d8 07       	cpc	r29, r24
     246:	89 f4       	brne	.+34     	; 0x26a <prvAddCurrentTaskToDelayedList+0x4e>
     248:	ff 20       	and	r15, r15
     24a:	79 f0       	breq	.+30     	; 0x26a <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     24c:	60 91 5e 01 	lds	r22, 0x015E	; 0x80015e <__data_end>
     250:	70 91 5f 01 	lds	r23, 0x015F	; 0x80015f <__data_end+0x1>
     254:	6e 5f       	subi	r22, 0xFE	; 254
     256:	7f 4f       	sbci	r23, 0xFF	; 255
     258:	8e e6       	ldi	r24, 0x6E	; 110
     25a:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     25c:	df 91       	pop	r29
     25e:	cf 91       	pop	r28
     260:	1f 91       	pop	r17
     262:	0f 91       	pop	r16
     264:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     266:	0c 94 f1 0d 	jmp	0x1be2	; 0x1be2 <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     26a:	c0 0f       	add	r28, r16
     26c:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     26e:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     272:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     276:	d3 83       	std	Z+3, r29	; 0x03
     278:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     27a:	60 91 5e 01 	lds	r22, 0x015E	; 0x80015e <__data_end>
     27e:	70 91 5f 01 	lds	r23, 0x015F	; 0x80015f <__data_end+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     282:	c0 17       	cp	r28, r16
     284:	d1 07       	cpc	r29, r17
     286:	68 f4       	brcc	.+26     	; 0x2a2 <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     288:	80 91 8a 01 	lds	r24, 0x018A	; 0x80018a <pxOverflowDelayedTaskList>
     28c:	90 91 8b 01 	lds	r25, 0x018B	; 0x80018b <pxOverflowDelayedTaskList+0x1>
     290:	6e 5f       	subi	r22, 0xFE	; 254
     292:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     294:	df 91       	pop	r29
     296:	cf 91       	pop	r28
     298:	1f 91       	pop	r17
     29a:	0f 91       	pop	r16
     29c:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     29e:	0c 94 12 0e 	jmp	0x1c24	; 0x1c24 <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     2a2:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <pxDelayedTaskList>
     2a6:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <pxDelayedTaskList+0x1>
     2aa:	6e 5f       	subi	r22, 0xFE	; 254
     2ac:	7f 4f       	sbci	r23, 0xFF	; 255
     2ae:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     2b2:	80 91 63 01 	lds	r24, 0x0163	; 0x800163 <xNextTaskUnblockTime>
     2b6:	90 91 64 01 	lds	r25, 0x0164	; 0x800164 <xNextTaskUnblockTime+0x1>
     2ba:	c8 17       	cp	r28, r24
     2bc:	d9 07       	cpc	r29, r25
     2be:	20 f4       	brcc	.+8      	; 0x2c8 <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     2c0:	d0 93 64 01 	sts	0x0164, r29	; 0x800164 <xNextTaskUnblockTime+0x1>
     2c4:	c0 93 63 01 	sts	0x0163, r28	; 0x800163 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     2c8:	df 91       	pop	r29
     2ca:	cf 91       	pop	r28
     2cc:	1f 91       	pop	r17
     2ce:	0f 91       	pop	r16
     2d0:	ff 90       	pop	r15
     2d2:	08 95       	ret

000002d4 <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     2d4:	80 91 77 01 	lds	r24, 0x0177	; 0x800177 <uxDeletedTasksWaitingCleanUp>
     2d8:	88 23       	and	r24, r24
     2da:	09 f1       	breq	.+66     	; 0x31e <prvIdleTask+0x4a>
		{
			taskENTER_CRITICAL();
     2dc:	0f b6       	in	r0, 0x3f	; 63
     2de:	f8 94       	cli
     2e0:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     2e2:	e0 91 7d 01 	lds	r30, 0x017D	; 0x80017d <xTasksWaitingTermination+0x5>
     2e6:	f0 91 7e 01 	lds	r31, 0x017E	; 0x80017e <xTasksWaitingTermination+0x6>
     2ea:	c6 81       	ldd	r28, Z+6	; 0x06
     2ec:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     2ee:	ce 01       	movw	r24, r28
     2f0:	02 96       	adiw	r24, 0x02	; 2
     2f2:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
				--uxCurrentNumberOfTasks;
     2f6:	80 91 6d 01 	lds	r24, 0x016D	; 0x80016d <uxCurrentNumberOfTasks>
     2fa:	81 50       	subi	r24, 0x01	; 1
     2fc:	80 93 6d 01 	sts	0x016D, r24	; 0x80016d <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     300:	80 91 77 01 	lds	r24, 0x0177	; 0x800177 <uxDeletedTasksWaitingCleanUp>
     304:	81 50       	subi	r24, 0x01	; 1
     306:	80 93 77 01 	sts	0x0177, r24	; 0x800177 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     30a:	0f 90       	pop	r0
     30c:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     30e:	8f 89       	ldd	r24, Y+23	; 0x17
     310:	98 8d       	ldd	r25, Y+24	; 0x18
     312:	0e 94 66 10 	call	0x20cc	; 0x20cc <vPortFree>
			vPortFree( pxTCB );
     316:	ce 01       	movw	r24, r28
     318:	0e 94 66 10 	call	0x20cc	; 0x20cc <vPortFree>
     31c:	db cf       	rjmp	.-74     	; 0x2d4 <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     31e:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <pxReadyTasksLists>
     322:	82 30       	cpi	r24, 0x02	; 2
     324:	10 f0       	brcs	.+4      	; 0x32a <prvIdleTask+0x56>
			{
				taskYIELD();
     326:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     32a:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     32e:	d2 cf       	rjmp	.-92     	; 0x2d4 <prvIdleTask>

00000330 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     330:	3f 92       	push	r3
     332:	4f 92       	push	r4
     334:	5f 92       	push	r5
     336:	6f 92       	push	r6
     338:	7f 92       	push	r7
     33a:	8f 92       	push	r8
     33c:	9f 92       	push	r9
     33e:	af 92       	push	r10
     340:	bf 92       	push	r11
     342:	cf 92       	push	r12
     344:	df 92       	push	r13
     346:	ef 92       	push	r14
     348:	ff 92       	push	r15
     34a:	0f 93       	push	r16
     34c:	1f 93       	push	r17
     34e:	cf 93       	push	r28
     350:	df 93       	push	r29
     352:	4c 01       	movw	r8, r24
     354:	16 2f       	mov	r17, r22
     356:	37 2e       	mov	r3, r23
     358:	6a 01       	movw	r12, r20
     35a:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     35c:	ca 01       	movw	r24, r20
     35e:	0e 94 34 10 	call	0x2068	; 0x2068 <pvPortMalloc>
     362:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     364:	89 2b       	or	r24, r25
     366:	09 f4       	brne	.+2      	; 0x36a <xTaskCreate+0x3a>
     368:	d1 c0       	rjmp	.+418    	; 0x50c <__EEPROM_REGION_LENGTH__+0x10c>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     36a:	86 e2       	ldi	r24, 0x26	; 38
     36c:	90 e0       	ldi	r25, 0x00	; 0
     36e:	0e 94 34 10 	call	0x2068	; 0x2068 <pvPortMalloc>
     372:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     374:	89 2b       	or	r24, r25
     376:	79 f0       	breq	.+30     	; 0x396 <xTaskCreate+0x66>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     378:	58 8e       	std	Y+24, r5	; 0x18
     37a:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     37c:	c6 01       	movw	r24, r12
     37e:	01 97       	sbiw	r24, 0x01	; 1
     380:	32 01       	movw	r6, r4
     382:	68 0e       	add	r6, r24
     384:	79 1e       	adc	r7, r25
     386:	be 01       	movw	r22, r28
     388:	67 5e       	subi	r22, 0xE7	; 231
     38a:	7f 4f       	sbci	r23, 0xFF	; 255
     38c:	e1 2f       	mov	r30, r17
     38e:	f3 2d       	mov	r31, r3
     390:	cf 01       	movw	r24, r30
     392:	08 96       	adiw	r24, 0x08	; 8
     394:	07 c0       	rjmp	.+14     	; 0x3a4 <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     396:	c2 01       	movw	r24, r4
     398:	0e 94 66 10 	call	0x20cc	; 0x20cc <vPortFree>
     39c:	b7 c0       	rjmp	.+366    	; 0x50c <__EEPROM_REGION_LENGTH__+0x10c>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     39e:	e8 17       	cp	r30, r24
     3a0:	f9 07       	cpc	r31, r25
     3a2:	49 f0       	breq	.+18     	; 0x3b6 <xTaskCreate+0x86>
     3a4:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     3a6:	41 91       	ld	r20, Z+
     3a8:	db 01       	movw	r26, r22
     3aa:	4d 93       	st	X+, r20
     3ac:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     3ae:	d9 01       	movw	r26, r18
     3b0:	2c 91       	ld	r18, X
     3b2:	21 11       	cpse	r18, r1
     3b4:	f4 cf       	rjmp	.-24     	; 0x39e <xTaskCreate+0x6e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     3b6:	18 a2       	std	Y+32, r1	; 0x20
     3b8:	04 30       	cpi	r16, 0x04	; 4
     3ba:	08 f0       	brcs	.+2      	; 0x3be <xTaskCreate+0x8e>
     3bc:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     3be:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     3c0:	6e 01       	movw	r12, r28
     3c2:	b2 e0       	ldi	r27, 0x02	; 2
     3c4:	cb 0e       	add	r12, r27
     3c6:	d1 1c       	adc	r13, r1
     3c8:	c6 01       	movw	r24, r12
     3ca:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     3ce:	ce 01       	movw	r24, r28
     3d0:	0c 96       	adiw	r24, 0x0c	; 12
     3d2:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     3d6:	d9 87       	std	Y+9, r29	; 0x09
     3d8:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     3da:	84 e0       	ldi	r24, 0x04	; 4
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	80 1b       	sub	r24, r16
     3e0:	91 09       	sbc	r25, r1
     3e2:	9d 87       	std	Y+13, r25	; 0x0d
     3e4:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     3e6:	db 8b       	std	Y+19, r29	; 0x13
     3e8:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     3ea:	19 a2       	std	Y+33, r1	; 0x21
     3ec:	1a a2       	std	Y+34, r1	; 0x22
     3ee:	1b a2       	std	Y+35, r1	; 0x23
     3f0:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     3f2:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     3f4:	a5 01       	movw	r20, r10
     3f6:	b4 01       	movw	r22, r8
     3f8:	c3 01       	movw	r24, r6
     3fa:	0e 94 75 10 	call	0x20ea	; 0x20ea <pxPortInitialiseStack>
     3fe:	99 83       	std	Y+1, r25	; 0x01
     400:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     402:	e1 14       	cp	r14, r1
     404:	f1 04       	cpc	r15, r1
     406:	19 f0       	breq	.+6      	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     408:	f7 01       	movw	r30, r14
     40a:	d1 83       	std	Z+1, r29	; 0x01
     40c:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     40e:	0f b6       	in	r0, 0x3f	; 63
     410:	f8 94       	cli
     412:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     414:	80 91 6d 01 	lds	r24, 0x016D	; 0x80016d <uxCurrentNumberOfTasks>
     418:	8f 5f       	subi	r24, 0xFF	; 255
     41a:	80 93 6d 01 	sts	0x016D, r24	; 0x80016d <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     41e:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <__data_end>
     422:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <__data_end+0x1>
     426:	89 2b       	or	r24, r25
     428:	d1 f5       	brne	.+116    	; 0x49e <__EEPROM_REGION_LENGTH__+0x9e>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     42a:	d0 93 5f 01 	sts	0x015F, r29	; 0x80015f <__data_end+0x1>
     42e:	c0 93 5e 01 	sts	0x015E, r28	; 0x80015e <__data_end>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     432:	80 91 6d 01 	lds	r24, 0x016D	; 0x80016d <uxCurrentNumberOfTasks>
     436:	81 30       	cpi	r24, 0x01	; 1
     438:	09 f0       	breq	.+2      	; 0x43c <__EEPROM_REGION_LENGTH__+0x3c>
     43a:	41 c0       	rjmp	.+130    	; 0x4be <__EEPROM_REGION_LENGTH__+0xbe>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     43c:	80 ea       	ldi	r24, 0xA0	; 160
     43e:	91 e0       	ldi	r25, 0x01	; 1
     440:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
     444:	89 ea       	ldi	r24, 0xA9	; 169
     446:	91 e0       	ldi	r25, 0x01	; 1
     448:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
     44c:	82 eb       	ldi	r24, 0xB2	; 178
     44e:	91 e0       	ldi	r25, 0x01	; 1
     450:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
     454:	8b eb       	ldi	r24, 0xBB	; 187
     456:	91 e0       	ldi	r25, 0x01	; 1
     458:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     45c:	87 e9       	ldi	r24, 0x97	; 151
     45e:	91 e0       	ldi	r25, 0x01	; 1
     460:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     464:	8e e8       	ldi	r24, 0x8E	; 142
     466:	91 e0       	ldi	r25, 0x01	; 1
     468:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
	vListInitialise( &xPendingReadyList );
     46c:	81 e8       	ldi	r24, 0x81	; 129
     46e:	91 e0       	ldi	r25, 0x01	; 1
     470:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     474:	88 e7       	ldi	r24, 0x78	; 120
     476:	91 e0       	ldi	r25, 0x01	; 1
     478:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     47c:	8e e6       	ldi	r24, 0x6E	; 110
     47e:	91 e0       	ldi	r25, 0x01	; 1
     480:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     484:	87 e9       	ldi	r24, 0x97	; 151
     486:	91 e0       	ldi	r25, 0x01	; 1
     488:	90 93 8d 01 	sts	0x018D, r25	; 0x80018d <pxDelayedTaskList+0x1>
     48c:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     490:	8e e8       	ldi	r24, 0x8E	; 142
     492:	91 e0       	ldi	r25, 0x01	; 1
     494:	90 93 8b 01 	sts	0x018B, r25	; 0x80018b <pxOverflowDelayedTaskList+0x1>
     498:	80 93 8a 01 	sts	0x018A, r24	; 0x80018a <pxOverflowDelayedTaskList>
     49c:	10 c0       	rjmp	.+32     	; 0x4be <__EEPROM_REGION_LENGTH__+0xbe>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     49e:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <xSchedulerRunning>
     4a2:	81 11       	cpse	r24, r1
     4a4:	0c c0       	rjmp	.+24     	; 0x4be <__EEPROM_REGION_LENGTH__+0xbe>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     4a6:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     4aa:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     4ae:	96 89       	ldd	r25, Z+22	; 0x16
     4b0:	8e 89       	ldd	r24, Y+22	; 0x16
     4b2:	89 17       	cp	r24, r25
     4b4:	20 f0       	brcs	.+8      	; 0x4be <__EEPROM_REGION_LENGTH__+0xbe>
				{
					pxCurrentTCB = pxNewTCB;
     4b6:	d0 93 5f 01 	sts	0x015F, r29	; 0x80015f <__data_end+0x1>
     4ba:	c0 93 5e 01 	sts	0x015E, r28	; 0x80015e <__data_end>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     4be:	80 91 65 01 	lds	r24, 0x0165	; 0x800165 <uxTaskNumber>
     4c2:	8f 5f       	subi	r24, 0xFF	; 255
     4c4:	80 93 65 01 	sts	0x0165, r24	; 0x800165 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     4c8:	8e 89       	ldd	r24, Y+22	; 0x16
     4ca:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <uxTopReadyPriority>
     4ce:	98 17       	cp	r25, r24
     4d0:	10 f4       	brcc	.+4      	; 0x4d6 <__EEPROM_REGION_LENGTH__+0xd6>
     4d2:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <uxTopReadyPriority>
     4d6:	f9 e0       	ldi	r31, 0x09	; 9
     4d8:	8f 9f       	mul	r24, r31
     4da:	c0 01       	movw	r24, r0
     4dc:	11 24       	eor	r1, r1
     4de:	b6 01       	movw	r22, r12
     4e0:	80 56       	subi	r24, 0x60	; 96
     4e2:	9e 4f       	sbci	r25, 0xFE	; 254
     4e4:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     4e8:	0f 90       	pop	r0
     4ea:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     4ec:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <xSchedulerRunning>
     4f0:	88 23       	and	r24, r24
     4f2:	51 f0       	breq	.+20     	; 0x508 <__EEPROM_REGION_LENGTH__+0x108>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     4f4:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     4f8:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     4fc:	96 89       	ldd	r25, Z+22	; 0x16
     4fe:	8e 89       	ldd	r24, Y+22	; 0x16
     500:	98 17       	cp	r25, r24
     502:	10 f4       	brcc	.+4      	; 0x508 <__EEPROM_REGION_LENGTH__+0x108>
		{
			taskYIELD_IF_USING_PREEMPTION();
     504:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     508:	81 e0       	ldi	r24, 0x01	; 1
     50a:	01 c0       	rjmp	.+2      	; 0x50e <__EEPROM_REGION_LENGTH__+0x10e>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     50c:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     50e:	df 91       	pop	r29
     510:	cf 91       	pop	r28
     512:	1f 91       	pop	r17
     514:	0f 91       	pop	r16
     516:	ff 90       	pop	r15
     518:	ef 90       	pop	r14
     51a:	df 90       	pop	r13
     51c:	cf 90       	pop	r12
     51e:	bf 90       	pop	r11
     520:	af 90       	pop	r10
     522:	9f 90       	pop	r9
     524:	8f 90       	pop	r8
     526:	7f 90       	pop	r7
     528:	6f 90       	pop	r6
     52a:	5f 90       	pop	r5
     52c:	4f 90       	pop	r4
     52e:	3f 90       	pop	r3
     530:	08 95       	ret

00000532 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     532:	0f 93       	push	r16
     534:	1f 93       	push	r17
     536:	cf 93       	push	r28
     538:	df 93       	push	r29
     53a:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     53c:	0f b6       	in	r0, 0x3f	; 63
     53e:	f8 94       	cli
     540:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     542:	89 2b       	or	r24, r25
     544:	21 f4       	brne	.+8      	; 0x54e <vTaskDelete+0x1c>
     546:	c0 91 5e 01 	lds	r28, 0x015E	; 0x80015e <__data_end>
     54a:	d0 91 5f 01 	lds	r29, 0x015F	; 0x80015f <__data_end+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     54e:	8e 01       	movw	r16, r28
     550:	0e 5f       	subi	r16, 0xFE	; 254
     552:	1f 4f       	sbci	r17, 0xFF	; 255
     554:	c8 01       	movw	r24, r16
     556:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     55a:	8c 89       	ldd	r24, Y+20	; 0x14
     55c:	9d 89       	ldd	r25, Y+21	; 0x15
     55e:	89 2b       	or	r24, r25
     560:	21 f0       	breq	.+8      	; 0x56a <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     562:	ce 01       	movw	r24, r28
     564:	0c 96       	adiw	r24, 0x0c	; 12
     566:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     56a:	80 91 65 01 	lds	r24, 0x0165	; 0x800165 <uxTaskNumber>
     56e:	8f 5f       	subi	r24, 0xFF	; 255
     570:	80 93 65 01 	sts	0x0165, r24	; 0x800165 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     574:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <__data_end>
     578:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <__data_end+0x1>
     57c:	c8 17       	cp	r28, r24
     57e:	d9 07       	cpc	r29, r25
     580:	59 f4       	brne	.+22     	; 0x598 <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     582:	b8 01       	movw	r22, r16
     584:	88 e7       	ldi	r24, 0x78	; 120
     586:	91 e0       	ldi	r25, 0x01	; 1
     588:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     58c:	80 91 77 01 	lds	r24, 0x0177	; 0x800177 <uxDeletedTasksWaitingCleanUp>
     590:	8f 5f       	subi	r24, 0xFF	; 255
     592:	80 93 77 01 	sts	0x0177, r24	; 0x800177 <uxDeletedTasksWaitingCleanUp>
     596:	0e c0       	rjmp	.+28     	; 0x5b4 <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     598:	80 91 6d 01 	lds	r24, 0x016D	; 0x80016d <uxCurrentNumberOfTasks>
     59c:	81 50       	subi	r24, 0x01	; 1
     59e:	80 93 6d 01 	sts	0x016D, r24	; 0x80016d <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     5a2:	8f 89       	ldd	r24, Y+23	; 0x17
     5a4:	98 8d       	ldd	r25, Y+24	; 0x18
     5a6:	0e 94 66 10 	call	0x20cc	; 0x20cc <vPortFree>
			vPortFree( pxTCB );
     5aa:	ce 01       	movw	r24, r28
     5ac:	0e 94 66 10 	call	0x20cc	; 0x20cc <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     5b0:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     5b4:	0f 90       	pop	r0
     5b6:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     5b8:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <xSchedulerRunning>
     5bc:	88 23       	and	r24, r24
     5be:	49 f0       	breq	.+18     	; 0x5d2 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     5c0:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <__data_end>
     5c4:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <__data_end+0x1>
     5c8:	c8 17       	cp	r28, r24
     5ca:	d9 07       	cpc	r29, r25
     5cc:	11 f4       	brne	.+4      	; 0x5d2 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     5ce:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     5d2:	df 91       	pop	r29
     5d4:	cf 91       	pop	r28
     5d6:	1f 91       	pop	r17
     5d8:	0f 91       	pop	r16
     5da:	08 95       	ret

000005dc <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     5dc:	0f 93       	push	r16
     5de:	1f 93       	push	r17
     5e0:	cf 93       	push	r28
     5e2:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     5e4:	20 91 5e 01 	lds	r18, 0x015E	; 0x80015e <__data_end>
     5e8:	30 91 5f 01 	lds	r19, 0x015F	; 0x80015f <__data_end+0x1>
     5ec:	82 17       	cp	r24, r18
     5ee:	93 07       	cpc	r25, r19
     5f0:	b9 f1       	breq	.+110    	; 0x660 <vTaskResume+0x84>
     5f2:	00 97       	sbiw	r24, 0x00	; 0
     5f4:	a9 f1       	breq	.+106    	; 0x660 <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     5f6:	0f b6       	in	r0, 0x3f	; 63
     5f8:	f8 94       	cli
     5fa:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     5fc:	fc 01       	movw	r30, r24
     5fe:	22 85       	ldd	r18, Z+10	; 0x0a
     600:	33 85       	ldd	r19, Z+11	; 0x0b
     602:	2e 56       	subi	r18, 0x6E	; 110
     604:	31 40       	sbci	r19, 0x01	; 1
     606:	51 f5       	brne	.+84     	; 0x65c <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     608:	fc 01       	movw	r30, r24
     60a:	24 89       	ldd	r18, Z+20	; 0x14
     60c:	35 89       	ldd	r19, Z+21	; 0x15
     60e:	f1 e0       	ldi	r31, 0x01	; 1
     610:	21 38       	cpi	r18, 0x81	; 129
     612:	3f 07       	cpc	r19, r31
     614:	19 f1       	breq	.+70     	; 0x65c <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     616:	23 2b       	or	r18, r19
     618:	09 f5       	brne	.+66     	; 0x65c <vTaskResume+0x80>
     61a:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     61c:	8c 01       	movw	r16, r24
     61e:	0e 5f       	subi	r16, 0xFE	; 254
     620:	1f 4f       	sbci	r17, 0xFF	; 255
     622:	c8 01       	movw	r24, r16
     624:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     628:	8e 89       	ldd	r24, Y+22	; 0x16
     62a:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <uxTopReadyPriority>
     62e:	98 17       	cp	r25, r24
     630:	10 f4       	brcc	.+4      	; 0x636 <vTaskResume+0x5a>
     632:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <uxTopReadyPriority>
     636:	29 e0       	ldi	r18, 0x09	; 9
     638:	82 9f       	mul	r24, r18
     63a:	c0 01       	movw	r24, r0
     63c:	11 24       	eor	r1, r1
     63e:	b8 01       	movw	r22, r16
     640:	80 56       	subi	r24, 0x60	; 96
     642:	9e 4f       	sbci	r25, 0xFE	; 254
     644:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     648:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     64c:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     650:	9e 89       	ldd	r25, Y+22	; 0x16
     652:	86 89       	ldd	r24, Z+22	; 0x16
     654:	98 17       	cp	r25, r24
     656:	10 f0       	brcs	.+4      	; 0x65c <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     658:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     65c:	0f 90       	pop	r0
     65e:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     660:	df 91       	pop	r29
     662:	cf 91       	pop	r28
     664:	1f 91       	pop	r17
     666:	0f 91       	pop	r16
     668:	08 95       	ret

0000066a <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     66a:	ef 92       	push	r14
     66c:	ff 92       	push	r15
     66e:	1f 93       	push	r17
     670:	cf 93       	push	r28
     672:	df 93       	push	r29
     674:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     676:	8a 85       	ldd	r24, Y+10	; 0x0a
     678:	9b 85       	ldd	r25, Y+11	; 0x0b
     67a:	8e 56       	subi	r24, 0x6E	; 110
     67c:	91 40       	sbci	r25, 0x01	; 1
     67e:	99 f4       	brne	.+38     	; 0x6a6 <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     680:	8c 89       	ldd	r24, Y+20	; 0x14
     682:	9d 89       	ldd	r25, Y+21	; 0x15
     684:	21 e0       	ldi	r18, 0x01	; 1
     686:	81 38       	cpi	r24, 0x81	; 129
     688:	92 07       	cpc	r25, r18
     68a:	69 f0       	breq	.+26     	; 0x6a6 <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     68c:	89 2b       	or	r24, r25
     68e:	59 f4       	brne	.+22     	; 0x6a6 <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     690:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <uxSchedulerSuspended>
     694:	88 23       	and	r24, r24
     696:	49 f0       	breq	.+18     	; 0x6aa <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     698:	be 01       	movw	r22, r28
     69a:	64 5f       	subi	r22, 0xF4	; 244
     69c:	7f 4f       	sbci	r23, 0xFF	; 255
     69e:	81 e8       	ldi	r24, 0x81	; 129
     6a0:	91 e0       	ldi	r25, 0x01	; 1
     6a2:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     6a6:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     6a8:	21 c0       	rjmp	.+66     	; 0x6ec <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     6aa:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     6ae:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     6b2:	11 e0       	ldi	r17, 0x01	; 1
     6b4:	9e 89       	ldd	r25, Y+22	; 0x16
     6b6:	86 89       	ldd	r24, Z+22	; 0x16
     6b8:	98 17       	cp	r25, r24
     6ba:	08 f4       	brcc	.+2      	; 0x6be <xTaskResumeFromISR+0x54>
     6bc:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     6be:	7e 01       	movw	r14, r28
     6c0:	82 e0       	ldi	r24, 0x02	; 2
     6c2:	e8 0e       	add	r14, r24
     6c4:	f1 1c       	adc	r15, r1
     6c6:	c7 01       	movw	r24, r14
     6c8:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     6cc:	8e 89       	ldd	r24, Y+22	; 0x16
     6ce:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <uxTopReadyPriority>
     6d2:	98 17       	cp	r25, r24
     6d4:	10 f4       	brcc	.+4      	; 0x6da <xTaskResumeFromISR+0x70>
     6d6:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <uxTopReadyPriority>
     6da:	29 e0       	ldi	r18, 0x09	; 9
     6dc:	82 9f       	mul	r24, r18
     6de:	c0 01       	movw	r24, r0
     6e0:	11 24       	eor	r1, r1
     6e2:	b7 01       	movw	r22, r14
     6e4:	80 56       	subi	r24, 0x60	; 96
     6e6:	9e 4f       	sbci	r25, 0xFE	; 254
     6e8:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     6ec:	81 2f       	mov	r24, r17
     6ee:	df 91       	pop	r29
     6f0:	cf 91       	pop	r28
     6f2:	1f 91       	pop	r17
     6f4:	ff 90       	pop	r15
     6f6:	ef 90       	pop	r14
     6f8:	08 95       	ret

000006fa <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     6fa:	ef 92       	push	r14
     6fc:	ff 92       	push	r15
     6fe:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     700:	81 e6       	ldi	r24, 0x61	; 97
     702:	e8 2e       	mov	r14, r24
     704:	81 e0       	ldi	r24, 0x01	; 1
     706:	f8 2e       	mov	r15, r24
     708:	00 e0       	ldi	r16, 0x00	; 0
     70a:	20 e0       	ldi	r18, 0x00	; 0
     70c:	30 e0       	ldi	r19, 0x00	; 0
     70e:	45 e5       	ldi	r20, 0x55	; 85
     710:	50 e0       	ldi	r21, 0x00	; 0
     712:	68 e5       	ldi	r22, 0x58	; 88
     714:	71 e0       	ldi	r23, 0x01	; 1
     716:	8a e6       	ldi	r24, 0x6A	; 106
     718:	91 e0       	ldi	r25, 0x01	; 1
     71a:	0e 94 98 01 	call	0x330	; 0x330 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     71e:	81 30       	cpi	r24, 0x01	; 1
     720:	91 f4       	brne	.+36     	; 0x746 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     722:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     724:	2f ef       	ldi	r18, 0xFF	; 255
     726:	3f ef       	ldi	r19, 0xFF	; 255
     728:	30 93 64 01 	sts	0x0164, r19	; 0x800164 <xNextTaskUnblockTime+0x1>
     72c:	20 93 63 01 	sts	0x0163, r18	; 0x800163 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     730:	80 93 69 01 	sts	0x0169, r24	; 0x800169 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     734:	10 92 6c 01 	sts	0x016C, r1	; 0x80016c <xTickCount+0x1>
     738:	10 92 6b 01 	sts	0x016B, r1	; 0x80016b <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     73c:	0f 91       	pop	r16
     73e:	ff 90       	pop	r15
     740:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     742:	0c 94 e1 10 	jmp	0x21c2	; 0x21c2 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     746:	0f 91       	pop	r16
     748:	ff 90       	pop	r15
     74a:	ef 90       	pop	r14
     74c:	08 95       	ret

0000074e <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     74e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     750:	10 92 69 01 	sts	0x0169, r1	; 0x800169 <xSchedulerRunning>
	vPortEndScheduler();
     754:	0c 94 21 11 	jmp	0x2242	; 0x2242 <vPortEndScheduler>

00000758 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     758:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <uxSchedulerSuspended>
     75c:	8f 5f       	subi	r24, 0xFF	; 255
     75e:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <uxSchedulerSuspended>
     762:	08 95       	ret

00000764 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     764:	0f b6       	in	r0, 0x3f	; 63
     766:	f8 94       	cli
     768:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     76a:	80 91 6b 01 	lds	r24, 0x016B	; 0x80016b <xTickCount>
     76e:	90 91 6c 01 	lds	r25, 0x016C	; 0x80016c <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     772:	0f 90       	pop	r0
     774:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     776:	08 95       	ret

00000778 <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     778:	80 91 6b 01 	lds	r24, 0x016B	; 0x80016b <xTickCount>
     77c:	90 91 6c 01 	lds	r25, 0x016C	; 0x80016c <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     780:	08 95       	ret

00000782 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     782:	80 91 6d 01 	lds	r24, 0x016D	; 0x80016d <uxCurrentNumberOfTasks>
}
     786:	08 95       	ret

00000788 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     788:	00 97       	sbiw	r24, 0x00	; 0
     78a:	21 f4       	brne	.+8      	; 0x794 <pcTaskGetName+0xc>
     78c:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <__data_end>
     790:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <__data_end+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     794:	49 96       	adiw	r24, 0x19	; 25
     796:	08 95       	ret

00000798 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     798:	cf 92       	push	r12
     79a:	df 92       	push	r13
     79c:	ef 92       	push	r14
     79e:	ff 92       	push	r15
     7a0:	0f 93       	push	r16
     7a2:	1f 93       	push	r17
     7a4:	cf 93       	push	r28
     7a6:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     7a8:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <uxSchedulerSuspended>
     7ac:	81 11       	cpse	r24, r1
     7ae:	8c c0       	rjmp	.+280    	; 0x8c8 <__DATA_REGION_LENGTH__+0xc8>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     7b0:	00 91 6b 01 	lds	r16, 0x016B	; 0x80016b <xTickCount>
     7b4:	10 91 6c 01 	lds	r17, 0x016C	; 0x80016c <xTickCount+0x1>
     7b8:	0f 5f       	subi	r16, 0xFF	; 255
     7ba:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     7bc:	10 93 6c 01 	sts	0x016C, r17	; 0x80016c <xTickCount+0x1>
     7c0:	00 93 6b 01 	sts	0x016B, r16	; 0x80016b <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     7c4:	01 15       	cp	r16, r1
     7c6:	11 05       	cpc	r17, r1
     7c8:	b9 f4       	brne	.+46     	; 0x7f8 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     7ca:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <pxDelayedTaskList>
     7ce:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <pxDelayedTaskList+0x1>
     7d2:	20 91 8a 01 	lds	r18, 0x018A	; 0x80018a <pxOverflowDelayedTaskList>
     7d6:	30 91 8b 01 	lds	r19, 0x018B	; 0x80018b <pxOverflowDelayedTaskList+0x1>
     7da:	30 93 8d 01 	sts	0x018D, r19	; 0x80018d <pxDelayedTaskList+0x1>
     7de:	20 93 8c 01 	sts	0x018C, r18	; 0x80018c <pxDelayedTaskList>
     7e2:	90 93 8b 01 	sts	0x018B, r25	; 0x80018b <pxOverflowDelayedTaskList+0x1>
     7e6:	80 93 8a 01 	sts	0x018A, r24	; 0x80018a <pxOverflowDelayedTaskList>
     7ea:	80 91 66 01 	lds	r24, 0x0166	; 0x800166 <xNumOfOverflows>
     7ee:	8f 5f       	subi	r24, 0xFF	; 255
     7f0:	80 93 66 01 	sts	0x0166, r24	; 0x800166 <xNumOfOverflows>
     7f4:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     7f8:	80 91 63 01 	lds	r24, 0x0163	; 0x800163 <xNextTaskUnblockTime>
     7fc:	90 91 64 01 	lds	r25, 0x0164	; 0x800164 <xNextTaskUnblockTime+0x1>
     800:	c0 e0       	ldi	r28, 0x00	; 0
     802:	08 17       	cp	r16, r24
     804:	19 07       	cpc	r17, r25
     806:	08 f4       	brcc	.+2      	; 0x80a <__DATA_REGION_LENGTH__+0xa>
     808:	4f c0       	rjmp	.+158    	; 0x8a8 <__DATA_REGION_LENGTH__+0xa8>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     80a:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     80c:	e0 91 8c 01 	lds	r30, 0x018C	; 0x80018c <pxDelayedTaskList>
     810:	f0 91 8d 01 	lds	r31, 0x018D	; 0x80018d <pxDelayedTaskList+0x1>
     814:	80 81       	ld	r24, Z
     816:	81 11       	cpse	r24, r1
     818:	03 c0       	rjmp	.+6      	; 0x820 <__DATA_REGION_LENGTH__+0x20>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     81a:	8f ef       	ldi	r24, 0xFF	; 255
     81c:	9f ef       	ldi	r25, 0xFF	; 255
     81e:	11 c0       	rjmp	.+34     	; 0x842 <__DATA_REGION_LENGTH__+0x42>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     820:	e0 91 8c 01 	lds	r30, 0x018C	; 0x80018c <pxDelayedTaskList>
     824:	f0 91 8d 01 	lds	r31, 0x018D	; 0x80018d <pxDelayedTaskList+0x1>
     828:	05 80       	ldd	r0, Z+5	; 0x05
     82a:	f6 81       	ldd	r31, Z+6	; 0x06
     82c:	e0 2d       	mov	r30, r0
     82e:	e6 80       	ldd	r14, Z+6	; 0x06
     830:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     832:	d7 01       	movw	r26, r14
     834:	12 96       	adiw	r26, 0x02	; 2
     836:	8d 91       	ld	r24, X+
     838:	9c 91       	ld	r25, X
     83a:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     83c:	08 17       	cp	r16, r24
     83e:	19 07       	cpc	r17, r25
     840:	28 f4       	brcc	.+10     	; 0x84c <__DATA_REGION_LENGTH__+0x4c>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     842:	90 93 64 01 	sts	0x0164, r25	; 0x800164 <xNextTaskUnblockTime+0x1>
     846:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     84a:	2e c0       	rjmp	.+92     	; 0x8a8 <__DATA_REGION_LENGTH__+0xa8>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     84c:	67 01       	movw	r12, r14
     84e:	b2 e0       	ldi	r27, 0x02	; 2
     850:	cb 0e       	add	r12, r27
     852:	d1 1c       	adc	r13, r1
     854:	c6 01       	movw	r24, r12
     856:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     85a:	f7 01       	movw	r30, r14
     85c:	84 89       	ldd	r24, Z+20	; 0x14
     85e:	95 89       	ldd	r25, Z+21	; 0x15
     860:	89 2b       	or	r24, r25
     862:	21 f0       	breq	.+8      	; 0x86c <__DATA_REGION_LENGTH__+0x6c>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     864:	c7 01       	movw	r24, r14
     866:	0c 96       	adiw	r24, 0x0c	; 12
     868:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     86c:	d7 01       	movw	r26, r14
     86e:	56 96       	adiw	r26, 0x16	; 22
     870:	8c 91       	ld	r24, X
     872:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <uxTopReadyPriority>
     876:	98 17       	cp	r25, r24
     878:	10 f4       	brcc	.+4      	; 0x87e <__DATA_REGION_LENGTH__+0x7e>
     87a:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <uxTopReadyPriority>
     87e:	d8 9f       	mul	r29, r24
     880:	c0 01       	movw	r24, r0
     882:	11 24       	eor	r1, r1
     884:	b6 01       	movw	r22, r12
     886:	80 56       	subi	r24, 0x60	; 96
     888:	9e 4f       	sbci	r25, 0xFE	; 254
     88a:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     88e:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     892:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     896:	d7 01       	movw	r26, r14
     898:	56 96       	adiw	r26, 0x16	; 22
     89a:	9c 91       	ld	r25, X
     89c:	86 89       	ldd	r24, Z+22	; 0x16
     89e:	98 17       	cp	r25, r24
     8a0:	08 f4       	brcc	.+2      	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
     8a2:	b4 cf       	rjmp	.-152    	; 0x80c <__DATA_REGION_LENGTH__+0xc>
						{
							xSwitchRequired = pdTRUE;
     8a4:	c1 e0       	ldi	r28, 0x01	; 1
     8a6:	b2 cf       	rjmp	.-156    	; 0x80c <__DATA_REGION_LENGTH__+0xc>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     8a8:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     8ac:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     8b0:	e6 89       	ldd	r30, Z+22	; 0x16
     8b2:	b9 e0       	ldi	r27, 0x09	; 9
     8b4:	eb 9f       	mul	r30, r27
     8b6:	f0 01       	movw	r30, r0
     8b8:	11 24       	eor	r1, r1
     8ba:	e0 56       	subi	r30, 0x60	; 96
     8bc:	fe 4f       	sbci	r31, 0xFE	; 254
     8be:	80 81       	ld	r24, Z
     8c0:	82 30       	cpi	r24, 0x02	; 2
     8c2:	40 f0       	brcs	.+16     	; 0x8d4 <__DATA_REGION_LENGTH__+0xd4>
			{
				xSwitchRequired = pdTRUE;
     8c4:	c1 e0       	ldi	r28, 0x01	; 1
     8c6:	06 c0       	rjmp	.+12     	; 0x8d4 <__DATA_REGION_LENGTH__+0xd4>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     8c8:	80 91 68 01 	lds	r24, 0x0168	; 0x800168 <uxPendedTicks>
     8cc:	8f 5f       	subi	r24, 0xFF	; 255
     8ce:	80 93 68 01 	sts	0x0168, r24	; 0x800168 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     8d2:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     8d4:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <xYieldPending>
     8d8:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     8da:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     8dc:	8c 2f       	mov	r24, r28
     8de:	df 91       	pop	r29
     8e0:	cf 91       	pop	r28
     8e2:	1f 91       	pop	r17
     8e4:	0f 91       	pop	r16
     8e6:	ff 90       	pop	r15
     8e8:	ef 90       	pop	r14
     8ea:	df 90       	pop	r13
     8ec:	cf 90       	pop	r12
     8ee:	08 95       	ret

000008f0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     8f0:	ef 92       	push	r14
     8f2:	ff 92       	push	r15
     8f4:	0f 93       	push	r16
     8f6:	1f 93       	push	r17
     8f8:	cf 93       	push	r28
     8fa:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     8fc:	0f b6       	in	r0, 0x3f	; 63
     8fe:	f8 94       	cli
     900:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     902:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <uxSchedulerSuspended>
     906:	81 50       	subi	r24, 0x01	; 1
     908:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     90c:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <uxSchedulerSuspended>
     910:	88 23       	and	r24, r24
     912:	11 f0       	breq	.+4      	; 0x918 <__stack+0x19>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     914:	80 e0       	ldi	r24, 0x00	; 0
     916:	52 c0       	rjmp	.+164    	; 0x9bc <__stack+0xbd>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     918:	80 91 6d 01 	lds	r24, 0x016D	; 0x80016d <uxCurrentNumberOfTasks>
     91c:	88 23       	and	r24, r24
     91e:	d1 f3       	breq	.-12     	; 0x914 <__stack+0x15>
     920:	c0 e0       	ldi	r28, 0x00	; 0
     922:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     924:	89 e0       	ldi	r24, 0x09	; 9
     926:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     928:	ee 24       	eor	r14, r14
     92a:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     92c:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <xPendingReadyList>
     930:	88 23       	and	r24, r24
     932:	51 f1       	breq	.+84     	; 0x988 <__stack+0x89>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     934:	e0 91 86 01 	lds	r30, 0x0186	; 0x800186 <xPendingReadyList+0x5>
     938:	f0 91 87 01 	lds	r31, 0x0187	; 0x800187 <xPendingReadyList+0x6>
     93c:	c6 81       	ldd	r28, Z+6	; 0x06
     93e:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     940:	ce 01       	movw	r24, r28
     942:	0c 96       	adiw	r24, 0x0c	; 12
     944:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     948:	8e 01       	movw	r16, r28
     94a:	0e 5f       	subi	r16, 0xFE	; 254
     94c:	1f 4f       	sbci	r17, 0xFF	; 255
     94e:	c8 01       	movw	r24, r16
     950:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     954:	8e 89       	ldd	r24, Y+22	; 0x16
     956:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <uxTopReadyPriority>
     95a:	98 17       	cp	r25, r24
     95c:	10 f4       	brcc	.+4      	; 0x962 <__stack+0x63>
     95e:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <uxTopReadyPriority>
     962:	f8 9e       	mul	r15, r24
     964:	c0 01       	movw	r24, r0
     966:	11 24       	eor	r1, r1
     968:	b8 01       	movw	r22, r16
     96a:	80 56       	subi	r24, 0x60	; 96
     96c:	9e 4f       	sbci	r25, 0xFE	; 254
     96e:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     972:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     976:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     97a:	9e 89       	ldd	r25, Y+22	; 0x16
     97c:	86 89       	ldd	r24, Z+22	; 0x16
     97e:	98 17       	cp	r25, r24
     980:	a8 f2       	brcs	.-86     	; 0x92c <__stack+0x2d>
					{
						xYieldPending = pdTRUE;
     982:	e0 92 67 01 	sts	0x0167, r14	; 0x800167 <xYieldPending>
     986:	d2 cf       	rjmp	.-92     	; 0x92c <__stack+0x2d>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     988:	cd 2b       	or	r28, r29
     98a:	11 f0       	breq	.+4      	; 0x990 <__stack+0x91>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     98c:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     990:	c0 91 68 01 	lds	r28, 0x0168	; 0x800168 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     994:	cc 23       	and	r28, r28
     996:	51 f0       	breq	.+20     	; 0x9ac <__stack+0xad>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     998:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     99a:	0e 94 cc 03 	call	0x798	; 0x798 <xTaskIncrementTick>
     99e:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     9a0:	d0 93 67 01 	sts	0x0167, r29	; 0x800167 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     9a4:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     9a6:	c9 f7       	brne	.-14     	; 0x99a <__stack+0x9b>

						uxPendedTicks = 0;
     9a8:	10 92 68 01 	sts	0x0168, r1	; 0x800168 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     9ac:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <xYieldPending>
     9b0:	88 23       	and	r24, r24
     9b2:	09 f4       	brne	.+2      	; 0x9b6 <__stack+0xb7>
     9b4:	af cf       	rjmp	.-162    	; 0x914 <__stack+0x15>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     9b6:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     9ba:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     9bc:	0f 90       	pop	r0
     9be:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     9c0:	df 91       	pop	r29
     9c2:	cf 91       	pop	r28
     9c4:	1f 91       	pop	r17
     9c6:	0f 91       	pop	r16
     9c8:	ff 90       	pop	r15
     9ca:	ef 90       	pop	r14
     9cc:	08 95       	ret

000009ce <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     9ce:	0f 93       	push	r16
     9d0:	1f 93       	push	r17
     9d2:	cf 93       	push	r28
     9d4:	df 93       	push	r29
     9d6:	8c 01       	movw	r16, r24
     9d8:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     9da:	0e 94 ac 03 	call	0x758	; 0x758 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     9de:	40 91 6b 01 	lds	r20, 0x016B	; 0x80016b <xTickCount>
     9e2:	50 91 6c 01 	lds	r21, 0x016C	; 0x80016c <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     9e6:	f8 01       	movw	r30, r16
     9e8:	20 81       	ld	r18, Z
     9ea:	31 81       	ldd	r19, Z+1	; 0x01
     9ec:	c9 01       	movw	r24, r18
     9ee:	8c 0f       	add	r24, r28
     9f0:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     9f2:	42 17       	cp	r20, r18
     9f4:	53 07       	cpc	r21, r19
     9f6:	20 f4       	brcc	.+8      	; 0xa00 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     9f8:	82 17       	cp	r24, r18
     9fa:	93 07       	cpc	r25, r19
     9fc:	40 f4       	brcc	.+16     	; 0xa0e <vTaskDelayUntil+0x40>
     9fe:	03 c0       	rjmp	.+6      	; 0xa06 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     a00:	82 17       	cp	r24, r18
     a02:	93 07       	cpc	r25, r19
     a04:	30 f0       	brcs	.+12     	; 0xa12 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     a06:	21 e0       	ldi	r18, 0x01	; 1
     a08:	48 17       	cp	r20, r24
     a0a:	59 07       	cpc	r21, r25
     a0c:	18 f0       	brcs	.+6      	; 0xa14 <vTaskDelayUntil+0x46>
     a0e:	20 e0       	ldi	r18, 0x00	; 0
     a10:	01 c0       	rjmp	.+2      	; 0xa14 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     a12:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     a14:	f8 01       	movw	r30, r16
     a16:	91 83       	std	Z+1, r25	; 0x01
     a18:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     a1a:	22 23       	and	r18, r18
     a1c:	29 f0       	breq	.+10     	; 0xa28 <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     a1e:	60 e0       	ldi	r22, 0x00	; 0
     a20:	84 1b       	sub	r24, r20
     a22:	95 0b       	sbc	r25, r21
     a24:	0e 94 0e 01 	call	0x21c	; 0x21c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     a28:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a2c:	81 11       	cpse	r24, r1
     a2e:	02 c0       	rjmp	.+4      	; 0xa34 <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     a30:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a34:	df 91       	pop	r29
     a36:	cf 91       	pop	r28
     a38:	1f 91       	pop	r17
     a3a:	0f 91       	pop	r16
     a3c:	08 95       	ret

00000a3e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     a3e:	cf 93       	push	r28
     a40:	df 93       	push	r29
     a42:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     a44:	89 2b       	or	r24, r25
     a46:	19 f4       	brne	.+6      	; 0xa4e <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     a48:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
     a4c:	0a c0       	rjmp	.+20     	; 0xa62 <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     a4e:	0e 94 ac 03 	call	0x758	; 0x758 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     a52:	60 e0       	ldi	r22, 0x00	; 0
     a54:	ce 01       	movw	r24, r28
     a56:	0e 94 0e 01 	call	0x21c	; 0x21c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     a5a:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     a5e:	88 23       	and	r24, r24
     a60:	99 f3       	breq	.-26     	; 0xa48 <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     a62:	df 91       	pop	r29
     a64:	cf 91       	pop	r28
     a66:	08 95       	ret

00000a68 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     a68:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <uxSchedulerSuspended>
     a6c:	88 23       	and	r24, r24
     a6e:	21 f0       	breq	.+8      	; 0xa78 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     a70:	81 e0       	ldi	r24, 0x01	; 1
     a72:	80 93 67 01 	sts	0x0167, r24	; 0x800167 <xYieldPending>
     a76:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     a78:	10 92 67 01 	sts	0x0167, r1	; 0x800167 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     a7c:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <uxTopReadyPriority>
     a80:	69 e0       	ldi	r22, 0x09	; 9
     a82:	48 2f       	mov	r20, r24
     a84:	50 e0       	ldi	r21, 0x00	; 0
     a86:	64 9f       	mul	r22, r20
     a88:	90 01       	movw	r18, r0
     a8a:	65 9f       	mul	r22, r21
     a8c:	30 0d       	add	r19, r0
     a8e:	11 24       	eor	r1, r1
     a90:	f9 01       	movw	r30, r18
     a92:	e0 56       	subi	r30, 0x60	; 96
     a94:	fe 4f       	sbci	r31, 0xFE	; 254
     a96:	90 81       	ld	r25, Z
     a98:	91 11       	cpse	r25, r1
     a9a:	02 c0       	rjmp	.+4      	; 0xaa0 <vTaskSwitchContext+0x38>
     a9c:	81 50       	subi	r24, 0x01	; 1
     a9e:	f1 cf       	rjmp	.-30     	; 0xa82 <vTaskSwitchContext+0x1a>
     aa0:	a1 81       	ldd	r26, Z+1	; 0x01
     aa2:	b2 81       	ldd	r27, Z+2	; 0x02
     aa4:	12 96       	adiw	r26, 0x02	; 2
     aa6:	0d 90       	ld	r0, X+
     aa8:	bc 91       	ld	r27, X
     aaa:	a0 2d       	mov	r26, r0
     aac:	b2 83       	std	Z+2, r27	; 0x02
     aae:	a1 83       	std	Z+1, r26	; 0x01
     ab0:	2d 55       	subi	r18, 0x5D	; 93
     ab2:	3e 4f       	sbci	r19, 0xFE	; 254
     ab4:	a2 17       	cp	r26, r18
     ab6:	b3 07       	cpc	r27, r19
     ab8:	31 f4       	brne	.+12     	; 0xac6 <vTaskSwitchContext+0x5e>
     aba:	12 96       	adiw	r26, 0x02	; 2
     abc:	2d 91       	ld	r18, X+
     abe:	3c 91       	ld	r19, X
     ac0:	13 97       	sbiw	r26, 0x03	; 3
     ac2:	32 83       	std	Z+2, r19	; 0x02
     ac4:	21 83       	std	Z+1, r18	; 0x01
     ac6:	99 e0       	ldi	r25, 0x09	; 9
     ac8:	94 9f       	mul	r25, r20
     aca:	f0 01       	movw	r30, r0
     acc:	95 9f       	mul	r25, r21
     ace:	f0 0d       	add	r31, r0
     ad0:	11 24       	eor	r1, r1
     ad2:	e0 56       	subi	r30, 0x60	; 96
     ad4:	fe 4f       	sbci	r31, 0xFE	; 254
     ad6:	01 80       	ldd	r0, Z+1	; 0x01
     ad8:	f2 81       	ldd	r31, Z+2	; 0x02
     ada:	e0 2d       	mov	r30, r0
     adc:	26 81       	ldd	r18, Z+6	; 0x06
     ade:	37 81       	ldd	r19, Z+7	; 0x07
     ae0:	30 93 5f 01 	sts	0x015F, r19	; 0x80015f <__data_end+0x1>
     ae4:	20 93 5e 01 	sts	0x015E, r18	; 0x80015e <__data_end>
     ae8:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <uxTopReadyPriority>
     aec:	08 95       	ret

00000aee <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     aee:	0f 93       	push	r16
     af0:	1f 93       	push	r17
     af2:	cf 93       	push	r28
     af4:	df 93       	push	r29
     af6:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     af8:	0f b6       	in	r0, 0x3f	; 63
     afa:	f8 94       	cli
     afc:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     afe:	89 2b       	or	r24, r25
     b00:	21 f4       	brne	.+8      	; 0xb0a <vTaskSuspend+0x1c>
     b02:	c0 91 5e 01 	lds	r28, 0x015E	; 0x80015e <__data_end>
     b06:	d0 91 5f 01 	lds	r29, 0x015F	; 0x80015f <__data_end+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     b0a:	8e 01       	movw	r16, r28
     b0c:	0e 5f       	subi	r16, 0xFE	; 254
     b0e:	1f 4f       	sbci	r17, 0xFF	; 255
     b10:	c8 01       	movw	r24, r16
     b12:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     b16:	8c 89       	ldd	r24, Y+20	; 0x14
     b18:	9d 89       	ldd	r25, Y+21	; 0x15
     b1a:	89 2b       	or	r24, r25
     b1c:	21 f0       	breq	.+8      	; 0xb26 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     b1e:	ce 01       	movw	r24, r28
     b20:	0c 96       	adiw	r24, 0x0c	; 12
     b22:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     b26:	b8 01       	movw	r22, r16
     b28:	8e e6       	ldi	r24, 0x6E	; 110
     b2a:	91 e0       	ldi	r25, 0x01	; 1
     b2c:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     b30:	8d a1       	ldd	r24, Y+37	; 0x25
     b32:	81 30       	cpi	r24, 0x01	; 1
     b34:	09 f4       	brne	.+2      	; 0xb38 <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     b36:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     b38:	0f 90       	pop	r0
     b3a:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     b3c:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <xSchedulerRunning>
     b40:	88 23       	and	r24, r24
     b42:	39 f0       	breq	.+14     	; 0xb52 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     b44:	0f b6       	in	r0, 0x3f	; 63
     b46:	f8 94       	cli
     b48:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     b4a:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     b4e:	0f 90       	pop	r0
     b50:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     b52:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <__data_end>
     b56:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <__data_end+0x1>
     b5a:	c8 17       	cp	r28, r24
     b5c:	d9 07       	cpc	r29, r25
     b5e:	c1 f4       	brne	.+48     	; 0xb90 <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     b60:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <xSchedulerRunning>
     b64:	88 23       	and	r24, r24
     b66:	19 f0       	breq	.+6      	; 0xb6e <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     b68:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
     b6c:	11 c0       	rjmp	.+34     	; 0xb90 <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     b6e:	90 91 6e 01 	lds	r25, 0x016E	; 0x80016e <xSuspendedTaskList>
     b72:	80 91 6d 01 	lds	r24, 0x016D	; 0x80016d <uxCurrentNumberOfTasks>
     b76:	98 13       	cpse	r25, r24
     b78:	05 c0       	rjmp	.+10     	; 0xb84 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     b7a:	10 92 5f 01 	sts	0x015F, r1	; 0x80015f <__data_end+0x1>
     b7e:	10 92 5e 01 	sts	0x015E, r1	; 0x80015e <__data_end>
     b82:	06 c0       	rjmp	.+12     	; 0xb90 <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b84:	df 91       	pop	r29
     b86:	cf 91       	pop	r28
     b88:	1f 91       	pop	r17
     b8a:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     b8c:	0c 94 34 05 	jmp	0xa68	; 0xa68 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b90:	df 91       	pop	r29
     b92:	cf 91       	pop	r28
     b94:	1f 91       	pop	r17
     b96:	0f 91       	pop	r16
     b98:	08 95       	ret

00000b9a <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     b9a:	cf 93       	push	r28
     b9c:	df 93       	push	r29
     b9e:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     ba0:	60 91 5e 01 	lds	r22, 0x015E	; 0x80015e <__data_end>
     ba4:	70 91 5f 01 	lds	r23, 0x015F	; 0x80015f <__data_end+0x1>
     ba8:	64 5f       	subi	r22, 0xF4	; 244
     baa:	7f 4f       	sbci	r23, 0xFF	; 255
     bac:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bb0:	61 e0       	ldi	r22, 0x01	; 1
     bb2:	ce 01       	movw	r24, r28
}
     bb4:	df 91       	pop	r29
     bb6:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bb8:	0c 94 0e 01 	jmp	0x21c	; 0x21c <prvAddCurrentTaskToDelayedList>

00000bbc <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     bc2:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     bc6:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     bca:	70 68       	ori	r23, 0x80	; 128
     bcc:	75 87       	std	Z+13, r23	; 0x0d
     bce:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     bd0:	60 91 5e 01 	lds	r22, 0x015E	; 0x80015e <__data_end>
     bd4:	70 91 5f 01 	lds	r23, 0x015F	; 0x80015f <__data_end+0x1>
     bd8:	64 5f       	subi	r22, 0xF4	; 244
     bda:	7f 4f       	sbci	r23, 0xFF	; 255
     bdc:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     be0:	61 e0       	ldi	r22, 0x01	; 1
     be2:	ce 01       	movw	r24, r28
}
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     be8:	0c 94 0e 01 	jmp	0x21c	; 0x21c <prvAddCurrentTaskToDelayedList>

00000bec <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     bec:	0f 93       	push	r16
     bee:	1f 93       	push	r17
     bf0:	cf 93       	push	r28
     bf2:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     bf4:	dc 01       	movw	r26, r24
     bf6:	15 96       	adiw	r26, 0x05	; 5
     bf8:	ed 91       	ld	r30, X+
     bfa:	fc 91       	ld	r31, X
     bfc:	16 97       	sbiw	r26, 0x06	; 6
     bfe:	c6 81       	ldd	r28, Z+6	; 0x06
     c00:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     c02:	8e 01       	movw	r16, r28
     c04:	04 5f       	subi	r16, 0xF4	; 244
     c06:	1f 4f       	sbci	r17, 0xFF	; 255
     c08:	c8 01       	movw	r24, r16
     c0a:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c0e:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <uxSchedulerSuspended>
     c12:	81 11       	cpse	r24, r1
     c14:	14 c0       	rjmp	.+40     	; 0xc3e <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c16:	0a 50       	subi	r16, 0x0A	; 10
     c18:	11 09       	sbc	r17, r1
     c1a:	c8 01       	movw	r24, r16
     c1c:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     c20:	8e 89       	ldd	r24, Y+22	; 0x16
     c22:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <uxTopReadyPriority>
     c26:	98 17       	cp	r25, r24
     c28:	10 f4       	brcc	.+4      	; 0xc2e <xTaskRemoveFromEventList+0x42>
     c2a:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <uxTopReadyPriority>
     c2e:	b9 e0       	ldi	r27, 0x09	; 9
     c30:	8b 9f       	mul	r24, r27
     c32:	c0 01       	movw	r24, r0
     c34:	11 24       	eor	r1, r1
     c36:	b8 01       	movw	r22, r16
     c38:	80 56       	subi	r24, 0x60	; 96
     c3a:	9e 4f       	sbci	r25, 0xFE	; 254
     c3c:	03 c0       	rjmp	.+6      	; 0xc44 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     c3e:	b8 01       	movw	r22, r16
     c40:	81 e8       	ldi	r24, 0x81	; 129
     c42:	91 e0       	ldi	r25, 0x01	; 1
     c44:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     c48:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     c4c:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     c50:	9e 89       	ldd	r25, Y+22	; 0x16
     c52:	86 89       	ldd	r24, Z+22	; 0x16
     c54:	89 17       	cp	r24, r25
     c56:	20 f4       	brcc	.+8      	; 0xc60 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     c58:	81 e0       	ldi	r24, 0x01	; 1
     c5a:	80 93 67 01 	sts	0x0167, r24	; 0x800167 <xYieldPending>
     c5e:	01 c0       	rjmp	.+2      	; 0xc62 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     c60:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     c62:	df 91       	pop	r29
     c64:	cf 91       	pop	r28
     c66:	1f 91       	pop	r17
     c68:	0f 91       	pop	r16
     c6a:	08 95       	ret

00000c6c <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     c6c:	0f 93       	push	r16
     c6e:	1f 93       	push	r17
     c70:	cf 93       	push	r28
     c72:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     c74:	70 68       	ori	r23, 0x80	; 128
     c76:	fc 01       	movw	r30, r24
     c78:	71 83       	std	Z+1, r23	; 0x01
     c7a:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     c7c:	c6 81       	ldd	r28, Z+6	; 0x06
     c7e:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     c80:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     c84:	8e 01       	movw	r16, r28
     c86:	0e 5f       	subi	r16, 0xFE	; 254
     c88:	1f 4f       	sbci	r17, 0xFF	; 255
     c8a:	c8 01       	movw	r24, r16
     c8c:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     c90:	8e 89       	ldd	r24, Y+22	; 0x16
     c92:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <uxTopReadyPriority>
     c96:	98 17       	cp	r25, r24
     c98:	10 f4       	brcc	.+4      	; 0xc9e <vTaskRemoveFromUnorderedEventList+0x32>
     c9a:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <uxTopReadyPriority>
     c9e:	f9 e0       	ldi	r31, 0x09	; 9
     ca0:	8f 9f       	mul	r24, r31
     ca2:	c0 01       	movw	r24, r0
     ca4:	11 24       	eor	r1, r1
     ca6:	b8 01       	movw	r22, r16
     ca8:	80 56       	subi	r24, 0x60	; 96
     caa:	9e 4f       	sbci	r25, 0xFE	; 254
     cac:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     cb0:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     cb4:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     cb8:	9e 89       	ldd	r25, Y+22	; 0x16
     cba:	86 89       	ldd	r24, Z+22	; 0x16
     cbc:	89 17       	cp	r24, r25
     cbe:	18 f4       	brcc	.+6      	; 0xcc6 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     cc0:	81 e0       	ldi	r24, 0x01	; 1
     cc2:	80 93 67 01 	sts	0x0167, r24	; 0x800167 <xYieldPending>
	}
}
     cc6:	df 91       	pop	r29
     cc8:	cf 91       	pop	r28
     cca:	1f 91       	pop	r17
     ccc:	0f 91       	pop	r16
     cce:	08 95       	ret

00000cd0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     cd0:	0f b6       	in	r0, 0x3f	; 63
     cd2:	f8 94       	cli
     cd4:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     cd6:	20 91 66 01 	lds	r18, 0x0166	; 0x800166 <xNumOfOverflows>
     cda:	fc 01       	movw	r30, r24
     cdc:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     cde:	20 91 6b 01 	lds	r18, 0x016B	; 0x80016b <xTickCount>
     ce2:	30 91 6c 01 	lds	r19, 0x016C	; 0x80016c <xTickCount+0x1>
     ce6:	32 83       	std	Z+2, r19	; 0x02
     ce8:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     cea:	0f 90       	pop	r0
     cec:	0f be       	out	0x3f, r0	; 63
     cee:	08 95       	ret

00000cf0 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     cf0:	20 91 66 01 	lds	r18, 0x0166	; 0x800166 <xNumOfOverflows>
     cf4:	fc 01       	movw	r30, r24
     cf6:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     cf8:	20 91 6b 01 	lds	r18, 0x016B	; 0x80016b <xTickCount>
     cfc:	30 91 6c 01 	lds	r19, 0x016C	; 0x80016c <xTickCount+0x1>
     d00:	32 83       	std	Z+2, r19	; 0x02
     d02:	21 83       	std	Z+1, r18	; 0x01
     d04:	08 95       	ret

00000d06 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     d06:	cf 93       	push	r28
     d08:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     d0a:	0f b6       	in	r0, 0x3f	; 63
     d0c:	f8 94       	cli
     d0e:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     d10:	40 91 6b 01 	lds	r20, 0x016B	; 0x80016b <xTickCount>
     d14:	50 91 6c 01 	lds	r21, 0x016C	; 0x80016c <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     d18:	db 01       	movw	r26, r22
     d1a:	2d 91       	ld	r18, X+
     d1c:	3c 91       	ld	r19, X
     d1e:	2f 3f       	cpi	r18, 0xFF	; 255
     d20:	bf ef       	ldi	r27, 0xFF	; 255
     d22:	3b 07       	cpc	r19, r27
     d24:	d9 f0       	breq	.+54     	; 0xd5c <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     d26:	ec 01       	movw	r28, r24
     d28:	e9 81       	ldd	r30, Y+1	; 0x01
     d2a:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     d2c:	a0 91 66 01 	lds	r26, 0x0166	; 0x800166 <xNumOfOverflows>
     d30:	b8 81       	ld	r27, Y
     d32:	ba 17       	cp	r27, r26
     d34:	19 f0       	breq	.+6      	; 0xd3c <xTaskCheckForTimeOut+0x36>
     d36:	4e 17       	cp	r20, r30
     d38:	5f 07       	cpc	r21, r31
     d3a:	90 f4       	brcc	.+36     	; 0xd60 <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     d3c:	4e 1b       	sub	r20, r30
     d3e:	5f 0b       	sbc	r21, r31
     d40:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     d42:	42 17       	cp	r20, r18
     d44:	53 07       	cpc	r21, r19
     d46:	38 f4       	brcc	.+14     	; 0xd56 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     d48:	24 1b       	sub	r18, r20
     d4a:	35 0b       	sbc	r19, r21
     d4c:	31 83       	std	Z+1, r19	; 0x01
     d4e:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     d50:	0e 94 78 06 	call	0xcf0	; 0xcf0 <vTaskInternalSetTimeOutState>
     d54:	03 c0       	rjmp	.+6      	; 0xd5c <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     d56:	11 82       	std	Z+1, r1	; 0x01
     d58:	10 82       	st	Z, r1
     d5a:	02 c0       	rjmp	.+4      	; 0xd60 <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     d5c:	80 e0       	ldi	r24, 0x00	; 0
     d5e:	01 c0       	rjmp	.+2      	; 0xd62 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     d60:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     d62:	0f 90       	pop	r0
     d64:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     d66:	df 91       	pop	r29
     d68:	cf 91       	pop	r28
     d6a:	08 95       	ret

00000d6c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     d6c:	81 e0       	ldi	r24, 0x01	; 1
     d6e:	80 93 67 01 	sts	0x0167, r24	; 0x800167 <xYieldPending>
     d72:	08 95       	ret

00000d74 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     d74:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     d78:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     d7c:	84 85       	ldd	r24, Z+12	; 0x0c
     d7e:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d80:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     d84:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     d88:	a0 91 5e 01 	lds	r26, 0x015E	; 0x80015e <__data_end>
     d8c:	b0 91 5f 01 	lds	r27, 0x015F	; 0x80015f <__data_end+0x1>
     d90:	56 96       	adiw	r26, 0x16	; 22
     d92:	4c 91       	ld	r20, X
     d94:	24 e0       	ldi	r18, 0x04	; 4
     d96:	30 e0       	ldi	r19, 0x00	; 0
     d98:	24 1b       	sub	r18, r20
     d9a:	31 09       	sbc	r19, r1
     d9c:	35 87       	std	Z+13, r19	; 0x0d
     d9e:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     da0:	08 95       	ret

00000da2 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     da2:	0f 93       	push	r16
     da4:	1f 93       	push	r17
     da6:	18 2f       	mov	r17, r24
     da8:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     daa:	0f b6       	in	r0, 0x3f	; 63
     dac:	f8 94       	cli
     dae:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     db0:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     db4:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     db8:	41 a1       	ldd	r20, Z+33	; 0x21
     dba:	52 a1       	ldd	r21, Z+34	; 0x22
     dbc:	63 a1       	ldd	r22, Z+35	; 0x23
     dbe:	74 a1       	ldd	r23, Z+36	; 0x24
     dc0:	45 2b       	or	r20, r21
     dc2:	46 2b       	or	r20, r22
     dc4:	47 2b       	or	r20, r23
     dc6:	69 f4       	brne	.+26     	; 0xde2 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     dc8:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     dcc:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     dd0:	21 e0       	ldi	r18, 0x01	; 1
     dd2:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     dd4:	00 97       	sbiw	r24, 0x00	; 0
     dd6:	29 f0       	breq	.+10     	; 0xde2 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     dd8:	61 e0       	ldi	r22, 0x01	; 1
     dda:	0e 94 0e 01 	call	0x21c	; 0x21c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     dde:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     de2:	0f 90       	pop	r0
     de4:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     de6:	0f b6       	in	r0, 0x3f	; 63
     de8:	f8 94       	cli
     dea:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
     dec:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     df0:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     df4:	61 a1       	ldd	r22, Z+33	; 0x21
     df6:	72 a1       	ldd	r23, Z+34	; 0x22
     df8:	83 a1       	ldd	r24, Z+35	; 0x23
     dfa:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
     dfc:	61 15       	cp	r22, r1
     dfe:	71 05       	cpc	r23, r1
     e00:	81 05       	cpc	r24, r1
     e02:	91 05       	cpc	r25, r1
     e04:	a9 f0       	breq	.+42     	; 0xe30 <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     e06:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     e0a:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
     e0e:	11 23       	and	r17, r17
     e10:	29 f0       	breq	.+10     	; 0xe1c <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     e12:	11 a2       	std	Z+33, r1	; 0x21
     e14:	12 a2       	std	Z+34, r1	; 0x22
     e16:	13 a2       	std	Z+35, r1	; 0x23
     e18:	14 a2       	std	Z+36, r1	; 0x24
     e1a:	0a c0       	rjmp	.+20     	; 0xe30 <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
     e1c:	8b 01       	movw	r16, r22
     e1e:	9c 01       	movw	r18, r24
     e20:	01 50       	subi	r16, 0x01	; 1
     e22:	11 09       	sbc	r17, r1
     e24:	21 09       	sbc	r18, r1
     e26:	31 09       	sbc	r19, r1
     e28:	01 a3       	std	Z+33, r16	; 0x21
     e2a:	12 a3       	std	Z+34, r17	; 0x22
     e2c:	23 a3       	std	Z+35, r18	; 0x23
     e2e:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     e30:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     e34:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     e38:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     e3a:	0f 90       	pop	r0
     e3c:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
     e3e:	1f 91       	pop	r17
     e40:	0f 91       	pop	r16
     e42:	08 95       	ret

00000e44 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     e44:	4f 92       	push	r4
     e46:	5f 92       	push	r5
     e48:	6f 92       	push	r6
     e4a:	7f 92       	push	r7
     e4c:	8f 92       	push	r8
     e4e:	9f 92       	push	r9
     e50:	af 92       	push	r10
     e52:	bf 92       	push	r11
     e54:	ef 92       	push	r14
     e56:	ff 92       	push	r15
     e58:	0f 93       	push	r16
     e5a:	1f 93       	push	r17
     e5c:	49 01       	movw	r8, r18
     e5e:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     e60:	0f b6       	in	r0, 0x3f	; 63
     e62:	f8 94       	cli
     e64:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     e66:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     e6a:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     e6e:	25 a1       	ldd	r18, Z+37	; 0x25
     e70:	22 30       	cpi	r18, 0x02	; 2
     e72:	39 f1       	breq	.+78     	; 0xec2 <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     e74:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     e78:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     e7c:	21 a1       	ldd	r18, Z+33	; 0x21
     e7e:	32 a1       	ldd	r19, Z+34	; 0x22
     e80:	43 a1       	ldd	r20, Z+35	; 0x23
     e82:	54 a1       	ldd	r21, Z+36	; 0x24
     e84:	2b 01       	movw	r4, r22
     e86:	3c 01       	movw	r6, r24
     e88:	40 94       	com	r4
     e8a:	50 94       	com	r5
     e8c:	60 94       	com	r6
     e8e:	70 94       	com	r7
     e90:	d3 01       	movw	r26, r6
     e92:	c2 01       	movw	r24, r4
     e94:	82 23       	and	r24, r18
     e96:	93 23       	and	r25, r19
     e98:	a4 23       	and	r26, r20
     e9a:	b5 23       	and	r27, r21
     e9c:	81 a3       	std	Z+33, r24	; 0x21
     e9e:	92 a3       	std	Z+34, r25	; 0x22
     ea0:	a3 a3       	std	Z+35, r26	; 0x23
     ea2:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     ea4:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     ea8:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     eac:	81 e0       	ldi	r24, 0x01	; 1
     eae:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     eb0:	e1 14       	cp	r14, r1
     eb2:	f1 04       	cpc	r15, r1
     eb4:	31 f0       	breq	.+12     	; 0xec2 <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     eb6:	61 e0       	ldi	r22, 0x01	; 1
     eb8:	c7 01       	movw	r24, r14
     eba:	0e 94 0e 01 	call	0x21c	; 0x21c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     ebe:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     ec2:	0f 90       	pop	r0
     ec4:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     ec6:	0f b6       	in	r0, 0x3f	; 63
     ec8:	f8 94       	cli
     eca:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
     ecc:	01 15       	cp	r16, r1
     ece:	11 05       	cpc	r17, r1
     ed0:	69 f0       	breq	.+26     	; 0xeec <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     ed2:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     ed6:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     eda:	81 a1       	ldd	r24, Z+33	; 0x21
     edc:	92 a1       	ldd	r25, Z+34	; 0x22
     ede:	a3 a1       	ldd	r26, Z+35	; 0x23
     ee0:	b4 a1       	ldd	r27, Z+36	; 0x24
     ee2:	f8 01       	movw	r30, r16
     ee4:	80 83       	st	Z, r24
     ee6:	91 83       	std	Z+1, r25	; 0x01
     ee8:	a2 83       	std	Z+2, r26	; 0x02
     eea:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     eec:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     ef0:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     ef4:	85 a1       	ldd	r24, Z+37	; 0x25
     ef6:	82 30       	cpi	r24, 0x02	; 2
     ef8:	c1 f4       	brne	.+48     	; 0xf2a <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
     efa:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     efe:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     f02:	41 a1       	ldd	r20, Z+33	; 0x21
     f04:	52 a1       	ldd	r21, Z+34	; 0x22
     f06:	63 a1       	ldd	r22, Z+35	; 0x23
     f08:	74 a1       	ldd	r23, Z+36	; 0x24
     f0a:	d5 01       	movw	r26, r10
     f0c:	c4 01       	movw	r24, r8
     f0e:	80 95       	com	r24
     f10:	90 95       	com	r25
     f12:	a0 95       	com	r26
     f14:	b0 95       	com	r27
     f16:	84 23       	and	r24, r20
     f18:	95 23       	and	r25, r21
     f1a:	a6 23       	and	r26, r22
     f1c:	b7 23       	and	r27, r23
     f1e:	81 a3       	std	Z+33, r24	; 0x21
     f20:	92 a3       	std	Z+34, r25	; 0x22
     f22:	a3 a3       	std	Z+35, r26	; 0x23
     f24:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
     f26:	81 e0       	ldi	r24, 0x01	; 1
     f28:	01 c0       	rjmp	.+2      	; 0xf2c <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
     f2a:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     f2c:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
     f30:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
     f34:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     f36:	0f 90       	pop	r0
     f38:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
     f3a:	1f 91       	pop	r17
     f3c:	0f 91       	pop	r16
     f3e:	ff 90       	pop	r15
     f40:	ef 90       	pop	r14
     f42:	bf 90       	pop	r11
     f44:	af 90       	pop	r10
     f46:	9f 90       	pop	r9
     f48:	8f 90       	pop	r8
     f4a:	7f 90       	pop	r7
     f4c:	6f 90       	pop	r6
     f4e:	5f 90       	pop	r5
     f50:	4f 90       	pop	r4
     f52:	08 95       	ret

00000f54 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
     f54:	0f 93       	push	r16
     f56:	1f 93       	push	r17
     f58:	cf 93       	push	r28
     f5a:	df 93       	push	r29
     f5c:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
     f5e:	0f b6       	in	r0, 0x3f	; 63
     f60:	f8 94       	cli
     f62:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
     f64:	01 15       	cp	r16, r1
     f66:	11 05       	cpc	r17, r1
     f68:	49 f0       	breq	.+18     	; 0xf7c <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
     f6a:	81 a1       	ldd	r24, Z+33	; 0x21
     f6c:	92 a1       	ldd	r25, Z+34	; 0x22
     f6e:	a3 a1       	ldd	r26, Z+35	; 0x23
     f70:	b4 a1       	ldd	r27, Z+36	; 0x24
     f72:	e8 01       	movw	r28, r16
     f74:	88 83       	st	Y, r24
     f76:	99 83       	std	Y+1, r25	; 0x01
     f78:	aa 83       	std	Y+2, r26	; 0x02
     f7a:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
     f7c:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
     f7e:	82 e0       	ldi	r24, 0x02	; 2
     f80:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
     f82:	22 30       	cpi	r18, 0x02	; 2
     f84:	89 f0       	breq	.+34     	; 0xfa8 <xTaskGenericNotify+0x54>
     f86:	58 f4       	brcc	.+22     	; 0xf9e <xTaskGenericNotify+0x4a>
     f88:	21 30       	cpi	r18, 0x01	; 1
     f8a:	01 f5       	brne	.+64     	; 0xfcc <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
     f8c:	81 a1       	ldd	r24, Z+33	; 0x21
     f8e:	92 a1       	ldd	r25, Z+34	; 0x22
     f90:	a3 a1       	ldd	r26, Z+35	; 0x23
     f92:	b4 a1       	ldd	r27, Z+36	; 0x24
     f94:	48 2b       	or	r20, r24
     f96:	59 2b       	or	r21, r25
     f98:	6a 2b       	or	r22, r26
     f9a:	7b 2b       	or	r23, r27
     f9c:	13 c0       	rjmp	.+38     	; 0xfc4 <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
     f9e:	23 30       	cpi	r18, 0x03	; 3
     fa0:	89 f0       	breq	.+34     	; 0xfc4 <xTaskGenericNotify+0x70>
     fa2:	24 30       	cpi	r18, 0x04	; 4
     fa4:	69 f0       	breq	.+26     	; 0xfc0 <xTaskGenericNotify+0x6c>
     fa6:	12 c0       	rjmp	.+36     	; 0xfcc <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
     fa8:	81 a1       	ldd	r24, Z+33	; 0x21
     faa:	92 a1       	ldd	r25, Z+34	; 0x22
     fac:	a3 a1       	ldd	r26, Z+35	; 0x23
     fae:	b4 a1       	ldd	r27, Z+36	; 0x24
     fb0:	01 96       	adiw	r24, 0x01	; 1
     fb2:	a1 1d       	adc	r26, r1
     fb4:	b1 1d       	adc	r27, r1
     fb6:	81 a3       	std	Z+33, r24	; 0x21
     fb8:	92 a3       	std	Z+34, r25	; 0x22
     fba:	a3 a3       	std	Z+35, r26	; 0x23
     fbc:	b4 a3       	std	Z+36, r27	; 0x24
					break;
     fbe:	06 c0       	rjmp	.+12     	; 0xfcc <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
     fc0:	32 30       	cpi	r19, 0x02	; 2
     fc2:	49 f1       	breq	.+82     	; 0x1016 <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
     fc4:	41 a3       	std	Z+33, r20	; 0x21
     fc6:	52 a3       	std	Z+34, r21	; 0x22
     fc8:	63 a3       	std	Z+35, r22	; 0x23
     fca:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
     fcc:	31 30       	cpi	r19, 0x01	; 1
     fce:	09 f5       	brne	.+66     	; 0x1012 <xTaskGenericNotify+0xbe>
     fd0:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     fd2:	8f 01       	movw	r16, r30
     fd4:	0e 5f       	subi	r16, 0xFE	; 254
     fd6:	1f 4f       	sbci	r17, 0xFF	; 255
     fd8:	c8 01       	movw	r24, r16
     fda:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
     fde:	8e 89       	ldd	r24, Y+22	; 0x16
     fe0:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <uxTopReadyPriority>
     fe4:	98 17       	cp	r25, r24
     fe6:	10 f4       	brcc	.+4      	; 0xfec <xTaskGenericNotify+0x98>
     fe8:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <uxTopReadyPriority>
     fec:	29 e0       	ldi	r18, 0x09	; 9
     fee:	82 9f       	mul	r24, r18
     ff0:	c0 01       	movw	r24, r0
     ff2:	11 24       	eor	r1, r1
     ff4:	b8 01       	movw	r22, r16
     ff6:	80 56       	subi	r24, 0x60	; 96
     ff8:	9e 4f       	sbci	r25, 0xFE	; 254
     ffa:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     ffe:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
    1002:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
    1006:	9e 89       	ldd	r25, Y+22	; 0x16
    1008:	86 89       	ldd	r24, Z+22	; 0x16
    100a:	89 17       	cp	r24, r25
    100c:	10 f4       	brcc	.+4      	; 0x1012 <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    100e:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
    1012:	81 e0       	ldi	r24, 0x01	; 1
    1014:	01 c0       	rjmp	.+2      	; 0x1018 <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1016:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1018:	0f 90       	pop	r0
    101a:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    101c:	df 91       	pop	r29
    101e:	cf 91       	pop	r28
    1020:	1f 91       	pop	r17
    1022:	0f 91       	pop	r16
    1024:	08 95       	ret

00001026 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1026:	ef 92       	push	r14
    1028:	ff 92       	push	r15
    102a:	0f 93       	push	r16
    102c:	1f 93       	push	r17
    102e:	cf 93       	push	r28
    1030:	df 93       	push	r29
    1032:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    1034:	01 15       	cp	r16, r1
    1036:	11 05       	cpc	r17, r1
    1038:	49 f0       	breq	.+18     	; 0x104c <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    103a:	81 a1       	ldd	r24, Z+33	; 0x21
    103c:	92 a1       	ldd	r25, Z+34	; 0x22
    103e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1040:	b4 a1       	ldd	r27, Z+36	; 0x24
    1042:	e8 01       	movw	r28, r16
    1044:	88 83       	st	Y, r24
    1046:	99 83       	std	Y+1, r25	; 0x01
    1048:	aa 83       	std	Y+2, r26	; 0x02
    104a:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    104c:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    104e:	82 e0       	ldi	r24, 0x02	; 2
    1050:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    1052:	22 30       	cpi	r18, 0x02	; 2
    1054:	89 f0       	breq	.+34     	; 0x1078 <xTaskGenericNotifyFromISR+0x52>
    1056:	58 f4       	brcc	.+22     	; 0x106e <xTaskGenericNotifyFromISR+0x48>
    1058:	21 30       	cpi	r18, 0x01	; 1
    105a:	01 f5       	brne	.+64     	; 0x109c <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    105c:	81 a1       	ldd	r24, Z+33	; 0x21
    105e:	92 a1       	ldd	r25, Z+34	; 0x22
    1060:	a3 a1       	ldd	r26, Z+35	; 0x23
    1062:	b4 a1       	ldd	r27, Z+36	; 0x24
    1064:	48 2b       	or	r20, r24
    1066:	59 2b       	or	r21, r25
    1068:	6a 2b       	or	r22, r26
    106a:	7b 2b       	or	r23, r27
    106c:	13 c0       	rjmp	.+38     	; 0x1094 <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    106e:	23 30       	cpi	r18, 0x03	; 3
    1070:	89 f0       	breq	.+34     	; 0x1094 <xTaskGenericNotifyFromISR+0x6e>
    1072:	24 30       	cpi	r18, 0x04	; 4
    1074:	69 f0       	breq	.+26     	; 0x1090 <xTaskGenericNotifyFromISR+0x6a>
    1076:	12 c0       	rjmp	.+36     	; 0x109c <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1078:	81 a1       	ldd	r24, Z+33	; 0x21
    107a:	92 a1       	ldd	r25, Z+34	; 0x22
    107c:	a3 a1       	ldd	r26, Z+35	; 0x23
    107e:	b4 a1       	ldd	r27, Z+36	; 0x24
    1080:	01 96       	adiw	r24, 0x01	; 1
    1082:	a1 1d       	adc	r26, r1
    1084:	b1 1d       	adc	r27, r1
    1086:	81 a3       	std	Z+33, r24	; 0x21
    1088:	92 a3       	std	Z+34, r25	; 0x22
    108a:	a3 a3       	std	Z+35, r26	; 0x23
    108c:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    108e:	06 c0       	rjmp	.+12     	; 0x109c <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1090:	32 30       	cpi	r19, 0x02	; 2
    1092:	d9 f1       	breq	.+118    	; 0x110a <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1094:	41 a3       	std	Z+33, r20	; 0x21
    1096:	52 a3       	std	Z+34, r21	; 0x22
    1098:	63 a3       	std	Z+35, r22	; 0x23
    109a:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    109c:	31 30       	cpi	r19, 0x01	; 1
    109e:	11 f0       	breq	.+4      	; 0x10a4 <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    10a0:	81 e0       	ldi	r24, 0x01	; 1
    10a2:	34 c0       	rjmp	.+104    	; 0x110c <xTaskGenericNotifyFromISR+0xe6>
    10a4:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    10a6:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <uxSchedulerSuspended>
    10aa:	81 11       	cpse	r24, r1
    10ac:	15 c0       	rjmp	.+42     	; 0x10d8 <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    10ae:	8f 01       	movw	r16, r30
    10b0:	0e 5f       	subi	r16, 0xFE	; 254
    10b2:	1f 4f       	sbci	r17, 0xFF	; 255
    10b4:	c8 01       	movw	r24, r16
    10b6:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    10ba:	8e 89       	ldd	r24, Y+22	; 0x16
    10bc:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <uxTopReadyPriority>
    10c0:	98 17       	cp	r25, r24
    10c2:	10 f4       	brcc	.+4      	; 0x10c8 <xTaskGenericNotifyFromISR+0xa2>
    10c4:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <uxTopReadyPriority>
    10c8:	e9 e0       	ldi	r30, 0x09	; 9
    10ca:	8e 9f       	mul	r24, r30
    10cc:	c0 01       	movw	r24, r0
    10ce:	11 24       	eor	r1, r1
    10d0:	b8 01       	movw	r22, r16
    10d2:	80 56       	subi	r24, 0x60	; 96
    10d4:	9e 4f       	sbci	r25, 0xFE	; 254
    10d6:	05 c0       	rjmp	.+10     	; 0x10e2 <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    10d8:	bf 01       	movw	r22, r30
    10da:	64 5f       	subi	r22, 0xF4	; 244
    10dc:	7f 4f       	sbci	r23, 0xFF	; 255
    10de:	81 e8       	ldi	r24, 0x81	; 129
    10e0:	91 e0       	ldi	r25, 0x01	; 1
    10e2:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    10e6:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
    10ea:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
    10ee:	9e 89       	ldd	r25, Y+22	; 0x16
    10f0:	86 89       	ldd	r24, Z+22	; 0x16
    10f2:	89 17       	cp	r24, r25
    10f4:	a8 f6       	brcc	.-86     	; 0x10a0 <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    10f6:	e1 14       	cp	r14, r1
    10f8:	f1 04       	cpc	r15, r1
    10fa:	19 f0       	breq	.+6      	; 0x1102 <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    10fc:	81 e0       	ldi	r24, 0x01	; 1
    10fe:	e7 01       	movw	r28, r14
    1100:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    1102:	81 e0       	ldi	r24, 0x01	; 1
    1104:	80 93 67 01 	sts	0x0167, r24	; 0x800167 <xYieldPending>
    1108:	01 c0       	rjmp	.+2      	; 0x110c <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    110a:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    110c:	df 91       	pop	r29
    110e:	cf 91       	pop	r28
    1110:	1f 91       	pop	r17
    1112:	0f 91       	pop	r16
    1114:	ff 90       	pop	r15
    1116:	ef 90       	pop	r14
    1118:	08 95       	ret

0000111a <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    111a:	ef 92       	push	r14
    111c:	ff 92       	push	r15
    111e:	0f 93       	push	r16
    1120:	1f 93       	push	r17
    1122:	cf 93       	push	r28
    1124:	df 93       	push	r29
    1126:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1128:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    112a:	82 e0       	ldi	r24, 0x02	; 2
    112c:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    112e:	81 a1       	ldd	r24, Z+33	; 0x21
    1130:	92 a1       	ldd	r25, Z+34	; 0x22
    1132:	a3 a1       	ldd	r26, Z+35	; 0x23
    1134:	b4 a1       	ldd	r27, Z+36	; 0x24
    1136:	01 96       	adiw	r24, 0x01	; 1
    1138:	a1 1d       	adc	r26, r1
    113a:	b1 1d       	adc	r27, r1
    113c:	81 a3       	std	Z+33, r24	; 0x21
    113e:	92 a3       	std	Z+34, r25	; 0x22
    1140:	a3 a3       	std	Z+35, r26	; 0x23
    1142:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1144:	21 30       	cpi	r18, 0x01	; 1
    1146:	a1 f5       	brne	.+104    	; 0x11b0 <vTaskNotifyGiveFromISR+0x96>
    1148:	8b 01       	movw	r16, r22
    114a:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    114c:	80 91 60 01 	lds	r24, 0x0160	; 0x800160 <uxSchedulerSuspended>
    1150:	81 11       	cpse	r24, r1
    1152:	16 c0       	rjmp	.+44     	; 0x1180 <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1154:	7f 01       	movw	r14, r30
    1156:	22 e0       	ldi	r18, 0x02	; 2
    1158:	e2 0e       	add	r14, r18
    115a:	f1 1c       	adc	r15, r1
    115c:	c7 01       	movw	r24, r14
    115e:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1162:	8e 89       	ldd	r24, Y+22	; 0x16
    1164:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <uxTopReadyPriority>
    1168:	98 17       	cp	r25, r24
    116a:	10 f4       	brcc	.+4      	; 0x1170 <vTaskNotifyGiveFromISR+0x56>
    116c:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <uxTopReadyPriority>
    1170:	e9 e0       	ldi	r30, 0x09	; 9
    1172:	8e 9f       	mul	r24, r30
    1174:	c0 01       	movw	r24, r0
    1176:	11 24       	eor	r1, r1
    1178:	b7 01       	movw	r22, r14
    117a:	80 56       	subi	r24, 0x60	; 96
    117c:	9e 4f       	sbci	r25, 0xFE	; 254
    117e:	05 c0       	rjmp	.+10     	; 0x118a <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1180:	bf 01       	movw	r22, r30
    1182:	64 5f       	subi	r22, 0xF4	; 244
    1184:	7f 4f       	sbci	r23, 0xFF	; 255
    1186:	81 e8       	ldi	r24, 0x81	; 129
    1188:	91 e0       	ldi	r25, 0x01	; 1
    118a:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    118e:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <__data_end>
    1192:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <__data_end+0x1>
    1196:	9e 89       	ldd	r25, Y+22	; 0x16
    1198:	86 89       	ldd	r24, Z+22	; 0x16
    119a:	89 17       	cp	r24, r25
    119c:	48 f4       	brcc	.+18     	; 0x11b0 <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    119e:	01 15       	cp	r16, r1
    11a0:	11 05       	cpc	r17, r1
    11a2:	19 f0       	breq	.+6      	; 0x11aa <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    11a4:	81 e0       	ldi	r24, 0x01	; 1
    11a6:	f8 01       	movw	r30, r16
    11a8:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	80 93 67 01 	sts	0x0167, r24	; 0x800167 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    11b0:	df 91       	pop	r29
    11b2:	cf 91       	pop	r28
    11b4:	1f 91       	pop	r17
    11b6:	0f 91       	pop	r16
    11b8:	ff 90       	pop	r15
    11ba:	ef 90       	pop	r14
    11bc:	08 95       	ret

000011be <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    11be:	00 97       	sbiw	r24, 0x00	; 0
    11c0:	21 f4       	brne	.+8      	; 0x11ca <xTaskNotifyStateClear+0xc>
    11c2:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <__data_end>
    11c6:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <__data_end+0x1>

		taskENTER_CRITICAL();
    11ca:	0f b6       	in	r0, 0x3f	; 63
    11cc:	f8 94       	cli
    11ce:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    11d0:	fc 01       	movw	r30, r24
    11d2:	25 a1       	ldd	r18, Z+37	; 0x25
    11d4:	22 30       	cpi	r18, 0x02	; 2
    11d6:	19 f4       	brne	.+6      	; 0x11de <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    11d8:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    11da:	81 e0       	ldi	r24, 0x01	; 1
    11dc:	01 c0       	rjmp	.+2      	; 0x11e0 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    11de:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    11e0:	0f 90       	pop	r0
    11e2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    11e4:	08 95       	ret

000011e6 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    11e6:	0f b6       	in	r0, 0x3f	; 63
    11e8:	f8 94       	cli
    11ea:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    11ec:	fc 01       	movw	r30, r24
    11ee:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    11f0:	0f 90       	pop	r0
    11f2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    11f4:	81 e0       	ldi	r24, 0x01	; 1
    11f6:	91 11       	cpse	r25, r1
    11f8:	80 e0       	ldi	r24, 0x00	; 0
}
    11fa:	08 95       	ret

000011fc <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    11fc:	0f 93       	push	r16
    11fe:	1f 93       	push	r17
    1200:	cf 93       	push	r28
    1202:	df 93       	push	r29
    1204:	ec 01       	movw	r28, r24
    1206:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1208:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    120a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    120c:	44 23       	and	r20, r20
    120e:	b1 f1       	breq	.+108    	; 0x127c <prvCopyDataToQueue+0x80>
    1210:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1212:	01 11       	cpse	r16, r1
    1214:	15 c0       	rjmp	.+42     	; 0x1240 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1216:	8a 81       	ldd	r24, Y+2	; 0x02
    1218:	9b 81       	ldd	r25, Y+3	; 0x03
    121a:	0e 94 22 12 	call	0x2444	; 0x2444 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    121e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1220:	8a 81       	ldd	r24, Y+2	; 0x02
    1222:	9b 81       	ldd	r25, Y+3	; 0x03
    1224:	82 0f       	add	r24, r18
    1226:	91 1d       	adc	r25, r1
    1228:	9b 83       	std	Y+3, r25	; 0x03
    122a:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    122c:	2c 81       	ldd	r18, Y+4	; 0x04
    122e:	3d 81       	ldd	r19, Y+5	; 0x05
    1230:	82 17       	cp	r24, r18
    1232:	93 07       	cpc	r25, r19
    1234:	18 f1       	brcs	.+70     	; 0x127c <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1236:	88 81       	ld	r24, Y
    1238:	99 81       	ldd	r25, Y+1	; 0x01
    123a:	9b 83       	std	Y+3, r25	; 0x03
    123c:	8a 83       	std	Y+2, r24	; 0x02
    123e:	1e c0       	rjmp	.+60     	; 0x127c <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1240:	8e 81       	ldd	r24, Y+6	; 0x06
    1242:	9f 81       	ldd	r25, Y+7	; 0x07
    1244:	0e 94 22 12 	call	0x2444	; 0x2444 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1248:	8c 8d       	ldd	r24, Y+28	; 0x1c
    124a:	90 e0       	ldi	r25, 0x00	; 0
    124c:	91 95       	neg	r25
    124e:	81 95       	neg	r24
    1250:	91 09       	sbc	r25, r1
    1252:	2e 81       	ldd	r18, Y+6	; 0x06
    1254:	3f 81       	ldd	r19, Y+7	; 0x07
    1256:	28 0f       	add	r18, r24
    1258:	39 1f       	adc	r19, r25
    125a:	3f 83       	std	Y+7, r19	; 0x07
    125c:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    125e:	48 81       	ld	r20, Y
    1260:	59 81       	ldd	r21, Y+1	; 0x01
    1262:	24 17       	cp	r18, r20
    1264:	35 07       	cpc	r19, r21
    1266:	30 f4       	brcc	.+12     	; 0x1274 <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1268:	2c 81       	ldd	r18, Y+4	; 0x04
    126a:	3d 81       	ldd	r19, Y+5	; 0x05
    126c:	82 0f       	add	r24, r18
    126e:	93 1f       	adc	r25, r19
    1270:	9f 83       	std	Y+7, r25	; 0x07
    1272:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1274:	02 30       	cpi	r16, 0x02	; 2
    1276:	11 f4       	brne	.+4      	; 0x127c <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1278:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    127a:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    127c:	1f 5f       	subi	r17, 0xFF	; 255
    127e:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    1280:	80 e0       	ldi	r24, 0x00	; 0
    1282:	df 91       	pop	r29
    1284:	cf 91       	pop	r28
    1286:	1f 91       	pop	r17
    1288:	0f 91       	pop	r16
    128a:	08 95       	ret

0000128c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    128c:	fc 01       	movw	r30, r24
    128e:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1290:	44 8d       	ldd	r20, Z+28	; 0x1c
    1292:	44 23       	and	r20, r20
    1294:	a1 f0       	breq	.+40     	; 0x12be <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1296:	50 e0       	ldi	r21, 0x00	; 0
    1298:	26 81       	ldd	r18, Z+6	; 0x06
    129a:	37 81       	ldd	r19, Z+7	; 0x07
    129c:	24 0f       	add	r18, r20
    129e:	35 1f       	adc	r19, r21
    12a0:	37 83       	std	Z+7, r19	; 0x07
    12a2:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    12a4:	64 81       	ldd	r22, Z+4	; 0x04
    12a6:	75 81       	ldd	r23, Z+5	; 0x05
    12a8:	26 17       	cp	r18, r22
    12aa:	37 07       	cpc	r19, r23
    12ac:	20 f0       	brcs	.+8      	; 0x12b6 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    12ae:	20 81       	ld	r18, Z
    12b0:	31 81       	ldd	r19, Z+1	; 0x01
    12b2:	37 83       	std	Z+7, r19	; 0x07
    12b4:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    12b6:	66 81       	ldd	r22, Z+6	; 0x06
    12b8:	77 81       	ldd	r23, Z+7	; 0x07
    12ba:	0c 94 22 12 	jmp	0x2444	; 0x2444 <memcpy>
    12be:	08 95       	ret

000012c0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    12c0:	ef 92       	push	r14
    12c2:	ff 92       	push	r15
    12c4:	1f 93       	push	r17
    12c6:	cf 93       	push	r28
    12c8:	df 93       	push	r29
    12ca:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    12cc:	0f b6       	in	r0, 0x3f	; 63
    12ce:	f8 94       	cli
    12d0:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    12d2:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12d4:	7c 01       	movw	r14, r24
    12d6:	81 e1       	ldi	r24, 0x11	; 17
    12d8:	e8 0e       	add	r14, r24
    12da:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    12dc:	11 16       	cp	r1, r17
    12de:	5c f4       	brge	.+22     	; 0x12f6 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12e0:	89 89       	ldd	r24, Y+17	; 0x11
    12e2:	88 23       	and	r24, r24
    12e4:	41 f0       	breq	.+16     	; 0x12f6 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12e6:	c7 01       	movw	r24, r14
    12e8:	0e 94 f6 05 	call	0xbec	; 0xbec <xTaskRemoveFromEventList>
    12ec:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    12ee:	0e 94 b6 06 	call	0xd6c	; 0xd6c <vTaskMissedYield>
    12f2:	11 50       	subi	r17, 0x01	; 1
    12f4:	f3 cf       	rjmp	.-26     	; 0x12dc <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    12f6:	8f ef       	ldi	r24, 0xFF	; 255
    12f8:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    12fa:	0f 90       	pop	r0
    12fc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    12fe:	0f b6       	in	r0, 0x3f	; 63
    1300:	f8 94       	cli
    1302:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1304:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1306:	7e 01       	movw	r14, r28
    1308:	88 e0       	ldi	r24, 0x08	; 8
    130a:	e8 0e       	add	r14, r24
    130c:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    130e:	11 16       	cp	r1, r17
    1310:	5c f4       	brge	.+22     	; 0x1328 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1312:	88 85       	ldd	r24, Y+8	; 0x08
    1314:	88 23       	and	r24, r24
    1316:	41 f0       	breq	.+16     	; 0x1328 <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1318:	c7 01       	movw	r24, r14
    131a:	0e 94 f6 05 	call	0xbec	; 0xbec <xTaskRemoveFromEventList>
    131e:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1320:	0e 94 b6 06 	call	0xd6c	; 0xd6c <vTaskMissedYield>
    1324:	11 50       	subi	r17, 0x01	; 1
    1326:	f3 cf       	rjmp	.-26     	; 0x130e <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1328:	8f ef       	ldi	r24, 0xFF	; 255
    132a:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    132c:	0f 90       	pop	r0
    132e:	0f be       	out	0x3f, r0	; 63
}
    1330:	df 91       	pop	r29
    1332:	cf 91       	pop	r28
    1334:	1f 91       	pop	r17
    1336:	ff 90       	pop	r15
    1338:	ef 90       	pop	r14
    133a:	08 95       	ret

0000133c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    133c:	cf 93       	push	r28
    133e:	df 93       	push	r29
    1340:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1342:	0f b6       	in	r0, 0x3f	; 63
    1344:	f8 94       	cli
    1346:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1348:	48 81       	ld	r20, Y
    134a:	59 81       	ldd	r21, Y+1	; 0x01
    134c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    134e:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1350:	9a 01       	movw	r18, r20
    1352:	87 9f       	mul	r24, r23
    1354:	20 0d       	add	r18, r0
    1356:	31 1d       	adc	r19, r1
    1358:	11 24       	eor	r1, r1
    135a:	3d 83       	std	Y+5, r19	; 0x05
    135c:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    135e:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1360:	5b 83       	std	Y+3, r21	; 0x03
    1362:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1364:	90 e0       	ldi	r25, 0x00	; 0
    1366:	01 97       	sbiw	r24, 0x01	; 1
    1368:	78 9f       	mul	r23, r24
    136a:	90 01       	movw	r18, r0
    136c:	79 9f       	mul	r23, r25
    136e:	30 0d       	add	r19, r0
    1370:	11 24       	eor	r1, r1
    1372:	ca 01       	movw	r24, r20
    1374:	82 0f       	add	r24, r18
    1376:	93 1f       	adc	r25, r19
    1378:	9f 83       	std	Y+7, r25	; 0x07
    137a:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    137c:	8f ef       	ldi	r24, 0xFF	; 255
    137e:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1380:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1382:	61 11       	cpse	r22, r1
    1384:	0c c0       	rjmp	.+24     	; 0x139e <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1386:	88 85       	ldd	r24, Y+8	; 0x08
    1388:	88 23       	and	r24, r24
    138a:	89 f0       	breq	.+34     	; 0x13ae <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    138c:	ce 01       	movw	r24, r28
    138e:	08 96       	adiw	r24, 0x08	; 8
    1390:	0e 94 f6 05 	call	0xbec	; 0xbec <xTaskRemoveFromEventList>
    1394:	88 23       	and	r24, r24
    1396:	59 f0       	breq	.+22     	; 0x13ae <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1398:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
    139c:	08 c0       	rjmp	.+16     	; 0x13ae <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    139e:	ce 01       	movw	r24, r28
    13a0:	08 96       	adiw	r24, 0x08	; 8
    13a2:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    13a6:	ce 01       	movw	r24, r28
    13a8:	41 96       	adiw	r24, 0x11	; 17
    13aa:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    13ae:	0f 90       	pop	r0
    13b0:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    13b2:	81 e0       	ldi	r24, 0x01	; 1
    13b4:	df 91       	pop	r29
    13b6:	cf 91       	pop	r28
    13b8:	08 95       	ret

000013ba <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    13ba:	0f 93       	push	r16
    13bc:	1f 93       	push	r17
    13be:	cf 93       	push	r28
    13c0:	df 93       	push	r29
    13c2:	08 2f       	mov	r16, r24
    13c4:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    13c6:	66 23       	and	r22, r22
    13c8:	21 f0       	breq	.+8      	; 0x13d2 <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    13ca:	86 9f       	mul	r24, r22
    13cc:	c0 01       	movw	r24, r0
    13ce:	11 24       	eor	r1, r1
    13d0:	02 c0       	rjmp	.+4      	; 0x13d6 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    13d2:	80 e0       	ldi	r24, 0x00	; 0
    13d4:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    13d6:	4f 96       	adiw	r24, 0x1f	; 31
    13d8:	0e 94 34 10 	call	0x2068	; 0x2068 <pvPortMalloc>
    13dc:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    13de:	00 97       	sbiw	r24, 0x00	; 0
    13e0:	71 f0       	breq	.+28     	; 0x13fe <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    13e2:	11 11       	cpse	r17, r1
    13e4:	03 c0       	rjmp	.+6      	; 0x13ec <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    13e6:	99 83       	std	Y+1, r25	; 0x01
    13e8:	88 83       	st	Y, r24
    13ea:	03 c0       	rjmp	.+6      	; 0x13f2 <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    13ec:	4f 96       	adiw	r24, 0x1f	; 31
    13ee:	99 83       	std	Y+1, r25	; 0x01
    13f0:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    13f2:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    13f4:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    13f6:	61 e0       	ldi	r22, 0x01	; 1
    13f8:	ce 01       	movw	r24, r28
    13fa:	0e 94 9e 09 	call	0x133c	; 0x133c <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    13fe:	ce 01       	movw	r24, r28
    1400:	df 91       	pop	r29
    1402:	cf 91       	pop	r28
    1404:	1f 91       	pop	r17
    1406:	0f 91       	pop	r16
    1408:	08 95       	ret

0000140a <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    140a:	af 92       	push	r10
    140c:	bf 92       	push	r11
    140e:	cf 92       	push	r12
    1410:	df 92       	push	r13
    1412:	ff 92       	push	r15
    1414:	0f 93       	push	r16
    1416:	1f 93       	push	r17
    1418:	cf 93       	push	r28
    141a:	df 93       	push	r29
    141c:	00 d0       	rcall	.+0      	; 0x141e <xQueueGenericSend+0x14>
    141e:	00 d0       	rcall	.+0      	; 0x1420 <xQueueGenericSend+0x16>
    1420:	1f 92       	push	r1
    1422:	cd b7       	in	r28, 0x3d	; 61
    1424:	de b7       	in	r29, 0x3e	; 62
    1426:	8c 01       	movw	r16, r24
    1428:	6b 01       	movw	r12, r22
    142a:	5d 83       	std	Y+5, r21	; 0x05
    142c:	4c 83       	std	Y+4, r20	; 0x04
    142e:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1430:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1432:	58 01       	movw	r10, r16
    1434:	98 e0       	ldi	r25, 0x08	; 8
    1436:	a9 0e       	add	r10, r25
    1438:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    143a:	0f b6       	in	r0, 0x3f	; 63
    143c:	f8 94       	cli
    143e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1440:	f8 01       	movw	r30, r16
    1442:	22 8d       	ldd	r18, Z+26	; 0x1a
    1444:	93 8d       	ldd	r25, Z+27	; 0x1b
    1446:	29 17       	cp	r18, r25
    1448:	18 f0       	brcs	.+6      	; 0x1450 <xQueueGenericSend+0x46>
    144a:	f2 e0       	ldi	r31, 0x02	; 2
    144c:	ff 12       	cpse	r15, r31
    144e:	14 c0       	rjmp	.+40     	; 0x1478 <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1450:	4f 2d       	mov	r20, r15
    1452:	b6 01       	movw	r22, r12
    1454:	c8 01       	movw	r24, r16
    1456:	0e 94 fe 08 	call	0x11fc	; 0x11fc <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    145a:	f8 01       	movw	r30, r16
    145c:	91 89       	ldd	r25, Z+17	; 0x11
    145e:	99 23       	and	r25, r25
    1460:	21 f0       	breq	.+8      	; 0x146a <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1462:	c8 01       	movw	r24, r16
    1464:	41 96       	adiw	r24, 0x11	; 17
    1466:	0e 94 f6 05 	call	0xbec	; 0xbec <xTaskRemoveFromEventList>
    146a:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    146c:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1470:	0f 90       	pop	r0
    1472:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1474:	81 e0       	ldi	r24, 0x01	; 1
    1476:	50 c0       	rjmp	.+160    	; 0x1518 <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1478:	2c 81       	ldd	r18, Y+4	; 0x04
    147a:	3d 81       	ldd	r19, Y+5	; 0x05
    147c:	23 2b       	or	r18, r19
    147e:	19 f4       	brne	.+6      	; 0x1486 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1480:	0f 90       	pop	r0
    1482:	0f be       	out	0x3f, r0	; 63
    1484:	48 c0       	rjmp	.+144    	; 0x1516 <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1486:	81 11       	cpse	r24, r1
    1488:	04 c0       	rjmp	.+8      	; 0x1492 <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    148a:	ce 01       	movw	r24, r28
    148c:	01 96       	adiw	r24, 0x01	; 1
    148e:	0e 94 78 06 	call	0xcf0	; 0xcf0 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1492:	0f 90       	pop	r0
    1494:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1496:	0e 94 ac 03 	call	0x758	; 0x758 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    149a:	0f b6       	in	r0, 0x3f	; 63
    149c:	f8 94       	cli
    149e:	0f 92       	push	r0
    14a0:	f8 01       	movw	r30, r16
    14a2:	85 8d       	ldd	r24, Z+29	; 0x1d
    14a4:	8f 3f       	cpi	r24, 0xFF	; 255
    14a6:	09 f4       	brne	.+2      	; 0x14aa <xQueueGenericSend+0xa0>
    14a8:	15 8e       	std	Z+29, r1	; 0x1d
    14aa:	f8 01       	movw	r30, r16
    14ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    14ae:	8f 3f       	cpi	r24, 0xFF	; 255
    14b0:	09 f4       	brne	.+2      	; 0x14b4 <xQueueGenericSend+0xaa>
    14b2:	16 8e       	std	Z+30, r1	; 0x1e
    14b4:	0f 90       	pop	r0
    14b6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14b8:	be 01       	movw	r22, r28
    14ba:	6c 5f       	subi	r22, 0xFC	; 252
    14bc:	7f 4f       	sbci	r23, 0xFF	; 255
    14be:	ce 01       	movw	r24, r28
    14c0:	01 96       	adiw	r24, 0x01	; 1
    14c2:	0e 94 83 06 	call	0xd06	; 0xd06 <xTaskCheckForTimeOut>
    14c6:	81 11       	cpse	r24, r1
    14c8:	21 c0       	rjmp	.+66     	; 0x150c <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    14ca:	0f b6       	in	r0, 0x3f	; 63
    14cc:	f8 94       	cli
    14ce:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    14d0:	f8 01       	movw	r30, r16
    14d2:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    14d4:	0f 90       	pop	r0
    14d6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    14d8:	83 8d       	ldd	r24, Z+27	; 0x1b
    14da:	98 13       	cpse	r25, r24
    14dc:	11 c0       	rjmp	.+34     	; 0x1500 <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    14de:	6c 81       	ldd	r22, Y+4	; 0x04
    14e0:	7d 81       	ldd	r23, Y+5	; 0x05
    14e2:	c5 01       	movw	r24, r10
    14e4:	0e 94 cd 05 	call	0xb9a	; 0xb9a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    14e8:	c8 01       	movw	r24, r16
    14ea:	0e 94 60 09 	call	0x12c0	; 0x12c0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    14ee:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>
    14f2:	88 23       	and	r24, r24
    14f4:	11 f0       	breq	.+4      	; 0x14fa <xQueueGenericSend+0xf0>
    14f6:	81 e0       	ldi	r24, 0x01	; 1
    14f8:	a0 cf       	rjmp	.-192    	; 0x143a <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    14fa:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
    14fe:	fb cf       	rjmp	.-10     	; 0x14f6 <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1500:	c8 01       	movw	r24, r16
    1502:	0e 94 60 09 	call	0x12c0	; 0x12c0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1506:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>
    150a:	f5 cf       	rjmp	.-22     	; 0x14f6 <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    150c:	c8 01       	movw	r24, r16
    150e:	0e 94 60 09 	call	0x12c0	; 0x12c0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1512:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1516:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    1518:	0f 90       	pop	r0
    151a:	0f 90       	pop	r0
    151c:	0f 90       	pop	r0
    151e:	0f 90       	pop	r0
    1520:	0f 90       	pop	r0
    1522:	df 91       	pop	r29
    1524:	cf 91       	pop	r28
    1526:	1f 91       	pop	r17
    1528:	0f 91       	pop	r16
    152a:	ff 90       	pop	r15
    152c:	df 90       	pop	r13
    152e:	cf 90       	pop	r12
    1530:	bf 90       	pop	r11
    1532:	af 90       	pop	r10
    1534:	08 95       	ret

00001536 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1536:	ef 92       	push	r14
    1538:	ff 92       	push	r15
    153a:	1f 93       	push	r17
    153c:	cf 93       	push	r28
    153e:	df 93       	push	r29
    1540:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1542:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1544:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1546:	98 17       	cp	r25, r24
    1548:	10 f0       	brcs	.+4      	; 0x154e <xQueueGenericSendFromISR+0x18>
    154a:	22 30       	cpi	r18, 0x02	; 2
    154c:	e1 f4       	brne	.+56     	; 0x1586 <xQueueGenericSendFromISR+0x50>
    154e:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1550:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1552:	42 2f       	mov	r20, r18
    1554:	ce 01       	movw	r24, r28
    1556:	0e 94 fe 08 	call	0x11fc	; 0x11fc <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    155a:	1f 3f       	cpi	r17, 0xFF	; 255
    155c:	81 f4       	brne	.+32     	; 0x157e <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    155e:	89 89       	ldd	r24, Y+17	; 0x11
    1560:	88 23       	and	r24, r24
    1562:	79 f0       	breq	.+30     	; 0x1582 <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1564:	ce 01       	movw	r24, r28
    1566:	41 96       	adiw	r24, 0x11	; 17
    1568:	0e 94 f6 05 	call	0xbec	; 0xbec <xTaskRemoveFromEventList>
    156c:	88 23       	and	r24, r24
    156e:	49 f0       	breq	.+18     	; 0x1582 <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1570:	e1 14       	cp	r14, r1
    1572:	f1 04       	cpc	r15, r1
    1574:	31 f0       	breq	.+12     	; 0x1582 <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1576:	81 e0       	ldi	r24, 0x01	; 1
    1578:	f7 01       	movw	r30, r14
    157a:	80 83       	st	Z, r24
    157c:	05 c0       	rjmp	.+10     	; 0x1588 <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    157e:	1f 5f       	subi	r17, 0xFF	; 255
    1580:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    1582:	81 e0       	ldi	r24, 0x01	; 1
    1584:	01 c0       	rjmp	.+2      	; 0x1588 <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1586:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1588:	df 91       	pop	r29
    158a:	cf 91       	pop	r28
    158c:	1f 91       	pop	r17
    158e:	ff 90       	pop	r15
    1590:	ef 90       	pop	r14
    1592:	08 95       	ret

00001594 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1594:	cf 93       	push	r28
    1596:	df 93       	push	r29
    1598:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    159a:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    159c:	83 8d       	ldd	r24, Z+27	; 0x1b
    159e:	98 17       	cp	r25, r24
    15a0:	c0 f4       	brcc	.+48     	; 0x15d2 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    15a2:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    15a4:	9f 5f       	subi	r25, 0xFF	; 255
    15a6:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    15a8:	8f 3f       	cpi	r24, 0xFF	; 255
    15aa:	79 f4       	brne	.+30     	; 0x15ca <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    15ac:	81 89       	ldd	r24, Z+17	; 0x11
    15ae:	88 23       	and	r24, r24
    15b0:	71 f0       	breq	.+28     	; 0x15ce <xQueueGiveFromISR+0x3a>
    15b2:	eb 01       	movw	r28, r22
    15b4:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15b6:	41 96       	adiw	r24, 0x11	; 17
    15b8:	0e 94 f6 05 	call	0xbec	; 0xbec <xTaskRemoveFromEventList>
    15bc:	88 23       	and	r24, r24
    15be:	39 f0       	breq	.+14     	; 0x15ce <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    15c0:	20 97       	sbiw	r28, 0x00	; 0
    15c2:	29 f0       	breq	.+10     	; 0x15ce <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    15c4:	81 e0       	ldi	r24, 0x01	; 1
    15c6:	88 83       	st	Y, r24
    15c8:	05 c0       	rjmp	.+10     	; 0x15d4 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    15ca:	8f 5f       	subi	r24, 0xFF	; 255
    15cc:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    15ce:	81 e0       	ldi	r24, 0x01	; 1
    15d0:	01 c0       	rjmp	.+2      	; 0x15d4 <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    15d2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    15d4:	df 91       	pop	r29
    15d6:	cf 91       	pop	r28
    15d8:	08 95       	ret

000015da <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    15da:	af 92       	push	r10
    15dc:	bf 92       	push	r11
    15de:	cf 92       	push	r12
    15e0:	df 92       	push	r13
    15e2:	ff 92       	push	r15
    15e4:	0f 93       	push	r16
    15e6:	1f 93       	push	r17
    15e8:	cf 93       	push	r28
    15ea:	df 93       	push	r29
    15ec:	00 d0       	rcall	.+0      	; 0x15ee <xQueueReceive+0x14>
    15ee:	00 d0       	rcall	.+0      	; 0x15f0 <xQueueReceive+0x16>
    15f0:	1f 92       	push	r1
    15f2:	cd b7       	in	r28, 0x3d	; 61
    15f4:	de b7       	in	r29, 0x3e	; 62
    15f6:	8c 01       	movw	r16, r24
    15f8:	6b 01       	movw	r12, r22
    15fa:	5d 83       	std	Y+5, r21	; 0x05
    15fc:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    15fe:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1600:	58 01       	movw	r10, r16
    1602:	91 e1       	ldi	r25, 0x11	; 17
    1604:	a9 0e       	add	r10, r25
    1606:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1608:	0f b6       	in	r0, 0x3f	; 63
    160a:	f8 94       	cli
    160c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    160e:	f8 01       	movw	r30, r16
    1610:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1612:	ff 20       	and	r15, r15
    1614:	a9 f0       	breq	.+42     	; 0x1640 <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1616:	b6 01       	movw	r22, r12
    1618:	c8 01       	movw	r24, r16
    161a:	0e 94 46 09 	call	0x128c	; 0x128c <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    161e:	fa 94       	dec	r15
    1620:	f8 01       	movw	r30, r16
    1622:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1624:	80 85       	ldd	r24, Z+8	; 0x08
    1626:	88 23       	and	r24, r24
    1628:	39 f0       	breq	.+14     	; 0x1638 <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    162a:	c8 01       	movw	r24, r16
    162c:	08 96       	adiw	r24, 0x08	; 8
    162e:	0e 94 f6 05 	call	0xbec	; 0xbec <xTaskRemoveFromEventList>
    1632:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1634:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1638:	0f 90       	pop	r0
    163a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    163c:	81 e0       	ldi	r24, 0x01	; 1
    163e:	50 c0       	rjmp	.+160    	; 0x16e0 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1640:	2c 81       	ldd	r18, Y+4	; 0x04
    1642:	3d 81       	ldd	r19, Y+5	; 0x05
    1644:	23 2b       	or	r18, r19
    1646:	19 f4       	brne	.+6      	; 0x164e <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1648:	0f 90       	pop	r0
    164a:	0f be       	out	0x3f, r0	; 63
    164c:	48 c0       	rjmp	.+144    	; 0x16de <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    164e:	81 11       	cpse	r24, r1
    1650:	04 c0       	rjmp	.+8      	; 0x165a <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1652:	ce 01       	movw	r24, r28
    1654:	01 96       	adiw	r24, 0x01	; 1
    1656:	0e 94 78 06 	call	0xcf0	; 0xcf0 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    165a:	0f 90       	pop	r0
    165c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    165e:	0e 94 ac 03 	call	0x758	; 0x758 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1662:	0f b6       	in	r0, 0x3f	; 63
    1664:	f8 94       	cli
    1666:	0f 92       	push	r0
    1668:	f8 01       	movw	r30, r16
    166a:	85 8d       	ldd	r24, Z+29	; 0x1d
    166c:	8f 3f       	cpi	r24, 0xFF	; 255
    166e:	09 f4       	brne	.+2      	; 0x1672 <xQueueReceive+0x98>
    1670:	15 8e       	std	Z+29, r1	; 0x1d
    1672:	f8 01       	movw	r30, r16
    1674:	86 8d       	ldd	r24, Z+30	; 0x1e
    1676:	8f 3f       	cpi	r24, 0xFF	; 255
    1678:	09 f4       	brne	.+2      	; 0x167c <xQueueReceive+0xa2>
    167a:	16 8e       	std	Z+30, r1	; 0x1e
    167c:	0f 90       	pop	r0
    167e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1680:	be 01       	movw	r22, r28
    1682:	6c 5f       	subi	r22, 0xFC	; 252
    1684:	7f 4f       	sbci	r23, 0xFF	; 255
    1686:	ce 01       	movw	r24, r28
    1688:	01 96       	adiw	r24, 0x01	; 1
    168a:	0e 94 83 06 	call	0xd06	; 0xd06 <xTaskCheckForTimeOut>
    168e:	81 11       	cpse	r24, r1
    1690:	1c c0       	rjmp	.+56     	; 0x16ca <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1692:	c8 01       	movw	r24, r16
    1694:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <prvIsQueueEmpty>
    1698:	88 23       	and	r24, r24
    169a:	89 f0       	breq	.+34     	; 0x16be <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    169c:	6c 81       	ldd	r22, Y+4	; 0x04
    169e:	7d 81       	ldd	r23, Y+5	; 0x05
    16a0:	c5 01       	movw	r24, r10
    16a2:	0e 94 cd 05 	call	0xb9a	; 0xb9a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    16a6:	c8 01       	movw	r24, r16
    16a8:	0e 94 60 09 	call	0x12c0	; 0x12c0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    16ac:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>
    16b0:	88 23       	and	r24, r24
    16b2:	11 f0       	breq	.+4      	; 0x16b8 <xQueueReceive+0xde>
    16b4:	81 e0       	ldi	r24, 0x01	; 1
    16b6:	a8 cf       	rjmp	.-176    	; 0x1608 <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    16b8:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
    16bc:	fb cf       	rjmp	.-10     	; 0x16b4 <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    16be:	c8 01       	movw	r24, r16
    16c0:	0e 94 60 09 	call	0x12c0	; 0x12c0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    16c4:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>
    16c8:	f5 cf       	rjmp	.-22     	; 0x16b4 <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    16ca:	c8 01       	movw	r24, r16
    16cc:	0e 94 60 09 	call	0x12c0	; 0x12c0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    16d0:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16d4:	c8 01       	movw	r24, r16
    16d6:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <prvIsQueueEmpty>
    16da:	88 23       	and	r24, r24
    16dc:	59 f3       	breq	.-42     	; 0x16b4 <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    16de:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    16e0:	0f 90       	pop	r0
    16e2:	0f 90       	pop	r0
    16e4:	0f 90       	pop	r0
    16e6:	0f 90       	pop	r0
    16e8:	0f 90       	pop	r0
    16ea:	df 91       	pop	r29
    16ec:	cf 91       	pop	r28
    16ee:	1f 91       	pop	r17
    16f0:	0f 91       	pop	r16
    16f2:	ff 90       	pop	r15
    16f4:	df 90       	pop	r13
    16f6:	cf 90       	pop	r12
    16f8:	bf 90       	pop	r11
    16fa:	af 90       	pop	r10
    16fc:	08 95       	ret

000016fe <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    16fe:	ef 92       	push	r14
    1700:	ff 92       	push	r15
    1702:	0f 93       	push	r16
    1704:	1f 93       	push	r17
    1706:	cf 93       	push	r28
    1708:	df 93       	push	r29
    170a:	00 d0       	rcall	.+0      	; 0x170c <xQueueSemaphoreTake+0xe>
    170c:	00 d0       	rcall	.+0      	; 0x170e <xQueueSemaphoreTake+0x10>
    170e:	1f 92       	push	r1
    1710:	cd b7       	in	r28, 0x3d	; 61
    1712:	de b7       	in	r29, 0x3e	; 62
    1714:	8c 01       	movw	r16, r24
    1716:	7d 83       	std	Y+5, r23	; 0x05
    1718:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    171a:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    171c:	78 01       	movw	r14, r16
    171e:	81 e1       	ldi	r24, 0x11	; 17
    1720:	e8 0e       	add	r14, r24
    1722:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1724:	0f b6       	in	r0, 0x3f	; 63
    1726:	f8 94       	cli
    1728:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    172a:	f8 01       	movw	r30, r16
    172c:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    172e:	88 23       	and	r24, r24
    1730:	81 f0       	breq	.+32     	; 0x1752 <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1732:	81 50       	subi	r24, 0x01	; 1
    1734:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1736:	80 85       	ldd	r24, Z+8	; 0x08
    1738:	88 23       	and	r24, r24
    173a:	39 f0       	breq	.+14     	; 0x174a <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    173c:	c8 01       	movw	r24, r16
    173e:	08 96       	adiw	r24, 0x08	; 8
    1740:	0e 94 f6 05 	call	0xbec	; 0xbec <xTaskRemoveFromEventList>
    1744:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1746:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    174a:	0f 90       	pop	r0
    174c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    174e:	81 e0       	ldi	r24, 0x01	; 1
    1750:	50 c0       	rjmp	.+160    	; 0x17f2 <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1752:	2c 81       	ldd	r18, Y+4	; 0x04
    1754:	3d 81       	ldd	r19, Y+5	; 0x05
    1756:	23 2b       	or	r18, r19
    1758:	19 f4       	brne	.+6      	; 0x1760 <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    175a:	0f 90       	pop	r0
    175c:	0f be       	out	0x3f, r0	; 63
    175e:	48 c0       	rjmp	.+144    	; 0x17f0 <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1760:	91 11       	cpse	r25, r1
    1762:	04 c0       	rjmp	.+8      	; 0x176c <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1764:	ce 01       	movw	r24, r28
    1766:	01 96       	adiw	r24, 0x01	; 1
    1768:	0e 94 78 06 	call	0xcf0	; 0xcf0 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    176c:	0f 90       	pop	r0
    176e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    1770:	0e 94 ac 03 	call	0x758	; 0x758 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1774:	0f b6       	in	r0, 0x3f	; 63
    1776:	f8 94       	cli
    1778:	0f 92       	push	r0
    177a:	f8 01       	movw	r30, r16
    177c:	85 8d       	ldd	r24, Z+29	; 0x1d
    177e:	8f 3f       	cpi	r24, 0xFF	; 255
    1780:	09 f4       	brne	.+2      	; 0x1784 <xQueueSemaphoreTake+0x86>
    1782:	15 8e       	std	Z+29, r1	; 0x1d
    1784:	f8 01       	movw	r30, r16
    1786:	86 8d       	ldd	r24, Z+30	; 0x1e
    1788:	8f 3f       	cpi	r24, 0xFF	; 255
    178a:	09 f4       	brne	.+2      	; 0x178e <xQueueSemaphoreTake+0x90>
    178c:	16 8e       	std	Z+30, r1	; 0x1e
    178e:	0f 90       	pop	r0
    1790:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1792:	be 01       	movw	r22, r28
    1794:	6c 5f       	subi	r22, 0xFC	; 252
    1796:	7f 4f       	sbci	r23, 0xFF	; 255
    1798:	ce 01       	movw	r24, r28
    179a:	01 96       	adiw	r24, 0x01	; 1
    179c:	0e 94 83 06 	call	0xd06	; 0xd06 <xTaskCheckForTimeOut>
    17a0:	81 11       	cpse	r24, r1
    17a2:	1c c0       	rjmp	.+56     	; 0x17dc <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17a4:	c8 01       	movw	r24, r16
    17a6:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <prvIsQueueEmpty>
    17aa:	88 23       	and	r24, r24
    17ac:	89 f0       	breq	.+34     	; 0x17d0 <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17ae:	6c 81       	ldd	r22, Y+4	; 0x04
    17b0:	7d 81       	ldd	r23, Y+5	; 0x05
    17b2:	c7 01       	movw	r24, r14
    17b4:	0e 94 cd 05 	call	0xb9a	; 0xb9a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    17b8:	c8 01       	movw	r24, r16
    17ba:	0e 94 60 09 	call	0x12c0	; 0x12c0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    17be:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>
    17c2:	88 23       	and	r24, r24
    17c4:	11 f0       	breq	.+4      	; 0x17ca <xQueueSemaphoreTake+0xcc>
    17c6:	91 e0       	ldi	r25, 0x01	; 1
    17c8:	ad cf       	rjmp	.-166    	; 0x1724 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    17ca:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
    17ce:	fb cf       	rjmp	.-10     	; 0x17c6 <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    17d0:	c8 01       	movw	r24, r16
    17d2:	0e 94 60 09 	call	0x12c0	; 0x12c0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    17d6:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>
    17da:	f5 cf       	rjmp	.-22     	; 0x17c6 <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    17dc:	c8 01       	movw	r24, r16
    17de:	0e 94 60 09 	call	0x12c0	; 0x12c0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    17e2:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17e6:	c8 01       	movw	r24, r16
    17e8:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <prvIsQueueEmpty>
    17ec:	88 23       	and	r24, r24
    17ee:	59 f3       	breq	.-42     	; 0x17c6 <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    17f0:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    17f2:	0f 90       	pop	r0
    17f4:	0f 90       	pop	r0
    17f6:	0f 90       	pop	r0
    17f8:	0f 90       	pop	r0
    17fa:	0f 90       	pop	r0
    17fc:	df 91       	pop	r29
    17fe:	cf 91       	pop	r28
    1800:	1f 91       	pop	r17
    1802:	0f 91       	pop	r16
    1804:	ff 90       	pop	r15
    1806:	ef 90       	pop	r14
    1808:	08 95       	ret

0000180a <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    180a:	cf 92       	push	r12
    180c:	df 92       	push	r13
    180e:	ef 92       	push	r14
    1810:	ff 92       	push	r15
    1812:	0f 93       	push	r16
    1814:	1f 93       	push	r17
    1816:	cf 93       	push	r28
    1818:	df 93       	push	r29
    181a:	00 d0       	rcall	.+0      	; 0x181c <xQueuePeek+0x12>
    181c:	00 d0       	rcall	.+0      	; 0x181e <xQueuePeek+0x14>
    181e:	1f 92       	push	r1
    1820:	cd b7       	in	r28, 0x3d	; 61
    1822:	de b7       	in	r29, 0x3e	; 62
    1824:	8c 01       	movw	r16, r24
    1826:	7b 01       	movw	r14, r22
    1828:	5d 83       	std	Y+5, r21	; 0x05
    182a:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    182c:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    182e:	68 01       	movw	r12, r16
    1830:	91 e1       	ldi	r25, 0x11	; 17
    1832:	c9 0e       	add	r12, r25
    1834:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1836:	0f b6       	in	r0, 0x3f	; 63
    1838:	f8 94       	cli
    183a:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    183c:	f8 01       	movw	r30, r16
    183e:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1840:	99 23       	and	r25, r25
    1842:	b9 f0       	breq	.+46     	; 0x1872 <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1844:	c6 80       	ldd	r12, Z+6	; 0x06
    1846:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1848:	b7 01       	movw	r22, r14
    184a:	c8 01       	movw	r24, r16
    184c:	0e 94 46 09 	call	0x128c	; 0x128c <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1850:	f8 01       	movw	r30, r16
    1852:	d7 82       	std	Z+7, r13	; 0x07
    1854:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1856:	81 89       	ldd	r24, Z+17	; 0x11
    1858:	88 23       	and	r24, r24
    185a:	39 f0       	breq	.+14     	; 0x186a <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    185c:	c8 01       	movw	r24, r16
    185e:	41 96       	adiw	r24, 0x11	; 17
    1860:	0e 94 f6 05 	call	0xbec	; 0xbec <xTaskRemoveFromEventList>
    1864:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1866:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    186a:	0f 90       	pop	r0
    186c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    186e:	81 e0       	ldi	r24, 0x01	; 1
    1870:	50 c0       	rjmp	.+160    	; 0x1912 <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1872:	2c 81       	ldd	r18, Y+4	; 0x04
    1874:	3d 81       	ldd	r19, Y+5	; 0x05
    1876:	23 2b       	or	r18, r19
    1878:	19 f4       	brne	.+6      	; 0x1880 <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    187a:	0f 90       	pop	r0
    187c:	0f be       	out	0x3f, r0	; 63
    187e:	48 c0       	rjmp	.+144    	; 0x1910 <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1880:	81 11       	cpse	r24, r1
    1882:	04 c0       	rjmp	.+8      	; 0x188c <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1884:	ce 01       	movw	r24, r28
    1886:	01 96       	adiw	r24, 0x01	; 1
    1888:	0e 94 78 06 	call	0xcf0	; 0xcf0 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    188c:	0f 90       	pop	r0
    188e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1890:	0e 94 ac 03 	call	0x758	; 0x758 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1894:	0f b6       	in	r0, 0x3f	; 63
    1896:	f8 94       	cli
    1898:	0f 92       	push	r0
    189a:	f8 01       	movw	r30, r16
    189c:	85 8d       	ldd	r24, Z+29	; 0x1d
    189e:	8f 3f       	cpi	r24, 0xFF	; 255
    18a0:	09 f4       	brne	.+2      	; 0x18a4 <xQueuePeek+0x9a>
    18a2:	15 8e       	std	Z+29, r1	; 0x1d
    18a4:	f8 01       	movw	r30, r16
    18a6:	86 8d       	ldd	r24, Z+30	; 0x1e
    18a8:	8f 3f       	cpi	r24, 0xFF	; 255
    18aa:	09 f4       	brne	.+2      	; 0x18ae <xQueuePeek+0xa4>
    18ac:	16 8e       	std	Z+30, r1	; 0x1e
    18ae:	0f 90       	pop	r0
    18b0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18b2:	be 01       	movw	r22, r28
    18b4:	6c 5f       	subi	r22, 0xFC	; 252
    18b6:	7f 4f       	sbci	r23, 0xFF	; 255
    18b8:	ce 01       	movw	r24, r28
    18ba:	01 96       	adiw	r24, 0x01	; 1
    18bc:	0e 94 83 06 	call	0xd06	; 0xd06 <xTaskCheckForTimeOut>
    18c0:	81 11       	cpse	r24, r1
    18c2:	1c c0       	rjmp	.+56     	; 0x18fc <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18c4:	c8 01       	movw	r24, r16
    18c6:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <prvIsQueueEmpty>
    18ca:	88 23       	and	r24, r24
    18cc:	89 f0       	breq	.+34     	; 0x18f0 <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18ce:	6c 81       	ldd	r22, Y+4	; 0x04
    18d0:	7d 81       	ldd	r23, Y+5	; 0x05
    18d2:	c6 01       	movw	r24, r12
    18d4:	0e 94 cd 05 	call	0xb9a	; 0xb9a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    18d8:	c8 01       	movw	r24, r16
    18da:	0e 94 60 09 	call	0x12c0	; 0x12c0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18de:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>
    18e2:	88 23       	and	r24, r24
    18e4:	11 f0       	breq	.+4      	; 0x18ea <xQueuePeek+0xe0>
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	a6 cf       	rjmp	.-180    	; 0x1836 <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    18ea:	0e 94 22 11 	call	0x2244	; 0x2244 <vPortYield>
    18ee:	fb cf       	rjmp	.-10     	; 0x18e6 <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    18f0:	c8 01       	movw	r24, r16
    18f2:	0e 94 60 09 	call	0x12c0	; 0x12c0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18f6:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>
    18fa:	f5 cf       	rjmp	.-22     	; 0x18e6 <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    18fc:	c8 01       	movw	r24, r16
    18fe:	0e 94 60 09 	call	0x12c0	; 0x12c0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1902:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1906:	c8 01       	movw	r24, r16
    1908:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <prvIsQueueEmpty>
    190c:	88 23       	and	r24, r24
    190e:	59 f3       	breq	.-42     	; 0x18e6 <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1910:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1912:	0f 90       	pop	r0
    1914:	0f 90       	pop	r0
    1916:	0f 90       	pop	r0
    1918:	0f 90       	pop	r0
    191a:	0f 90       	pop	r0
    191c:	df 91       	pop	r29
    191e:	cf 91       	pop	r28
    1920:	1f 91       	pop	r17
    1922:	0f 91       	pop	r16
    1924:	ff 90       	pop	r15
    1926:	ef 90       	pop	r14
    1928:	df 90       	pop	r13
    192a:	cf 90       	pop	r12
    192c:	08 95       	ret

0000192e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    192e:	ef 92       	push	r14
    1930:	ff 92       	push	r15
    1932:	0f 93       	push	r16
    1934:	1f 93       	push	r17
    1936:	cf 93       	push	r28
    1938:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    193a:	fc 01       	movw	r30, r24
    193c:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    193e:	00 23       	and	r16, r16
    1940:	e9 f0       	breq	.+58     	; 0x197c <xQueueReceiveFromISR+0x4e>
    1942:	7a 01       	movw	r14, r20
    1944:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1946:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1948:	0e 94 46 09 	call	0x128c	; 0x128c <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    194c:	01 50       	subi	r16, 0x01	; 1
    194e:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1950:	1f 3f       	cpi	r17, 0xFF	; 255
    1952:	81 f4       	brne	.+32     	; 0x1974 <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1954:	88 85       	ldd	r24, Y+8	; 0x08
    1956:	88 23       	and	r24, r24
    1958:	79 f0       	breq	.+30     	; 0x1978 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    195a:	ce 01       	movw	r24, r28
    195c:	08 96       	adiw	r24, 0x08	; 8
    195e:	0e 94 f6 05 	call	0xbec	; 0xbec <xTaskRemoveFromEventList>
    1962:	88 23       	and	r24, r24
    1964:	49 f0       	breq	.+18     	; 0x1978 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1966:	e1 14       	cp	r14, r1
    1968:	f1 04       	cpc	r15, r1
    196a:	31 f0       	breq	.+12     	; 0x1978 <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    196c:	81 e0       	ldi	r24, 0x01	; 1
    196e:	f7 01       	movw	r30, r14
    1970:	80 83       	st	Z, r24
    1972:	05 c0       	rjmp	.+10     	; 0x197e <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1974:	1f 5f       	subi	r17, 0xFF	; 255
    1976:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1978:	81 e0       	ldi	r24, 0x01	; 1
    197a:	01 c0       	rjmp	.+2      	; 0x197e <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    197c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    197e:	df 91       	pop	r29
    1980:	cf 91       	pop	r28
    1982:	1f 91       	pop	r17
    1984:	0f 91       	pop	r16
    1986:	ff 90       	pop	r15
    1988:	ef 90       	pop	r14
    198a:	08 95       	ret

0000198c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    198c:	0f 93       	push	r16
    198e:	1f 93       	push	r17
    1990:	cf 93       	push	r28
    1992:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1994:	fc 01       	movw	r30, r24
    1996:	22 8d       	ldd	r18, Z+26	; 0x1a
    1998:	22 23       	and	r18, r18
    199a:	49 f0       	breq	.+18     	; 0x19ae <xQueuePeekFromISR+0x22>
    199c:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    199e:	06 81       	ldd	r16, Z+6	; 0x06
    19a0:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    19a2:	0e 94 46 09 	call	0x128c	; 0x128c <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    19a6:	1f 83       	std	Y+7, r17	; 0x07
    19a8:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    19aa:	81 e0       	ldi	r24, 0x01	; 1
    19ac:	01 c0       	rjmp	.+2      	; 0x19b0 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    19ae:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19b0:	df 91       	pop	r29
    19b2:	cf 91       	pop	r28
    19b4:	1f 91       	pop	r17
    19b6:	0f 91       	pop	r16
    19b8:	08 95       	ret

000019ba <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    19ba:	0f b6       	in	r0, 0x3f	; 63
    19bc:	f8 94       	cli
    19be:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    19c0:	fc 01       	movw	r30, r24
    19c2:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    19c4:	0f 90       	pop	r0
    19c6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19c8:	08 95       	ret

000019ca <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    19ca:	0f b6       	in	r0, 0x3f	; 63
    19cc:	f8 94       	cli
    19ce:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    19d0:	fc 01       	movw	r30, r24
    19d2:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    19d4:	0f 90       	pop	r0
    19d6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    19d8:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19da:	82 1b       	sub	r24, r18
    19dc:	08 95       	ret

000019de <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    19de:	fc 01       	movw	r30, r24
    19e0:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    19e2:	08 95       	ret

000019e4 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    19e4:	0c 94 66 10 	jmp	0x20cc	; 0x20cc <vPortFree>

000019e8 <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    19e8:	fc 01       	movw	r30, r24
    19ea:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    19ec:	81 e0       	ldi	r24, 0x01	; 1
    19ee:	91 11       	cpse	r25, r1
    19f0:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    19f2:	08 95       	ret

000019f4 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    19f4:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    19f6:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    19f8:	81 e0       	ldi	r24, 0x01	; 1
    19fa:	23 8d       	ldd	r18, Z+27	; 0x1b
    19fc:	29 13       	cpse	r18, r25
    19fe:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1a00:	08 95       	ret

00001a02 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1a02:	cf 93       	push	r28
    1a04:	df 93       	push	r29
    1a06:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1a08:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1a0a:	0f b6       	in	r0, 0x3f	; 63
    1a0c:	f8 94       	cli
    1a0e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1a10:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a12:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1a14:	0f 90       	pop	r0
    1a16:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1a18:	89 13       	cpse	r24, r25
    1a1a:	0f c0       	rjmp	.+30     	; 0x1a3a <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1a1c:	41 15       	cp	r20, r1
    1a1e:	51 05       	cpc	r21, r1
    1a20:	49 f0       	breq	.+18     	; 0x1a34 <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1a22:	be 01       	movw	r22, r28
    1a24:	68 5f       	subi	r22, 0xF8	; 248
    1a26:	7f 4f       	sbci	r23, 0xFF	; 255
    1a28:	ca 01       	movw	r24, r20
    1a2a:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1a2e:	78 94       	sei
					return errQUEUE_BLOCKED;
    1a30:	8c ef       	ldi	r24, 0xFC	; 252
    1a32:	1b c0       	rjmp	.+54     	; 0x1a6a <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1a34:	78 94       	sei
					return errQUEUE_FULL;
    1a36:	80 e0       	ldi	r24, 0x00	; 0
    1a38:	18 c0       	rjmp	.+48     	; 0x1a6a <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1a3a:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1a3c:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1a3e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a40:	89 17       	cp	r24, r25
    1a42:	88 f4       	brcc	.+34     	; 0x1a66 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1a44:	40 e0       	ldi	r20, 0x00	; 0
    1a46:	ce 01       	movw	r24, r28
    1a48:	0e 94 fe 08 	call	0x11fc	; 0x11fc <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a4c:	89 89       	ldd	r24, Y+17	; 0x11
    1a4e:	81 11       	cpse	r24, r1
    1a50:	02 c0       	rjmp	.+4      	; 0x1a56 <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1a52:	81 e0       	ldi	r24, 0x01	; 1
    1a54:	09 c0       	rjmp	.+18     	; 0x1a68 <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a56:	ce 01       	movw	r24, r28
    1a58:	41 96       	adiw	r24, 0x11	; 17
    1a5a:	0e 94 0f 10 	call	0x201e	; 0x201e <xCoRoutineRemoveFromEventList>
    1a5e:	88 23       	and	r24, r24
    1a60:	c1 f3       	breq	.-16     	; 0x1a52 <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1a62:	8b ef       	ldi	r24, 0xFB	; 251
    1a64:	01 c0       	rjmp	.+2      	; 0x1a68 <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1a66:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1a68:	78 94       	sei

		return xReturn;
	}
    1a6a:	df 91       	pop	r29
    1a6c:	cf 91       	pop	r28
    1a6e:	08 95       	ret

00001a70 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1a70:	cf 93       	push	r28
    1a72:	df 93       	push	r29
    1a74:	ec 01       	movw	r28, r24
    1a76:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1a78:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1a7a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a7c:	81 11       	cpse	r24, r1
    1a7e:	0f c0       	rjmp	.+30     	; 0x1a9e <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1a80:	41 15       	cp	r20, r1
    1a82:	51 05       	cpc	r21, r1
    1a84:	49 f0       	breq	.+18     	; 0x1a98 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1a86:	be 01       	movw	r22, r28
    1a88:	6f 5e       	subi	r22, 0xEF	; 239
    1a8a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a8c:	ca 01       	movw	r24, r20
    1a8e:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1a92:	78 94       	sei
					return errQUEUE_BLOCKED;
    1a94:	8c ef       	ldi	r24, 0xFC	; 252
    1a96:	30 c0       	rjmp	.+96     	; 0x1af8 <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1a98:	78 94       	sei
					return errQUEUE_FULL;
    1a9a:	80 e0       	ldi	r24, 0x00	; 0
    1a9c:	2d c0       	rjmp	.+90     	; 0x1af8 <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1a9e:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1aa0:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1aa2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1aa4:	88 23       	and	r24, r24
    1aa6:	31 f1       	breq	.+76     	; 0x1af4 <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1aa8:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1aaa:	50 e0       	ldi	r21, 0x00	; 0
    1aac:	2e 81       	ldd	r18, Y+6	; 0x06
    1aae:	3f 81       	ldd	r19, Y+7	; 0x07
    1ab0:	24 0f       	add	r18, r20
    1ab2:	35 1f       	adc	r19, r21
    1ab4:	3f 83       	std	Y+7, r19	; 0x07
    1ab6:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1ab8:	8c 81       	ldd	r24, Y+4	; 0x04
    1aba:	9d 81       	ldd	r25, Y+5	; 0x05
    1abc:	28 17       	cp	r18, r24
    1abe:	39 07       	cpc	r19, r25
    1ac0:	20 f0       	brcs	.+8      	; 0x1aca <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1ac2:	88 81       	ld	r24, Y
    1ac4:	99 81       	ldd	r25, Y+1	; 0x01
    1ac6:	9f 83       	std	Y+7, r25	; 0x07
    1ac8:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1aca:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1acc:	91 50       	subi	r25, 0x01	; 1
    1ace:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1ad0:	6e 81       	ldd	r22, Y+6	; 0x06
    1ad2:	7f 81       	ldd	r23, Y+7	; 0x07
    1ad4:	cf 01       	movw	r24, r30
    1ad6:	0e 94 22 12 	call	0x2444	; 0x2444 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ada:	88 85       	ldd	r24, Y+8	; 0x08
    1adc:	81 11       	cpse	r24, r1
    1ade:	02 c0       	rjmp	.+4      	; 0x1ae4 <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1ae0:	81 e0       	ldi	r24, 0x01	; 1
    1ae2:	09 c0       	rjmp	.+18     	; 0x1af6 <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ae4:	ce 01       	movw	r24, r28
    1ae6:	08 96       	adiw	r24, 0x08	; 8
    1ae8:	0e 94 0f 10 	call	0x201e	; 0x201e <xCoRoutineRemoveFromEventList>
    1aec:	88 23       	and	r24, r24
    1aee:	c1 f3       	breq	.-16     	; 0x1ae0 <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1af0:	8b ef       	ldi	r24, 0xFB	; 251
    1af2:	01 c0       	rjmp	.+2      	; 0x1af6 <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1af4:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1af6:	78 94       	sei

		return xReturn;
	}
    1af8:	df 91       	pop	r29
    1afa:	cf 91       	pop	r28
    1afc:	08 95       	ret

00001afe <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1afe:	0f 93       	push	r16
    1b00:	1f 93       	push	r17
    1b02:	cf 93       	push	r28
    1b04:	8c 01       	movw	r16, r24
    1b06:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1b08:	fc 01       	movw	r30, r24
    1b0a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b0c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b0e:	98 17       	cp	r25, r24
    1b10:	10 f0       	brcs	.+4      	; 0x1b16 <xQueueCRSendFromISR+0x18>
    1b12:	4c 2f       	mov	r20, r28
    1b14:	12 c0       	rjmp	.+36     	; 0x1b3a <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1b16:	40 e0       	ldi	r20, 0x00	; 0
    1b18:	c8 01       	movw	r24, r16
    1b1a:	0e 94 fe 08 	call	0x11fc	; 0x11fc <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1b1e:	c1 11       	cpse	r28, r1
    1b20:	f8 cf       	rjmp	.-16     	; 0x1b12 <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b22:	f8 01       	movw	r30, r16
    1b24:	81 89       	ldd	r24, Z+17	; 0x11
    1b26:	88 23       	and	r24, r24
    1b28:	39 f0       	breq	.+14     	; 0x1b38 <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b2a:	c8 01       	movw	r24, r16
    1b2c:	41 96       	adiw	r24, 0x11	; 17
    1b2e:	0e 94 0f 10 	call	0x201e	; 0x201e <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1b32:	41 e0       	ldi	r20, 0x01	; 1
    1b34:	81 11       	cpse	r24, r1
    1b36:	01 c0       	rjmp	.+2      	; 0x1b3a <xQueueCRSendFromISR+0x3c>
    1b38:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1b3a:	84 2f       	mov	r24, r20
    1b3c:	cf 91       	pop	r28
    1b3e:	1f 91       	pop	r17
    1b40:	0f 91       	pop	r16
    1b42:	08 95       	ret

00001b44 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1b44:	0f 93       	push	r16
    1b46:	1f 93       	push	r17
    1b48:	cf 93       	push	r28
    1b4a:	df 93       	push	r29
    1b4c:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b4e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b50:	88 23       	and	r24, r24
    1b52:	79 f1       	breq	.+94     	; 0x1bb2 <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1b54:	24 8d       	ldd	r18, Z+28	; 0x1c
    1b56:	30 e0       	ldi	r19, 0x00	; 0
    1b58:	a6 81       	ldd	r26, Z+6	; 0x06
    1b5a:	b7 81       	ldd	r27, Z+7	; 0x07
    1b5c:	a2 0f       	add	r26, r18
    1b5e:	b3 1f       	adc	r27, r19
    1b60:	b7 83       	std	Z+7, r27	; 0x07
    1b62:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1b64:	84 81       	ldd	r24, Z+4	; 0x04
    1b66:	95 81       	ldd	r25, Z+5	; 0x05
    1b68:	a8 17       	cp	r26, r24
    1b6a:	b9 07       	cpc	r27, r25
    1b6c:	20 f0       	brcs	.+8      	; 0x1b76 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1b6e:	80 81       	ld	r24, Z
    1b70:	91 81       	ldd	r25, Z+1	; 0x01
    1b72:	97 83       	std	Z+7, r25	; 0x07
    1b74:	86 83       	std	Z+6, r24	; 0x06
    1b76:	8a 01       	movw	r16, r20
    1b78:	cb 01       	movw	r24, r22
    1b7a:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1b7c:	42 8d       	ldd	r20, Z+26	; 0x1a
    1b7e:	41 50       	subi	r20, 0x01	; 1
    1b80:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1b82:	66 81       	ldd	r22, Z+6	; 0x06
    1b84:	77 81       	ldd	r23, Z+7	; 0x07
    1b86:	a9 01       	movw	r20, r18
    1b88:	0e 94 22 12 	call	0x2444	; 0x2444 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1b8c:	f8 01       	movw	r30, r16
    1b8e:	80 81       	ld	r24, Z
    1b90:	88 23       	and	r24, r24
    1b92:	11 f0       	breq	.+4      	; 0x1b98 <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1b94:	81 e0       	ldi	r24, 0x01	; 1
    1b96:	0e c0       	rjmp	.+28     	; 0x1bb4 <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b98:	88 85       	ldd	r24, Y+8	; 0x08
    1b9a:	88 23       	and	r24, r24
    1b9c:	d9 f3       	breq	.-10     	; 0x1b94 <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b9e:	ce 01       	movw	r24, r28
    1ba0:	08 96       	adiw	r24, 0x08	; 8
    1ba2:	0e 94 0f 10 	call	0x201e	; 0x201e <xCoRoutineRemoveFromEventList>
    1ba6:	88 23       	and	r24, r24
    1ba8:	a9 f3       	breq	.-22     	; 0x1b94 <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1baa:	81 e0       	ldi	r24, 0x01	; 1
    1bac:	f8 01       	movw	r30, r16
    1bae:	80 83       	st	Z, r24
    1bb0:	01 c0       	rjmp	.+2      	; 0x1bb4 <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1bb2:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1bb4:	df 91       	pop	r29
    1bb6:	cf 91       	pop	r28
    1bb8:	1f 91       	pop	r17
    1bba:	0f 91       	pop	r16
    1bbc:	08 95       	ret

00001bbe <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1bbe:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bc0:	03 96       	adiw	r24, 0x03	; 3
    1bc2:	92 83       	std	Z+2, r25	; 0x02
    1bc4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1bc6:	2f ef       	ldi	r18, 0xFF	; 255
    1bc8:	3f ef       	ldi	r19, 0xFF	; 255
    1bca:	34 83       	std	Z+4, r19	; 0x04
    1bcc:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bce:	96 83       	std	Z+6, r25	; 0x06
    1bd0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bd2:	90 87       	std	Z+8, r25	; 0x08
    1bd4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1bd6:	10 82       	st	Z, r1
    1bd8:	08 95       	ret

00001bda <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1bda:	fc 01       	movw	r30, r24
    1bdc:	11 86       	std	Z+9, r1	; 0x09
    1bde:	10 86       	std	Z+8, r1	; 0x08
    1be0:	08 95       	ret

00001be2 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1be2:	cf 93       	push	r28
    1be4:	df 93       	push	r29
    1be6:	9c 01       	movw	r18, r24
    1be8:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1bea:	dc 01       	movw	r26, r24
    1bec:	11 96       	adiw	r26, 0x01	; 1
    1bee:	cd 91       	ld	r28, X+
    1bf0:	dc 91       	ld	r29, X
    1bf2:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1bf4:	d3 83       	std	Z+3, r29	; 0x03
    1bf6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1bf8:	8c 81       	ldd	r24, Y+4	; 0x04
    1bfa:	9d 81       	ldd	r25, Y+5	; 0x05
    1bfc:	95 83       	std	Z+5, r25	; 0x05
    1bfe:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c00:	8c 81       	ldd	r24, Y+4	; 0x04
    1c02:	9d 81       	ldd	r25, Y+5	; 0x05
    1c04:	dc 01       	movw	r26, r24
    1c06:	13 96       	adiw	r26, 0x03	; 3
    1c08:	7c 93       	st	X, r23
    1c0a:	6e 93       	st	-X, r22
    1c0c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1c0e:	7d 83       	std	Y+5, r23	; 0x05
    1c10:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1c12:	31 87       	std	Z+9, r19	; 0x09
    1c14:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1c16:	f9 01       	movw	r30, r18
    1c18:	80 81       	ld	r24, Z
    1c1a:	8f 5f       	subi	r24, 0xFF	; 255
    1c1c:	80 83       	st	Z, r24
}
    1c1e:	df 91       	pop	r29
    1c20:	cf 91       	pop	r28
    1c22:	08 95       	ret

00001c24 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c24:	0f 93       	push	r16
    1c26:	1f 93       	push	r17
    1c28:	cf 93       	push	r28
    1c2a:	df 93       	push	r29
    1c2c:	8c 01       	movw	r16, r24
    1c2e:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c30:	80 81       	ld	r24, Z
    1c32:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c34:	8f 3f       	cpi	r24, 0xFF	; 255
    1c36:	2f ef       	ldi	r18, 0xFF	; 255
    1c38:	92 07       	cpc	r25, r18
    1c3a:	21 f4       	brne	.+8      	; 0x1c44 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c3c:	e8 01       	movw	r28, r16
    1c3e:	af 81       	ldd	r26, Y+7	; 0x07
    1c40:	b8 85       	ldd	r27, Y+8	; 0x08
    1c42:	0e c0       	rjmp	.+28     	; 0x1c60 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1c44:	d8 01       	movw	r26, r16
    1c46:	13 96       	adiw	r26, 0x03	; 3
    1c48:	12 96       	adiw	r26, 0x02	; 2
    1c4a:	2d 91       	ld	r18, X+
    1c4c:	3c 91       	ld	r19, X
    1c4e:	13 97       	sbiw	r26, 0x03	; 3
    1c50:	e9 01       	movw	r28, r18
    1c52:	48 81       	ld	r20, Y
    1c54:	59 81       	ldd	r21, Y+1	; 0x01
    1c56:	84 17       	cp	r24, r20
    1c58:	95 07       	cpc	r25, r21
    1c5a:	10 f0       	brcs	.+4      	; 0x1c60 <vListInsert+0x3c>
    1c5c:	d9 01       	movw	r26, r18
    1c5e:	f4 cf       	rjmp	.-24     	; 0x1c48 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c60:	12 96       	adiw	r26, 0x02	; 2
    1c62:	8d 91       	ld	r24, X+
    1c64:	9c 91       	ld	r25, X
    1c66:	13 97       	sbiw	r26, 0x03	; 3
    1c68:	93 83       	std	Z+3, r25	; 0x03
    1c6a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c6c:	ec 01       	movw	r28, r24
    1c6e:	fd 83       	std	Y+5, r31	; 0x05
    1c70:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c72:	b5 83       	std	Z+5, r27	; 0x05
    1c74:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1c76:	13 96       	adiw	r26, 0x03	; 3
    1c78:	fc 93       	st	X, r31
    1c7a:	ee 93       	st	-X, r30
    1c7c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1c7e:	11 87       	std	Z+9, r17	; 0x09
    1c80:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1c82:	f8 01       	movw	r30, r16
    1c84:	80 81       	ld	r24, Z
    1c86:	8f 5f       	subi	r24, 0xFF	; 255
    1c88:	80 83       	st	Z, r24
}
    1c8a:	df 91       	pop	r29
    1c8c:	cf 91       	pop	r28
    1c8e:	1f 91       	pop	r17
    1c90:	0f 91       	pop	r16
    1c92:	08 95       	ret

00001c94 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1c94:	cf 93       	push	r28
    1c96:	df 93       	push	r29
    1c98:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1c9a:	a0 85       	ldd	r26, Z+8	; 0x08
    1c9c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c9e:	82 81       	ldd	r24, Z+2	; 0x02
    1ca0:	93 81       	ldd	r25, Z+3	; 0x03
    1ca2:	24 81       	ldd	r18, Z+4	; 0x04
    1ca4:	35 81       	ldd	r19, Z+5	; 0x05
    1ca6:	ec 01       	movw	r28, r24
    1ca8:	3d 83       	std	Y+5, r19	; 0x05
    1caa:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1cac:	c4 81       	ldd	r28, Z+4	; 0x04
    1cae:	d5 81       	ldd	r29, Z+5	; 0x05
    1cb0:	9b 83       	std	Y+3, r25	; 0x03
    1cb2:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1cb4:	11 96       	adiw	r26, 0x01	; 1
    1cb6:	8d 91       	ld	r24, X+
    1cb8:	9c 91       	ld	r25, X
    1cba:	12 97       	sbiw	r26, 0x02	; 2
    1cbc:	e8 17       	cp	r30, r24
    1cbe:	f9 07       	cpc	r31, r25
    1cc0:	21 f4       	brne	.+8      	; 0x1cca <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1cc2:	12 96       	adiw	r26, 0x02	; 2
    1cc4:	dc 93       	st	X, r29
    1cc6:	ce 93       	st	-X, r28
    1cc8:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1cca:	11 86       	std	Z+9, r1	; 0x09
    1ccc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1cce:	8c 91       	ld	r24, X
    1cd0:	81 50       	subi	r24, 0x01	; 1
    1cd2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1cd4:	8c 91       	ld	r24, X
}
    1cd6:	df 91       	pop	r29
    1cd8:	cf 91       	pop	r28
    1cda:	08 95       	ret

00001cdc <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1cdc:	cf 92       	push	r12
    1cde:	df 92       	push	r13
    1ce0:	ef 92       	push	r14
    1ce2:	ff 92       	push	r15
    1ce4:	1f 93       	push	r17
    1ce6:	cf 93       	push	r28
    1ce8:	df 93       	push	r29
    1cea:	6c 01       	movw	r12, r24
    1cec:	16 2f       	mov	r17, r22
    1cee:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1cf0:	8a e1       	ldi	r24, 0x1A	; 26
    1cf2:	90 e0       	ldi	r25, 0x00	; 0
    1cf4:	0e 94 34 10 	call	0x2068	; 0x2068 <pvPortMalloc>
    1cf8:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1cfa:	89 2b       	or	r24, r25
    1cfc:	09 f4       	brne	.+2      	; 0x1d00 <xCoRoutineCreate+0x24>
    1cfe:	57 c0       	rjmp	.+174    	; 0x1dae <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1d00:	80 91 c4 01 	lds	r24, 0x01C4	; 0x8001c4 <pxCurrentCoRoutine>
    1d04:	90 91 c5 01 	lds	r25, 0x01C5	; 0x8001c5 <pxCurrentCoRoutine+0x1>
    1d08:	89 2b       	or	r24, r25
    1d0a:	21 f5       	brne	.+72     	; 0x1d54 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1d0c:	d0 93 c5 01 	sts	0x01C5, r29	; 0x8001c5 <pxCurrentCoRoutine+0x1>
    1d10:	c0 93 c4 01 	sts	0x01C4, r28	; 0x8001c4 <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1d14:	8c ee       	ldi	r24, 0xEC	; 236
    1d16:	91 e0       	ldi	r25, 0x01	; 1
    1d18:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
    1d1c:	85 ef       	ldi	r24, 0xF5	; 245
    1d1e:	91 e0       	ldi	r25, 0x01	; 1
    1d20:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1d24:	83 ee       	ldi	r24, 0xE3	; 227
    1d26:	91 e0       	ldi	r25, 0x01	; 1
    1d28:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1d2c:	8a ed       	ldi	r24, 0xDA	; 218
    1d2e:	91 e0       	ldi	r25, 0x01	; 1
    1d30:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1d34:	8d ec       	ldi	r24, 0xCD	; 205
    1d36:	91 e0       	ldi	r25, 0x01	; 1
    1d38:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1d3c:	83 ee       	ldi	r24, 0xE3	; 227
    1d3e:	91 e0       	ldi	r25, 0x01	; 1
    1d40:	90 93 d9 01 	sts	0x01D9, r25	; 0x8001d9 <pxDelayedCoRoutineList+0x1>
    1d44:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1d48:	8a ed       	ldi	r24, 0xDA	; 218
    1d4a:	91 e0       	ldi	r25, 0x01	; 1
    1d4c:	90 93 d7 01 	sts	0x01D7, r25	; 0x8001d7 <pxOverflowDelayedCoRoutineList+0x1>
    1d50:	80 93 d6 01 	sts	0x01D6, r24	; 0x8001d6 <pxOverflowDelayedCoRoutineList>
    1d54:	11 11       	cpse	r17, r1
    1d56:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1d58:	19 8e       	std	Y+25, r1	; 0x19
    1d5a:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1d5c:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1d5e:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1d60:	fe 01       	movw	r30, r28
    1d62:	c1 92       	st	Z+, r12
    1d64:	d1 92       	st	Z+, r13
    1d66:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1d68:	cf 01       	movw	r24, r30
    1d6a:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1d6e:	ce 01       	movw	r24, r28
    1d70:	0c 96       	adiw	r24, 0x0c	; 12
    1d72:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1d76:	d9 87       	std	Y+9, r29	; 0x09
    1d78:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1d7a:	db 8b       	std	Y+19, r29	; 0x13
    1d7c:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    1d7e:	82 e0       	ldi	r24, 0x02	; 2
    1d80:	90 e0       	ldi	r25, 0x00	; 0
    1d82:	81 1b       	sub	r24, r17
    1d84:	91 09       	sbc	r25, r1
    1d86:	9d 87       	std	Y+13, r25	; 0x0d
    1d88:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1d8a:	8e 89       	ldd	r24, Y+22	; 0x16
    1d8c:	90 91 cc 01 	lds	r25, 0x01CC	; 0x8001cc <uxTopCoRoutineReadyPriority>
    1d90:	98 17       	cp	r25, r24
    1d92:	10 f4       	brcc	.+4      	; 0x1d98 <xCoRoutineCreate+0xbc>
    1d94:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <uxTopCoRoutineReadyPriority>
    1d98:	f9 e0       	ldi	r31, 0x09	; 9
    1d9a:	8f 9f       	mul	r24, r31
    1d9c:	c0 01       	movw	r24, r0
    1d9e:	11 24       	eor	r1, r1
    1da0:	b7 01       	movw	r22, r14
    1da2:	84 51       	subi	r24, 0x14	; 20
    1da4:	9e 4f       	sbci	r25, 0xFE	; 254
    1da6:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>

		xReturn = pdPASS;
    1daa:	81 e0       	ldi	r24, 0x01	; 1
    1dac:	01 c0       	rjmp	.+2      	; 0x1db0 <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1dae:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    1db0:	df 91       	pop	r29
    1db2:	cf 91       	pop	r28
    1db4:	1f 91       	pop	r17
    1db6:	ff 90       	pop	r15
    1db8:	ef 90       	pop	r14
    1dba:	df 90       	pop	r13
    1dbc:	cf 90       	pop	r12
    1dbe:	08 95       	ret

00001dc0 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    1dc0:	0f 93       	push	r16
    1dc2:	1f 93       	push	r17
    1dc4:	cf 93       	push	r28
    1dc6:	df 93       	push	r29
    1dc8:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1dca:	c0 91 ca 01 	lds	r28, 0x01CA	; 0x8001ca <xCoRoutineTickCount>
    1dce:	d0 91 cb 01 	lds	r29, 0x01CB	; 0x8001cb <xCoRoutineTickCount+0x1>
    1dd2:	c8 0f       	add	r28, r24
    1dd4:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1dd6:	80 91 c4 01 	lds	r24, 0x01C4	; 0x8001c4 <pxCurrentCoRoutine>
    1dda:	90 91 c5 01 	lds	r25, 0x01C5	; 0x8001c5 <pxCurrentCoRoutine+0x1>
    1dde:	02 96       	adiw	r24, 0x02	; 2
    1de0:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1de4:	e0 91 c4 01 	lds	r30, 0x01C4	; 0x8001c4 <pxCurrentCoRoutine>
    1de8:	f0 91 c5 01 	lds	r31, 0x01C5	; 0x8001c5 <pxCurrentCoRoutine+0x1>
    1dec:	d3 83       	std	Z+3, r29	; 0x03
    1dee:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1df0:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <xCoRoutineTickCount>
    1df4:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <xCoRoutineTickCount+0x1>
    1df8:	bf 01       	movw	r22, r30
    1dfa:	6e 5f       	subi	r22, 0xFE	; 254
    1dfc:	7f 4f       	sbci	r23, 0xFF	; 255
    1dfe:	c8 17       	cp	r28, r24
    1e00:	d9 07       	cpc	r29, r25
    1e02:	28 f4       	brcc	.+10     	; 0x1e0e <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1e04:	80 91 d6 01 	lds	r24, 0x01D6	; 0x8001d6 <pxOverflowDelayedCoRoutineList>
    1e08:	90 91 d7 01 	lds	r25, 0x01D7	; 0x8001d7 <pxOverflowDelayedCoRoutineList+0x1>
    1e0c:	04 c0       	rjmp	.+8      	; 0x1e16 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1e0e:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <pxDelayedCoRoutineList>
    1e12:	90 91 d9 01 	lds	r25, 0x01D9	; 0x8001d9 <pxDelayedCoRoutineList+0x1>
    1e16:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <vListInsert>
	}

	if( pxEventList )
    1e1a:	01 15       	cp	r16, r1
    1e1c:	11 05       	cpc	r17, r1
    1e1e:	69 f0       	breq	.+26     	; 0x1e3a <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1e20:	60 91 c4 01 	lds	r22, 0x01C4	; 0x8001c4 <pxCurrentCoRoutine>
    1e24:	70 91 c5 01 	lds	r23, 0x01C5	; 0x8001c5 <pxCurrentCoRoutine+0x1>
    1e28:	64 5f       	subi	r22, 0xF4	; 244
    1e2a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e2c:	c8 01       	movw	r24, r16
	}
}
    1e2e:	df 91       	pop	r29
    1e30:	cf 91       	pop	r28
    1e32:	1f 91       	pop	r17
    1e34:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1e36:	0c 94 12 0e 	jmp	0x1c24	; 0x1c24 <vListInsert>
	}
}
    1e3a:	df 91       	pop	r29
    1e3c:	cf 91       	pop	r28
    1e3e:	1f 91       	pop	r17
    1e40:	0f 91       	pop	r16
    1e42:	08 95       	ret

00001e44 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1e44:	ff 92       	push	r15
    1e46:	0f 93       	push	r16
    1e48:	1f 93       	push	r17
    1e4a:	cf 93       	push	r28
    1e4c:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1e4e:	99 e0       	ldi	r25, 0x09	; 9
    1e50:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1e52:	80 91 cd 01 	lds	r24, 0x01CD	; 0x8001cd <xPendingReadyCoRoutineList>
    1e56:	88 23       	and	r24, r24
    1e58:	11 f1       	breq	.+68     	; 0x1e9e <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1e5a:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1e5c:	e0 91 d2 01 	lds	r30, 0x01D2	; 0x8001d2 <xPendingReadyCoRoutineList+0x5>
    1e60:	f0 91 d3 01 	lds	r31, 0x01D3	; 0x8001d3 <xPendingReadyCoRoutineList+0x6>
    1e64:	c6 81       	ldd	r28, Z+6	; 0x06
    1e66:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1e68:	ce 01       	movw	r24, r28
    1e6a:	0c 96       	adiw	r24, 0x0c	; 12
    1e6c:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1e70:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1e72:	8e 01       	movw	r16, r28
    1e74:	0e 5f       	subi	r16, 0xFE	; 254
    1e76:	1f 4f       	sbci	r17, 0xFF	; 255
    1e78:	c8 01       	movw	r24, r16
    1e7a:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1e7e:	8e 89       	ldd	r24, Y+22	; 0x16
    1e80:	90 91 cc 01 	lds	r25, 0x01CC	; 0x8001cc <uxTopCoRoutineReadyPriority>
    1e84:	98 17       	cp	r25, r24
    1e86:	10 f4       	brcc	.+4      	; 0x1e8c <vCoRoutineSchedule+0x48>
    1e88:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <uxTopCoRoutineReadyPriority>
    1e8c:	f8 9e       	mul	r15, r24
    1e8e:	c0 01       	movw	r24, r0
    1e90:	11 24       	eor	r1, r1
    1e92:	b8 01       	movw	r22, r16
    1e94:	84 51       	subi	r24, 0x14	; 20
    1e96:	9e 4f       	sbci	r25, 0xFE	; 254
    1e98:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>
    1e9c:	da cf       	rjmp	.-76     	; 0x1e52 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1e9e:	0e 94 b2 03 	call	0x764	; 0x764 <xTaskGetTickCount>
    1ea2:	20 91 c8 01 	lds	r18, 0x01C8	; 0x8001c8 <xLastTickCount>
    1ea6:	30 91 c9 01 	lds	r19, 0x01C9	; 0x8001c9 <xLastTickCount+0x1>
    1eaa:	82 1b       	sub	r24, r18
    1eac:	93 0b       	sbc	r25, r19
    1eae:	90 93 c7 01 	sts	0x01C7, r25	; 0x8001c7 <xPassedTicks+0x1>
    1eb2:	80 93 c6 01 	sts	0x01C6, r24	; 0x8001c6 <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1eb6:	89 e0       	ldi	r24, 0x09	; 9
    1eb8:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1eba:	20 91 c6 01 	lds	r18, 0x01C6	; 0x8001c6 <xPassedTicks>
    1ebe:	30 91 c7 01 	lds	r19, 0x01C7	; 0x8001c7 <xPassedTicks+0x1>
    1ec2:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <xCoRoutineTickCount>
    1ec6:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <xCoRoutineTickCount+0x1>
    1eca:	21 15       	cp	r18, r1
    1ecc:	31 05       	cpc	r19, r1
    1ece:	09 f4       	brne	.+2      	; 0x1ed2 <vCoRoutineSchedule+0x8e>
    1ed0:	54 c0       	rjmp	.+168    	; 0x1f7a <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    1ed2:	01 96       	adiw	r24, 0x01	; 1
    1ed4:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <xCoRoutineTickCount+0x1>
    1ed8:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <xCoRoutineTickCount>
		xPassedTicks--;
    1edc:	21 50       	subi	r18, 0x01	; 1
    1ede:	31 09       	sbc	r19, r1
    1ee0:	30 93 c7 01 	sts	0x01C7, r19	; 0x8001c7 <xPassedTicks+0x1>
    1ee4:	20 93 c6 01 	sts	0x01C6, r18	; 0x8001c6 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1ee8:	89 2b       	or	r24, r25
    1eea:	09 f0       	breq	.+2      	; 0x1eee <vCoRoutineSchedule+0xaa>
    1eec:	3e c0       	rjmp	.+124    	; 0x1f6a <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1eee:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <pxDelayedCoRoutineList>
    1ef2:	90 91 d9 01 	lds	r25, 0x01D9	; 0x8001d9 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1ef6:	20 91 d6 01 	lds	r18, 0x01D6	; 0x8001d6 <pxOverflowDelayedCoRoutineList>
    1efa:	30 91 d7 01 	lds	r19, 0x01D7	; 0x8001d7 <pxOverflowDelayedCoRoutineList+0x1>
    1efe:	30 93 d9 01 	sts	0x01D9, r19	; 0x8001d9 <pxDelayedCoRoutineList+0x1>
    1f02:	20 93 d8 01 	sts	0x01D8, r18	; 0x8001d8 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    1f06:	90 93 d7 01 	sts	0x01D7, r25	; 0x8001d7 <pxOverflowDelayedCoRoutineList+0x1>
    1f0a:	80 93 d6 01 	sts	0x01D6, r24	; 0x8001d6 <pxOverflowDelayedCoRoutineList>
    1f0e:	2d c0       	rjmp	.+90     	; 0x1f6a <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1f10:	05 80       	ldd	r0, Z+5	; 0x05
    1f12:	f6 81       	ldd	r31, Z+6	; 0x06
    1f14:	e0 2d       	mov	r30, r0
    1f16:	c6 81       	ldd	r28, Z+6	; 0x06
    1f18:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1f1a:	2a 81       	ldd	r18, Y+2	; 0x02
    1f1c:	3b 81       	ldd	r19, Y+3	; 0x03
    1f1e:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <xCoRoutineTickCount>
    1f22:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <xCoRoutineTickCount+0x1>
    1f26:	82 17       	cp	r24, r18
    1f28:	93 07       	cpc	r25, r19
    1f2a:	38 f2       	brcs	.-114    	; 0x1eba <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1f2c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1f2e:	8e 01       	movw	r16, r28
    1f30:	0e 5f       	subi	r16, 0xFE	; 254
    1f32:	1f 4f       	sbci	r17, 0xFF	; 255
    1f34:	c8 01       	movw	r24, r16
    1f36:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    1f3a:	8c 89       	ldd	r24, Y+20	; 0x14
    1f3c:	9d 89       	ldd	r25, Y+21	; 0x15
    1f3e:	89 2b       	or	r24, r25
    1f40:	21 f0       	breq	.+8      	; 0x1f4a <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    1f42:	ce 01       	movw	r24, r28
    1f44:	0c 96       	adiw	r24, 0x0c	; 12
    1f46:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1f4a:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1f4c:	8e 89       	ldd	r24, Y+22	; 0x16
    1f4e:	90 91 cc 01 	lds	r25, 0x01CC	; 0x8001cc <uxTopCoRoutineReadyPriority>
    1f52:	98 17       	cp	r25, r24
    1f54:	10 f4       	brcc	.+4      	; 0x1f5a <vCoRoutineSchedule+0x116>
    1f56:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <uxTopCoRoutineReadyPriority>
    1f5a:	f8 9e       	mul	r15, r24
    1f5c:	c0 01       	movw	r24, r0
    1f5e:	11 24       	eor	r1, r1
    1f60:	b8 01       	movw	r22, r16
    1f62:	84 51       	subi	r24, 0x14	; 20
    1f64:	9e 4f       	sbci	r25, 0xFE	; 254
    1f66:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1f6a:	e0 91 d8 01 	lds	r30, 0x01D8	; 0x8001d8 <pxDelayedCoRoutineList>
    1f6e:	f0 91 d9 01 	lds	r31, 0x01D9	; 0x8001d9 <pxDelayedCoRoutineList+0x1>
    1f72:	80 81       	ld	r24, Z
    1f74:	81 11       	cpse	r24, r1
    1f76:	cc cf       	rjmp	.-104    	; 0x1f10 <vCoRoutineSchedule+0xcc>
    1f78:	a0 cf       	rjmp	.-192    	; 0x1eba <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    1f7a:	90 93 c9 01 	sts	0x01C9, r25	; 0x8001c9 <xLastTickCount+0x1>
    1f7e:	80 93 c8 01 	sts	0x01C8, r24	; 0x8001c8 <xLastTickCount>
    1f82:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1f86:	69 e0       	ldi	r22, 0x09	; 9
    1f88:	48 2f       	mov	r20, r24
    1f8a:	50 e0       	ldi	r21, 0x00	; 0
    1f8c:	64 9f       	mul	r22, r20
    1f8e:	90 01       	movw	r18, r0
    1f90:	65 9f       	mul	r22, r21
    1f92:	30 0d       	add	r19, r0
    1f94:	11 24       	eor	r1, r1
    1f96:	f9 01       	movw	r30, r18
    1f98:	e4 51       	subi	r30, 0x14	; 20
    1f9a:	fe 4f       	sbci	r31, 0xFE	; 254
    1f9c:	90 81       	ld	r25, Z
    1f9e:	91 11       	cpse	r25, r1
    1fa0:	0c c0       	rjmp	.+24     	; 0x1fba <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1fa2:	81 11       	cpse	r24, r1
    1fa4:	08 c0       	rjmp	.+16     	; 0x1fb6 <vCoRoutineSchedule+0x172>
    1fa6:	10 92 cc 01 	sts	0x01CC, r1	; 0x8001cc <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    1faa:	df 91       	pop	r29
    1fac:	cf 91       	pop	r28
    1fae:	1f 91       	pop	r17
    1fb0:	0f 91       	pop	r16
    1fb2:	ff 90       	pop	r15
    1fb4:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1fb6:	81 50       	subi	r24, 0x01	; 1
    1fb8:	e7 cf       	rjmp	.-50     	; 0x1f88 <vCoRoutineSchedule+0x144>
    1fba:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1fbe:	a1 81       	ldd	r26, Z+1	; 0x01
    1fc0:	b2 81       	ldd	r27, Z+2	; 0x02
    1fc2:	12 96       	adiw	r26, 0x02	; 2
    1fc4:	0d 90       	ld	r0, X+
    1fc6:	bc 91       	ld	r27, X
    1fc8:	a0 2d       	mov	r26, r0
    1fca:	b2 83       	std	Z+2, r27	; 0x02
    1fcc:	a1 83       	std	Z+1, r26	; 0x01
    1fce:	21 51       	subi	r18, 0x11	; 17
    1fd0:	3e 4f       	sbci	r19, 0xFE	; 254
    1fd2:	a2 17       	cp	r26, r18
    1fd4:	b3 07       	cpc	r27, r19
    1fd6:	31 f4       	brne	.+12     	; 0x1fe4 <vCoRoutineSchedule+0x1a0>
    1fd8:	12 96       	adiw	r26, 0x02	; 2
    1fda:	8d 91       	ld	r24, X+
    1fdc:	9c 91       	ld	r25, X
    1fde:	13 97       	sbiw	r26, 0x03	; 3
    1fe0:	92 83       	std	Z+2, r25	; 0x02
    1fe2:	81 83       	std	Z+1, r24	; 0x01
    1fe4:	89 e0       	ldi	r24, 0x09	; 9
    1fe6:	84 9f       	mul	r24, r20
    1fe8:	f0 01       	movw	r30, r0
    1fea:	85 9f       	mul	r24, r21
    1fec:	f0 0d       	add	r31, r0
    1fee:	11 24       	eor	r1, r1
    1ff0:	e4 51       	subi	r30, 0x14	; 20
    1ff2:	fe 4f       	sbci	r31, 0xFE	; 254
    1ff4:	01 80       	ldd	r0, Z+1	; 0x01
    1ff6:	f2 81       	ldd	r31, Z+2	; 0x02
    1ff8:	e0 2d       	mov	r30, r0
    1ffa:	86 81       	ldd	r24, Z+6	; 0x06
    1ffc:	97 81       	ldd	r25, Z+7	; 0x07
    1ffe:	90 93 c5 01 	sts	0x01C5, r25	; 0x8001c5 <pxCurrentCoRoutine+0x1>
    2002:	80 93 c4 01 	sts	0x01C4, r24	; 0x8001c4 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2006:	dc 01       	movw	r26, r24
    2008:	ed 91       	ld	r30, X+
    200a:	fc 91       	ld	r31, X
    200c:	11 97       	sbiw	r26, 0x01	; 1
    200e:	57 96       	adiw	r26, 0x17	; 23
    2010:	6c 91       	ld	r22, X

	return;
}
    2012:	df 91       	pop	r29
    2014:	cf 91       	pop	r28
    2016:	1f 91       	pop	r17
    2018:	0f 91       	pop	r16
    201a:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    201c:	09 94       	ijmp

0000201e <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    201e:	0f 93       	push	r16
    2020:	1f 93       	push	r17
    2022:	cf 93       	push	r28
    2024:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2026:	dc 01       	movw	r26, r24
    2028:	15 96       	adiw	r26, 0x05	; 5
    202a:	ed 91       	ld	r30, X+
    202c:	fc 91       	ld	r31, X
    202e:	16 97       	sbiw	r26, 0x06	; 6
    2030:	c6 81       	ldd	r28, Z+6	; 0x06
    2032:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2034:	8e 01       	movw	r16, r28
    2036:	04 5f       	subi	r16, 0xF4	; 244
    2038:	1f 4f       	sbci	r17, 0xFF	; 255
    203a:	c8 01       	movw	r24, r16
    203c:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2040:	b8 01       	movw	r22, r16
    2042:	8d ec       	ldi	r24, 0xCD	; 205
    2044:	91 e0       	ldi	r25, 0x01	; 1
    2046:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    204a:	e0 91 c4 01 	lds	r30, 0x01C4	; 0x8001c4 <pxCurrentCoRoutine>
    204e:	f0 91 c5 01 	lds	r31, 0x01C5	; 0x8001c5 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2052:	81 e0       	ldi	r24, 0x01	; 1
    2054:	2e 89       	ldd	r18, Y+22	; 0x16
    2056:	96 89       	ldd	r25, Z+22	; 0x16
    2058:	29 17       	cp	r18, r25
    205a:	08 f4       	brcc	.+2      	; 0x205e <xCoRoutineRemoveFromEventList+0x40>
    205c:	80 e0       	ldi	r24, 0x00	; 0
}
    205e:	df 91       	pop	r29
    2060:	cf 91       	pop	r28
    2062:	1f 91       	pop	r17
    2064:	0f 91       	pop	r16
    2066:	08 95       	ret

00002068 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2068:	cf 93       	push	r28
    206a:	df 93       	push	r29
    206c:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    206e:	0e 94 ac 03 	call	0x758	; 0x758 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2072:	80 91 fe 01 	lds	r24, 0x01FE	; 0x8001fe <pucAlignedHeap.2081>
    2076:	90 91 ff 01 	lds	r25, 0x01FF	; 0x8001ff <pucAlignedHeap.2081+0x1>
    207a:	89 2b       	or	r24, r25
    207c:	31 f4       	brne	.+12     	; 0x208a <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    207e:	83 e0       	ldi	r24, 0x03	; 3
    2080:	92 e0       	ldi	r25, 0x02	; 2
    2082:	90 93 ff 01 	sts	0x01FF, r25	; 0x8001ff <pucAlignedHeap.2081+0x1>
    2086:	80 93 fe 01 	sts	0x01FE, r24	; 0x8001fe <pucAlignedHeap.2081>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    208a:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <xNextFreeByte>
    208e:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <xNextFreeByte+0x1>
    2092:	c9 01       	movw	r24, r18
    2094:	8c 0f       	add	r24, r28
    2096:	9d 1f       	adc	r25, r29
    2098:	8b 3d       	cpi	r24, 0xDB	; 219
    209a:	45 e0       	ldi	r20, 0x05	; 5
    209c:	94 07       	cpc	r25, r20
    209e:	70 f4       	brcc	.+28     	; 0x20bc <pvPortMalloc+0x54>
    20a0:	28 17       	cp	r18, r24
    20a2:	39 07       	cpc	r19, r25
    20a4:	58 f4       	brcc	.+22     	; 0x20bc <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    20a6:	c0 91 fe 01 	lds	r28, 0x01FE	; 0x8001fe <pucAlignedHeap.2081>
    20aa:	d0 91 ff 01 	lds	r29, 0x01FF	; 0x8001ff <pucAlignedHeap.2081+0x1>
    20ae:	c2 0f       	add	r28, r18
    20b0:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    20b2:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <xNextFreeByte+0x1>
    20b6:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <xNextFreeByte>
    20ba:	02 c0       	rjmp	.+4      	; 0x20c0 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    20bc:	c0 e0       	ldi	r28, 0x00	; 0
    20be:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    20c0:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    20c4:	ce 01       	movw	r24, r28
    20c6:	df 91       	pop	r29
    20c8:	cf 91       	pop	r28
    20ca:	08 95       	ret

000020cc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    20cc:	08 95       	ret

000020ce <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    20ce:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <xNextFreeByte+0x1>
    20d2:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <xNextFreeByte>
    20d6:	08 95       	ret

000020d8 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    20d8:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <xNextFreeByte>
    20dc:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <xNextFreeByte+0x1>
}
    20e0:	8b ed       	ldi	r24, 0xDB	; 219
    20e2:	95 e0       	ldi	r25, 0x05	; 5
    20e4:	82 1b       	sub	r24, r18
    20e6:	93 0b       	sbc	r25, r19
    20e8:	08 95       	ret

000020ea <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    20ea:	31 e1       	ldi	r19, 0x11	; 17
    20ec:	fc 01       	movw	r30, r24
    20ee:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    20f0:	31 97       	sbiw	r30, 0x01	; 1
    20f2:	22 e2       	ldi	r18, 0x22	; 34
    20f4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    20f6:	31 97       	sbiw	r30, 0x01	; 1
    20f8:	a3 e3       	ldi	r26, 0x33	; 51
    20fa:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    20fc:	31 97       	sbiw	r30, 0x01	; 1
    20fe:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2100:	31 97       	sbiw	r30, 0x01	; 1
    2102:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2104:	31 97       	sbiw	r30, 0x01	; 1
    2106:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2108:	31 97       	sbiw	r30, 0x01	; 1
    210a:	60 e8       	ldi	r22, 0x80	; 128
    210c:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    210e:	31 97       	sbiw	r30, 0x01	; 1
    2110:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    2112:	31 97       	sbiw	r30, 0x01	; 1
    2114:	62 e0       	ldi	r22, 0x02	; 2
    2116:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2118:	31 97       	sbiw	r30, 0x01	; 1
    211a:	63 e0       	ldi	r22, 0x03	; 3
    211c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    211e:	31 97       	sbiw	r30, 0x01	; 1
    2120:	64 e0       	ldi	r22, 0x04	; 4
    2122:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2124:	31 97       	sbiw	r30, 0x01	; 1
    2126:	65 e0       	ldi	r22, 0x05	; 5
    2128:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    212a:	31 97       	sbiw	r30, 0x01	; 1
    212c:	66 e0       	ldi	r22, 0x06	; 6
    212e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2130:	31 97       	sbiw	r30, 0x01	; 1
    2132:	67 e0       	ldi	r22, 0x07	; 7
    2134:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2136:	31 97       	sbiw	r30, 0x01	; 1
    2138:	68 e0       	ldi	r22, 0x08	; 8
    213a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    213c:	31 97       	sbiw	r30, 0x01	; 1
    213e:	69 e0       	ldi	r22, 0x09	; 9
    2140:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2142:	31 97       	sbiw	r30, 0x01	; 1
    2144:	60 e1       	ldi	r22, 0x10	; 16
    2146:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2148:	31 97       	sbiw	r30, 0x01	; 1
    214a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    214c:	31 97       	sbiw	r30, 0x01	; 1
    214e:	32 e1       	ldi	r19, 0x12	; 18
    2150:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2152:	31 97       	sbiw	r30, 0x01	; 1
    2154:	33 e1       	ldi	r19, 0x13	; 19
    2156:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2158:	31 97       	sbiw	r30, 0x01	; 1
    215a:	34 e1       	ldi	r19, 0x14	; 20
    215c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    215e:	31 97       	sbiw	r30, 0x01	; 1
    2160:	35 e1       	ldi	r19, 0x15	; 21
    2162:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2164:	31 97       	sbiw	r30, 0x01	; 1
    2166:	36 e1       	ldi	r19, 0x16	; 22
    2168:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    216a:	31 97       	sbiw	r30, 0x01	; 1
    216c:	37 e1       	ldi	r19, 0x17	; 23
    216e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2170:	31 97       	sbiw	r30, 0x01	; 1
    2172:	38 e1       	ldi	r19, 0x18	; 24
    2174:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2176:	31 97       	sbiw	r30, 0x01	; 1
    2178:	39 e1       	ldi	r19, 0x19	; 25
    217a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    217c:	31 97       	sbiw	r30, 0x01	; 1
    217e:	30 e2       	ldi	r19, 0x20	; 32
    2180:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2182:	31 97       	sbiw	r30, 0x01	; 1
    2184:	31 e2       	ldi	r19, 0x21	; 33
    2186:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2188:	31 97       	sbiw	r30, 0x01	; 1
    218a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    218c:	31 97       	sbiw	r30, 0x01	; 1
    218e:	23 e2       	ldi	r18, 0x23	; 35
    2190:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2192:	31 97       	sbiw	r30, 0x01	; 1
    2194:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2196:	31 97       	sbiw	r30, 0x01	; 1
    2198:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    219a:	31 97       	sbiw	r30, 0x01	; 1
    219c:	26 e2       	ldi	r18, 0x26	; 38
    219e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    21a0:	31 97       	sbiw	r30, 0x01	; 1
    21a2:	27 e2       	ldi	r18, 0x27	; 39
    21a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    21a6:	31 97       	sbiw	r30, 0x01	; 1
    21a8:	28 e2       	ldi	r18, 0x28	; 40
    21aa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    21ac:	31 97       	sbiw	r30, 0x01	; 1
    21ae:	29 e2       	ldi	r18, 0x29	; 41
    21b0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    21b2:	31 97       	sbiw	r30, 0x01	; 1
    21b4:	20 e3       	ldi	r18, 0x30	; 48
    21b6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    21b8:	31 97       	sbiw	r30, 0x01	; 1
    21ba:	21 e3       	ldi	r18, 0x31	; 49
    21bc:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    21be:	86 97       	sbiw	r24, 0x26	; 38
    21c0:	08 95       	ret

000021c2 <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    21c2:	89 ef       	ldi	r24, 0xF9	; 249
    21c4:	90 e0       	ldi	r25, 0x00	; 0
    21c6:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
    21ca:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    21ce:	e0 e8       	ldi	r30, 0x80	; 128
    21d0:	f0 e0       	ldi	r31, 0x00	; 0
    21d2:	80 81       	ld	r24, Z
    21d4:	8c 7f       	andi	r24, 0xFC	; 252
    21d6:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    21d8:	8b e0       	ldi	r24, 0x0B	; 11
    21da:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    21de:	ef e6       	ldi	r30, 0x6F	; 111
    21e0:	f0 e0       	ldi	r31, 0x00	; 0
    21e2:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    21e4:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    21e6:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    21e8:	a0 91 5e 01 	lds	r26, 0x015E	; 0x80015e <__data_end>
    21ec:	b0 91 5f 01 	lds	r27, 0x015F	; 0x80015f <__data_end+0x1>
    21f0:	cd 91       	ld	r28, X+
    21f2:	cd bf       	out	0x3d, r28	; 61
    21f4:	dd 91       	ld	r29, X+
    21f6:	de bf       	out	0x3e, r29	; 62
    21f8:	ff 91       	pop	r31
    21fa:	ef 91       	pop	r30
    21fc:	df 91       	pop	r29
    21fe:	cf 91       	pop	r28
    2200:	bf 91       	pop	r27
    2202:	af 91       	pop	r26
    2204:	9f 91       	pop	r25
    2206:	8f 91       	pop	r24
    2208:	7f 91       	pop	r23
    220a:	6f 91       	pop	r22
    220c:	5f 91       	pop	r21
    220e:	4f 91       	pop	r20
    2210:	3f 91       	pop	r19
    2212:	2f 91       	pop	r18
    2214:	1f 91       	pop	r17
    2216:	0f 91       	pop	r16
    2218:	ff 90       	pop	r15
    221a:	ef 90       	pop	r14
    221c:	df 90       	pop	r13
    221e:	cf 90       	pop	r12
    2220:	bf 90       	pop	r11
    2222:	af 90       	pop	r10
    2224:	9f 90       	pop	r9
    2226:	8f 90       	pop	r8
    2228:	7f 90       	pop	r7
    222a:	6f 90       	pop	r6
    222c:	5f 90       	pop	r5
    222e:	4f 90       	pop	r4
    2230:	3f 90       	pop	r3
    2232:	2f 90       	pop	r2
    2234:	1f 90       	pop	r1
    2236:	0f 90       	pop	r0
    2238:	0f be       	out	0x3f, r0	; 63
    223a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    223c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    223e:	81 e0       	ldi	r24, 0x01	; 1
    2240:	08 95       	ret

00002242 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2242:	08 95       	ret

00002244 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2244:	0f 92       	push	r0
    2246:	0f b6       	in	r0, 0x3f	; 63
    2248:	f8 94       	cli
    224a:	0f 92       	push	r0
    224c:	1f 92       	push	r1
    224e:	11 24       	eor	r1, r1
    2250:	2f 92       	push	r2
    2252:	3f 92       	push	r3
    2254:	4f 92       	push	r4
    2256:	5f 92       	push	r5
    2258:	6f 92       	push	r6
    225a:	7f 92       	push	r7
    225c:	8f 92       	push	r8
    225e:	9f 92       	push	r9
    2260:	af 92       	push	r10
    2262:	bf 92       	push	r11
    2264:	cf 92       	push	r12
    2266:	df 92       	push	r13
    2268:	ef 92       	push	r14
    226a:	ff 92       	push	r15
    226c:	0f 93       	push	r16
    226e:	1f 93       	push	r17
    2270:	2f 93       	push	r18
    2272:	3f 93       	push	r19
    2274:	4f 93       	push	r20
    2276:	5f 93       	push	r21
    2278:	6f 93       	push	r22
    227a:	7f 93       	push	r23
    227c:	8f 93       	push	r24
    227e:	9f 93       	push	r25
    2280:	af 93       	push	r26
    2282:	bf 93       	push	r27
    2284:	cf 93       	push	r28
    2286:	df 93       	push	r29
    2288:	ef 93       	push	r30
    228a:	ff 93       	push	r31
    228c:	a0 91 5e 01 	lds	r26, 0x015E	; 0x80015e <__data_end>
    2290:	b0 91 5f 01 	lds	r27, 0x015F	; 0x80015f <__data_end+0x1>
    2294:	0d b6       	in	r0, 0x3d	; 61
    2296:	0d 92       	st	X+, r0
    2298:	0e b6       	in	r0, 0x3e	; 62
    229a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    229c:	0e 94 34 05 	call	0xa68	; 0xa68 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    22a0:	a0 91 5e 01 	lds	r26, 0x015E	; 0x80015e <__data_end>
    22a4:	b0 91 5f 01 	lds	r27, 0x015F	; 0x80015f <__data_end+0x1>
    22a8:	cd 91       	ld	r28, X+
    22aa:	cd bf       	out	0x3d, r28	; 61
    22ac:	dd 91       	ld	r29, X+
    22ae:	de bf       	out	0x3e, r29	; 62
    22b0:	ff 91       	pop	r31
    22b2:	ef 91       	pop	r30
    22b4:	df 91       	pop	r29
    22b6:	cf 91       	pop	r28
    22b8:	bf 91       	pop	r27
    22ba:	af 91       	pop	r26
    22bc:	9f 91       	pop	r25
    22be:	8f 91       	pop	r24
    22c0:	7f 91       	pop	r23
    22c2:	6f 91       	pop	r22
    22c4:	5f 91       	pop	r21
    22c6:	4f 91       	pop	r20
    22c8:	3f 91       	pop	r19
    22ca:	2f 91       	pop	r18
    22cc:	1f 91       	pop	r17
    22ce:	0f 91       	pop	r16
    22d0:	ff 90       	pop	r15
    22d2:	ef 90       	pop	r14
    22d4:	df 90       	pop	r13
    22d6:	cf 90       	pop	r12
    22d8:	bf 90       	pop	r11
    22da:	af 90       	pop	r10
    22dc:	9f 90       	pop	r9
    22de:	8f 90       	pop	r8
    22e0:	7f 90       	pop	r7
    22e2:	6f 90       	pop	r6
    22e4:	5f 90       	pop	r5
    22e6:	4f 90       	pop	r4
    22e8:	3f 90       	pop	r3
    22ea:	2f 90       	pop	r2
    22ec:	1f 90       	pop	r1
    22ee:	0f 90       	pop	r0
    22f0:	0f be       	out	0x3f, r0	; 63
    22f2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    22f4:	08 95       	ret

000022f6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    22f6:	0f 92       	push	r0
    22f8:	0f b6       	in	r0, 0x3f	; 63
    22fa:	f8 94       	cli
    22fc:	0f 92       	push	r0
    22fe:	1f 92       	push	r1
    2300:	11 24       	eor	r1, r1
    2302:	2f 92       	push	r2
    2304:	3f 92       	push	r3
    2306:	4f 92       	push	r4
    2308:	5f 92       	push	r5
    230a:	6f 92       	push	r6
    230c:	7f 92       	push	r7
    230e:	8f 92       	push	r8
    2310:	9f 92       	push	r9
    2312:	af 92       	push	r10
    2314:	bf 92       	push	r11
    2316:	cf 92       	push	r12
    2318:	df 92       	push	r13
    231a:	ef 92       	push	r14
    231c:	ff 92       	push	r15
    231e:	0f 93       	push	r16
    2320:	1f 93       	push	r17
    2322:	2f 93       	push	r18
    2324:	3f 93       	push	r19
    2326:	4f 93       	push	r20
    2328:	5f 93       	push	r21
    232a:	6f 93       	push	r22
    232c:	7f 93       	push	r23
    232e:	8f 93       	push	r24
    2330:	9f 93       	push	r25
    2332:	af 93       	push	r26
    2334:	bf 93       	push	r27
    2336:	cf 93       	push	r28
    2338:	df 93       	push	r29
    233a:	ef 93       	push	r30
    233c:	ff 93       	push	r31
    233e:	a0 91 5e 01 	lds	r26, 0x015E	; 0x80015e <__data_end>
    2342:	b0 91 5f 01 	lds	r27, 0x015F	; 0x80015f <__data_end+0x1>
    2346:	0d b6       	in	r0, 0x3d	; 61
    2348:	0d 92       	st	X+, r0
    234a:	0e b6       	in	r0, 0x3e	; 62
    234c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    234e:	0e 94 cc 03 	call	0x798	; 0x798 <xTaskIncrementTick>
    2352:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2354:	0e 94 34 05 	call	0xa68	; 0xa68 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2358:	a0 91 5e 01 	lds	r26, 0x015E	; 0x80015e <__data_end>
    235c:	b0 91 5f 01 	lds	r27, 0x015F	; 0x80015f <__data_end+0x1>
    2360:	cd 91       	ld	r28, X+
    2362:	cd bf       	out	0x3d, r28	; 61
    2364:	dd 91       	ld	r29, X+
    2366:	de bf       	out	0x3e, r29	; 62
    2368:	ff 91       	pop	r31
    236a:	ef 91       	pop	r30
    236c:	df 91       	pop	r29
    236e:	cf 91       	pop	r28
    2370:	bf 91       	pop	r27
    2372:	af 91       	pop	r26
    2374:	9f 91       	pop	r25
    2376:	8f 91       	pop	r24
    2378:	7f 91       	pop	r23
    237a:	6f 91       	pop	r22
    237c:	5f 91       	pop	r21
    237e:	4f 91       	pop	r20
    2380:	3f 91       	pop	r19
    2382:	2f 91       	pop	r18
    2384:	1f 91       	pop	r17
    2386:	0f 91       	pop	r16
    2388:	ff 90       	pop	r15
    238a:	ef 90       	pop	r14
    238c:	df 90       	pop	r13
    238e:	cf 90       	pop	r12
    2390:	bf 90       	pop	r11
    2392:	af 90       	pop	r10
    2394:	9f 90       	pop	r9
    2396:	8f 90       	pop	r8
    2398:	7f 90       	pop	r7
    239a:	6f 90       	pop	r6
    239c:	5f 90       	pop	r5
    239e:	4f 90       	pop	r4
    23a0:	3f 90       	pop	r3
    23a2:	2f 90       	pop	r2
    23a4:	1f 90       	pop	r1
    23a6:	0f 90       	pop	r0
    23a8:	0f be       	out	0x3f, r0	; 63
    23aa:	0f 90       	pop	r0

	asm volatile ( "ret" );
    23ac:	08 95       	ret

000023ae <__vector_11>:
    23ae:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <vPortYieldFromTick>
    23b2:	18 95       	reti

000023b4 <main>:
  return UDR0;
}

QueueHandle_t xQueue;
int main(void)
{
    23b4:	ef 92       	push	r14
    23b6:	ff 92       	push	r15
    23b8:	0f 93       	push	r16
    23ba:	cf 93       	push	r28
    23bc:	df 93       	push	r29
    23be:	00 d0       	rcall	.+0      	; 0x23c0 <main+0xc>
    23c0:	00 d0       	rcall	.+0      	; 0x23c2 <main+0xe>
    23c2:	cd b7       	in	r28, 0x3d	; 61
    23c4:	de b7       	in	r29, 0x3e	; 62
    xQueue = xQueueCreate(10,sizeof(uint16_t));
    23c6:	40 e0       	ldi	r20, 0x00	; 0
    23c8:	62 e0       	ldi	r22, 0x02	; 2
    23ca:	8a e0       	ldi	r24, 0x0A	; 10
    23cc:	0e 94 dd 09 	call	0x13ba	; 0x13ba <xQueueGenericCreate>
    23d0:	90 93 df 07 	sts	0x07DF, r25	; 0x8007df <xQueue+0x1>
    23d4:	80 93 de 07 	sts	0x07DE, r24	; 0x8007de <xQueue>
    uart_init();
    23d8:	0e 94 ab 00 	call	0x156	; 0x156 <uart_init>
    stdin = stdout = stderr = &uart_file;
    23dc:	e0 ee       	ldi	r30, 0xE0	; 224
    23de:	f7 e0       	ldi	r31, 0x07	; 7
    23e0:	80 e0       	ldi	r24, 0x00	; 0
    23e2:	91 e0       	ldi	r25, 0x01	; 1
    23e4:	95 83       	std	Z+5, r25	; 0x05
    23e6:	84 83       	std	Z+4, r24	; 0x04
    23e8:	93 83       	std	Z+3, r25	; 0x03
    23ea:	82 83       	std	Z+2, r24	; 0x02
    23ec:	91 83       	std	Z+1, r25	; 0x01
    23ee:	80 83       	st	Z, r24
    xTaskHandle writer_hendler;
    xTaskHandle blinker_hendler;
    xTaskCreate(vBlinker,"blink",600,NULL,mainBlinker,&blinker_hendler);
    23f0:	ce 01       	movw	r24, r28
    23f2:	01 96       	adiw	r24, 0x01	; 1
    23f4:	7c 01       	movw	r14, r24
    23f6:	02 e0       	ldi	r16, 0x02	; 2
    23f8:	20 e0       	ldi	r18, 0x00	; 0
    23fa:	30 e0       	ldi	r19, 0x00	; 0
    23fc:	48 e5       	ldi	r20, 0x58	; 88
    23fe:	52 e0       	ldi	r21, 0x02	; 2
    2400:	6b e4       	ldi	r22, 0x4B	; 75
    2402:	71 e0       	ldi	r23, 0x01	; 1
    2404:	8a eb       	ldi	r24, 0xBA	; 186
    2406:	90 e0       	ldi	r25, 0x00	; 0
    2408:	0e 94 98 01 	call	0x330	; 0x330 <xTaskCreate>
    xTaskCreate(vWriter,"writer",600,NULL,mainWriter,&writer_hendler);
    240c:	ce 01       	movw	r24, r28
    240e:	03 96       	adiw	r24, 0x03	; 3
    2410:	7c 01       	movw	r14, r24
    2412:	01 e0       	ldi	r16, 0x01	; 1
    2414:	20 e0       	ldi	r18, 0x00	; 0
    2416:	30 e0       	ldi	r19, 0x00	; 0
    2418:	48 e5       	ldi	r20, 0x58	; 88
    241a:	52 e0       	ldi	r21, 0x02	; 2
    241c:	61 e5       	ldi	r22, 0x51	; 81
    241e:	71 e0       	ldi	r23, 0x01	; 1
    2420:	83 e7       	ldi	r24, 0x73	; 115
    2422:	90 e0       	ldi	r25, 0x00	; 0
    2424:	0e 94 98 01 	call	0x330	; 0x330 <xTaskCreate>
    
    // Start scheduler.
    vTaskStartScheduler();
    2428:	0e 94 7d 03 	call	0x6fa	; 0x6fa <vTaskStartScheduler>

    return 0;
}
    242c:	80 e0       	ldi	r24, 0x00	; 0
    242e:	90 e0       	ldi	r25, 0x00	; 0
    2430:	0f 90       	pop	r0
    2432:	0f 90       	pop	r0
    2434:	0f 90       	pop	r0
    2436:	0f 90       	pop	r0
    2438:	df 91       	pop	r29
    243a:	cf 91       	pop	r28
    243c:	0f 91       	pop	r16
    243e:	ff 90       	pop	r15
    2440:	ef 90       	pop	r14
    2442:	08 95       	ret

00002444 <memcpy>:
    2444:	fb 01       	movw	r30, r22
    2446:	dc 01       	movw	r26, r24
    2448:	02 c0       	rjmp	.+4      	; 0x244e <memcpy+0xa>
    244a:	01 90       	ld	r0, Z+
    244c:	0d 92       	st	X+, r0
    244e:	41 50       	subi	r20, 0x01	; 1
    2450:	50 40       	sbci	r21, 0x00	; 0
    2452:	d8 f7       	brcc	.-10     	; 0x244a <memcpy+0x6>
    2454:	08 95       	ret

00002456 <printf>:
    2456:	a0 e0       	ldi	r26, 0x00	; 0
    2458:	b0 e0       	ldi	r27, 0x00	; 0
    245a:	e1 e3       	ldi	r30, 0x31	; 49
    245c:	f2 e1       	ldi	r31, 0x12	; 18
    245e:	0c 94 43 18 	jmp	0x3086	; 0x3086 <__prologue_saves__+0x20>
    2462:	ae 01       	movw	r20, r28
    2464:	4b 5f       	subi	r20, 0xFB	; 251
    2466:	5f 4f       	sbci	r21, 0xFF	; 255
    2468:	fa 01       	movw	r30, r20
    246a:	61 91       	ld	r22, Z+
    246c:	71 91       	ld	r23, Z+
    246e:	af 01       	movw	r20, r30
    2470:	80 91 e2 07 	lds	r24, 0x07E2	; 0x8007e2 <__iob+0x2>
    2474:	90 91 e3 07 	lds	r25, 0x07E3	; 0x8007e3 <__iob+0x3>
    2478:	0e 94 87 12 	call	0x250e	; 0x250e <vfprintf>
    247c:	e2 e0       	ldi	r30, 0x02	; 2
    247e:	0c 94 5f 18 	jmp	0x30be	; 0x30be <__epilogue_restores__+0x20>

00002482 <puts>:
    2482:	0f 93       	push	r16
    2484:	1f 93       	push	r17
    2486:	cf 93       	push	r28
    2488:	df 93       	push	r29
    248a:	e0 91 e2 07 	lds	r30, 0x07E2	; 0x8007e2 <__iob+0x2>
    248e:	f0 91 e3 07 	lds	r31, 0x07E3	; 0x8007e3 <__iob+0x3>
    2492:	23 81       	ldd	r18, Z+3	; 0x03
    2494:	21 ff       	sbrs	r18, 1
    2496:	1b c0       	rjmp	.+54     	; 0x24ce <puts+0x4c>
    2498:	8c 01       	movw	r16, r24
    249a:	d0 e0       	ldi	r29, 0x00	; 0
    249c:	c0 e0       	ldi	r28, 0x00	; 0
    249e:	f8 01       	movw	r30, r16
    24a0:	81 91       	ld	r24, Z+
    24a2:	8f 01       	movw	r16, r30
    24a4:	60 91 e2 07 	lds	r22, 0x07E2	; 0x8007e2 <__iob+0x2>
    24a8:	70 91 e3 07 	lds	r23, 0x07E3	; 0x8007e3 <__iob+0x3>
    24ac:	db 01       	movw	r26, r22
    24ae:	18 96       	adiw	r26, 0x08	; 8
    24b0:	ed 91       	ld	r30, X+
    24b2:	fc 91       	ld	r31, X
    24b4:	19 97       	sbiw	r26, 0x09	; 9
    24b6:	88 23       	and	r24, r24
    24b8:	31 f0       	breq	.+12     	; 0x24c6 <puts+0x44>
    24ba:	09 95       	icall
    24bc:	89 2b       	or	r24, r25
    24be:	79 f3       	breq	.-34     	; 0x249e <puts+0x1c>
    24c0:	df ef       	ldi	r29, 0xFF	; 255
    24c2:	cf ef       	ldi	r28, 0xFF	; 255
    24c4:	ec cf       	rjmp	.-40     	; 0x249e <puts+0x1c>
    24c6:	8a e0       	ldi	r24, 0x0A	; 10
    24c8:	09 95       	icall
    24ca:	89 2b       	or	r24, r25
    24cc:	19 f0       	breq	.+6      	; 0x24d4 <puts+0x52>
    24ce:	8f ef       	ldi	r24, 0xFF	; 255
    24d0:	9f ef       	ldi	r25, 0xFF	; 255
    24d2:	02 c0       	rjmp	.+4      	; 0x24d8 <puts+0x56>
    24d4:	8d 2f       	mov	r24, r29
    24d6:	9c 2f       	mov	r25, r28
    24d8:	df 91       	pop	r29
    24da:	cf 91       	pop	r28
    24dc:	1f 91       	pop	r17
    24de:	0f 91       	pop	r16
    24e0:	08 95       	ret

000024e2 <scanf>:
    24e2:	a0 e0       	ldi	r26, 0x00	; 0
    24e4:	b0 e0       	ldi	r27, 0x00	; 0
    24e6:	e7 e7       	ldi	r30, 0x77	; 119
    24e8:	f2 e1       	ldi	r31, 0x12	; 18
    24ea:	0c 94 43 18 	jmp	0x3086	; 0x3086 <__prologue_saves__+0x20>
    24ee:	ae 01       	movw	r20, r28
    24f0:	4b 5f       	subi	r20, 0xFB	; 251
    24f2:	5f 4f       	sbci	r21, 0xFF	; 255
    24f4:	fa 01       	movw	r30, r20
    24f6:	61 91       	ld	r22, Z+
    24f8:	71 91       	ld	r23, Z+
    24fa:	af 01       	movw	r20, r30
    24fc:	80 91 e0 07 	lds	r24, 0x07E0	; 0x8007e0 <__iob>
    2500:	90 91 e1 07 	lds	r25, 0x07E1	; 0x8007e1 <__iob+0x1>
    2504:	0e 94 04 16 	call	0x2c08	; 0x2c08 <vfscanf>
    2508:	e2 e0       	ldi	r30, 0x02	; 2
    250a:	0c 94 5f 18 	jmp	0x30be	; 0x30be <__epilogue_restores__+0x20>

0000250e <vfprintf>:
    250e:	ab e0       	ldi	r26, 0x0B	; 11
    2510:	b0 e0       	ldi	r27, 0x00	; 0
    2512:	ed e8       	ldi	r30, 0x8D	; 141
    2514:	f2 e1       	ldi	r31, 0x12	; 18
    2516:	0c 94 33 18 	jmp	0x3066	; 0x3066 <__prologue_saves__>
    251a:	6c 01       	movw	r12, r24
    251c:	7b 01       	movw	r14, r22
    251e:	8a 01       	movw	r16, r20
    2520:	fc 01       	movw	r30, r24
    2522:	17 82       	std	Z+7, r1	; 0x07
    2524:	16 82       	std	Z+6, r1	; 0x06
    2526:	83 81       	ldd	r24, Z+3	; 0x03
    2528:	81 ff       	sbrs	r24, 1
    252a:	cc c1       	rjmp	.+920    	; 0x28c4 <vfprintf+0x3b6>
    252c:	ce 01       	movw	r24, r28
    252e:	01 96       	adiw	r24, 0x01	; 1
    2530:	3c 01       	movw	r6, r24
    2532:	f6 01       	movw	r30, r12
    2534:	93 81       	ldd	r25, Z+3	; 0x03
    2536:	f7 01       	movw	r30, r14
    2538:	93 fd       	sbrc	r25, 3
    253a:	85 91       	lpm	r24, Z+
    253c:	93 ff       	sbrs	r25, 3
    253e:	81 91       	ld	r24, Z+
    2540:	7f 01       	movw	r14, r30
    2542:	88 23       	and	r24, r24
    2544:	09 f4       	brne	.+2      	; 0x2548 <vfprintf+0x3a>
    2546:	ba c1       	rjmp	.+884    	; 0x28bc <vfprintf+0x3ae>
    2548:	85 32       	cpi	r24, 0x25	; 37
    254a:	39 f4       	brne	.+14     	; 0x255a <vfprintf+0x4c>
    254c:	93 fd       	sbrc	r25, 3
    254e:	85 91       	lpm	r24, Z+
    2550:	93 ff       	sbrs	r25, 3
    2552:	81 91       	ld	r24, Z+
    2554:	7f 01       	movw	r14, r30
    2556:	85 32       	cpi	r24, 0x25	; 37
    2558:	29 f4       	brne	.+10     	; 0x2564 <vfprintf+0x56>
    255a:	b6 01       	movw	r22, r12
    255c:	90 e0       	ldi	r25, 0x00	; 0
    255e:	0e 94 7d 17 	call	0x2efa	; 0x2efa <fputc>
    2562:	e7 cf       	rjmp	.-50     	; 0x2532 <vfprintf+0x24>
    2564:	91 2c       	mov	r9, r1
    2566:	21 2c       	mov	r2, r1
    2568:	31 2c       	mov	r3, r1
    256a:	ff e1       	ldi	r31, 0x1F	; 31
    256c:	f3 15       	cp	r31, r3
    256e:	d8 f0       	brcs	.+54     	; 0x25a6 <vfprintf+0x98>
    2570:	8b 32       	cpi	r24, 0x2B	; 43
    2572:	79 f0       	breq	.+30     	; 0x2592 <vfprintf+0x84>
    2574:	38 f4       	brcc	.+14     	; 0x2584 <vfprintf+0x76>
    2576:	80 32       	cpi	r24, 0x20	; 32
    2578:	79 f0       	breq	.+30     	; 0x2598 <vfprintf+0x8a>
    257a:	83 32       	cpi	r24, 0x23	; 35
    257c:	a1 f4       	brne	.+40     	; 0x25a6 <vfprintf+0x98>
    257e:	23 2d       	mov	r18, r3
    2580:	20 61       	ori	r18, 0x10	; 16
    2582:	1d c0       	rjmp	.+58     	; 0x25be <vfprintf+0xb0>
    2584:	8d 32       	cpi	r24, 0x2D	; 45
    2586:	61 f0       	breq	.+24     	; 0x25a0 <vfprintf+0x92>
    2588:	80 33       	cpi	r24, 0x30	; 48
    258a:	69 f4       	brne	.+26     	; 0x25a6 <vfprintf+0x98>
    258c:	23 2d       	mov	r18, r3
    258e:	21 60       	ori	r18, 0x01	; 1
    2590:	16 c0       	rjmp	.+44     	; 0x25be <vfprintf+0xb0>
    2592:	83 2d       	mov	r24, r3
    2594:	82 60       	ori	r24, 0x02	; 2
    2596:	38 2e       	mov	r3, r24
    2598:	e3 2d       	mov	r30, r3
    259a:	e4 60       	ori	r30, 0x04	; 4
    259c:	3e 2e       	mov	r3, r30
    259e:	2a c0       	rjmp	.+84     	; 0x25f4 <vfprintf+0xe6>
    25a0:	f3 2d       	mov	r31, r3
    25a2:	f8 60       	ori	r31, 0x08	; 8
    25a4:	1d c0       	rjmp	.+58     	; 0x25e0 <vfprintf+0xd2>
    25a6:	37 fc       	sbrc	r3, 7
    25a8:	2d c0       	rjmp	.+90     	; 0x2604 <vfprintf+0xf6>
    25aa:	20 ed       	ldi	r18, 0xD0	; 208
    25ac:	28 0f       	add	r18, r24
    25ae:	2a 30       	cpi	r18, 0x0A	; 10
    25b0:	40 f0       	brcs	.+16     	; 0x25c2 <vfprintf+0xb4>
    25b2:	8e 32       	cpi	r24, 0x2E	; 46
    25b4:	b9 f4       	brne	.+46     	; 0x25e4 <vfprintf+0xd6>
    25b6:	36 fc       	sbrc	r3, 6
    25b8:	81 c1       	rjmp	.+770    	; 0x28bc <vfprintf+0x3ae>
    25ba:	23 2d       	mov	r18, r3
    25bc:	20 64       	ori	r18, 0x40	; 64
    25be:	32 2e       	mov	r3, r18
    25c0:	19 c0       	rjmp	.+50     	; 0x25f4 <vfprintf+0xe6>
    25c2:	36 fe       	sbrs	r3, 6
    25c4:	06 c0       	rjmp	.+12     	; 0x25d2 <vfprintf+0xc4>
    25c6:	8a e0       	ldi	r24, 0x0A	; 10
    25c8:	98 9e       	mul	r9, r24
    25ca:	20 0d       	add	r18, r0
    25cc:	11 24       	eor	r1, r1
    25ce:	92 2e       	mov	r9, r18
    25d0:	11 c0       	rjmp	.+34     	; 0x25f4 <vfprintf+0xe6>
    25d2:	ea e0       	ldi	r30, 0x0A	; 10
    25d4:	2e 9e       	mul	r2, r30
    25d6:	20 0d       	add	r18, r0
    25d8:	11 24       	eor	r1, r1
    25da:	22 2e       	mov	r2, r18
    25dc:	f3 2d       	mov	r31, r3
    25de:	f0 62       	ori	r31, 0x20	; 32
    25e0:	3f 2e       	mov	r3, r31
    25e2:	08 c0       	rjmp	.+16     	; 0x25f4 <vfprintf+0xe6>
    25e4:	8c 36       	cpi	r24, 0x6C	; 108
    25e6:	21 f4       	brne	.+8      	; 0x25f0 <vfprintf+0xe2>
    25e8:	83 2d       	mov	r24, r3
    25ea:	80 68       	ori	r24, 0x80	; 128
    25ec:	38 2e       	mov	r3, r24
    25ee:	02 c0       	rjmp	.+4      	; 0x25f4 <vfprintf+0xe6>
    25f0:	88 36       	cpi	r24, 0x68	; 104
    25f2:	41 f4       	brne	.+16     	; 0x2604 <vfprintf+0xf6>
    25f4:	f7 01       	movw	r30, r14
    25f6:	93 fd       	sbrc	r25, 3
    25f8:	85 91       	lpm	r24, Z+
    25fa:	93 ff       	sbrs	r25, 3
    25fc:	81 91       	ld	r24, Z+
    25fe:	7f 01       	movw	r14, r30
    2600:	81 11       	cpse	r24, r1
    2602:	b3 cf       	rjmp	.-154    	; 0x256a <vfprintf+0x5c>
    2604:	98 2f       	mov	r25, r24
    2606:	9f 7d       	andi	r25, 0xDF	; 223
    2608:	95 54       	subi	r25, 0x45	; 69
    260a:	93 30       	cpi	r25, 0x03	; 3
    260c:	28 f4       	brcc	.+10     	; 0x2618 <vfprintf+0x10a>
    260e:	0c 5f       	subi	r16, 0xFC	; 252
    2610:	1f 4f       	sbci	r17, 0xFF	; 255
    2612:	9f e3       	ldi	r25, 0x3F	; 63
    2614:	99 83       	std	Y+1, r25	; 0x01
    2616:	0d c0       	rjmp	.+26     	; 0x2632 <vfprintf+0x124>
    2618:	83 36       	cpi	r24, 0x63	; 99
    261a:	31 f0       	breq	.+12     	; 0x2628 <vfprintf+0x11a>
    261c:	83 37       	cpi	r24, 0x73	; 115
    261e:	71 f0       	breq	.+28     	; 0x263c <vfprintf+0x12e>
    2620:	83 35       	cpi	r24, 0x53	; 83
    2622:	09 f0       	breq	.+2      	; 0x2626 <vfprintf+0x118>
    2624:	59 c0       	rjmp	.+178    	; 0x26d8 <vfprintf+0x1ca>
    2626:	21 c0       	rjmp	.+66     	; 0x266a <vfprintf+0x15c>
    2628:	f8 01       	movw	r30, r16
    262a:	80 81       	ld	r24, Z
    262c:	89 83       	std	Y+1, r24	; 0x01
    262e:	0e 5f       	subi	r16, 0xFE	; 254
    2630:	1f 4f       	sbci	r17, 0xFF	; 255
    2632:	88 24       	eor	r8, r8
    2634:	83 94       	inc	r8
    2636:	91 2c       	mov	r9, r1
    2638:	53 01       	movw	r10, r6
    263a:	13 c0       	rjmp	.+38     	; 0x2662 <vfprintf+0x154>
    263c:	28 01       	movw	r4, r16
    263e:	f2 e0       	ldi	r31, 0x02	; 2
    2640:	4f 0e       	add	r4, r31
    2642:	51 1c       	adc	r5, r1
    2644:	f8 01       	movw	r30, r16
    2646:	a0 80       	ld	r10, Z
    2648:	b1 80       	ldd	r11, Z+1	; 0x01
    264a:	36 fe       	sbrs	r3, 6
    264c:	03 c0       	rjmp	.+6      	; 0x2654 <vfprintf+0x146>
    264e:	69 2d       	mov	r22, r9
    2650:	70 e0       	ldi	r23, 0x00	; 0
    2652:	02 c0       	rjmp	.+4      	; 0x2658 <vfprintf+0x14a>
    2654:	6f ef       	ldi	r22, 0xFF	; 255
    2656:	7f ef       	ldi	r23, 0xFF	; 255
    2658:	c5 01       	movw	r24, r10
    265a:	0e 94 34 17 	call	0x2e68	; 0x2e68 <strnlen>
    265e:	4c 01       	movw	r8, r24
    2660:	82 01       	movw	r16, r4
    2662:	f3 2d       	mov	r31, r3
    2664:	ff 77       	andi	r31, 0x7F	; 127
    2666:	3f 2e       	mov	r3, r31
    2668:	16 c0       	rjmp	.+44     	; 0x2696 <vfprintf+0x188>
    266a:	28 01       	movw	r4, r16
    266c:	22 e0       	ldi	r18, 0x02	; 2
    266e:	42 0e       	add	r4, r18
    2670:	51 1c       	adc	r5, r1
    2672:	f8 01       	movw	r30, r16
    2674:	a0 80       	ld	r10, Z
    2676:	b1 80       	ldd	r11, Z+1	; 0x01
    2678:	36 fe       	sbrs	r3, 6
    267a:	03 c0       	rjmp	.+6      	; 0x2682 <vfprintf+0x174>
    267c:	69 2d       	mov	r22, r9
    267e:	70 e0       	ldi	r23, 0x00	; 0
    2680:	02 c0       	rjmp	.+4      	; 0x2686 <vfprintf+0x178>
    2682:	6f ef       	ldi	r22, 0xFF	; 255
    2684:	7f ef       	ldi	r23, 0xFF	; 255
    2686:	c5 01       	movw	r24, r10
    2688:	0e 94 29 17 	call	0x2e52	; 0x2e52 <strnlen_P>
    268c:	4c 01       	movw	r8, r24
    268e:	f3 2d       	mov	r31, r3
    2690:	f0 68       	ori	r31, 0x80	; 128
    2692:	3f 2e       	mov	r3, r31
    2694:	82 01       	movw	r16, r4
    2696:	33 fc       	sbrc	r3, 3
    2698:	1b c0       	rjmp	.+54     	; 0x26d0 <vfprintf+0x1c2>
    269a:	82 2d       	mov	r24, r2
    269c:	90 e0       	ldi	r25, 0x00	; 0
    269e:	88 16       	cp	r8, r24
    26a0:	99 06       	cpc	r9, r25
    26a2:	b0 f4       	brcc	.+44     	; 0x26d0 <vfprintf+0x1c2>
    26a4:	b6 01       	movw	r22, r12
    26a6:	80 e2       	ldi	r24, 0x20	; 32
    26a8:	90 e0       	ldi	r25, 0x00	; 0
    26aa:	0e 94 7d 17 	call	0x2efa	; 0x2efa <fputc>
    26ae:	2a 94       	dec	r2
    26b0:	f4 cf       	rjmp	.-24     	; 0x269a <vfprintf+0x18c>
    26b2:	f5 01       	movw	r30, r10
    26b4:	37 fc       	sbrc	r3, 7
    26b6:	85 91       	lpm	r24, Z+
    26b8:	37 fe       	sbrs	r3, 7
    26ba:	81 91       	ld	r24, Z+
    26bc:	5f 01       	movw	r10, r30
    26be:	b6 01       	movw	r22, r12
    26c0:	90 e0       	ldi	r25, 0x00	; 0
    26c2:	0e 94 7d 17 	call	0x2efa	; 0x2efa <fputc>
    26c6:	21 10       	cpse	r2, r1
    26c8:	2a 94       	dec	r2
    26ca:	21 e0       	ldi	r18, 0x01	; 1
    26cc:	82 1a       	sub	r8, r18
    26ce:	91 08       	sbc	r9, r1
    26d0:	81 14       	cp	r8, r1
    26d2:	91 04       	cpc	r9, r1
    26d4:	71 f7       	brne	.-36     	; 0x26b2 <vfprintf+0x1a4>
    26d6:	e8 c0       	rjmp	.+464    	; 0x28a8 <vfprintf+0x39a>
    26d8:	84 36       	cpi	r24, 0x64	; 100
    26da:	11 f0       	breq	.+4      	; 0x26e0 <vfprintf+0x1d2>
    26dc:	89 36       	cpi	r24, 0x69	; 105
    26de:	41 f5       	brne	.+80     	; 0x2730 <vfprintf+0x222>
    26e0:	f8 01       	movw	r30, r16
    26e2:	37 fe       	sbrs	r3, 7
    26e4:	07 c0       	rjmp	.+14     	; 0x26f4 <vfprintf+0x1e6>
    26e6:	60 81       	ld	r22, Z
    26e8:	71 81       	ldd	r23, Z+1	; 0x01
    26ea:	82 81       	ldd	r24, Z+2	; 0x02
    26ec:	93 81       	ldd	r25, Z+3	; 0x03
    26ee:	0c 5f       	subi	r16, 0xFC	; 252
    26f0:	1f 4f       	sbci	r17, 0xFF	; 255
    26f2:	08 c0       	rjmp	.+16     	; 0x2704 <vfprintf+0x1f6>
    26f4:	60 81       	ld	r22, Z
    26f6:	71 81       	ldd	r23, Z+1	; 0x01
    26f8:	07 2e       	mov	r0, r23
    26fa:	00 0c       	add	r0, r0
    26fc:	88 0b       	sbc	r24, r24
    26fe:	99 0b       	sbc	r25, r25
    2700:	0e 5f       	subi	r16, 0xFE	; 254
    2702:	1f 4f       	sbci	r17, 0xFF	; 255
    2704:	f3 2d       	mov	r31, r3
    2706:	ff 76       	andi	r31, 0x6F	; 111
    2708:	3f 2e       	mov	r3, r31
    270a:	97 ff       	sbrs	r25, 7
    270c:	09 c0       	rjmp	.+18     	; 0x2720 <vfprintf+0x212>
    270e:	90 95       	com	r25
    2710:	80 95       	com	r24
    2712:	70 95       	com	r23
    2714:	61 95       	neg	r22
    2716:	7f 4f       	sbci	r23, 0xFF	; 255
    2718:	8f 4f       	sbci	r24, 0xFF	; 255
    271a:	9f 4f       	sbci	r25, 0xFF	; 255
    271c:	f0 68       	ori	r31, 0x80	; 128
    271e:	3f 2e       	mov	r3, r31
    2720:	2a e0       	ldi	r18, 0x0A	; 10
    2722:	30 e0       	ldi	r19, 0x00	; 0
    2724:	a3 01       	movw	r20, r6
    2726:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <__ultoa_invert>
    272a:	88 2e       	mov	r8, r24
    272c:	86 18       	sub	r8, r6
    272e:	45 c0       	rjmp	.+138    	; 0x27ba <vfprintf+0x2ac>
    2730:	85 37       	cpi	r24, 0x75	; 117
    2732:	31 f4       	brne	.+12     	; 0x2740 <vfprintf+0x232>
    2734:	23 2d       	mov	r18, r3
    2736:	2f 7e       	andi	r18, 0xEF	; 239
    2738:	b2 2e       	mov	r11, r18
    273a:	2a e0       	ldi	r18, 0x0A	; 10
    273c:	30 e0       	ldi	r19, 0x00	; 0
    273e:	25 c0       	rjmp	.+74     	; 0x278a <vfprintf+0x27c>
    2740:	93 2d       	mov	r25, r3
    2742:	99 7f       	andi	r25, 0xF9	; 249
    2744:	b9 2e       	mov	r11, r25
    2746:	8f 36       	cpi	r24, 0x6F	; 111
    2748:	c1 f0       	breq	.+48     	; 0x277a <vfprintf+0x26c>
    274a:	18 f4       	brcc	.+6      	; 0x2752 <vfprintf+0x244>
    274c:	88 35       	cpi	r24, 0x58	; 88
    274e:	79 f0       	breq	.+30     	; 0x276e <vfprintf+0x260>
    2750:	b5 c0       	rjmp	.+362    	; 0x28bc <vfprintf+0x3ae>
    2752:	80 37       	cpi	r24, 0x70	; 112
    2754:	19 f0       	breq	.+6      	; 0x275c <vfprintf+0x24e>
    2756:	88 37       	cpi	r24, 0x78	; 120
    2758:	21 f0       	breq	.+8      	; 0x2762 <vfprintf+0x254>
    275a:	b0 c0       	rjmp	.+352    	; 0x28bc <vfprintf+0x3ae>
    275c:	e9 2f       	mov	r30, r25
    275e:	e0 61       	ori	r30, 0x10	; 16
    2760:	be 2e       	mov	r11, r30
    2762:	b4 fe       	sbrs	r11, 4
    2764:	0d c0       	rjmp	.+26     	; 0x2780 <vfprintf+0x272>
    2766:	fb 2d       	mov	r31, r11
    2768:	f4 60       	ori	r31, 0x04	; 4
    276a:	bf 2e       	mov	r11, r31
    276c:	09 c0       	rjmp	.+18     	; 0x2780 <vfprintf+0x272>
    276e:	34 fe       	sbrs	r3, 4
    2770:	0a c0       	rjmp	.+20     	; 0x2786 <vfprintf+0x278>
    2772:	29 2f       	mov	r18, r25
    2774:	26 60       	ori	r18, 0x06	; 6
    2776:	b2 2e       	mov	r11, r18
    2778:	06 c0       	rjmp	.+12     	; 0x2786 <vfprintf+0x278>
    277a:	28 e0       	ldi	r18, 0x08	; 8
    277c:	30 e0       	ldi	r19, 0x00	; 0
    277e:	05 c0       	rjmp	.+10     	; 0x278a <vfprintf+0x27c>
    2780:	20 e1       	ldi	r18, 0x10	; 16
    2782:	30 e0       	ldi	r19, 0x00	; 0
    2784:	02 c0       	rjmp	.+4      	; 0x278a <vfprintf+0x27c>
    2786:	20 e1       	ldi	r18, 0x10	; 16
    2788:	32 e0       	ldi	r19, 0x02	; 2
    278a:	f8 01       	movw	r30, r16
    278c:	b7 fe       	sbrs	r11, 7
    278e:	07 c0       	rjmp	.+14     	; 0x279e <vfprintf+0x290>
    2790:	60 81       	ld	r22, Z
    2792:	71 81       	ldd	r23, Z+1	; 0x01
    2794:	82 81       	ldd	r24, Z+2	; 0x02
    2796:	93 81       	ldd	r25, Z+3	; 0x03
    2798:	0c 5f       	subi	r16, 0xFC	; 252
    279a:	1f 4f       	sbci	r17, 0xFF	; 255
    279c:	06 c0       	rjmp	.+12     	; 0x27aa <vfprintf+0x29c>
    279e:	60 81       	ld	r22, Z
    27a0:	71 81       	ldd	r23, Z+1	; 0x01
    27a2:	80 e0       	ldi	r24, 0x00	; 0
    27a4:	90 e0       	ldi	r25, 0x00	; 0
    27a6:	0e 5f       	subi	r16, 0xFE	; 254
    27a8:	1f 4f       	sbci	r17, 0xFF	; 255
    27aa:	a3 01       	movw	r20, r6
    27ac:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <__ultoa_invert>
    27b0:	88 2e       	mov	r8, r24
    27b2:	86 18       	sub	r8, r6
    27b4:	fb 2d       	mov	r31, r11
    27b6:	ff 77       	andi	r31, 0x7F	; 127
    27b8:	3f 2e       	mov	r3, r31
    27ba:	36 fe       	sbrs	r3, 6
    27bc:	0d c0       	rjmp	.+26     	; 0x27d8 <vfprintf+0x2ca>
    27be:	23 2d       	mov	r18, r3
    27c0:	2e 7f       	andi	r18, 0xFE	; 254
    27c2:	a2 2e       	mov	r10, r18
    27c4:	89 14       	cp	r8, r9
    27c6:	58 f4       	brcc	.+22     	; 0x27de <vfprintf+0x2d0>
    27c8:	34 fe       	sbrs	r3, 4
    27ca:	0b c0       	rjmp	.+22     	; 0x27e2 <vfprintf+0x2d4>
    27cc:	32 fc       	sbrc	r3, 2
    27ce:	09 c0       	rjmp	.+18     	; 0x27e2 <vfprintf+0x2d4>
    27d0:	83 2d       	mov	r24, r3
    27d2:	8e 7e       	andi	r24, 0xEE	; 238
    27d4:	a8 2e       	mov	r10, r24
    27d6:	05 c0       	rjmp	.+10     	; 0x27e2 <vfprintf+0x2d4>
    27d8:	b8 2c       	mov	r11, r8
    27da:	a3 2c       	mov	r10, r3
    27dc:	03 c0       	rjmp	.+6      	; 0x27e4 <vfprintf+0x2d6>
    27de:	b8 2c       	mov	r11, r8
    27e0:	01 c0       	rjmp	.+2      	; 0x27e4 <vfprintf+0x2d6>
    27e2:	b9 2c       	mov	r11, r9
    27e4:	a4 fe       	sbrs	r10, 4
    27e6:	0f c0       	rjmp	.+30     	; 0x2806 <vfprintf+0x2f8>
    27e8:	fe 01       	movw	r30, r28
    27ea:	e8 0d       	add	r30, r8
    27ec:	f1 1d       	adc	r31, r1
    27ee:	80 81       	ld	r24, Z
    27f0:	80 33       	cpi	r24, 0x30	; 48
    27f2:	21 f4       	brne	.+8      	; 0x27fc <vfprintf+0x2ee>
    27f4:	9a 2d       	mov	r25, r10
    27f6:	99 7e       	andi	r25, 0xE9	; 233
    27f8:	a9 2e       	mov	r10, r25
    27fa:	09 c0       	rjmp	.+18     	; 0x280e <vfprintf+0x300>
    27fc:	a2 fe       	sbrs	r10, 2
    27fe:	06 c0       	rjmp	.+12     	; 0x280c <vfprintf+0x2fe>
    2800:	b3 94       	inc	r11
    2802:	b3 94       	inc	r11
    2804:	04 c0       	rjmp	.+8      	; 0x280e <vfprintf+0x300>
    2806:	8a 2d       	mov	r24, r10
    2808:	86 78       	andi	r24, 0x86	; 134
    280a:	09 f0       	breq	.+2      	; 0x280e <vfprintf+0x300>
    280c:	b3 94       	inc	r11
    280e:	a3 fc       	sbrc	r10, 3
    2810:	11 c0       	rjmp	.+34     	; 0x2834 <vfprintf+0x326>
    2812:	a0 fe       	sbrs	r10, 0
    2814:	06 c0       	rjmp	.+12     	; 0x2822 <vfprintf+0x314>
    2816:	b2 14       	cp	r11, r2
    2818:	88 f4       	brcc	.+34     	; 0x283c <vfprintf+0x32e>
    281a:	28 0c       	add	r2, r8
    281c:	92 2c       	mov	r9, r2
    281e:	9b 18       	sub	r9, r11
    2820:	0e c0       	rjmp	.+28     	; 0x283e <vfprintf+0x330>
    2822:	b2 14       	cp	r11, r2
    2824:	60 f4       	brcc	.+24     	; 0x283e <vfprintf+0x330>
    2826:	b6 01       	movw	r22, r12
    2828:	80 e2       	ldi	r24, 0x20	; 32
    282a:	90 e0       	ldi	r25, 0x00	; 0
    282c:	0e 94 7d 17 	call	0x2efa	; 0x2efa <fputc>
    2830:	b3 94       	inc	r11
    2832:	f7 cf       	rjmp	.-18     	; 0x2822 <vfprintf+0x314>
    2834:	b2 14       	cp	r11, r2
    2836:	18 f4       	brcc	.+6      	; 0x283e <vfprintf+0x330>
    2838:	2b 18       	sub	r2, r11
    283a:	02 c0       	rjmp	.+4      	; 0x2840 <vfprintf+0x332>
    283c:	98 2c       	mov	r9, r8
    283e:	21 2c       	mov	r2, r1
    2840:	a4 fe       	sbrs	r10, 4
    2842:	10 c0       	rjmp	.+32     	; 0x2864 <vfprintf+0x356>
    2844:	b6 01       	movw	r22, r12
    2846:	80 e3       	ldi	r24, 0x30	; 48
    2848:	90 e0       	ldi	r25, 0x00	; 0
    284a:	0e 94 7d 17 	call	0x2efa	; 0x2efa <fputc>
    284e:	a2 fe       	sbrs	r10, 2
    2850:	17 c0       	rjmp	.+46     	; 0x2880 <vfprintf+0x372>
    2852:	a1 fc       	sbrc	r10, 1
    2854:	03 c0       	rjmp	.+6      	; 0x285c <vfprintf+0x34e>
    2856:	88 e7       	ldi	r24, 0x78	; 120
    2858:	90 e0       	ldi	r25, 0x00	; 0
    285a:	02 c0       	rjmp	.+4      	; 0x2860 <vfprintf+0x352>
    285c:	88 e5       	ldi	r24, 0x58	; 88
    285e:	90 e0       	ldi	r25, 0x00	; 0
    2860:	b6 01       	movw	r22, r12
    2862:	0c c0       	rjmp	.+24     	; 0x287c <vfprintf+0x36e>
    2864:	8a 2d       	mov	r24, r10
    2866:	86 78       	andi	r24, 0x86	; 134
    2868:	59 f0       	breq	.+22     	; 0x2880 <vfprintf+0x372>
    286a:	a1 fe       	sbrs	r10, 1
    286c:	02 c0       	rjmp	.+4      	; 0x2872 <vfprintf+0x364>
    286e:	8b e2       	ldi	r24, 0x2B	; 43
    2870:	01 c0       	rjmp	.+2      	; 0x2874 <vfprintf+0x366>
    2872:	80 e2       	ldi	r24, 0x20	; 32
    2874:	a7 fc       	sbrc	r10, 7
    2876:	8d e2       	ldi	r24, 0x2D	; 45
    2878:	b6 01       	movw	r22, r12
    287a:	90 e0       	ldi	r25, 0x00	; 0
    287c:	0e 94 7d 17 	call	0x2efa	; 0x2efa <fputc>
    2880:	89 14       	cp	r8, r9
    2882:	38 f4       	brcc	.+14     	; 0x2892 <vfprintf+0x384>
    2884:	b6 01       	movw	r22, r12
    2886:	80 e3       	ldi	r24, 0x30	; 48
    2888:	90 e0       	ldi	r25, 0x00	; 0
    288a:	0e 94 7d 17 	call	0x2efa	; 0x2efa <fputc>
    288e:	9a 94       	dec	r9
    2890:	f7 cf       	rjmp	.-18     	; 0x2880 <vfprintf+0x372>
    2892:	8a 94       	dec	r8
    2894:	f3 01       	movw	r30, r6
    2896:	e8 0d       	add	r30, r8
    2898:	f1 1d       	adc	r31, r1
    289a:	80 81       	ld	r24, Z
    289c:	b6 01       	movw	r22, r12
    289e:	90 e0       	ldi	r25, 0x00	; 0
    28a0:	0e 94 7d 17 	call	0x2efa	; 0x2efa <fputc>
    28a4:	81 10       	cpse	r8, r1
    28a6:	f5 cf       	rjmp	.-22     	; 0x2892 <vfprintf+0x384>
    28a8:	22 20       	and	r2, r2
    28aa:	09 f4       	brne	.+2      	; 0x28ae <vfprintf+0x3a0>
    28ac:	42 ce       	rjmp	.-892    	; 0x2532 <vfprintf+0x24>
    28ae:	b6 01       	movw	r22, r12
    28b0:	80 e2       	ldi	r24, 0x20	; 32
    28b2:	90 e0       	ldi	r25, 0x00	; 0
    28b4:	0e 94 7d 17 	call	0x2efa	; 0x2efa <fputc>
    28b8:	2a 94       	dec	r2
    28ba:	f6 cf       	rjmp	.-20     	; 0x28a8 <vfprintf+0x39a>
    28bc:	f6 01       	movw	r30, r12
    28be:	86 81       	ldd	r24, Z+6	; 0x06
    28c0:	97 81       	ldd	r25, Z+7	; 0x07
    28c2:	02 c0       	rjmp	.+4      	; 0x28c8 <vfprintf+0x3ba>
    28c4:	8f ef       	ldi	r24, 0xFF	; 255
    28c6:	9f ef       	ldi	r25, 0xFF	; 255
    28c8:	2b 96       	adiw	r28, 0x0b	; 11
    28ca:	e2 e1       	ldi	r30, 0x12	; 18
    28cc:	0c 94 4f 18 	jmp	0x309e	; 0x309e <__epilogue_restores__>

000028d0 <putval>:
    28d0:	20 fd       	sbrc	r18, 0
    28d2:	09 c0       	rjmp	.+18     	; 0x28e6 <putval+0x16>
    28d4:	fc 01       	movw	r30, r24
    28d6:	23 fd       	sbrc	r18, 3
    28d8:	05 c0       	rjmp	.+10     	; 0x28e4 <putval+0x14>
    28da:	22 ff       	sbrs	r18, 2
    28dc:	02 c0       	rjmp	.+4      	; 0x28e2 <putval+0x12>
    28de:	73 83       	std	Z+3, r23	; 0x03
    28e0:	62 83       	std	Z+2, r22	; 0x02
    28e2:	51 83       	std	Z+1, r21	; 0x01
    28e4:	40 83       	st	Z, r20
    28e6:	08 95       	ret

000028e8 <mulacc>:
    28e8:	44 fd       	sbrc	r20, 4
    28ea:	17 c0       	rjmp	.+46     	; 0x291a <mulacc+0x32>
    28ec:	46 fd       	sbrc	r20, 6
    28ee:	17 c0       	rjmp	.+46     	; 0x291e <mulacc+0x36>
    28f0:	ab 01       	movw	r20, r22
    28f2:	bc 01       	movw	r22, r24
    28f4:	da 01       	movw	r26, r20
    28f6:	fb 01       	movw	r30, r22
    28f8:	aa 0f       	add	r26, r26
    28fa:	bb 1f       	adc	r27, r27
    28fc:	ee 1f       	adc	r30, r30
    28fe:	ff 1f       	adc	r31, r31
    2900:	10 94       	com	r1
    2902:	d1 f7       	brne	.-12     	; 0x28f8 <mulacc+0x10>
    2904:	4a 0f       	add	r20, r26
    2906:	5b 1f       	adc	r21, r27
    2908:	6e 1f       	adc	r22, r30
    290a:	7f 1f       	adc	r23, r31
    290c:	cb 01       	movw	r24, r22
    290e:	ba 01       	movw	r22, r20
    2910:	66 0f       	add	r22, r22
    2912:	77 1f       	adc	r23, r23
    2914:	88 1f       	adc	r24, r24
    2916:	99 1f       	adc	r25, r25
    2918:	09 c0       	rjmp	.+18     	; 0x292c <mulacc+0x44>
    291a:	33 e0       	ldi	r19, 0x03	; 3
    291c:	01 c0       	rjmp	.+2      	; 0x2920 <mulacc+0x38>
    291e:	34 e0       	ldi	r19, 0x04	; 4
    2920:	66 0f       	add	r22, r22
    2922:	77 1f       	adc	r23, r23
    2924:	88 1f       	adc	r24, r24
    2926:	99 1f       	adc	r25, r25
    2928:	31 50       	subi	r19, 0x01	; 1
    292a:	d1 f7       	brne	.-12     	; 0x2920 <mulacc+0x38>
    292c:	62 0f       	add	r22, r18
    292e:	71 1d       	adc	r23, r1
    2930:	81 1d       	adc	r24, r1
    2932:	91 1d       	adc	r25, r1
    2934:	08 95       	ret

00002936 <skip_spaces>:
    2936:	0f 93       	push	r16
    2938:	1f 93       	push	r17
    293a:	cf 93       	push	r28
    293c:	df 93       	push	r29
    293e:	8c 01       	movw	r16, r24
    2940:	c8 01       	movw	r24, r16
    2942:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <fgetc>
    2946:	ec 01       	movw	r28, r24
    2948:	97 fd       	sbrc	r25, 7
    294a:	08 c0       	rjmp	.+16     	; 0x295c <skip_spaces+0x26>
    294c:	0e 94 15 17 	call	0x2e2a	; 0x2e2a <isspace>
    2950:	89 2b       	or	r24, r25
    2952:	b1 f7       	brne	.-20     	; 0x2940 <skip_spaces+0xa>
    2954:	b8 01       	movw	r22, r16
    2956:	ce 01       	movw	r24, r28
    2958:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <ungetc>
    295c:	ce 01       	movw	r24, r28
    295e:	df 91       	pop	r29
    2960:	cf 91       	pop	r28
    2962:	1f 91       	pop	r17
    2964:	0f 91       	pop	r16
    2966:	08 95       	ret

00002968 <conv_int>:
    2968:	8f 92       	push	r8
    296a:	9f 92       	push	r9
    296c:	af 92       	push	r10
    296e:	bf 92       	push	r11
    2970:	ef 92       	push	r14
    2972:	ff 92       	push	r15
    2974:	0f 93       	push	r16
    2976:	1f 93       	push	r17
    2978:	cf 93       	push	r28
    297a:	df 93       	push	r29
    297c:	8c 01       	movw	r16, r24
    297e:	d6 2f       	mov	r29, r22
    2980:	7a 01       	movw	r14, r20
    2982:	b2 2e       	mov	r11, r18
    2984:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <fgetc>
    2988:	9c 01       	movw	r18, r24
    298a:	33 27       	eor	r19, r19
    298c:	2b 32       	cpi	r18, 0x2B	; 43
    298e:	31 05       	cpc	r19, r1
    2990:	31 f0       	breq	.+12     	; 0x299e <conv_int+0x36>
    2992:	2d 32       	cpi	r18, 0x2D	; 45
    2994:	31 05       	cpc	r19, r1
    2996:	61 f4       	brne	.+24     	; 0x29b0 <conv_int+0x48>
    2998:	8b 2d       	mov	r24, r11
    299a:	80 68       	ori	r24, 0x80	; 128
    299c:	b8 2e       	mov	r11, r24
    299e:	d1 50       	subi	r29, 0x01	; 1
    29a0:	11 f4       	brne	.+4      	; 0x29a6 <conv_int+0x3e>
    29a2:	80 e0       	ldi	r24, 0x00	; 0
    29a4:	68 c0       	rjmp	.+208    	; 0x2a76 <conv_int+0x10e>
    29a6:	c8 01       	movw	r24, r16
    29a8:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <fgetc>
    29ac:	97 fd       	sbrc	r25, 7
    29ae:	f9 cf       	rjmp	.-14     	; 0x29a2 <conv_int+0x3a>
    29b0:	cb 2d       	mov	r28, r11
    29b2:	cd 7f       	andi	r28, 0xFD	; 253
    29b4:	2b 2d       	mov	r18, r11
    29b6:	20 73       	andi	r18, 0x30	; 48
    29b8:	09 f5       	brne	.+66     	; 0x29fc <conv_int+0x94>
    29ba:	80 33       	cpi	r24, 0x30	; 48
    29bc:	f9 f4       	brne	.+62     	; 0x29fc <conv_int+0x94>
    29be:	aa 24       	eor	r10, r10
    29c0:	aa 94       	dec	r10
    29c2:	ad 0e       	add	r10, r29
    29c4:	09 f4       	brne	.+2      	; 0x29c8 <conv_int+0x60>
    29c6:	43 c0       	rjmp	.+134    	; 0x2a4e <conv_int+0xe6>
    29c8:	c8 01       	movw	r24, r16
    29ca:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <fgetc>
    29ce:	97 fd       	sbrc	r25, 7
    29d0:	3e c0       	rjmp	.+124    	; 0x2a4e <conv_int+0xe6>
    29d2:	9c 01       	movw	r18, r24
    29d4:	2f 7d       	andi	r18, 0xDF	; 223
    29d6:	33 27       	eor	r19, r19
    29d8:	28 35       	cpi	r18, 0x58	; 88
    29da:	31 05       	cpc	r19, r1
    29dc:	49 f4       	brne	.+18     	; 0x29f0 <conv_int+0x88>
    29de:	c2 64       	ori	r28, 0x42	; 66
    29e0:	d2 50       	subi	r29, 0x02	; 2
    29e2:	a9 f1       	breq	.+106    	; 0x2a4e <conv_int+0xe6>
    29e4:	c8 01       	movw	r24, r16
    29e6:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <fgetc>
    29ea:	97 ff       	sbrs	r25, 7
    29ec:	07 c0       	rjmp	.+14     	; 0x29fc <conv_int+0x94>
    29ee:	2f c0       	rjmp	.+94     	; 0x2a4e <conv_int+0xe6>
    29f0:	b6 fe       	sbrs	r11, 6
    29f2:	02 c0       	rjmp	.+4      	; 0x29f8 <conv_int+0x90>
    29f4:	c2 60       	ori	r28, 0x02	; 2
    29f6:	01 c0       	rjmp	.+2      	; 0x29fa <conv_int+0x92>
    29f8:	c2 61       	ori	r28, 0x12	; 18
    29fa:	da 2d       	mov	r29, r10
    29fc:	81 2c       	mov	r8, r1
    29fe:	91 2c       	mov	r9, r1
    2a00:	54 01       	movw	r10, r8
    2a02:	20 ed       	ldi	r18, 0xD0	; 208
    2a04:	28 0f       	add	r18, r24
    2a06:	28 30       	cpi	r18, 0x08	; 8
    2a08:	80 f0       	brcs	.+32     	; 0x2a2a <conv_int+0xc2>
    2a0a:	c4 ff       	sbrs	r28, 4
    2a0c:	04 c0       	rjmp	.+8      	; 0x2a16 <conv_int+0xae>
    2a0e:	b8 01       	movw	r22, r16
    2a10:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <ungetc>
    2a14:	19 c0       	rjmp	.+50     	; 0x2a48 <conv_int+0xe0>
    2a16:	2a 30       	cpi	r18, 0x0A	; 10
    2a18:	40 f0       	brcs	.+16     	; 0x2a2a <conv_int+0xc2>
    2a1a:	c6 ff       	sbrs	r28, 6
    2a1c:	f8 cf       	rjmp	.-16     	; 0x2a0e <conv_int+0xa6>
    2a1e:	2f 7d       	andi	r18, 0xDF	; 223
    2a20:	3f ee       	ldi	r19, 0xEF	; 239
    2a22:	32 0f       	add	r19, r18
    2a24:	36 30       	cpi	r19, 0x06	; 6
    2a26:	98 f7       	brcc	.-26     	; 0x2a0e <conv_int+0xa6>
    2a28:	27 50       	subi	r18, 0x07	; 7
    2a2a:	4c 2f       	mov	r20, r28
    2a2c:	c5 01       	movw	r24, r10
    2a2e:	b4 01       	movw	r22, r8
    2a30:	0e 94 74 14 	call	0x28e8	; 0x28e8 <mulacc>
    2a34:	4b 01       	movw	r8, r22
    2a36:	5c 01       	movw	r10, r24
    2a38:	c2 60       	ori	r28, 0x02	; 2
    2a3a:	d1 50       	subi	r29, 0x01	; 1
    2a3c:	59 f0       	breq	.+22     	; 0x2a54 <conv_int+0xec>
    2a3e:	c8 01       	movw	r24, r16
    2a40:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <fgetc>
    2a44:	97 ff       	sbrs	r25, 7
    2a46:	dd cf       	rjmp	.-70     	; 0x2a02 <conv_int+0x9a>
    2a48:	c1 fd       	sbrc	r28, 1
    2a4a:	04 c0       	rjmp	.+8      	; 0x2a54 <conv_int+0xec>
    2a4c:	aa cf       	rjmp	.-172    	; 0x29a2 <conv_int+0x3a>
    2a4e:	81 2c       	mov	r8, r1
    2a50:	91 2c       	mov	r9, r1
    2a52:	54 01       	movw	r10, r8
    2a54:	c7 ff       	sbrs	r28, 7
    2a56:	08 c0       	rjmp	.+16     	; 0x2a68 <conv_int+0x100>
    2a58:	b0 94       	com	r11
    2a5a:	a0 94       	com	r10
    2a5c:	90 94       	com	r9
    2a5e:	80 94       	com	r8
    2a60:	81 1c       	adc	r8, r1
    2a62:	91 1c       	adc	r9, r1
    2a64:	a1 1c       	adc	r10, r1
    2a66:	b1 1c       	adc	r11, r1
    2a68:	2c 2f       	mov	r18, r28
    2a6a:	b5 01       	movw	r22, r10
    2a6c:	a4 01       	movw	r20, r8
    2a6e:	c7 01       	movw	r24, r14
    2a70:	0e 94 68 14 	call	0x28d0	; 0x28d0 <putval>
    2a74:	81 e0       	ldi	r24, 0x01	; 1
    2a76:	df 91       	pop	r29
    2a78:	cf 91       	pop	r28
    2a7a:	1f 91       	pop	r17
    2a7c:	0f 91       	pop	r16
    2a7e:	ff 90       	pop	r15
    2a80:	ef 90       	pop	r14
    2a82:	bf 90       	pop	r11
    2a84:	af 90       	pop	r10
    2a86:	9f 90       	pop	r9
    2a88:	8f 90       	pop	r8
    2a8a:	08 95       	ret

00002a8c <conv_brk>:
    2a8c:	a0 e2       	ldi	r26, 0x20	; 32
    2a8e:	b0 e0       	ldi	r27, 0x00	; 0
    2a90:	ec e4       	ldi	r30, 0x4C	; 76
    2a92:	f5 e1       	ldi	r31, 0x15	; 21
    2a94:	0c 94 36 18 	jmp	0x306c	; 0x306c <__prologue_saves__+0x6>
    2a98:	5c 01       	movw	r10, r24
    2a9a:	96 2e       	mov	r9, r22
    2a9c:	7a 01       	movw	r14, r20
    2a9e:	f9 01       	movw	r30, r18
    2aa0:	8e 01       	movw	r16, r28
    2aa2:	0f 5f       	subi	r16, 0xFF	; 255
    2aa4:	1f 4f       	sbci	r17, 0xFF	; 255
    2aa6:	68 01       	movw	r12, r16
    2aa8:	80 e2       	ldi	r24, 0x20	; 32
    2aaa:	d8 01       	movw	r26, r16
    2aac:	1d 92       	st	X+, r1
    2aae:	8a 95       	dec	r24
    2ab0:	e9 f7       	brne	.-6      	; 0x2aac <conv_brk+0x20>
    2ab2:	d5 01       	movw	r26, r10
    2ab4:	13 96       	adiw	r26, 0x03	; 3
    2ab6:	8c 90       	ld	r8, X
    2ab8:	80 e0       	ldi	r24, 0x00	; 0
    2aba:	90 e0       	ldi	r25, 0x00	; 0
    2abc:	61 2c       	mov	r6, r1
    2abe:	71 2c       	mov	r7, r1
    2ac0:	30 e0       	ldi	r19, 0x00	; 0
    2ac2:	61 e0       	ldi	r22, 0x01	; 1
    2ac4:	70 e0       	ldi	r23, 0x00	; 0
    2ac6:	83 fc       	sbrc	r8, 3
    2ac8:	25 91       	lpm	r18, Z+
    2aca:	83 fe       	sbrs	r8, 3
    2acc:	21 91       	ld	r18, Z+
    2ace:	8f 01       	movw	r16, r30
    2ad0:	52 2e       	mov	r5, r18
    2ad2:	21 11       	cpse	r18, r1
    2ad4:	03 c0       	rjmp	.+6      	; 0x2adc <conv_brk+0x50>
    2ad6:	80 e0       	ldi	r24, 0x00	; 0
    2ad8:	90 e0       	ldi	r25, 0x00	; 0
    2ada:	92 c0       	rjmp	.+292    	; 0x2c00 <conv_brk+0x174>
    2adc:	2e 35       	cpi	r18, 0x5E	; 94
    2ade:	11 f4       	brne	.+4      	; 0x2ae4 <conv_brk+0x58>
    2ae0:	00 97       	sbiw	r24, 0x00	; 0
    2ae2:	51 f1       	breq	.+84     	; 0x2b38 <conv_brk+0xac>
    2ae4:	43 2f       	mov	r20, r19
    2ae6:	50 e0       	ldi	r21, 0x00	; 0
    2ae8:	48 17       	cp	r20, r24
    2aea:	59 07       	cpc	r21, r25
    2aec:	3c f4       	brge	.+14     	; 0x2afc <conv_brk+0x70>
    2aee:	2d 35       	cpi	r18, 0x5D	; 93
    2af0:	59 f1       	breq	.+86     	; 0x2b48 <conv_brk+0xbc>
    2af2:	2d 32       	cpi	r18, 0x2D	; 45
    2af4:	19 f4       	brne	.+6      	; 0x2afc <conv_brk+0x70>
    2af6:	77 20       	and	r7, r7
    2af8:	09 f1       	breq	.+66     	; 0x2b3c <conv_brk+0xb0>
    2afa:	03 c0       	rjmp	.+6      	; 0x2b02 <conv_brk+0x76>
    2afc:	77 20       	and	r7, r7
    2afe:	09 f4       	brne	.+2      	; 0x2b02 <conv_brk+0x76>
    2b00:	6a c0       	rjmp	.+212    	; 0x2bd6 <conv_brk+0x14a>
    2b02:	45 2d       	mov	r20, r5
    2b04:	46 95       	lsr	r20
    2b06:	46 95       	lsr	r20
    2b08:	46 95       	lsr	r20
    2b0a:	d6 01       	movw	r26, r12
    2b0c:	a4 0f       	add	r26, r20
    2b0e:	b1 1d       	adc	r27, r1
    2b10:	45 2d       	mov	r20, r5
    2b12:	47 70       	andi	r20, 0x07	; 7
    2b14:	8b 01       	movw	r16, r22
    2b16:	02 c0       	rjmp	.+4      	; 0x2b1c <conv_brk+0x90>
    2b18:	00 0f       	add	r16, r16
    2b1a:	11 1f       	adc	r17, r17
    2b1c:	4a 95       	dec	r20
    2b1e:	e2 f7       	brpl	.-8      	; 0x2b18 <conv_brk+0x8c>
    2b20:	a8 01       	movw	r20, r16
    2b22:	5c 91       	ld	r21, X
    2b24:	45 2b       	or	r20, r21
    2b26:	4c 93       	st	X, r20
    2b28:	65 14       	cp	r6, r5
    2b2a:	59 f0       	breq	.+22     	; 0x2b42 <conv_brk+0xb6>
    2b2c:	56 14       	cp	r5, r6
    2b2e:	10 f4       	brcc	.+4      	; 0x2b34 <conv_brk+0xa8>
    2b30:	53 94       	inc	r5
    2b32:	e7 cf       	rjmp	.-50     	; 0x2b02 <conv_brk+0x76>
    2b34:	5a 94       	dec	r5
    2b36:	e5 cf       	rjmp	.-54     	; 0x2b02 <conv_brk+0x76>
    2b38:	31 e0       	ldi	r19, 0x01	; 1
    2b3a:	04 c0       	rjmp	.+8      	; 0x2b44 <conv_brk+0xb8>
    2b3c:	77 24       	eor	r7, r7
    2b3e:	73 94       	inc	r7
    2b40:	01 c0       	rjmp	.+2      	; 0x2b44 <conv_brk+0xb8>
    2b42:	71 2c       	mov	r7, r1
    2b44:	01 96       	adiw	r24, 0x01	; 1
    2b46:	bf cf       	rjmp	.-130    	; 0x2ac6 <conv_brk+0x3a>
    2b48:	77 20       	and	r7, r7
    2b4a:	19 f0       	breq	.+6      	; 0x2b52 <conv_brk+0xc6>
    2b4c:	8e 81       	ldd	r24, Y+6	; 0x06
    2b4e:	80 62       	ori	r24, 0x20	; 32
    2b50:	8e 83       	std	Y+6, r24	; 0x06
    2b52:	31 11       	cpse	r19, r1
    2b54:	03 c0       	rjmp	.+6      	; 0x2b5c <conv_brk+0xd0>
    2b56:	88 24       	eor	r8, r8
    2b58:	83 94       	inc	r8
    2b5a:	17 c0       	rjmp	.+46     	; 0x2b8a <conv_brk+0xfe>
    2b5c:	f6 01       	movw	r30, r12
    2b5e:	9e 01       	movw	r18, r28
    2b60:	2f 5d       	subi	r18, 0xDF	; 223
    2b62:	3f 4f       	sbci	r19, 0xFF	; 255
    2b64:	80 81       	ld	r24, Z
    2b66:	80 95       	com	r24
    2b68:	81 93       	st	Z+, r24
    2b6a:	2e 17       	cp	r18, r30
    2b6c:	3f 07       	cpc	r19, r31
    2b6e:	d1 f7       	brne	.-12     	; 0x2b64 <conv_brk+0xd8>
    2b70:	f2 cf       	rjmp	.-28     	; 0x2b56 <conv_brk+0xca>
    2b72:	e1 14       	cp	r14, r1
    2b74:	f1 04       	cpc	r15, r1
    2b76:	29 f0       	breq	.+10     	; 0x2b82 <conv_brk+0xf6>
    2b78:	d7 01       	movw	r26, r14
    2b7a:	8c 93       	st	X, r24
    2b7c:	f7 01       	movw	r30, r14
    2b7e:	31 96       	adiw	r30, 0x01	; 1
    2b80:	7f 01       	movw	r14, r30
    2b82:	9a 94       	dec	r9
    2b84:	81 2c       	mov	r8, r1
    2b86:	99 20       	and	r9, r9
    2b88:	f9 f0       	breq	.+62     	; 0x2bc8 <conv_brk+0x13c>
    2b8a:	c5 01       	movw	r24, r10
    2b8c:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <fgetc>
    2b90:	97 fd       	sbrc	r25, 7
    2b92:	18 c0       	rjmp	.+48     	; 0x2bc4 <conv_brk+0x138>
    2b94:	fc 01       	movw	r30, r24
    2b96:	ff 27       	eor	r31, r31
    2b98:	23 e0       	ldi	r18, 0x03	; 3
    2b9a:	f5 95       	asr	r31
    2b9c:	e7 95       	ror	r30
    2b9e:	2a 95       	dec	r18
    2ba0:	e1 f7       	brne	.-8      	; 0x2b9a <conv_brk+0x10e>
    2ba2:	ec 0d       	add	r30, r12
    2ba4:	fd 1d       	adc	r31, r13
    2ba6:	20 81       	ld	r18, Z
    2ba8:	30 e0       	ldi	r19, 0x00	; 0
    2baa:	ac 01       	movw	r20, r24
    2bac:	47 70       	andi	r20, 0x07	; 7
    2bae:	55 27       	eor	r21, r21
    2bb0:	02 c0       	rjmp	.+4      	; 0x2bb6 <conv_brk+0x12a>
    2bb2:	35 95       	asr	r19
    2bb4:	27 95       	ror	r18
    2bb6:	4a 95       	dec	r20
    2bb8:	e2 f7       	brpl	.-8      	; 0x2bb2 <conv_brk+0x126>
    2bba:	20 fd       	sbrc	r18, 0
    2bbc:	da cf       	rjmp	.-76     	; 0x2b72 <conv_brk+0xe6>
    2bbe:	b5 01       	movw	r22, r10
    2bc0:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <ungetc>
    2bc4:	81 10       	cpse	r8, r1
    2bc6:	87 cf       	rjmp	.-242    	; 0x2ad6 <conv_brk+0x4a>
    2bc8:	e1 14       	cp	r14, r1
    2bca:	f1 04       	cpc	r15, r1
    2bcc:	11 f0       	breq	.+4      	; 0x2bd2 <conv_brk+0x146>
    2bce:	d7 01       	movw	r26, r14
    2bd0:	1c 92       	st	X, r1
    2bd2:	c8 01       	movw	r24, r16
    2bd4:	15 c0       	rjmp	.+42     	; 0x2c00 <conv_brk+0x174>
    2bd6:	42 2f       	mov	r20, r18
    2bd8:	46 95       	lsr	r20
    2bda:	46 95       	lsr	r20
    2bdc:	46 95       	lsr	r20
    2bde:	d6 01       	movw	r26, r12
    2be0:	a4 0f       	add	r26, r20
    2be2:	b1 1d       	adc	r27, r1
    2be4:	42 2f       	mov	r20, r18
    2be6:	47 70       	andi	r20, 0x07	; 7
    2be8:	8b 01       	movw	r16, r22
    2bea:	02 c0       	rjmp	.+4      	; 0x2bf0 <conv_brk+0x164>
    2bec:	00 0f       	add	r16, r16
    2bee:	11 1f       	adc	r17, r17
    2bf0:	4a 95       	dec	r20
    2bf2:	e2 f7       	brpl	.-8      	; 0x2bec <conv_brk+0x160>
    2bf4:	a8 01       	movw	r20, r16
    2bf6:	5c 91       	ld	r21, X
    2bf8:	45 2b       	or	r20, r21
    2bfa:	4c 93       	st	X, r20
    2bfc:	62 2e       	mov	r6, r18
    2bfe:	a2 cf       	rjmp	.-188    	; 0x2b44 <conv_brk+0xb8>
    2c00:	a0 96       	adiw	r28, 0x20	; 32
    2c02:	ef e0       	ldi	r30, 0x0F	; 15
    2c04:	0c 94 52 18 	jmp	0x30a4	; 0x30a4 <__epilogue_restores__+0x6>

00002c08 <vfscanf>:
    2c08:	a0 e0       	ldi	r26, 0x00	; 0
    2c0a:	b0 e0       	ldi	r27, 0x00	; 0
    2c0c:	ea e0       	ldi	r30, 0x0A	; 10
    2c0e:	f6 e1       	ldi	r31, 0x16	; 22
    2c10:	0c 94 36 18 	jmp	0x306c	; 0x306c <__prologue_saves__+0x6>
    2c14:	6c 01       	movw	r12, r24
    2c16:	eb 01       	movw	r28, r22
    2c18:	5a 01       	movw	r10, r20
    2c1a:	fc 01       	movw	r30, r24
    2c1c:	17 82       	std	Z+7, r1	; 0x07
    2c1e:	16 82       	std	Z+6, r1	; 0x06
    2c20:	51 2c       	mov	r5, r1
    2c22:	f6 01       	movw	r30, r12
    2c24:	e3 80       	ldd	r14, Z+3	; 0x03
    2c26:	fe 01       	movw	r30, r28
    2c28:	e3 fc       	sbrc	r14, 3
    2c2a:	85 91       	lpm	r24, Z+
    2c2c:	e3 fe       	sbrs	r14, 3
    2c2e:	81 91       	ld	r24, Z+
    2c30:	18 2f       	mov	r17, r24
    2c32:	ef 01       	movw	r28, r30
    2c34:	88 23       	and	r24, r24
    2c36:	09 f4       	brne	.+2      	; 0x2c3a <vfscanf+0x32>
    2c38:	ee c0       	rjmp	.+476    	; 0x2e16 <vfscanf+0x20e>
    2c3a:	90 e0       	ldi	r25, 0x00	; 0
    2c3c:	0e 94 15 17 	call	0x2e2a	; 0x2e2a <isspace>
    2c40:	89 2b       	or	r24, r25
    2c42:	21 f0       	breq	.+8      	; 0x2c4c <vfscanf+0x44>
    2c44:	c6 01       	movw	r24, r12
    2c46:	0e 94 9b 14 	call	0x2936	; 0x2936 <skip_spaces>
    2c4a:	eb cf       	rjmp	.-42     	; 0x2c22 <vfscanf+0x1a>
    2c4c:	15 32       	cpi	r17, 0x25	; 37
    2c4e:	41 f4       	brne	.+16     	; 0x2c60 <vfscanf+0x58>
    2c50:	fe 01       	movw	r30, r28
    2c52:	e3 fc       	sbrc	r14, 3
    2c54:	15 91       	lpm	r17, Z+
    2c56:	e3 fe       	sbrs	r14, 3
    2c58:	11 91       	ld	r17, Z+
    2c5a:	ef 01       	movw	r28, r30
    2c5c:	15 32       	cpi	r17, 0x25	; 37
    2c5e:	81 f4       	brne	.+32     	; 0x2c80 <vfscanf+0x78>
    2c60:	c6 01       	movw	r24, r12
    2c62:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <fgetc>
    2c66:	97 fd       	sbrc	r25, 7
    2c68:	d4 c0       	rjmp	.+424    	; 0x2e12 <vfscanf+0x20a>
    2c6a:	41 2f       	mov	r20, r17
    2c6c:	50 e0       	ldi	r21, 0x00	; 0
    2c6e:	9c 01       	movw	r18, r24
    2c70:	33 27       	eor	r19, r19
    2c72:	24 17       	cp	r18, r20
    2c74:	35 07       	cpc	r19, r21
    2c76:	a9 f2       	breq	.-86     	; 0x2c22 <vfscanf+0x1a>
    2c78:	b6 01       	movw	r22, r12
    2c7a:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <ungetc>
    2c7e:	cb c0       	rjmp	.+406    	; 0x2e16 <vfscanf+0x20e>
    2c80:	1a 32       	cpi	r17, 0x2A	; 42
    2c82:	39 f4       	brne	.+14     	; 0x2c92 <vfscanf+0x8a>
    2c84:	e3 fc       	sbrc	r14, 3
    2c86:	15 91       	lpm	r17, Z+
    2c88:	e3 fe       	sbrs	r14, 3
    2c8a:	11 91       	ld	r17, Z+
    2c8c:	ef 01       	movw	r28, r30
    2c8e:	01 e0       	ldi	r16, 0x01	; 1
    2c90:	01 c0       	rjmp	.+2      	; 0x2c94 <vfscanf+0x8c>
    2c92:	00 e0       	ldi	r16, 0x00	; 0
    2c94:	f1 2c       	mov	r15, r1
    2c96:	20 ed       	ldi	r18, 0xD0	; 208
    2c98:	21 0f       	add	r18, r17
    2c9a:	2a 30       	cpi	r18, 0x0A	; 10
    2c9c:	80 f4       	brcc	.+32     	; 0x2cbe <vfscanf+0xb6>
    2c9e:	02 60       	ori	r16, 0x02	; 2
    2ca0:	6f 2d       	mov	r22, r15
    2ca2:	70 e0       	ldi	r23, 0x00	; 0
    2ca4:	80 e0       	ldi	r24, 0x00	; 0
    2ca6:	90 e0       	ldi	r25, 0x00	; 0
    2ca8:	40 e2       	ldi	r20, 0x20	; 32
    2caa:	0e 94 74 14 	call	0x28e8	; 0x28e8 <mulacc>
    2cae:	f6 2e       	mov	r15, r22
    2cb0:	fe 01       	movw	r30, r28
    2cb2:	e3 fc       	sbrc	r14, 3
    2cb4:	15 91       	lpm	r17, Z+
    2cb6:	e3 fe       	sbrs	r14, 3
    2cb8:	11 91       	ld	r17, Z+
    2cba:	ef 01       	movw	r28, r30
    2cbc:	ec cf       	rjmp	.-40     	; 0x2c96 <vfscanf+0x8e>
    2cbe:	01 ff       	sbrs	r16, 1
    2cc0:	03 c0       	rjmp	.+6      	; 0x2cc8 <vfscanf+0xc0>
    2cc2:	f1 10       	cpse	r15, r1
    2cc4:	03 c0       	rjmp	.+6      	; 0x2ccc <vfscanf+0xc4>
    2cc6:	a7 c0       	rjmp	.+334    	; 0x2e16 <vfscanf+0x20e>
    2cc8:	ff 24       	eor	r15, r15
    2cca:	fa 94       	dec	r15
    2ccc:	18 36       	cpi	r17, 0x68	; 104
    2cce:	19 f0       	breq	.+6      	; 0x2cd6 <vfscanf+0xce>
    2cd0:	1c 36       	cpi	r17, 0x6C	; 108
    2cd2:	51 f0       	breq	.+20     	; 0x2ce8 <vfscanf+0xe0>
    2cd4:	10 c0       	rjmp	.+32     	; 0x2cf6 <vfscanf+0xee>
    2cd6:	fe 01       	movw	r30, r28
    2cd8:	e3 fc       	sbrc	r14, 3
    2cda:	15 91       	lpm	r17, Z+
    2cdc:	e3 fe       	sbrs	r14, 3
    2cde:	11 91       	ld	r17, Z+
    2ce0:	ef 01       	movw	r28, r30
    2ce2:	18 36       	cpi	r17, 0x68	; 104
    2ce4:	41 f4       	brne	.+16     	; 0x2cf6 <vfscanf+0xee>
    2ce6:	08 60       	ori	r16, 0x08	; 8
    2ce8:	04 60       	ori	r16, 0x04	; 4
    2cea:	fe 01       	movw	r30, r28
    2cec:	e3 fc       	sbrc	r14, 3
    2cee:	15 91       	lpm	r17, Z+
    2cf0:	e3 fe       	sbrs	r14, 3
    2cf2:	11 91       	ld	r17, Z+
    2cf4:	ef 01       	movw	r28, r30
    2cf6:	11 23       	and	r17, r17
    2cf8:	09 f4       	brne	.+2      	; 0x2cfc <vfscanf+0xf4>
    2cfa:	8d c0       	rjmp	.+282    	; 0x2e16 <vfscanf+0x20e>
    2cfc:	61 2f       	mov	r22, r17
    2cfe:	70 e0       	ldi	r23, 0x00	; 0
    2d00:	88 e6       	ldi	r24, 0x68	; 104
    2d02:	90 e0       	ldi	r25, 0x00	; 0
    2d04:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <strchr_P>
    2d08:	89 2b       	or	r24, r25
    2d0a:	09 f4       	brne	.+2      	; 0x2d0e <vfscanf+0x106>
    2d0c:	84 c0       	rjmp	.+264    	; 0x2e16 <vfscanf+0x20e>
    2d0e:	00 fd       	sbrc	r16, 0
    2d10:	07 c0       	rjmp	.+14     	; 0x2d20 <vfscanf+0x118>
    2d12:	f5 01       	movw	r30, r10
    2d14:	80 80       	ld	r8, Z
    2d16:	91 80       	ldd	r9, Z+1	; 0x01
    2d18:	c5 01       	movw	r24, r10
    2d1a:	02 96       	adiw	r24, 0x02	; 2
    2d1c:	5c 01       	movw	r10, r24
    2d1e:	02 c0       	rjmp	.+4      	; 0x2d24 <vfscanf+0x11c>
    2d20:	81 2c       	mov	r8, r1
    2d22:	91 2c       	mov	r9, r1
    2d24:	1e 36       	cpi	r17, 0x6E	; 110
    2d26:	51 f4       	brne	.+20     	; 0x2d3c <vfscanf+0x134>
    2d28:	f6 01       	movw	r30, r12
    2d2a:	46 81       	ldd	r20, Z+6	; 0x06
    2d2c:	57 81       	ldd	r21, Z+7	; 0x07
    2d2e:	60 e0       	ldi	r22, 0x00	; 0
    2d30:	70 e0       	ldi	r23, 0x00	; 0
    2d32:	20 2f       	mov	r18, r16
    2d34:	c4 01       	movw	r24, r8
    2d36:	0e 94 68 14 	call	0x28d0	; 0x28d0 <putval>
    2d3a:	73 cf       	rjmp	.-282    	; 0x2c22 <vfscanf+0x1a>
    2d3c:	13 36       	cpi	r17, 0x63	; 99
    2d3e:	a9 f4       	brne	.+42     	; 0x2d6a <vfscanf+0x162>
    2d40:	01 fd       	sbrc	r16, 1
    2d42:	02 c0       	rjmp	.+4      	; 0x2d48 <vfscanf+0x140>
    2d44:	ff 24       	eor	r15, r15
    2d46:	f3 94       	inc	r15
    2d48:	c6 01       	movw	r24, r12
    2d4a:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <fgetc>
    2d4e:	97 fd       	sbrc	r25, 7
    2d50:	60 c0       	rjmp	.+192    	; 0x2e12 <vfscanf+0x20a>
    2d52:	81 14       	cp	r8, r1
    2d54:	91 04       	cpc	r9, r1
    2d56:	29 f0       	breq	.+10     	; 0x2d62 <vfscanf+0x15a>
    2d58:	f4 01       	movw	r30, r8
    2d5a:	80 83       	st	Z, r24
    2d5c:	c4 01       	movw	r24, r8
    2d5e:	01 96       	adiw	r24, 0x01	; 1
    2d60:	4c 01       	movw	r8, r24
    2d62:	fa 94       	dec	r15
    2d64:	f1 10       	cpse	r15, r1
    2d66:	f0 cf       	rjmp	.-32     	; 0x2d48 <vfscanf+0x140>
    2d68:	50 c0       	rjmp	.+160    	; 0x2e0a <vfscanf+0x202>
    2d6a:	1b 35       	cpi	r17, 0x5B	; 91
    2d6c:	59 f4       	brne	.+22     	; 0x2d84 <vfscanf+0x17c>
    2d6e:	9e 01       	movw	r18, r28
    2d70:	a4 01       	movw	r20, r8
    2d72:	6f 2d       	mov	r22, r15
    2d74:	c6 01       	movw	r24, r12
    2d76:	0e 94 46 15 	call	0x2a8c	; 0x2a8c <conv_brk>
    2d7a:	ec 01       	movw	r28, r24
    2d7c:	89 2b       	or	r24, r25
    2d7e:	09 f0       	breq	.+2      	; 0x2d82 <vfscanf+0x17a>
    2d80:	44 c0       	rjmp	.+136    	; 0x2e0a <vfscanf+0x202>
    2d82:	3e c0       	rjmp	.+124    	; 0x2e00 <vfscanf+0x1f8>
    2d84:	c6 01       	movw	r24, r12
    2d86:	0e 94 9b 14 	call	0x2936	; 0x2936 <skip_spaces>
    2d8a:	97 fd       	sbrc	r25, 7
    2d8c:	42 c0       	rjmp	.+132    	; 0x2e12 <vfscanf+0x20a>
    2d8e:	1f 36       	cpi	r17, 0x6F	; 111
    2d90:	61 f1       	breq	.+88     	; 0x2dea <vfscanf+0x1e2>
    2d92:	28 f4       	brcc	.+10     	; 0x2d9e <vfscanf+0x196>
    2d94:	14 36       	cpi	r17, 0x64	; 100
    2d96:	39 f1       	breq	.+78     	; 0x2de6 <vfscanf+0x1de>
    2d98:	19 36       	cpi	r17, 0x69	; 105
    2d9a:	51 f1       	breq	.+84     	; 0x2df0 <vfscanf+0x1e8>
    2d9c:	28 c0       	rjmp	.+80     	; 0x2dee <vfscanf+0x1e6>
    2d9e:	13 37       	cpi	r17, 0x73	; 115
    2da0:	71 f0       	breq	.+28     	; 0x2dbe <vfscanf+0x1b6>
    2da2:	15 37       	cpi	r17, 0x75	; 117
    2da4:	01 f1       	breq	.+64     	; 0x2de6 <vfscanf+0x1de>
    2da6:	23 c0       	rjmp	.+70     	; 0x2dee <vfscanf+0x1e6>
    2da8:	81 14       	cp	r8, r1
    2daa:	91 04       	cpc	r9, r1
    2dac:	29 f0       	breq	.+10     	; 0x2db8 <vfscanf+0x1b0>
    2dae:	f4 01       	movw	r30, r8
    2db0:	60 82       	st	Z, r6
    2db2:	c4 01       	movw	r24, r8
    2db4:	01 96       	adiw	r24, 0x01	; 1
    2db6:	4c 01       	movw	r8, r24
    2db8:	fa 94       	dec	r15
    2dba:	ff 20       	and	r15, r15
    2dbc:	71 f0       	breq	.+28     	; 0x2dda <vfscanf+0x1d2>
    2dbe:	c6 01       	movw	r24, r12
    2dc0:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <fgetc>
    2dc4:	3c 01       	movw	r6, r24
    2dc6:	97 fd       	sbrc	r25, 7
    2dc8:	08 c0       	rjmp	.+16     	; 0x2dda <vfscanf+0x1d2>
    2dca:	0e 94 15 17 	call	0x2e2a	; 0x2e2a <isspace>
    2dce:	89 2b       	or	r24, r25
    2dd0:	59 f3       	breq	.-42     	; 0x2da8 <vfscanf+0x1a0>
    2dd2:	b6 01       	movw	r22, r12
    2dd4:	c3 01       	movw	r24, r6
    2dd6:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <ungetc>
    2dda:	81 14       	cp	r8, r1
    2ddc:	91 04       	cpc	r9, r1
    2dde:	a9 f0       	breq	.+42     	; 0x2e0a <vfscanf+0x202>
    2de0:	f4 01       	movw	r30, r8
    2de2:	10 82       	st	Z, r1
    2de4:	12 c0       	rjmp	.+36     	; 0x2e0a <vfscanf+0x202>
    2de6:	00 62       	ori	r16, 0x20	; 32
    2de8:	03 c0       	rjmp	.+6      	; 0x2df0 <vfscanf+0x1e8>
    2dea:	00 61       	ori	r16, 0x10	; 16
    2dec:	01 c0       	rjmp	.+2      	; 0x2df0 <vfscanf+0x1e8>
    2dee:	00 64       	ori	r16, 0x40	; 64
    2df0:	20 2f       	mov	r18, r16
    2df2:	a4 01       	movw	r20, r8
    2df4:	6f 2d       	mov	r22, r15
    2df6:	c6 01       	movw	r24, r12
    2df8:	0e 94 b4 14 	call	0x2968	; 0x2968 <conv_int>
    2dfc:	81 11       	cpse	r24, r1
    2dfe:	05 c0       	rjmp	.+10     	; 0x2e0a <vfscanf+0x202>
    2e00:	f6 01       	movw	r30, r12
    2e02:	83 81       	ldd	r24, Z+3	; 0x03
    2e04:	80 73       	andi	r24, 0x30	; 48
    2e06:	29 f4       	brne	.+10     	; 0x2e12 <vfscanf+0x20a>
    2e08:	06 c0       	rjmp	.+12     	; 0x2e16 <vfscanf+0x20e>
    2e0a:	00 fd       	sbrc	r16, 0
    2e0c:	0a cf       	rjmp	.-492    	; 0x2c22 <vfscanf+0x1a>
    2e0e:	53 94       	inc	r5
    2e10:	08 cf       	rjmp	.-496    	; 0x2c22 <vfscanf+0x1a>
    2e12:	55 20       	and	r5, r5
    2e14:	19 f0       	breq	.+6      	; 0x2e1c <vfscanf+0x214>
    2e16:	85 2d       	mov	r24, r5
    2e18:	90 e0       	ldi	r25, 0x00	; 0
    2e1a:	02 c0       	rjmp	.+4      	; 0x2e20 <vfscanf+0x218>
    2e1c:	8f ef       	ldi	r24, 0xFF	; 255
    2e1e:	9f ef       	ldi	r25, 0xFF	; 255
    2e20:	cd b7       	in	r28, 0x3d	; 61
    2e22:	de b7       	in	r29, 0x3e	; 62
    2e24:	ef e0       	ldi	r30, 0x0F	; 15
    2e26:	0c 94 52 18 	jmp	0x30a4	; 0x30a4 <__epilogue_restores__+0x6>

00002e2a <isspace>:
    2e2a:	91 11       	cpse	r25, r1
    2e2c:	0c 94 30 18 	jmp	0x3060	; 0x3060 <__ctype_isfalse>
    2e30:	80 32       	cpi	r24, 0x20	; 32
    2e32:	19 f0       	breq	.+6      	; 0x2e3a <isspace+0x10>
    2e34:	89 50       	subi	r24, 0x09	; 9
    2e36:	85 50       	subi	r24, 0x05	; 5
    2e38:	c8 f7       	brcc	.-14     	; 0x2e2c <isspace+0x2>
    2e3a:	08 95       	ret

00002e3c <strchr_P>:
    2e3c:	fc 01       	movw	r30, r24
    2e3e:	05 90       	lpm	r0, Z+
    2e40:	06 16       	cp	r0, r22
    2e42:	21 f0       	breq	.+8      	; 0x2e4c <strchr_P+0x10>
    2e44:	00 20       	and	r0, r0
    2e46:	d9 f7       	brne	.-10     	; 0x2e3e <strchr_P+0x2>
    2e48:	c0 01       	movw	r24, r0
    2e4a:	08 95       	ret
    2e4c:	31 97       	sbiw	r30, 0x01	; 1
    2e4e:	cf 01       	movw	r24, r30
    2e50:	08 95       	ret

00002e52 <strnlen_P>:
    2e52:	fc 01       	movw	r30, r24
    2e54:	05 90       	lpm	r0, Z+
    2e56:	61 50       	subi	r22, 0x01	; 1
    2e58:	70 40       	sbci	r23, 0x00	; 0
    2e5a:	01 10       	cpse	r0, r1
    2e5c:	d8 f7       	brcc	.-10     	; 0x2e54 <strnlen_P+0x2>
    2e5e:	80 95       	com	r24
    2e60:	90 95       	com	r25
    2e62:	8e 0f       	add	r24, r30
    2e64:	9f 1f       	adc	r25, r31
    2e66:	08 95       	ret

00002e68 <strnlen>:
    2e68:	fc 01       	movw	r30, r24
    2e6a:	61 50       	subi	r22, 0x01	; 1
    2e6c:	70 40       	sbci	r23, 0x00	; 0
    2e6e:	01 90       	ld	r0, Z+
    2e70:	01 10       	cpse	r0, r1
    2e72:	d8 f7       	brcc	.-10     	; 0x2e6a <strnlen+0x2>
    2e74:	80 95       	com	r24
    2e76:	90 95       	com	r25
    2e78:	8e 0f       	add	r24, r30
    2e7a:	9f 1f       	adc	r25, r31
    2e7c:	08 95       	ret

00002e7e <fgetc>:
    2e7e:	cf 93       	push	r28
    2e80:	df 93       	push	r29
    2e82:	ec 01       	movw	r28, r24
    2e84:	2b 81       	ldd	r18, Y+3	; 0x03
    2e86:	20 ff       	sbrs	r18, 0
    2e88:	33 c0       	rjmp	.+102    	; 0x2ef0 <fgetc+0x72>
    2e8a:	26 ff       	sbrs	r18, 6
    2e8c:	0a c0       	rjmp	.+20     	; 0x2ea2 <fgetc+0x24>
    2e8e:	2f 7b       	andi	r18, 0xBF	; 191
    2e90:	2b 83       	std	Y+3, r18	; 0x03
    2e92:	8e 81       	ldd	r24, Y+6	; 0x06
    2e94:	9f 81       	ldd	r25, Y+7	; 0x07
    2e96:	01 96       	adiw	r24, 0x01	; 1
    2e98:	9f 83       	std	Y+7, r25	; 0x07
    2e9a:	8e 83       	std	Y+6, r24	; 0x06
    2e9c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e9e:	90 e0       	ldi	r25, 0x00	; 0
    2ea0:	29 c0       	rjmp	.+82     	; 0x2ef4 <fgetc+0x76>
    2ea2:	22 ff       	sbrs	r18, 2
    2ea4:	0f c0       	rjmp	.+30     	; 0x2ec4 <fgetc+0x46>
    2ea6:	e8 81       	ld	r30, Y
    2ea8:	f9 81       	ldd	r31, Y+1	; 0x01
    2eaa:	80 81       	ld	r24, Z
    2eac:	08 2e       	mov	r0, r24
    2eae:	00 0c       	add	r0, r0
    2eb0:	99 0b       	sbc	r25, r25
    2eb2:	00 97       	sbiw	r24, 0x00	; 0
    2eb4:	19 f4       	brne	.+6      	; 0x2ebc <fgetc+0x3e>
    2eb6:	20 62       	ori	r18, 0x20	; 32
    2eb8:	2b 83       	std	Y+3, r18	; 0x03
    2eba:	1a c0       	rjmp	.+52     	; 0x2ef0 <fgetc+0x72>
    2ebc:	31 96       	adiw	r30, 0x01	; 1
    2ebe:	f9 83       	std	Y+1, r31	; 0x01
    2ec0:	e8 83       	st	Y, r30
    2ec2:	0e c0       	rjmp	.+28     	; 0x2ee0 <fgetc+0x62>
    2ec4:	ea 85       	ldd	r30, Y+10	; 0x0a
    2ec6:	fb 85       	ldd	r31, Y+11	; 0x0b
    2ec8:	09 95       	icall
    2eca:	97 ff       	sbrs	r25, 7
    2ecc:	09 c0       	rjmp	.+18     	; 0x2ee0 <fgetc+0x62>
    2ece:	2b 81       	ldd	r18, Y+3	; 0x03
    2ed0:	01 96       	adiw	r24, 0x01	; 1
    2ed2:	11 f0       	breq	.+4      	; 0x2ed8 <fgetc+0x5a>
    2ed4:	80 e2       	ldi	r24, 0x20	; 32
    2ed6:	01 c0       	rjmp	.+2      	; 0x2eda <fgetc+0x5c>
    2ed8:	80 e1       	ldi	r24, 0x10	; 16
    2eda:	82 2b       	or	r24, r18
    2edc:	8b 83       	std	Y+3, r24	; 0x03
    2ede:	08 c0       	rjmp	.+16     	; 0x2ef0 <fgetc+0x72>
    2ee0:	2e 81       	ldd	r18, Y+6	; 0x06
    2ee2:	3f 81       	ldd	r19, Y+7	; 0x07
    2ee4:	2f 5f       	subi	r18, 0xFF	; 255
    2ee6:	3f 4f       	sbci	r19, 0xFF	; 255
    2ee8:	3f 83       	std	Y+7, r19	; 0x07
    2eea:	2e 83       	std	Y+6, r18	; 0x06
    2eec:	99 27       	eor	r25, r25
    2eee:	02 c0       	rjmp	.+4      	; 0x2ef4 <fgetc+0x76>
    2ef0:	8f ef       	ldi	r24, 0xFF	; 255
    2ef2:	9f ef       	ldi	r25, 0xFF	; 255
    2ef4:	df 91       	pop	r29
    2ef6:	cf 91       	pop	r28
    2ef8:	08 95       	ret

00002efa <fputc>:
    2efa:	0f 93       	push	r16
    2efc:	1f 93       	push	r17
    2efe:	cf 93       	push	r28
    2f00:	df 93       	push	r29
    2f02:	fb 01       	movw	r30, r22
    2f04:	23 81       	ldd	r18, Z+3	; 0x03
    2f06:	21 fd       	sbrc	r18, 1
    2f08:	03 c0       	rjmp	.+6      	; 0x2f10 <fputc+0x16>
    2f0a:	8f ef       	ldi	r24, 0xFF	; 255
    2f0c:	9f ef       	ldi	r25, 0xFF	; 255
    2f0e:	2c c0       	rjmp	.+88     	; 0x2f68 <fputc+0x6e>
    2f10:	22 ff       	sbrs	r18, 2
    2f12:	16 c0       	rjmp	.+44     	; 0x2f40 <fputc+0x46>
    2f14:	46 81       	ldd	r20, Z+6	; 0x06
    2f16:	57 81       	ldd	r21, Z+7	; 0x07
    2f18:	24 81       	ldd	r18, Z+4	; 0x04
    2f1a:	35 81       	ldd	r19, Z+5	; 0x05
    2f1c:	42 17       	cp	r20, r18
    2f1e:	53 07       	cpc	r21, r19
    2f20:	44 f4       	brge	.+16     	; 0x2f32 <fputc+0x38>
    2f22:	a0 81       	ld	r26, Z
    2f24:	b1 81       	ldd	r27, Z+1	; 0x01
    2f26:	9d 01       	movw	r18, r26
    2f28:	2f 5f       	subi	r18, 0xFF	; 255
    2f2a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f2c:	31 83       	std	Z+1, r19	; 0x01
    2f2e:	20 83       	st	Z, r18
    2f30:	8c 93       	st	X, r24
    2f32:	26 81       	ldd	r18, Z+6	; 0x06
    2f34:	37 81       	ldd	r19, Z+7	; 0x07
    2f36:	2f 5f       	subi	r18, 0xFF	; 255
    2f38:	3f 4f       	sbci	r19, 0xFF	; 255
    2f3a:	37 83       	std	Z+7, r19	; 0x07
    2f3c:	26 83       	std	Z+6, r18	; 0x06
    2f3e:	14 c0       	rjmp	.+40     	; 0x2f68 <fputc+0x6e>
    2f40:	8b 01       	movw	r16, r22
    2f42:	ec 01       	movw	r28, r24
    2f44:	fb 01       	movw	r30, r22
    2f46:	00 84       	ldd	r0, Z+8	; 0x08
    2f48:	f1 85       	ldd	r31, Z+9	; 0x09
    2f4a:	e0 2d       	mov	r30, r0
    2f4c:	09 95       	icall
    2f4e:	89 2b       	or	r24, r25
    2f50:	e1 f6       	brne	.-72     	; 0x2f0a <fputc+0x10>
    2f52:	d8 01       	movw	r26, r16
    2f54:	16 96       	adiw	r26, 0x06	; 6
    2f56:	8d 91       	ld	r24, X+
    2f58:	9c 91       	ld	r25, X
    2f5a:	17 97       	sbiw	r26, 0x07	; 7
    2f5c:	01 96       	adiw	r24, 0x01	; 1
    2f5e:	17 96       	adiw	r26, 0x07	; 7
    2f60:	9c 93       	st	X, r25
    2f62:	8e 93       	st	-X, r24
    2f64:	16 97       	sbiw	r26, 0x06	; 6
    2f66:	ce 01       	movw	r24, r28
    2f68:	df 91       	pop	r29
    2f6a:	cf 91       	pop	r28
    2f6c:	1f 91       	pop	r17
    2f6e:	0f 91       	pop	r16
    2f70:	08 95       	ret

00002f72 <ungetc>:
    2f72:	fb 01       	movw	r30, r22
    2f74:	23 81       	ldd	r18, Z+3	; 0x03
    2f76:	20 ff       	sbrs	r18, 0
    2f78:	12 c0       	rjmp	.+36     	; 0x2f9e <ungetc+0x2c>
    2f7a:	26 fd       	sbrc	r18, 6
    2f7c:	10 c0       	rjmp	.+32     	; 0x2f9e <ungetc+0x2c>
    2f7e:	8f 3f       	cpi	r24, 0xFF	; 255
    2f80:	3f ef       	ldi	r19, 0xFF	; 255
    2f82:	93 07       	cpc	r25, r19
    2f84:	61 f0       	breq	.+24     	; 0x2f9e <ungetc+0x2c>
    2f86:	82 83       	std	Z+2, r24	; 0x02
    2f88:	2f 7d       	andi	r18, 0xDF	; 223
    2f8a:	20 64       	ori	r18, 0x40	; 64
    2f8c:	23 83       	std	Z+3, r18	; 0x03
    2f8e:	26 81       	ldd	r18, Z+6	; 0x06
    2f90:	37 81       	ldd	r19, Z+7	; 0x07
    2f92:	21 50       	subi	r18, 0x01	; 1
    2f94:	31 09       	sbc	r19, r1
    2f96:	37 83       	std	Z+7, r19	; 0x07
    2f98:	26 83       	std	Z+6, r18	; 0x06
    2f9a:	99 27       	eor	r25, r25
    2f9c:	08 95       	ret
    2f9e:	8f ef       	ldi	r24, 0xFF	; 255
    2fa0:	9f ef       	ldi	r25, 0xFF	; 255
    2fa2:	08 95       	ret

00002fa4 <__ultoa_invert>:
    2fa4:	fa 01       	movw	r30, r20
    2fa6:	aa 27       	eor	r26, r26
    2fa8:	28 30       	cpi	r18, 0x08	; 8
    2faa:	51 f1       	breq	.+84     	; 0x3000 <__ultoa_invert+0x5c>
    2fac:	20 31       	cpi	r18, 0x10	; 16
    2fae:	81 f1       	breq	.+96     	; 0x3010 <__ultoa_invert+0x6c>
    2fb0:	e8 94       	clt
    2fb2:	6f 93       	push	r22
    2fb4:	6e 7f       	andi	r22, 0xFE	; 254
    2fb6:	6e 5f       	subi	r22, 0xFE	; 254
    2fb8:	7f 4f       	sbci	r23, 0xFF	; 255
    2fba:	8f 4f       	sbci	r24, 0xFF	; 255
    2fbc:	9f 4f       	sbci	r25, 0xFF	; 255
    2fbe:	af 4f       	sbci	r26, 0xFF	; 255
    2fc0:	b1 e0       	ldi	r27, 0x01	; 1
    2fc2:	3e d0       	rcall	.+124    	; 0x3040 <__ultoa_invert+0x9c>
    2fc4:	b4 e0       	ldi	r27, 0x04	; 4
    2fc6:	3c d0       	rcall	.+120    	; 0x3040 <__ultoa_invert+0x9c>
    2fc8:	67 0f       	add	r22, r23
    2fca:	78 1f       	adc	r23, r24
    2fcc:	89 1f       	adc	r24, r25
    2fce:	9a 1f       	adc	r25, r26
    2fd0:	a1 1d       	adc	r26, r1
    2fd2:	68 0f       	add	r22, r24
    2fd4:	79 1f       	adc	r23, r25
    2fd6:	8a 1f       	adc	r24, r26
    2fd8:	91 1d       	adc	r25, r1
    2fda:	a1 1d       	adc	r26, r1
    2fdc:	6a 0f       	add	r22, r26
    2fde:	71 1d       	adc	r23, r1
    2fe0:	81 1d       	adc	r24, r1
    2fe2:	91 1d       	adc	r25, r1
    2fe4:	a1 1d       	adc	r26, r1
    2fe6:	20 d0       	rcall	.+64     	; 0x3028 <__ultoa_invert+0x84>
    2fe8:	09 f4       	brne	.+2      	; 0x2fec <__ultoa_invert+0x48>
    2fea:	68 94       	set
    2fec:	3f 91       	pop	r19
    2fee:	2a e0       	ldi	r18, 0x0A	; 10
    2ff0:	26 9f       	mul	r18, r22
    2ff2:	11 24       	eor	r1, r1
    2ff4:	30 19       	sub	r19, r0
    2ff6:	30 5d       	subi	r19, 0xD0	; 208
    2ff8:	31 93       	st	Z+, r19
    2ffa:	de f6       	brtc	.-74     	; 0x2fb2 <__ultoa_invert+0xe>
    2ffc:	cf 01       	movw	r24, r30
    2ffe:	08 95       	ret
    3000:	46 2f       	mov	r20, r22
    3002:	47 70       	andi	r20, 0x07	; 7
    3004:	40 5d       	subi	r20, 0xD0	; 208
    3006:	41 93       	st	Z+, r20
    3008:	b3 e0       	ldi	r27, 0x03	; 3
    300a:	0f d0       	rcall	.+30     	; 0x302a <__ultoa_invert+0x86>
    300c:	c9 f7       	brne	.-14     	; 0x3000 <__ultoa_invert+0x5c>
    300e:	f6 cf       	rjmp	.-20     	; 0x2ffc <__ultoa_invert+0x58>
    3010:	46 2f       	mov	r20, r22
    3012:	4f 70       	andi	r20, 0x0F	; 15
    3014:	40 5d       	subi	r20, 0xD0	; 208
    3016:	4a 33       	cpi	r20, 0x3A	; 58
    3018:	18 f0       	brcs	.+6      	; 0x3020 <__ultoa_invert+0x7c>
    301a:	49 5d       	subi	r20, 0xD9	; 217
    301c:	31 fd       	sbrc	r19, 1
    301e:	40 52       	subi	r20, 0x20	; 32
    3020:	41 93       	st	Z+, r20
    3022:	02 d0       	rcall	.+4      	; 0x3028 <__ultoa_invert+0x84>
    3024:	a9 f7       	brne	.-22     	; 0x3010 <__ultoa_invert+0x6c>
    3026:	ea cf       	rjmp	.-44     	; 0x2ffc <__ultoa_invert+0x58>
    3028:	b4 e0       	ldi	r27, 0x04	; 4
    302a:	a6 95       	lsr	r26
    302c:	97 95       	ror	r25
    302e:	87 95       	ror	r24
    3030:	77 95       	ror	r23
    3032:	67 95       	ror	r22
    3034:	ba 95       	dec	r27
    3036:	c9 f7       	brne	.-14     	; 0x302a <__ultoa_invert+0x86>
    3038:	00 97       	sbiw	r24, 0x00	; 0
    303a:	61 05       	cpc	r22, r1
    303c:	71 05       	cpc	r23, r1
    303e:	08 95       	ret
    3040:	9b 01       	movw	r18, r22
    3042:	ac 01       	movw	r20, r24
    3044:	0a 2e       	mov	r0, r26
    3046:	06 94       	lsr	r0
    3048:	57 95       	ror	r21
    304a:	47 95       	ror	r20
    304c:	37 95       	ror	r19
    304e:	27 95       	ror	r18
    3050:	ba 95       	dec	r27
    3052:	c9 f7       	brne	.-14     	; 0x3046 <__ultoa_invert+0xa2>
    3054:	62 0f       	add	r22, r18
    3056:	73 1f       	adc	r23, r19
    3058:	84 1f       	adc	r24, r20
    305a:	95 1f       	adc	r25, r21
    305c:	a0 1d       	adc	r26, r0
    305e:	08 95       	ret

00003060 <__ctype_isfalse>:
    3060:	99 27       	eor	r25, r25
    3062:	88 27       	eor	r24, r24

00003064 <__ctype_istrue>:
    3064:	08 95       	ret

00003066 <__prologue_saves__>:
    3066:	2f 92       	push	r2
    3068:	3f 92       	push	r3
    306a:	4f 92       	push	r4
    306c:	5f 92       	push	r5
    306e:	6f 92       	push	r6
    3070:	7f 92       	push	r7
    3072:	8f 92       	push	r8
    3074:	9f 92       	push	r9
    3076:	af 92       	push	r10
    3078:	bf 92       	push	r11
    307a:	cf 92       	push	r12
    307c:	df 92       	push	r13
    307e:	ef 92       	push	r14
    3080:	ff 92       	push	r15
    3082:	0f 93       	push	r16
    3084:	1f 93       	push	r17
    3086:	cf 93       	push	r28
    3088:	df 93       	push	r29
    308a:	cd b7       	in	r28, 0x3d	; 61
    308c:	de b7       	in	r29, 0x3e	; 62
    308e:	ca 1b       	sub	r28, r26
    3090:	db 0b       	sbc	r29, r27
    3092:	0f b6       	in	r0, 0x3f	; 63
    3094:	f8 94       	cli
    3096:	de bf       	out	0x3e, r29	; 62
    3098:	0f be       	out	0x3f, r0	; 63
    309a:	cd bf       	out	0x3d, r28	; 61
    309c:	09 94       	ijmp

0000309e <__epilogue_restores__>:
    309e:	2a 88       	ldd	r2, Y+18	; 0x12
    30a0:	39 88       	ldd	r3, Y+17	; 0x11
    30a2:	48 88       	ldd	r4, Y+16	; 0x10
    30a4:	5f 84       	ldd	r5, Y+15	; 0x0f
    30a6:	6e 84       	ldd	r6, Y+14	; 0x0e
    30a8:	7d 84       	ldd	r7, Y+13	; 0x0d
    30aa:	8c 84       	ldd	r8, Y+12	; 0x0c
    30ac:	9b 84       	ldd	r9, Y+11	; 0x0b
    30ae:	aa 84       	ldd	r10, Y+10	; 0x0a
    30b0:	b9 84       	ldd	r11, Y+9	; 0x09
    30b2:	c8 84       	ldd	r12, Y+8	; 0x08
    30b4:	df 80       	ldd	r13, Y+7	; 0x07
    30b6:	ee 80       	ldd	r14, Y+6	; 0x06
    30b8:	fd 80       	ldd	r15, Y+5	; 0x05
    30ba:	0c 81       	ldd	r16, Y+4	; 0x04
    30bc:	1b 81       	ldd	r17, Y+3	; 0x03
    30be:	aa 81       	ldd	r26, Y+2	; 0x02
    30c0:	b9 81       	ldd	r27, Y+1	; 0x01
    30c2:	ce 0f       	add	r28, r30
    30c4:	d1 1d       	adc	r29, r1
    30c6:	0f b6       	in	r0, 0x3f	; 63
    30c8:	f8 94       	cli
    30ca:	de bf       	out	0x3e, r29	; 62
    30cc:	0f be       	out	0x3f, r0	; 63
    30ce:	cd bf       	out	0x3d, r28	; 61
    30d0:	ed 01       	movw	r28, r26
    30d2:	08 95       	ret

000030d4 <_exit>:
    30d4:	f8 94       	cli

000030d6 <__stop_program>:
    30d6:	ff cf       	rjmp	.-2      	; 0x30d6 <__stop_program>
